// Code generated by 'ccgo -export-defines "" -ignore-unsupported-alignment -o internal/mptest/main_linux_arm.go -trace-translation-units testdata/mptest.c -Itestdata/sqlite-amalgamation-3410200 -l modernc.org/sqlite/lib -full-path-comments -DNDEBUG -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_CORE -DSQLITE_DEFAULT_MEMSTATUS=0 -DSQLITE_ENABLE_COLUMN_METADATA -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_GEOPOLY -DSQLITE_ENABLE_MATH_FUNCTIONS -DSQLITE_ENABLE_MEMORY_MANAGEMENT -DSQLITE_ENABLE_OFFSET_SQL_FUNC -DSQLITE_ENABLE_PREUPDATE_HOOK -DSQLITE_ENABLE_RBU -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_SESSION -DSQLITE_ENABLE_SNAPSHOT -DSQLITE_ENABLE_STAT4 -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_MUTEX_NOOP -DSQLITE_SOUNDEX -DSQLITE_THREADSAFE=1 -DSQLITE_OS_UNIX=1', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/sqlite/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BIG_ENDIAN                            = 4321
	BUFSIZ                                = 8192
	BYTE_ORDER                            = 1234
	DEFAULT_TIMEOUT                       = 1000000
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 98
	EADDRNOTAVAIL                         = 99
	EADV                                  = 68
	EAFNOSUPPORT                          = 97
	EAGAIN                                = 11
	EALREADY                              = 114
	EBADE                                 = 52
	EBADF                                 = 9
	EBADFD                                = 77
	EBADMSG                               = 74
	EBADR                                 = 53
	EBADRQC                               = 56
	EBADSLT                               = 57
	EBFONT                                = 59
	EBUSY                                 = 16
	ECANCELED                             = 125
	ECHILD                                = 10
	ECHRNG                                = 44
	ECOMM                                 = 70
	ECONNABORTED                          = 103
	ECONNREFUSED                          = 111
	ECONNRESET                            = 104
	EDEADLK                               = 35
	EDEADLOCK                             = 35
	EDESTADDRREQ                          = 89
	EDOM                                  = 33
	EDOTDOT                               = 73
	EDQUOT                                = 122
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EHOSTDOWN                             = 112
	EHOSTUNREACH                          = 113
	EHWPOISON                             = 133
	EIDRM                                 = 43
	EILSEQ                                = 84
	EINPROGRESS                           = 115
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EISCONN                               = 106
	EISDIR                                = 21
	EISNAM                                = 120
	EKEYEXPIRED                           = 127
	EKEYREJECTED                          = 129
	EKEYREVOKED                           = 128
	EL2HLT                                = 51
	EL2NSYNC                              = 45
	EL3HLT                                = 46
	EL3RST                                = 47
	ELIBACC                               = 79
	ELIBBAD                               = 80
	ELIBEXEC                              = 83
	ELIBMAX                               = 82
	ELIBSCN                               = 81
	ELNRNG                                = 48
	ELOOP                                 = 40
	EMEDIUMTYPE                           = 124
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 90
	EMULTIHOP                             = 72
	ENAMETOOLONG                          = 36
	ENAVAIL                               = 119
	ENETDOWN                              = 100
	ENETRESET                             = 102
	ENETUNREACH                           = 101
	ENFILE                                = 23
	ENOANO                                = 55
	ENOBUFS                               = 105
	ENOCSI                                = 50
	ENODATA                               = 61
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOKEY                                = 126
	ENOLCK                                = 37
	ENOLINK                               = 67
	ENOMEDIUM                             = 123
	ENOMEM                                = 12
	ENOMSG                                = 42
	ENONET                                = 64
	ENOPKG                                = 65
	ENOPROTOOPT                           = 92
	ENOSPC                                = 28
	ENOSR                                 = 63
	ENOSTR                                = 60
	ENOSYS                                = 38
	ENOTBLK                               = 15
	ENOTCONN                              = 107
	ENOTDIR                               = 20
	ENOTEMPTY                             = 39
	ENOTNAM                               = 118
	ENOTRECOVERABLE                       = 131
	ENOTSOCK                              = 88
	ENOTSUP                               = 95
	ENOTTY                                = 25
	ENOTUNIQ                              = 76
	ENXIO                                 = 6
	EOF                                   = -1
	EOPNOTSUPP                            = 95
	EOVERFLOW                             = 75
	EOWNERDEAD                            = 130
	EPERM                                 = 1
	EPFNOSUPPORT                          = 96
	EPIPE                                 = 32
	EPROTO                                = 71
	EPROTONOSUPPORT                       = 93
	EPROTOTYPE                            = 91
	ERANGE                                = 34
	EREMCHG                               = 78
	EREMOTE                               = 66
	EREMOTEIO                             = 121
	ERESTART                              = 85
	ERFKILL                               = 132
	EROFS                                 = 30
	ESHUTDOWN                             = 108
	ESOCKTNOSUPPORT                       = 94
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESRMNT                                = 69
	ESTALE                                = 116
	ESTRPIPE                              = 86
	ETIME                                 = 62
	ETIMEDOUT                             = 110
	ETOOMANYREFS                          = 109
	ETXTBSY                               = 26
	EUCLEAN                               = 117
	EUNATCH                               = 49
	EUSERS                                = 87
	EWOULDBLOCK                           = 11
	EXDEV                                 = 18
	EXFULL                                = 54
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	FD_SETSIZE                            = 1024
	FILENAME_MAX                          = 4096
	FOPEN_MAX                             = 16
	FTS5_TOKENIZE_AUX                     = 0x0008
	FTS5_TOKENIZE_DOCUMENT                = 0x0004
	FTS5_TOKENIZE_PREFIX                  = 0x0002
	FTS5_TOKENIZE_QUERY                   = 0x0001
	FTS5_TOKEN_COLOCATED                  = 0x0001
	FULLY_WITHIN                          = 2
	F_LOCK                                = 1
	F_OK                                  = 0
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	HAVE_USLEEP                           = 1
	LITTLE_ENDIAN                         = 1234
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	L_ctermid                             = 9
	L_tmpnam                              = 20
	MX_ARG                                = 2
	NDEBUG                                = 1
	NOT_WITHIN                            = 0
	PARTLY_WITHIN                         = 1
	PDP_ENDIAN                            = 3412
	P_tmpdir                              = "/tmp"
	RAND_MAX                              = 2147483647
	R_OK                                  = 4
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	SQLITE3_H                             = 0
	SQLITE3_TEXT                          = 3
	SQLITE_ABORT                          = 4
	SQLITE_ABORT_ROLLBACK                 = 516
	SQLITE_ACCESS_EXISTS                  = 0
	SQLITE_ACCESS_READ                    = 2
	SQLITE_ACCESS_READWRITE               = 1
	SQLITE_ALTER_TABLE                    = 26
	SQLITE_ANALYZE                        = 28
	SQLITE_ANY                            = 5
	SQLITE_API                            = 0
	SQLITE_APICALL                        = 0
	SQLITE_ATTACH                         = 24
	SQLITE_AUTH                           = 23
	SQLITE_AUTH_USER                      = 279
	SQLITE_BLOB                           = 4
	SQLITE_BUSY                           = 5
	SQLITE_BUSY_RECOVERY                  = 261
	SQLITE_BUSY_SNAPSHOT                  = 517
	SQLITE_BUSY_TIMEOUT                   = 773
	SQLITE_CALLBACK                       = 0
	SQLITE_CANTOPEN                       = 14
	SQLITE_CANTOPEN_CONVPATH              = 1038
	SQLITE_CANTOPEN_DIRTYWAL              = 1294
	SQLITE_CANTOPEN_FULLPATH              = 782
	SQLITE_CANTOPEN_ISDIR                 = 526
	SQLITE_CANTOPEN_NOTEMPDIR             = 270
	SQLITE_CANTOPEN_SYMLINK               = 1550
	SQLITE_CDECL                          = 0
	SQLITE_CHANGESETAPPLY_INVERT          = 0x0002
	SQLITE_CHANGESETAPPLY_NOSAVEPOINT     = 0x0001
	SQLITE_CHANGESETSTART_INVERT          = 0x0002
	SQLITE_CHANGESET_ABORT                = 2
	SQLITE_CHANGESET_CONFLICT             = 3
	SQLITE_CHANGESET_CONSTRAINT           = 4
	SQLITE_CHANGESET_DATA                 = 1
	SQLITE_CHANGESET_FOREIGN_KEY          = 5
	SQLITE_CHANGESET_NOTFOUND             = 2
	SQLITE_CHANGESET_OMIT                 = 0
	SQLITE_CHANGESET_REPLACE              = 1
	SQLITE_CHECKPOINT_FULL                = 1
	SQLITE_CHECKPOINT_PASSIVE             = 0
	SQLITE_CHECKPOINT_RESTART             = 2
	SQLITE_CHECKPOINT_TRUNCATE            = 3
	SQLITE_CONFIG_COVERING_INDEX_SCAN     = 20
	SQLITE_CONFIG_GETMALLOC               = 5
	SQLITE_CONFIG_GETMUTEX                = 11
	SQLITE_CONFIG_GETPCACHE               = 15
	SQLITE_CONFIG_GETPCACHE2              = 19
	SQLITE_CONFIG_HEAP                    = 8
	SQLITE_CONFIG_LOG                     = 16
	SQLITE_CONFIG_LOOKASIDE               = 13
	SQLITE_CONFIG_MALLOC                  = 4
	SQLITE_CONFIG_MEMDB_MAXSIZE           = 29
	SQLITE_CONFIG_MEMSTATUS               = 9
	SQLITE_CONFIG_MMAP_SIZE               = 22
	SQLITE_CONFIG_MULTITHREAD             = 2
	SQLITE_CONFIG_MUTEX                   = 10
	SQLITE_CONFIG_PAGECACHE               = 7
	SQLITE_CONFIG_PCACHE                  = 14
	SQLITE_CONFIG_PCACHE2                 = 18
	SQLITE_CONFIG_PCACHE_HDRSZ            = 24
	SQLITE_CONFIG_PMASZ                   = 25
	SQLITE_CONFIG_SCRATCH                 = 6
	SQLITE_CONFIG_SERIALIZED              = 3
	SQLITE_CONFIG_SINGLETHREAD            = 1
	SQLITE_CONFIG_SMALL_MALLOC            = 27
	SQLITE_CONFIG_SORTERREF_SIZE          = 28
	SQLITE_CONFIG_SQLLOG                  = 21
	SQLITE_CONFIG_STMTJRNL_SPILL          = 26
	SQLITE_CONFIG_URI                     = 17
	SQLITE_CONFIG_WIN32_HEAPSIZE          = 23
	SQLITE_CONSTRAINT                     = 19
	SQLITE_CONSTRAINT_CHECK               = 275
	SQLITE_CONSTRAINT_COMMITHOOK          = 531
	SQLITE_CONSTRAINT_DATATYPE            = 3091
	SQLITE_CONSTRAINT_FOREIGNKEY          = 787
	SQLITE_CONSTRAINT_FUNCTION            = 1043
	SQLITE_CONSTRAINT_NOTNULL             = 1299
	SQLITE_CONSTRAINT_PINNED              = 2835
	SQLITE_CONSTRAINT_PRIMARYKEY          = 1555
	SQLITE_CONSTRAINT_ROWID               = 2579
	SQLITE_CONSTRAINT_TRIGGER             = 1811
	SQLITE_CONSTRAINT_UNIQUE              = 2067
	SQLITE_CONSTRAINT_VTAB                = 2323
	SQLITE_COPY                           = 0
	SQLITE_CORE                           = 1
	SQLITE_CORRUPT                        = 11
	SQLITE_CORRUPT_INDEX                  = 779
	SQLITE_CORRUPT_SEQUENCE               = 523
	SQLITE_CORRUPT_VTAB                   = 267
	SQLITE_CREATE_INDEX                   = 1
	SQLITE_CREATE_TABLE                   = 2
	SQLITE_CREATE_TEMP_INDEX              = 3
	SQLITE_CREATE_TEMP_TABLE              = 4
	SQLITE_CREATE_TEMP_TRIGGER            = 5
	SQLITE_CREATE_TEMP_VIEW               = 6
	SQLITE_CREATE_TRIGGER                 = 7
	SQLITE_CREATE_VIEW                    = 8
	SQLITE_CREATE_VTABLE                  = 29
	SQLITE_DBCONFIG_DEFENSIVE             = 1010
	SQLITE_DBCONFIG_DQS_DDL               = 1014
	SQLITE_DBCONFIG_DQS_DML               = 1013
	SQLITE_DBCONFIG_ENABLE_FKEY           = 1002
	SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004
	SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005
	SQLITE_DBCONFIG_ENABLE_QPSG           = 1007
	SQLITE_DBCONFIG_ENABLE_TRIGGER        = 1003
	SQLITE_DBCONFIG_ENABLE_VIEW           = 1015
	SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    = 1012
	SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    = 1016
	SQLITE_DBCONFIG_LOOKASIDE             = 1001
	SQLITE_DBCONFIG_MAINDBNAME            = 1000
	SQLITE_DBCONFIG_MAX                   = 1017
	SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      = 1006
	SQLITE_DBCONFIG_RESET_DATABASE        = 1009
	SQLITE_DBCONFIG_TRIGGER_EQP           = 1008
	SQLITE_DBCONFIG_TRUSTED_SCHEMA        = 1017
	SQLITE_DBCONFIG_WRITABLE_SCHEMA       = 1011
	SQLITE_DBSTATUS_CACHE_HIT             = 7
	SQLITE_DBSTATUS_CACHE_MISS            = 8
	SQLITE_DBSTATUS_CACHE_SPILL           = 12
	SQLITE_DBSTATUS_CACHE_USED            = 1
	SQLITE_DBSTATUS_CACHE_USED_SHARED     = 11
	SQLITE_DBSTATUS_CACHE_WRITE           = 9
	SQLITE_DBSTATUS_DEFERRED_FKS          = 10
	SQLITE_DBSTATUS_LOOKASIDE_HIT         = 4
	SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL   = 6
	SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE   = 5
	SQLITE_DBSTATUS_LOOKASIDE_USED        = 0
	SQLITE_DBSTATUS_MAX                   = 12
	SQLITE_DBSTATUS_SCHEMA_USED           = 2
	SQLITE_DBSTATUS_STMT_USED             = 3
	SQLITE_DEFAULT_MEMSTATUS              = 0
	SQLITE_DELETE                         = 9
	SQLITE_DENY                           = 1
	SQLITE_DEPRECATED                     = 0
	SQLITE_DESERIALIZE_FREEONCLOSE        = 1
	SQLITE_DESERIALIZE_READONLY           = 4
	SQLITE_DESERIALIZE_RESIZEABLE         = 2
	SQLITE_DETACH                         = 25
	SQLITE_DETERMINISTIC                  = 0x000000800
	SQLITE_DIRECTONLY                     = 0x000080000
	SQLITE_DONE                           = 101
	SQLITE_DROP_INDEX                     = 10
	SQLITE_DROP_TABLE                     = 11
	SQLITE_DROP_TEMP_INDEX                = 12
	SQLITE_DROP_TEMP_TABLE                = 13
	SQLITE_DROP_TEMP_TRIGGER              = 14
	SQLITE_DROP_TEMP_VIEW                 = 15
	SQLITE_DROP_TRIGGER                   = 16
	SQLITE_DROP_VIEW                      = 17
	SQLITE_DROP_VTABLE                    = 30
	SQLITE_EMPTY                          = 16
	SQLITE_ENABLE_COLUMN_METADATA         = 1
	SQLITE_ENABLE_FTS5                    = 1
	SQLITE_ENABLE_GEOPOLY                 = 1
	SQLITE_ENABLE_MATH_FUNCTIONS          = 1
	SQLITE_ENABLE_MEMORY_MANAGEMENT       = 1
	SQLITE_ENABLE_OFFSET_SQL_FUNC         = 1
	SQLITE_ENABLE_PREUPDATE_HOOK          = 1
	SQLITE_ENABLE_RBU                     = 1
	SQLITE_ENABLE_RTREE                   = 1
	SQLITE_ENABLE_SESSION                 = 1
	SQLITE_ENABLE_SNAPSHOT                = 1
	SQLITE_ENABLE_STAT4                   = 1
	SQLITE_ENABLE_UNLOCK_NOTIFY           = 1
	SQLITE_ERROR                          = 1
	SQLITE_ERROR_MISSING_COLLSEQ          = 257
	SQLITE_ERROR_RETRY                    = 513
	SQLITE_ERROR_SNAPSHOT                 = 769
	SQLITE_EXPERIMENTAL                   = 0
	SQLITE_FAIL                           = 3
	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE       = 31
	SQLITE_FCNTL_BUSYHANDLER              = 15
	SQLITE_FCNTL_CHUNK_SIZE               = 6
	SQLITE_FCNTL_CKPT_DONE                = 37
	SQLITE_FCNTL_CKPT_START               = 39
	SQLITE_FCNTL_CKSM_FILE                = 41
	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE      = 32
	SQLITE_FCNTL_COMMIT_PHASETWO          = 22
	SQLITE_FCNTL_DATA_VERSION             = 35
	SQLITE_FCNTL_EXTERNAL_READER          = 40
	SQLITE_FCNTL_FILE_POINTER             = 7
	SQLITE_FCNTL_GET_LOCKPROXYFILE        = 2
	SQLITE_FCNTL_HAS_MOVED                = 20
	SQLITE_FCNTL_JOURNAL_POINTER          = 28
	SQLITE_FCNTL_LAST_ERRNO               = 4
	SQLITE_FCNTL_LOCKSTATE                = 1
	SQLITE_FCNTL_LOCK_TIMEOUT             = 34
	SQLITE_FCNTL_MMAP_SIZE                = 18
	SQLITE_FCNTL_OVERWRITE                = 11
	SQLITE_FCNTL_PDB                      = 30
	SQLITE_FCNTL_PERSIST_WAL              = 10
	SQLITE_FCNTL_POWERSAFE_OVERWRITE      = 13
	SQLITE_FCNTL_PRAGMA                   = 14
	SQLITE_FCNTL_RBU                      = 26
	SQLITE_FCNTL_RESERVE_BYTES            = 38
	SQLITE_FCNTL_RESET_CACHE              = 42
	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE    = 33
	SQLITE_FCNTL_SET_LOCKPROXYFILE        = 3
	SQLITE_FCNTL_SIZE_HINT                = 5
	SQLITE_FCNTL_SIZE_LIMIT               = 36
	SQLITE_FCNTL_SYNC                     = 21
	SQLITE_FCNTL_SYNC_OMITTED             = 8
	SQLITE_FCNTL_TEMPFILENAME             = 16
	SQLITE_FCNTL_TRACE                    = 19
	SQLITE_FCNTL_VFSNAME                  = 12
	SQLITE_FCNTL_VFS_POINTER              = 27
	SQLITE_FCNTL_WAL_BLOCK                = 24
	SQLITE_FCNTL_WIN32_AV_RETRY           = 9
	SQLITE_FCNTL_WIN32_GET_HANDLE         = 29
	SQLITE_FCNTL_WIN32_SET_HANDLE         = 23
	SQLITE_FCNTL_ZIPVFS                   = 25
	SQLITE_FLOAT                          = 2
	SQLITE_FORMAT                         = 24
	SQLITE_FULL                           = 13
	SQLITE_FUNCTION                       = 31
	SQLITE_GET_LOCKPROXYFILE              = 2
	SQLITE_IGNORE                         = 2
	SQLITE_INDEX_CONSTRAINT_EQ            = 2
	SQLITE_INDEX_CONSTRAINT_FUNCTION      = 150
	SQLITE_INDEX_CONSTRAINT_GE            = 32
	SQLITE_INDEX_CONSTRAINT_GLOB          = 66
	SQLITE_INDEX_CONSTRAINT_GT            = 4
	SQLITE_INDEX_CONSTRAINT_IS            = 72
	SQLITE_INDEX_CONSTRAINT_ISNOT         = 69
	SQLITE_INDEX_CONSTRAINT_ISNOTNULL     = 70
	SQLITE_INDEX_CONSTRAINT_ISNULL        = 71
	SQLITE_INDEX_CONSTRAINT_LE            = 8
	SQLITE_INDEX_CONSTRAINT_LIKE          = 65
	SQLITE_INDEX_CONSTRAINT_LIMIT         = 73
	SQLITE_INDEX_CONSTRAINT_LT            = 16
	SQLITE_INDEX_CONSTRAINT_MATCH         = 64
	SQLITE_INDEX_CONSTRAINT_NE            = 68
	SQLITE_INDEX_CONSTRAINT_OFFSET        = 74
	SQLITE_INDEX_CONSTRAINT_REGEXP        = 67
	SQLITE_INDEX_SCAN_UNIQUE              = 1
	SQLITE_INNOCUOUS                      = 0x000200000
	SQLITE_INSERT                         = 18
	SQLITE_INTEGER                        = 1
	SQLITE_INTERNAL                       = 2
	SQLITE_INTERRUPT                      = 9
	SQLITE_IOCAP_ATOMIC                   = 0x00000001
	SQLITE_IOCAP_ATOMIC16K                = 0x00000040
	SQLITE_IOCAP_ATOMIC1K                 = 0x00000004
	SQLITE_IOCAP_ATOMIC2K                 = 0x00000008
	SQLITE_IOCAP_ATOMIC32K                = 0x00000080
	SQLITE_IOCAP_ATOMIC4K                 = 0x00000010
	SQLITE_IOCAP_ATOMIC512                = 0x00000002
	SQLITE_IOCAP_ATOMIC64K                = 0x00000100
	SQLITE_IOCAP_ATOMIC8K                 = 0x00000020
	SQLITE_IOCAP_BATCH_ATOMIC             = 0x00004000
	SQLITE_IOCAP_IMMUTABLE                = 0x00002000
	SQLITE_IOCAP_POWERSAFE_OVERWRITE      = 0x00001000
	SQLITE_IOCAP_SAFE_APPEND              = 0x00000200
	SQLITE_IOCAP_SEQUENTIAL               = 0x00000400
	SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN    = 0x00000800
	SQLITE_IOERR                          = 10
	SQLITE_IOERR_ACCESS                   = 3338
	SQLITE_IOERR_AUTH                     = 7178
	SQLITE_IOERR_BEGIN_ATOMIC             = 7434
	SQLITE_IOERR_BLOCKED                  = 2826
	SQLITE_IOERR_CHECKRESERVEDLOCK        = 3594
	SQLITE_IOERR_CLOSE                    = 4106
	SQLITE_IOERR_COMMIT_ATOMIC            = 7690
	SQLITE_IOERR_CONVPATH                 = 6666
	SQLITE_IOERR_CORRUPTFS                = 8458
	SQLITE_IOERR_DATA                     = 8202
	SQLITE_IOERR_DELETE                   = 2570
	SQLITE_IOERR_DELETE_NOENT             = 5898
	SQLITE_IOERR_DIR_CLOSE                = 4362
	SQLITE_IOERR_DIR_FSYNC                = 1290
	SQLITE_IOERR_FSTAT                    = 1802
	SQLITE_IOERR_FSYNC                    = 1034
	SQLITE_IOERR_GETTEMPPATH              = 6410
	SQLITE_IOERR_LOCK                     = 3850
	SQLITE_IOERR_MMAP                     = 6154
	SQLITE_IOERR_NOMEM                    = 3082
	SQLITE_IOERR_RDLOCK                   = 2314
	SQLITE_IOERR_READ                     = 266
	SQLITE_IOERR_ROLLBACK_ATOMIC          = 7946
	SQLITE_IOERR_SEEK                     = 5642
	SQLITE_IOERR_SHMLOCK                  = 5130
	SQLITE_IOERR_SHMMAP                   = 5386
	SQLITE_IOERR_SHMOPEN                  = 4618
	SQLITE_IOERR_SHMSIZE                  = 4874
	SQLITE_IOERR_SHORT_READ               = 522
	SQLITE_IOERR_TRUNCATE                 = 1546
	SQLITE_IOERR_UNLOCK                   = 2058
	SQLITE_IOERR_VNODE                    = 6922
	SQLITE_IOERR_WRITE                    = 778
	SQLITE_LAST_ERRNO                     = 4
	SQLITE_LIKE_DOESNT_MATCH_BLOBS        = 1
	SQLITE_LIMIT_ATTACHED                 = 7
	SQLITE_LIMIT_COLUMN                   = 2
	SQLITE_LIMIT_COMPOUND_SELECT          = 4
	SQLITE_LIMIT_EXPR_DEPTH               = 3
	SQLITE_LIMIT_FUNCTION_ARG             = 6
	SQLITE_LIMIT_LENGTH                   = 0
	SQLITE_LIMIT_LIKE_PATTERN_LENGTH      = 8
	SQLITE_LIMIT_SQL_LENGTH               = 1
	SQLITE_LIMIT_TRIGGER_DEPTH            = 10
	SQLITE_LIMIT_VARIABLE_NUMBER          = 9
	SQLITE_LIMIT_VDBE_OP                  = 5
	SQLITE_LIMIT_WORKER_THREADS           = 11
	SQLITE_LOCKED                         = 6
	SQLITE_LOCKED_SHAREDCACHE             = 262
	SQLITE_LOCKED_VTAB                    = 518
	SQLITE_LOCK_EXCLUSIVE                 = 4
	SQLITE_LOCK_NONE                      = 0
	SQLITE_LOCK_PENDING                   = 3
	SQLITE_LOCK_RESERVED                  = 2
	SQLITE_LOCK_SHARED                    = 1
	SQLITE_MISMATCH                       = 20
	SQLITE_MISUSE                         = 21
	SQLITE_MUTEX_APPDEF                   = 1
	SQLITE_MUTEX_FAST                     = 0
	SQLITE_MUTEX_NOOP                     = 1
	SQLITE_MUTEX_RECURSIVE                = 1
	SQLITE_MUTEX_STATIC_APP1              = 8
	SQLITE_MUTEX_STATIC_APP2              = 9
	SQLITE_MUTEX_STATIC_APP3              = 10
	SQLITE_MUTEX_STATIC_LRU               = 6
	SQLITE_MUTEX_STATIC_LRU2              = 7
	SQLITE_MUTEX_STATIC_MAIN              = 2
	SQLITE_MUTEX_STATIC_MASTER            = 2
	SQLITE_MUTEX_STATIC_MEM               = 3
	SQLITE_MUTEX_STATIC_MEM2              = 4
	SQLITE_MUTEX_STATIC_OPEN              = 4
	SQLITE_MUTEX_STATIC_PMEM              = 7
	SQLITE_MUTEX_STATIC_PRNG              = 5
	SQLITE_MUTEX_STATIC_VFS1              = 11
	SQLITE_MUTEX_STATIC_VFS2              = 12
	SQLITE_MUTEX_STATIC_VFS3              = 13
	SQLITE_NOLFS                          = 22
	SQLITE_NOMEM                          = 7
	SQLITE_NOTADB                         = 26
	SQLITE_NOTFOUND                       = 12
	SQLITE_NOTICE                         = 27
	SQLITE_NOTICE_RBU                     = 795
	SQLITE_NOTICE_RECOVER_ROLLBACK        = 539
	SQLITE_NOTICE_RECOVER_WAL             = 283
	SQLITE_NULL                           = 5
	SQLITE_OK                             = 0
	SQLITE_OK_LOAD_PERMANENTLY            = 256
	SQLITE_OK_SYMLINK                     = 512
	SQLITE_OPEN_AUTOPROXY                 = 0x00000020
	SQLITE_OPEN_CREATE                    = 0x00000004
	SQLITE_OPEN_DELETEONCLOSE             = 0x00000008
	SQLITE_OPEN_EXCLUSIVE                 = 0x00000010
	SQLITE_OPEN_EXRESCODE                 = 0x02000000
	SQLITE_OPEN_FULLMUTEX                 = 0x00010000
	SQLITE_OPEN_MAIN_DB                   = 0x00000100
	SQLITE_OPEN_MAIN_JOURNAL              = 0x00000800
	SQLITE_OPEN_MASTER_JOURNAL            = 0x00004000
	SQLITE_OPEN_MEMORY                    = 0x00000080
	SQLITE_OPEN_NOFOLLOW                  = 0x01000000
	SQLITE_OPEN_NOMUTEX                   = 0x00008000
	SQLITE_OPEN_PRIVATECACHE              = 0x00040000
	SQLITE_OPEN_READONLY                  = 0x00000001
	SQLITE_OPEN_READWRITE                 = 0x00000002
	SQLITE_OPEN_SHAREDCACHE               = 0x00020000
	SQLITE_OPEN_SUBJOURNAL                = 0x00002000
	SQLITE_OPEN_SUPER_JOURNAL             = 0x00004000
	SQLITE_OPEN_TEMP_DB                   = 0x00000200
	SQLITE_OPEN_TEMP_JOURNAL              = 0x00001000
	SQLITE_OPEN_TRANSIENT_DB              = 0x00000400
	SQLITE_OPEN_URI                       = 0x00000040
	SQLITE_OPEN_WAL                       = 0x00080000
	SQLITE_OS_UNIX                        = 1
	SQLITE_PERM                           = 3
	SQLITE_PRAGMA                         = 19
	SQLITE_PREPARE_NORMALIZE              = 0x02
	SQLITE_PREPARE_NO_VTAB                = 0x04
	SQLITE_PREPARE_PERSISTENT             = 0x01
	SQLITE_PROTOCOL                       = 15
	SQLITE_RANGE                          = 25
	SQLITE_READ                           = 20
	SQLITE_READONLY                       = 8
	SQLITE_READONLY_CANTINIT              = 1288
	SQLITE_READONLY_CANTLOCK              = 520
	SQLITE_READONLY_DBMOVED               = 1032
	SQLITE_READONLY_DIRECTORY             = 1544
	SQLITE_READONLY_RECOVERY              = 264
	SQLITE_READONLY_ROLLBACK              = 776
	SQLITE_RECURSIVE                      = 33
	SQLITE_REINDEX                        = 27
	SQLITE_REPLACE                        = 5
	SQLITE_ROLLBACK                       = 1
	SQLITE_ROW                            = 100
	SQLITE_SAVEPOINT                      = 32
	SQLITE_SCANSTAT_COMPLEX               = 0x0001
	SQLITE_SCANSTAT_EST                   = 2
	SQLITE_SCANSTAT_EXPLAIN               = 4
	SQLITE_SCANSTAT_NAME                  = 3
	SQLITE_SCANSTAT_NCYCLE                = 7
	SQLITE_SCANSTAT_NLOOP                 = 0
	SQLITE_SCANSTAT_NVISIT                = 1
	SQLITE_SCANSTAT_PARENTID              = 6
	SQLITE_SCANSTAT_SELECTID              = 5
	SQLITE_SCHEMA                         = 17
	SQLITE_SELECT                         = 21
	SQLITE_SERIALIZE_NOCOPY               = 0x001
	SQLITE_SESSION_CONFIG_STRMSIZE        = 1
	SQLITE_SESSION_OBJCONFIG_SIZE         = 1
	SQLITE_SET_LOCKPROXYFILE              = 3
	SQLITE_SHM_EXCLUSIVE                  = 8
	SQLITE_SHM_LOCK                       = 2
	SQLITE_SHM_NLOCK                      = 8
	SQLITE_SHM_SHARED                     = 4
	SQLITE_SHM_UNLOCK                     = 1
	SQLITE_SOUNDEX                        = 1
	SQLITE_SOURCE_ID                      = "2023-03-22 11:56:21 0d1fc92f94cb6b76bffe3ec34d69cffde2924203304e8ffc4155597af0c191da"
	SQLITE_STATUS_MALLOC_COUNT            = 9
	SQLITE_STATUS_MALLOC_SIZE             = 5
	SQLITE_STATUS_MEMORY_USED             = 0
	SQLITE_STATUS_PAGECACHE_OVERFLOW      = 2
	SQLITE_STATUS_PAGECACHE_SIZE          = 7
	SQLITE_STATUS_PAGECACHE_USED          = 1
	SQLITE_STATUS_PARSER_STACK            = 6
	SQLITE_STATUS_SCRATCH_OVERFLOW        = 4
	SQLITE_STATUS_SCRATCH_SIZE            = 8
	SQLITE_STATUS_SCRATCH_USED            = 3
	SQLITE_STDCALL                        = 0
	SQLITE_STMTSTATUS_AUTOINDEX           = 3
	SQLITE_STMTSTATUS_FILTER_HIT          = 8
	SQLITE_STMTSTATUS_FILTER_MISS         = 7
	SQLITE_STMTSTATUS_FULLSCAN_STEP       = 1
	SQLITE_STMTSTATUS_MEMUSED             = 99
	SQLITE_STMTSTATUS_REPREPARE           = 5
	SQLITE_STMTSTATUS_RUN                 = 6
	SQLITE_STMTSTATUS_SORT                = 2
	SQLITE_STMTSTATUS_VM_STEP             = 4
	SQLITE_SUBTYPE                        = 0x000100000
	SQLITE_SYNC_DATAONLY                  = 0x00010
	SQLITE_SYNC_FULL                      = 0x00003
	SQLITE_SYNC_NORMAL                    = 0x00002
	SQLITE_SYSAPI                         = 0
	SQLITE_TESTCTRL_ALWAYS                = 13
	SQLITE_TESTCTRL_ASSERT                = 12
	SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS   = 10
	SQLITE_TESTCTRL_BITVEC_TEST           = 8
	SQLITE_TESTCTRL_BYTEORDER             = 22
	SQLITE_TESTCTRL_EXPLAIN_STMT          = 19
	SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS   = 29
	SQLITE_TESTCTRL_FAULT_INSTALL         = 9
	SQLITE_TESTCTRL_FIRST                 = 5
	SQLITE_TESTCTRL_IMPOSTER              = 25
	SQLITE_TESTCTRL_INTERNAL_FUNCTIONS    = 17
	SQLITE_TESTCTRL_ISINIT                = 23
	SQLITE_TESTCTRL_ISKEYWORD             = 16
	SQLITE_TESTCTRL_LAST                  = 33
	SQLITE_TESTCTRL_LOCALTIME_FAULT       = 18
	SQLITE_TESTCTRL_LOGEST                = 33
	SQLITE_TESTCTRL_NEVER_CORRUPT         = 20
	SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD  = 19
	SQLITE_TESTCTRL_OPTIMIZATIONS         = 15
	SQLITE_TESTCTRL_PARSER_COVERAGE       = 26
	SQLITE_TESTCTRL_PENDING_BYTE          = 11
	SQLITE_TESTCTRL_PRNG_RESET            = 7
	SQLITE_TESTCTRL_PRNG_RESTORE          = 6
	SQLITE_TESTCTRL_PRNG_SAVE             = 5
	SQLITE_TESTCTRL_PRNG_SEED             = 28
	SQLITE_TESTCTRL_RESERVE               = 14
	SQLITE_TESTCTRL_RESULT_INTREAL        = 27
	SQLITE_TESTCTRL_SCRATCHMALLOC         = 17
	SQLITE_TESTCTRL_SEEK_COUNT            = 30
	SQLITE_TESTCTRL_SORTER_MMAP           = 24
	SQLITE_TESTCTRL_TRACEFLAGS            = 31
	SQLITE_TESTCTRL_TUNE                  = 32
	SQLITE_TESTCTRL_VDBE_COVERAGE         = 21
	SQLITE_TEXT                           = 3
	SQLITE_THREADSAFE                     = 1
	SQLITE_TOOBIG                         = 18
	SQLITE_TRACE_CLOSE                    = 0x08
	SQLITE_TRACE_PROFILE                  = 0x02
	SQLITE_TRACE_ROW                      = 0x04
	SQLITE_TRACE_STMT                     = 0x01
	SQLITE_TRANSACTION                    = 22
	SQLITE_TXN_NONE                       = 0
	SQLITE_TXN_READ                       = 1
	SQLITE_TXN_WRITE                      = 2
	SQLITE_UPDATE                         = 23
	SQLITE_UTF16                          = 4
	SQLITE_UTF16BE                        = 3
	SQLITE_UTF16LE                        = 2
	SQLITE_UTF16_ALIGNED                  = 8
	SQLITE_UTF8                           = 1
	SQLITE_VERSION                        = "3.41.2"
	SQLITE_VERSION_NUMBER                 = 3041002
	SQLITE_VTAB_CONSTRAINT_SUPPORT        = 1
	SQLITE_VTAB_DIRECTONLY                = 3
	SQLITE_VTAB_INNOCUOUS                 = 2
	SQLITE_WARNING                        = 28
	SQLITE_WARNING_AUTOINDEX              = 284
	SQLITE_WIN32_DATA_DIRECTORY_TYPE      = 1
	SQLITE_WIN32_TEMP_DIRECTORY_TYPE      = 2
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	TMP_MAX                               = 238328
	WCONTINUED                            = 8
	WEXITED                               = 4
	WNOHANG                               = 1
	WNOWAIT                               = 0x01000000
	WSTOPPED                              = 2
	WUNTRACED                             = 2
	W_OK                                  = 2
	X_OK                                  = 1
	X_ALLOCA_H                            = 1
	X_ANSI_STDARG_H_                      = 0
	X_ASM_GENERIC_ERRNO_BASE_H            = 0
	X_ASM_GENERIC_ERRNO_H                 = 0
	X_ASSERT_H                            = 1
	X_ATFILE_SOURCE                       = 1
	X_BITS_BYTESWAP_H                     = 1
	X_BITS_ENDIANNESS_H                   = 1
	X_BITS_ENDIAN_H                       = 1
	X_BITS_ERRNO_H                        = 1
	X_BITS_FLOATN_COMMON_H                = 0
	X_BITS_POSIX_OPT_H                    = 1
	X_BITS_PTHREADTYPES_ARCH_H            = 1
	X_BITS_PTHREADTYPES_COMMON_H          = 1
	X_BITS_STDINT_INTN_H                  = 1
	X_BITS_STDIO_LIM_H                    = 1
	X_BITS_TIME64_H                       = 1
	X_BITS_TYPESIZES_H                    = 1
	X_BITS_TYPES_H                        = 1
	X_BITS_TYPES_LOCALE_T_H               = 1
	X_BITS_TYPES___LOCALE_T_H             = 1
	X_BITS_UINTN_IDENTITY_H               = 1
	X_BSD_SIZE_T_                         = 0
	X_BSD_SIZE_T_DEFINED_                 = 0
	X_CTYPE_H                             = 1
	X_DEFAULT_SOURCE                      = 1
	X_ENDIAN_H                            = 1
	X_ERRNO_H                             = 1
	X_FEATURES_H                          = 1
	X_FILE_OFFSET_BITS                    = 64
	X_FTS5_H                              = 0
	X_GCC_SIZE_T                          = 0
	X_GCC_WCHAR_T                         = 0
	X_GETOPT_CORE_H                       = 1
	X_GETOPT_POSIX_H                      = 1
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_IO_EOF_SEEN                         = 0x0010
	X_IO_ERR_SEEN                         = 0x0020
	X_IO_USER_LOCK                        = 0x8000
	X_LFS64_ASYNCHRONOUS_IO               = 1
	X_LFS64_LARGEFILE                     = 1
	X_LFS64_STDIO                         = 1
	X_LFS_ASYNCHRONOUS_IO                 = 1
	X_LFS_LARGEFILE                       = 1
	X_POSIX2_CHAR_TERM                    = 200809
	X_POSIX2_C_BIND                       = 200809
	X_POSIX2_C_DEV                        = 200809
	X_POSIX2_C_VERSION                    = 200809
	X_POSIX2_LOCALEDEF                    = 200809
	X_POSIX2_SW_DEV                       = 200809
	X_POSIX2_VERSION                      = 200809
	X_POSIX_ADVISORY_INFO                 = 200809
	X_POSIX_ASYNCHRONOUS_IO               = 200809
	X_POSIX_ASYNC_IO                      = 1
	X_POSIX_BARRIERS                      = 200809
	X_POSIX_CHOWN_RESTRICTED              = 0
	X_POSIX_CLOCK_SELECTION               = 200809
	X_POSIX_CPUTIME                       = 0
	X_POSIX_C_SOURCE                      = 200809
	X_POSIX_FSYNC                         = 200809
	X_POSIX_IPV6                          = 200809
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_MAPPED_FILES                  = 200809
	X_POSIX_MEMLOCK                       = 200809
	X_POSIX_MEMLOCK_RANGE                 = 200809
	X_POSIX_MEMORY_PROTECTION             = 200809
	X_POSIX_MESSAGE_PASSING               = 200809
	X_POSIX_MONOTONIC_CLOCK               = 0
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_PRIORITIZED_IO                = 200809
	X_POSIX_PRIORITY_SCHEDULING           = 200809
	X_POSIX_RAW_SOCKETS                   = 200809
	X_POSIX_READER_WRITER_LOCKS           = 200809
	X_POSIX_REALTIME_SIGNALS              = 200809
	X_POSIX_REENTRANT_FUNCTIONS           = 1
	X_POSIX_REGEXP                        = 1
	X_POSIX_SAVED_IDS                     = 1
	X_POSIX_SEMAPHORES                    = 200809
	X_POSIX_SHARED_MEMORY_OBJECTS         = 200809
	X_POSIX_SHELL                         = 1
	X_POSIX_SOURCE                        = 1
	X_POSIX_SPAWN                         = 200809
	X_POSIX_SPIN_LOCKS                    = 200809
	X_POSIX_SPORADIC_SERVER               = -1
	X_POSIX_SYNCHRONIZED_IO               = 200809
	X_POSIX_THREADS                       = 200809
	X_POSIX_THREAD_ATTR_STACKADDR         = 200809
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200809
	X_POSIX_THREAD_CPUTIME                = 0
	X_POSIX_THREAD_PRIORITY_SCHEDULING    = 200809
	X_POSIX_THREAD_PRIO_INHERIT           = 200809
	X_POSIX_THREAD_PRIO_PROTECT           = 200809
	X_POSIX_THREAD_PROCESS_SHARED         = 200809
	X_POSIX_THREAD_ROBUST_PRIO_INHERIT    = 200809
	X_POSIX_THREAD_ROBUST_PRIO_PROTECT    = -1
	X_POSIX_THREAD_SAFE_FUNCTIONS         = 200809
	X_POSIX_THREAD_SPORADIC_SERVER        = -1
	X_POSIX_TIMEOUTS                      = 200809
	X_POSIX_TIMERS                        = 200809
	X_POSIX_TRACE                         = -1
	X_POSIX_TRACE_EVENT_FILTER            = -1
	X_POSIX_TRACE_INHERIT                 = -1
	X_POSIX_TRACE_LOG                     = -1
	X_POSIX_TYPED_MEMORY_OBJECTS          = -1
	X_POSIX_V6_ILP32_OFF32                = 1
	X_POSIX_V6_ILP32_OFFBIG               = 1
	X_POSIX_V6_LP64_OFF64                 = -1
	X_POSIX_V6_LPBIG_OFFBIG               = -1
	X_POSIX_V7_ILP32_OFF32                = 1
	X_POSIX_V7_ILP32_OFFBIG               = 1
	X_POSIX_V7_LP64_OFF64                 = -1
	X_POSIX_V7_LPBIG_OFFBIG               = -1
	X_POSIX_VDISABLE                      = 0
	X_POSIX_VERSION                       = 200809
	X_SIZET_                              = 0
	X_SIZE_T                              = 0
	X_SIZE_T_                             = 0
	X_SIZE_T_DECLARED                     = 0
	X_SIZE_T_DEFINED                      = 0
	X_SIZE_T_DEFINED_                     = 0
	X_SQLITE3RTREE_H_                     = 0
	X_STDARG_H                            = 0
	X_STDC_PREDEF_H                       = 1
	X_STDIO_H                             = 1
	X_STDLIB_H                            = 1
	X_STRINGS_H                           = 1
	X_STRING_H                            = 1
	X_STRUCT_TIMESPEC                     = 1
	X_SYS_CDEFS_H                         = 1
	X_SYS_SELECT_H                        = 1
	X_SYS_SIZE_T_H                        = 0
	X_SYS_TYPES_H                         = 1
	X_THREAD_MUTEX_INTERNAL_H             = 1
	X_THREAD_SHARED_TYPES_H               = 1
	X_T_SIZE                              = 0
	X_T_SIZE_                             = 0
	X_T_WCHAR                             = 0
	X_T_WCHAR_                            = 0
	X_UNISTD_H                            = 1
	X_VA_LIST                             = 0
	X_VA_LIST_                            = 0
	X_VA_LIST_DEFINED                     = 0
	X_VA_LIST_T_H                         = 0
	X_WCHAR_T                             = 0
	X_WCHAR_T_                            = 0
	X_WCHAR_T_DECLARED                    = 0
	X_WCHAR_T_DEFINED                     = 0
	X_WCHAR_T_DEFINED_                    = 0
	X_WCHAR_T_H                           = 0
	X_XBS5_ILP32_OFF32                    = 1
	X_XBS5_ILP32_OFFBIG                   = 1
	X_XBS5_LP64_OFF64                     = -1
	X_XBS5_LPBIG_OFFBIG                   = -1
	X_XOPEN_ENH_I18N                      = 1
	X_XOPEN_LEGACY                        = 1
	X_XOPEN_REALTIME                      = 1
	X_XOPEN_REALTIME_THREADS              = 1
	X_XOPEN_SHM                           = 1
	X_XOPEN_UNIX                          = 1
	X_XOPEN_VERSION                       = 700
	X_XOPEN_XCU_VERSION                   = 4
	X_XOPEN_XPG2                          = 1
	X_XOPEN_XPG3                          = 1
	X_XOPEN_XPG4                          = 1
	Linux                                 = 1
	Unix                                  = 1
)

const (
	_PC_LINK_MAX           = 0
	_PC_MAX_CANON          = 1
	_PC_MAX_INPUT          = 2
	_PC_NAME_MAX           = 3
	_PC_PATH_MAX           = 4
	_PC_PIPE_BUF           = 5
	_PC_CHOWN_RESTRICTED   = 6
	_PC_NO_TRUNC           = 7
	_PC_VDISABLE           = 8
	_PC_SYNC_IO            = 9
	_PC_ASYNC_IO           = 10
	_PC_PRIO_IO            = 11
	_PC_SOCK_MAXBUF        = 12
	_PC_FILESIZEBITS       = 13
	_PC_REC_INCR_XFER_SIZE = 14
	_PC_REC_MAX_XFER_SIZE  = 15
	_PC_REC_MIN_XFER_SIZE  = 16
	_PC_REC_XFER_ALIGN     = 17
	_PC_ALLOC_SIZE_MIN     = 18
	_PC_SYMLINK_MAX        = 19
	_PC_2_SYMLINKS         = 20
)

const (
	_CS_PATH = 0

	_CS_V6_WIDTH_RESTRICTED_ENVS = 1

	_CS_GNU_LIBC_VERSION       = 2
	_CS_GNU_LIBPTHREAD_VERSION = 3

	_CS_V5_WIDTH_RESTRICTED_ENVS = 4

	_CS_V7_WIDTH_RESTRICTED_ENVS = 5

	_CS_LFS_CFLAGS      = 1000
	_CS_LFS_LDFLAGS     = 1001
	_CS_LFS_LIBS        = 1002
	_CS_LFS_LINTFLAGS   = 1003
	_CS_LFS64_CFLAGS    = 1004
	_CS_LFS64_LDFLAGS   = 1005
	_CS_LFS64_LIBS      = 1006
	_CS_LFS64_LINTFLAGS = 1007

	_CS_XBS5_ILP32_OFF32_CFLAGS     = 1100
	_CS_XBS5_ILP32_OFF32_LDFLAGS    = 1101
	_CS_XBS5_ILP32_OFF32_LIBS       = 1102
	_CS_XBS5_ILP32_OFF32_LINTFLAGS  = 1103
	_CS_XBS5_ILP32_OFFBIG_CFLAGS    = 1104
	_CS_XBS5_ILP32_OFFBIG_LDFLAGS   = 1105
	_CS_XBS5_ILP32_OFFBIG_LIBS      = 1106
	_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107
	_CS_XBS5_LP64_OFF64_CFLAGS      = 1108
	_CS_XBS5_LP64_OFF64_LDFLAGS     = 1109
	_CS_XBS5_LP64_OFF64_LIBS        = 1110
	_CS_XBS5_LP64_OFF64_LINTFLAGS   = 1111
	_CS_XBS5_LPBIG_OFFBIG_CFLAGS    = 1112
	_CS_XBS5_LPBIG_OFFBIG_LDFLAGS   = 1113
	_CS_XBS5_LPBIG_OFFBIG_LIBS      = 1114
	_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115

	_CS_POSIX_V6_ILP32_OFF32_CFLAGS     = 1116
	_CS_POSIX_V6_ILP32_OFF32_LDFLAGS    = 1117
	_CS_POSIX_V6_ILP32_OFF32_LIBS       = 1118
	_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS  = 1119
	_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS    = 1120
	_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS   = 1121
	_CS_POSIX_V6_ILP32_OFFBIG_LIBS      = 1122
	_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123
	_CS_POSIX_V6_LP64_OFF64_CFLAGS      = 1124
	_CS_POSIX_V6_LP64_OFF64_LDFLAGS     = 1125
	_CS_POSIX_V6_LP64_OFF64_LIBS        = 1126
	_CS_POSIX_V6_LP64_OFF64_LINTFLAGS   = 1127
	_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS    = 1128
	_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS   = 1129
	_CS_POSIX_V6_LPBIG_OFFBIG_LIBS      = 1130
	_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131

	_CS_POSIX_V7_ILP32_OFF32_CFLAGS     = 1132
	_CS_POSIX_V7_ILP32_OFF32_LDFLAGS    = 1133
	_CS_POSIX_V7_ILP32_OFF32_LIBS       = 1134
	_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS  = 1135
	_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS    = 1136
	_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS   = 1137
	_CS_POSIX_V7_ILP32_OFFBIG_LIBS      = 1138
	_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139
	_CS_POSIX_V7_LP64_OFF64_CFLAGS      = 1140
	_CS_POSIX_V7_LP64_OFF64_LDFLAGS     = 1141
	_CS_POSIX_V7_LP64_OFF64_LIBS        = 1142
	_CS_POSIX_V7_LP64_OFF64_LINTFLAGS   = 1143
	_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS    = 1144
	_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS   = 1145
	_CS_POSIX_V7_LPBIG_OFFBIG_LIBS      = 1146
	_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147

	_CS_V6_ENV = 1148
	_CS_V7_ENV = 1149
)

const (
	_SC_ARG_MAX               = 0
	_SC_CHILD_MAX             = 1
	_SC_CLK_TCK               = 2
	_SC_NGROUPS_MAX           = 3
	_SC_OPEN_MAX              = 4
	_SC_STREAM_MAX            = 5
	_SC_TZNAME_MAX            = 6
	_SC_JOB_CONTROL           = 7
	_SC_SAVED_IDS             = 8
	_SC_REALTIME_SIGNALS      = 9
	_SC_PRIORITY_SCHEDULING   = 10
	_SC_TIMERS                = 11
	_SC_ASYNCHRONOUS_IO       = 12
	_SC_PRIORITIZED_IO        = 13
	_SC_SYNCHRONIZED_IO       = 14
	_SC_FSYNC                 = 15
	_SC_MAPPED_FILES          = 16
	_SC_MEMLOCK               = 17
	_SC_MEMLOCK_RANGE         = 18
	_SC_MEMORY_PROTECTION     = 19
	_SC_MESSAGE_PASSING       = 20
	_SC_SEMAPHORES            = 21
	_SC_SHARED_MEMORY_OBJECTS = 22
	_SC_AIO_LISTIO_MAX        = 23
	_SC_AIO_MAX               = 24
	_SC_AIO_PRIO_DELTA_MAX    = 25
	_SC_DELAYTIMER_MAX        = 26
	_SC_MQ_OPEN_MAX           = 27
	_SC_MQ_PRIO_MAX           = 28
	_SC_VERSION               = 29
	_SC_PAGESIZE              = 30
	_SC_RTSIG_MAX             = 31
	_SC_SEM_NSEMS_MAX         = 32
	_SC_SEM_VALUE_MAX         = 33
	_SC_SIGQUEUE_MAX          = 34
	_SC_TIMER_MAX             = 35

	_SC_BC_BASE_MAX        = 36
	_SC_BC_DIM_MAX         = 37
	_SC_BC_SCALE_MAX       = 38
	_SC_BC_STRING_MAX      = 39
	_SC_COLL_WEIGHTS_MAX   = 40
	_SC_EQUIV_CLASS_MAX    = 41
	_SC_EXPR_NEST_MAX      = 42
	_SC_LINE_MAX           = 43
	_SC_RE_DUP_MAX         = 44
	_SC_CHARCLASS_NAME_MAX = 45

	_SC_2_VERSION   = 46
	_SC_2_C_BIND    = 47
	_SC_2_C_DEV     = 48
	_SC_2_FORT_DEV  = 49
	_SC_2_FORT_RUN  = 50
	_SC_2_SW_DEV    = 51
	_SC_2_LOCALEDEF = 52

	_SC_PII                 = 53
	_SC_PII_XTI             = 54
	_SC_PII_SOCKET          = 55
	_SC_PII_INTERNET        = 56
	_SC_PII_OSI             = 57
	_SC_POLL                = 58
	_SC_SELECT              = 59
	_SC_UIO_MAXIOV          = 60
	_SC_IOV_MAX             = 60
	_SC_PII_INTERNET_STREAM = 61
	_SC_PII_INTERNET_DGRAM  = 62
	_SC_PII_OSI_COTS        = 63
	_SC_PII_OSI_CLTS        = 64
	_SC_PII_OSI_M           = 65
	_SC_T_IOV_MAX           = 66

	_SC_THREADS                      = 67
	_SC_THREAD_SAFE_FUNCTIONS        = 68
	_SC_GETGR_R_SIZE_MAX             = 69
	_SC_GETPW_R_SIZE_MAX             = 70
	_SC_LOGIN_NAME_MAX               = 71
	_SC_TTY_NAME_MAX                 = 72
	_SC_THREAD_DESTRUCTOR_ITERATIONS = 73
	_SC_THREAD_KEYS_MAX              = 74
	_SC_THREAD_STACK_MIN             = 75
	_SC_THREAD_THREADS_MAX           = 76
	_SC_THREAD_ATTR_STACKADDR        = 77
	_SC_THREAD_ATTR_STACKSIZE        = 78
	_SC_THREAD_PRIORITY_SCHEDULING   = 79
	_SC_THREAD_PRIO_INHERIT          = 80
	_SC_THREAD_PRIO_PROTECT          = 81
	_SC_THREAD_PROCESS_SHARED        = 82

	_SC_NPROCESSORS_CONF = 83
	_SC_NPROCESSORS_ONLN = 84
	_SC_PHYS_PAGES       = 85
	_SC_AVPHYS_PAGES     = 86
	_SC_ATEXIT_MAX       = 87
	_SC_PASS_MAX         = 88

	_SC_XOPEN_VERSION     = 89
	_SC_XOPEN_XCU_VERSION = 90
	_SC_XOPEN_UNIX        = 91
	_SC_XOPEN_CRYPT       = 92
	_SC_XOPEN_ENH_I18N    = 93
	_SC_XOPEN_SHM         = 94

	_SC_2_CHAR_TERM = 95
	_SC_2_C_VERSION = 96
	_SC_2_UPE       = 97

	_SC_XOPEN_XPG2 = 98
	_SC_XOPEN_XPG3 = 99
	_SC_XOPEN_XPG4 = 100

	_SC_CHAR_BIT   = 101
	_SC_CHAR_MAX   = 102
	_SC_CHAR_MIN   = 103
	_SC_INT_MAX    = 104
	_SC_INT_MIN    = 105
	_SC_LONG_BIT   = 106
	_SC_WORD_BIT   = 107
	_SC_MB_LEN_MAX = 108
	_SC_NZERO      = 109
	_SC_SSIZE_MAX  = 110
	_SC_SCHAR_MAX  = 111
	_SC_SCHAR_MIN  = 112
	_SC_SHRT_MAX   = 113
	_SC_SHRT_MIN   = 114
	_SC_UCHAR_MAX  = 115
	_SC_UINT_MAX   = 116
	_SC_ULONG_MAX  = 117
	_SC_USHRT_MAX  = 118

	_SC_NL_ARGMAX  = 119
	_SC_NL_LANGMAX = 120
	_SC_NL_MSGMAX  = 121
	_SC_NL_NMAX    = 122
	_SC_NL_SETMAX  = 123
	_SC_NL_TEXTMAX = 124

	_SC_XBS5_ILP32_OFF32  = 125
	_SC_XBS5_ILP32_OFFBIG = 126
	_SC_XBS5_LP64_OFF64   = 127
	_SC_XBS5_LPBIG_OFFBIG = 128

	_SC_XOPEN_LEGACY           = 129
	_SC_XOPEN_REALTIME         = 130
	_SC_XOPEN_REALTIME_THREADS = 131

	_SC_ADVISORY_INFO          = 132
	_SC_BARRIERS               = 133
	_SC_BASE                   = 134
	_SC_C_LANG_SUPPORT         = 135
	_SC_C_LANG_SUPPORT_R       = 136
	_SC_CLOCK_SELECTION        = 137
	_SC_CPUTIME                = 138
	_SC_THREAD_CPUTIME         = 139
	_SC_DEVICE_IO              = 140
	_SC_DEVICE_SPECIFIC        = 141
	_SC_DEVICE_SPECIFIC_R      = 142
	_SC_FD_MGMT                = 143
	_SC_FIFO                   = 144
	_SC_PIPE                   = 145
	_SC_FILE_ATTRIBUTES        = 146
	_SC_FILE_LOCKING           = 147
	_SC_FILE_SYSTEM            = 148
	_SC_MONOTONIC_CLOCK        = 149
	_SC_MULTI_PROCESS          = 150
	_SC_SINGLE_PROCESS         = 151
	_SC_NETWORKING             = 152
	_SC_READER_WRITER_LOCKS    = 153
	_SC_SPIN_LOCKS             = 154
	_SC_REGEXP                 = 155
	_SC_REGEX_VERSION          = 156
	_SC_SHELL                  = 157
	_SC_SIGNALS                = 158
	_SC_SPAWN                  = 159
	_SC_SPORADIC_SERVER        = 160
	_SC_THREAD_SPORADIC_SERVER = 161
	_SC_SYSTEM_DATABASE        = 162
	_SC_SYSTEM_DATABASE_R      = 163
	_SC_TIMEOUTS               = 164
	_SC_TYPED_MEMORY_OBJECTS   = 165
	_SC_USER_GROUPS            = 166
	_SC_USER_GROUPS_R          = 167
	_SC_2_PBS                  = 168
	_SC_2_PBS_ACCOUNTING       = 169
	_SC_2_PBS_LOCATE           = 170
	_SC_2_PBS_MESSAGE          = 171
	_SC_2_PBS_TRACK            = 172
	_SC_SYMLOOP_MAX            = 173
	_SC_STREAMS                = 174
	_SC_2_PBS_CHECKPOINT       = 175

	_SC_V6_ILP32_OFF32  = 176
	_SC_V6_ILP32_OFFBIG = 177
	_SC_V6_LP64_OFF64   = 178
	_SC_V6_LPBIG_OFFBIG = 179

	_SC_HOST_NAME_MAX      = 180
	_SC_TRACE              = 181
	_SC_TRACE_EVENT_FILTER = 182
	_SC_TRACE_INHERIT      = 183
	_SC_TRACE_LOG          = 184

	_SC_LEVEL1_ICACHE_SIZE     = 185
	_SC_LEVEL1_ICACHE_ASSOC    = 186
	_SC_LEVEL1_ICACHE_LINESIZE = 187
	_SC_LEVEL1_DCACHE_SIZE     = 188
	_SC_LEVEL1_DCACHE_ASSOC    = 189
	_SC_LEVEL1_DCACHE_LINESIZE = 190
	_SC_LEVEL2_CACHE_SIZE      = 191
	_SC_LEVEL2_CACHE_ASSOC     = 192
	_SC_LEVEL2_CACHE_LINESIZE  = 193
	_SC_LEVEL3_CACHE_SIZE      = 194
	_SC_LEVEL3_CACHE_ASSOC     = 195
	_SC_LEVEL3_CACHE_LINESIZE  = 196
	_SC_LEVEL4_CACHE_SIZE      = 197
	_SC_LEVEL4_CACHE_ASSOC     = 198
	_SC_LEVEL4_CACHE_LINESIZE  = 199

	_SC_IPV6        = 235
	_SC_RAW_SOCKETS = 236

	_SC_V7_ILP32_OFF32  = 237
	_SC_V7_ILP32_OFFBIG = 238
	_SC_V7_LP64_OFF64   = 239
	_SC_V7_LPBIG_OFFBIG = 240

	_SC_SS_REPL_MAX = 241

	_SC_TRACE_EVENT_NAME_MAX = 242
	_SC_TRACE_NAME_MAX       = 243
	_SC_TRACE_SYS_MAX        = 244
	_SC_TRACE_USER_EVENT_MAX = 245

	_SC_XOPEN_STREAMS = 246

	_SC_THREAD_ROBUST_PRIO_INHERIT = 247
	_SC_THREAD_ROBUST_PRIO_PROTECT = 248
)

const (
	P_ALL  = 0
	P_PID  = 1
	P_PGID = 2
)

const (
	_ISupper  = 256
	_ISlower  = 512
	_ISalpha  = 1024
	_ISdigit  = 2048
	_ISxdigit = 4096
	_ISspace  = 8192
	_ISprint  = 16384
	_ISgraph  = 32768
	_ISblank  = 1
	_IScntrl  = 2
	_ISpunct  = 4
	_ISalnum  = 8
)

type ptrdiff_t = int32

type size_t = uint32

type wchar_t = uint32

type va_list = uintptr

type sqlite_int64 = int64
type sqlite_uint64 = uint64
type sqlite3_int64 = sqlite_int64
type sqlite3_uint64 = sqlite_uint64

type sqlite3_callback = uintptr

type sqlite3_file1 = struct{ pMethods uintptr }

type sqlite3_file = sqlite3_file1
type sqlite3_io_methods1 = struct {
	iVersion               int32
	xClose                 uintptr
	xRead                  uintptr
	xWrite                 uintptr
	xTruncate              uintptr
	xSync                  uintptr
	xFileSize              uintptr
	xLock                  uintptr
	xUnlock                uintptr
	xCheckReservedLock     uintptr
	xFileControl           uintptr
	xSectorSize            uintptr
	xDeviceCharacteristics uintptr
	xShmMap                uintptr
	xShmLock               uintptr
	xShmBarrier            uintptr
	xShmUnmap              uintptr
	xFetch                 uintptr
	xUnfetch               uintptr
}

type sqlite3_io_methods = sqlite3_io_methods1

type sqlite3_filename = uintptr

type sqlite3_vfs1 = struct {
	iVersion          int32
	szOsFile          int32
	mxPathname        int32
	pNext             uintptr
	zName             uintptr
	pAppData          uintptr
	xOpen             uintptr
	xDelete           uintptr
	xAccess           uintptr
	xFullPathname     uintptr
	xDlOpen           uintptr
	xDlError          uintptr
	xDlSym            uintptr
	xDlClose          uintptr
	xRandomness       uintptr
	xSleep            uintptr
	xCurrentTime      uintptr
	xGetLastError     uintptr
	xCurrentTimeInt64 uintptr
	xSetSystemCall    uintptr
	xGetSystemCall    uintptr
	xNextSystemCall   uintptr
}

type sqlite3_vfs = sqlite3_vfs1
type sqlite3_syscall_ptr = uintptr

type sqlite3_mem_methods1 = struct {
	xMalloc   uintptr
	xFree     uintptr
	xRealloc  uintptr
	xSize     uintptr
	xRoundup  uintptr
	xInit     uintptr
	xShutdown uintptr
	pAppData  uintptr
}

type sqlite3_mem_methods = sqlite3_mem_methods1

type sqlite3_destructor_type = uintptr

type sqlite3_vtab1 = struct {
	pModule uintptr
	nRef    int32
	zErrMsg uintptr
}

type sqlite3_vtab = sqlite3_vtab1
type sqlite3_index_info1 = struct {
	nConstraint      int32
	aConstraint      uintptr
	nOrderBy         int32
	aOrderBy         uintptr
	aConstraintUsage uintptr
	idxNum           int32
	idxStr           uintptr
	needToFreeIdxStr int32
	orderByConsumed  int32
	_                [4]byte
	estimatedCost    float64
	estimatedRows    sqlite3_int64
	idxFlags         int32
	_                [4]byte
	colUsed          sqlite3_uint64
}

type sqlite3_index_info = sqlite3_index_info1
type sqlite3_vtab_cursor1 = struct{ pVtab uintptr }

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1
type sqlite3_module1 = struct {
	iVersion      int32
	xCreate       uintptr
	xConnect      uintptr
	xBestIndex    uintptr
	xDisconnect   uintptr
	xDestroy      uintptr
	xOpen         uintptr
	xClose        uintptr
	xFilter       uintptr
	xNext         uintptr
	xEof          uintptr
	xColumn       uintptr
	xRowid        uintptr
	xUpdate       uintptr
	xBegin        uintptr
	xSync         uintptr
	xCommit       uintptr
	xRollback     uintptr
	xFindFunction uintptr
	xRename       uintptr
	xSavepoint    uintptr
	xRelease      uintptr
	xRollbackTo   uintptr
	xShadowName   uintptr
}

type sqlite3_module = sqlite3_module1

type sqlite3_index_constraint = struct {
	iColumn     int32
	op          uint8
	usable      uint8
	_           [2]byte
	iTermOffset int32
}

type sqlite3_index_orderby = struct {
	iColumn int32
	desc    uint8
	_       [3]byte
}

type sqlite3_index_constraint_usage = struct {
	argvIndex int32
	omit      uint8
	_         [3]byte
}

type sqlite3_mutex_methods1 = struct {
	xMutexInit    uintptr
	xMutexEnd     uintptr
	xMutexAlloc   uintptr
	xMutexFree    uintptr
	xMutexEnter   uintptr
	xMutexTry     uintptr
	xMutexLeave   uintptr
	xMutexHeld    uintptr
	xMutexNotheld uintptr
}

type sqlite3_mutex_methods = sqlite3_mutex_methods1

type sqlite3_pcache_page1 = struct {
	pBuf   uintptr
	pExtra uintptr
}

type sqlite3_pcache_page = sqlite3_pcache_page1

type sqlite3_pcache_methods21 = struct {
	iVersion   int32
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
	xShrink    uintptr
}

type sqlite3_pcache_methods2 = sqlite3_pcache_methods21

type sqlite3_pcache_methods1 = struct {
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
}

type sqlite3_pcache_methods = sqlite3_pcache_methods1

type sqlite3_snapshot1 = struct{ hidden [48]uint8 }

type sqlite3_snapshot = sqlite3_snapshot1

type sqlite3_rtree_geometry1 = struct {
	pContext uintptr
	nParam   int32
	aParam   uintptr
	pUser    uintptr
	xDelUser uintptr
}

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1
type sqlite3_rtree_query_info1 = struct {
	pContext      uintptr
	nParam        int32
	aParam        uintptr
	pUser         uintptr
	xDelUser      uintptr
	aCoord        uintptr
	anQueue       uintptr
	nCoord        int32
	iLevel        int32
	mxLevel       int32
	iRowid        sqlite3_int64
	rParentScore  sqlite3_rtree_dbl
	eParentWithin int32
	eWithin       int32
	rScore        sqlite3_rtree_dbl
	apSqlParam    uintptr
	_             [4]byte
}

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1

type sqlite3_rtree_dbl = float64

type Fts5ExtensionApi1 = struct {
	iVersion           int32
	xUserData          uintptr
	xColumnCount       uintptr
	xRowCount          uintptr
	xColumnTotalSize   uintptr
	xTokenize          uintptr
	xPhraseCount       uintptr
	xPhraseSize        uintptr
	xInstCount         uintptr
	xInst              uintptr
	xRowid             uintptr
	xColumnText        uintptr
	xColumnSize        uintptr
	xQueryPhrase       uintptr
	xSetAuxdata        uintptr
	xGetAuxdata        uintptr
	xPhraseFirst       uintptr
	xPhraseNext        uintptr
	xPhraseFirstColumn uintptr
	xPhraseNextColumn  uintptr
}

type Fts5ExtensionApi = Fts5ExtensionApi1
type Fts5PhraseIter1 = struct {
	a uintptr
	b uintptr
}

type Fts5PhraseIter = Fts5PhraseIter1

type fts5_extension_function = uintptr
type fts5_tokenizer1 = struct {
	xCreate   uintptr
	xDelete   uintptr
	xTokenize uintptr
}

type fts5_tokenizer = fts5_tokenizer1

type fts5_api1 = struct {
	iVersion         int32
	xCreateTokenizer uintptr
	xFindTokenizer   uintptr
	xCreateFunction  uintptr
}

type fts5_api = fts5_api1

type _G_fpos_t = struct {
	__pos   int32
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
}

type _G_fpos64_t = struct {
	__pos   int64
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
}

type _IO_FILE = struct {
	_flags          int32
	_IO_read_ptr    uintptr
	_IO_read_end    uintptr
	_IO_read_base   uintptr
	_IO_write_base  uintptr
	_IO_write_ptr   uintptr
	_IO_write_end   uintptr
	_IO_buf_base    uintptr
	_IO_buf_end     uintptr
	_IO_save_base   uintptr
	_IO_backup_base uintptr
	_IO_save_end    uintptr
	_markers        uintptr
	_chain          uintptr
	_fileno         int32
	_flags2         int32
	_old_offset     int32
	_cur_column     uint16
	_vtable_offset  int8
	_shortbuf       [1]uint8
	_lock           uintptr
	_               [4]byte
	_offset         int64
	_codecvt        uintptr
	_wide_data      uintptr
	_freeres_list   uintptr
	_freeres_buf    uintptr
	__pad5          size_t
	_mode           int32
	_unused2        [40]uint8
}

type FILE = _IO_FILE

type off_t = int64

type ssize_t = int32

type fpos_t = _G_fpos64_t

type gid_t = uint32

type uid_t = uint32

type useconds_t = uint32

type pid_t = int32

type intptr_t = int32

type socklen_t = uint32

type idtype_t = uint32

type div_t = struct {
	quot int32
	rem  int32
}

type ldiv_t = struct {
	quot int32
	rem  int32
}

type lldiv_t = struct {
	quot int64
	rem  int64
}

type u_char = uint8
type u_short = uint16
type u_int = uint32
type u_long = uint32
type quad_t = int64
type u_quad_t = uint64
type fsid_t = struct{ __val [2]int32 }
type loff_t = int64

type ino_t = uint64

type dev_t = uint64

type mode_t = uint32

type nlink_t = uint32

type id_t = uint32

type daddr_t = int32
type caddr_t = uintptr

type key_t = int32

type clock_t = int32

type clockid_t = int32

type time_t = int32

type timer_t = uintptr

type ulong = uint32
type ushort = uint16
type uint = uint32

type int8_t = int8
type int16_t = int16
type int32_t = int32
type int64_t = int64

type u_int8_t = uint8
type u_int16_t = uint16
type u_int32_t = uint32
type u_int64_t = uint64

type register_t = int32

type sigset_t = struct{ __val [32]uint32 }

type timeval = struct {
	tv_sec  int32
	tv_usec int32
}

type timespec = struct {
	tv_sec  int32
	tv_nsec int32
}

type suseconds_t = int32

type fd_set = struct{ __fds_bits [32]int32 }

type fd_mask = int32

type blksize_t = int32

type blkcnt_t = int64
type fsblkcnt_t = uint64
type fsfilcnt_t = uint64

type __pthread_internal_list = struct {
	__prev uintptr
	__next uintptr
}

type __pthread_internal_slist = struct{ __next uintptr }

type __pthread_mutex_s = struct {
	__lock   int32
	__count  uint32
	__owner  int32
	__kind   int32
	__nusers uint32
	__20     struct{ __spins int32 }
}

type __pthread_rwlock_arch_t = struct {
	__readers       uint32
	__writers       uint32
	__wrphase_futex uint32
	__writers_futex uint32
	__pad3          uint32
	__pad4          uint32
	__flags         uint8
	__shared        uint8
	__pad1          uint8
	__pad2          uint8
	__cur_writer    int32
}

type __pthread_cond_s = struct {
	__0            struct{ __wseq uint64 }
	__8            struct{ __g1_start uint64 }
	__g_refs       [2]uint32
	__g_size       [2]uint32
	__g1_orig_size uint32
	__wrefs        uint32
	__g_signals    [2]uint32
}

type pthread_t = uint32

type pthread_mutexattr_t = struct {
	_      [0]uint32
	__size [4]uint8
}

type pthread_condattr_t = struct {
	_      [0]uint32
	__size [4]uint8
}

type pthread_key_t = uint32

type pthread_once_t = int32

type pthread_attr_t1 = struct {
	_      [0]uint32
	__size [36]uint8
}

type pthread_attr_t = pthread_attr_t1

type pthread_mutex_t = struct{ __data __pthread_mutex_s }

type pthread_cond_t = struct{ __data __pthread_cond_s }

type pthread_rwlock_t = struct{ __data __pthread_rwlock_arch_t }

type pthread_rwlockattr_t = struct {
	_      [0]uint32
	__size [8]uint8
}

type pthread_spinlock_t = int32

type pthread_barrier_t = struct {
	_      [0]uint32
	__size [20]uint8
}

type pthread_barrierattr_t = struct {
	_      [0]uint32
	__size [4]uint8
}

type random_data = struct {
	fptr      uintptr
	rptr      uintptr
	state     uintptr
	rand_type int32
	rand_deg  int32
	rand_sep  int32
	end_ptr   uintptr
}

type drand48_data = struct {
	__x     [3]uint16
	__old_x [3]uint16
	__c     uint16
	__init  uint16
	__a     uint64
}

type __locale_struct = struct {
	__locales       [13]uintptr
	__ctype_b       uintptr
	__ctype_tolower uintptr
	__ctype_toupper uintptr
	__names         [13]uintptr
}

type locale_t = uintptr

type Global = struct {
	argv0            uintptr
	zVfs             uintptr
	zDbFile          uintptr
	db               uintptr
	zErrLog          uintptr
	pErrLog          uintptr
	zLog             uintptr
	pLog             uintptr
	zName            [32]uint8
	taskId           int32
	iTrace           int32
	bSqlTrace        int32
	bIgnoreSqlErrors int32
	nError           int32
	nTest            int32
	iTimeout         int32
	bSync            int32
}

var g Global

func printWithPrefix(tls *libc.TLS, pOut uintptr, zPrefix uintptr, zMsg uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	for zMsg != 0 && *(*uint8)(unsafe.Pointer(zMsg)) != 0 {
		var i int32
		for i = 0; *(*uint8)(unsafe.Pointer(zMsg + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(zMsg + uintptr(i)))) != '\n' && int32(*(*uint8)(unsafe.Pointer(zMsg + uintptr(i)))) != '\r'; i++ {
		}
		libc.Xfprintf(tls, pOut, ts, libc.VaList(bp, zPrefix, i, zMsg))
		zMsg += uintptr(i)
		for int32(*(*uint8)(unsafe.Pointer(zMsg))) == '\n' || int32(*(*uint8)(unsafe.Pointer(zMsg))) == '\r' {
			zMsg++
		}
	}
}

func safe_strcmp(tls *libc.TLS, a uintptr, b uintptr) int32 {
	if a == b {
		return 0
	}
	if a == uintptr(0) {
		return -1
	}
	if b == uintptr(0) {
		return 1
	}
	return libc.Xstrcmp(tls, a, b)
}

func strglob(tls *libc.TLS, zGlob uintptr, z uintptr) int32 {
	var c int32
	var c2 int32
	var invert int32
	var seen int32

	for libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) != 0 {
		if c == '*' {
			for libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) == '*' || c == '?' {
				if c == '?' && int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
					return 0
				}
			}
			if c == 0 {
				return 1
			} else if c == '[' {
				for *(*uint8)(unsafe.Pointer(z)) != 0 && strglob(tls, zGlob-uintptr(1), z) != 0 {
					z++
				}
				return libc.Bool32(int32(*(*uint8)(unsafe.Pointer(z))) != 0)
			}
			for libc.AssignInt32(&c2, int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) != 0 {
				for c2 != c {
					c2 = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
					if c2 == 0 {
						return 0
					}
				}
				if strglob(tls, zGlob, z) != 0 {
					return 1
				}
			}
			return 0
		} else if c == '?' {
			if int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
				return 0
			}
		} else if c == '[' {
			var prior_c int32 = 0
			seen = 0
			invert = 0
			c = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
			if c == 0 {
				return 0
			}
			c2 = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			if c2 == '^' {
				invert = 1
				c2 = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == ']' {
				if c == ']' {
					seen = 1
				}
				c2 = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			for c2 != 0 && c2 != ']' {
				if c2 == '-' && int32(*(*uint8)(unsafe.Pointer(zGlob))) != ']' && int32(*(*uint8)(unsafe.Pointer(zGlob))) != 0 && prior_c > 0 {
					c2 = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
					if c >= prior_c && c <= c2 {
						seen = 1
					}
					prior_c = 0
				} else {
					if c == c2 {
						seen = 1
					}
					prior_c = c2
				}
				c2 = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == 0 || seen^invert == 0 {
				return 0
			}
		} else if c == '#' {
			if (int32(*(*uint8)(unsafe.Pointer(z))) == '-' || int32(*(*uint8)(unsafe.Pointer(z))) == '+') && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z + 1))))*2)))&int32(_ISdigit) != 0 {
				z++
			}
			if !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z))))*2)))&int32(_ISdigit) != 0) {
				return 0
			}
			z++
			for int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z))))*2)))&int32(_ISdigit) != 0 {
				z++
			}
		} else {
			if c != int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) {
				return 0
			}
		}
	}
	return libc.Bool32(int32(*(*uint8)(unsafe.Pointer(z))) == 0)
}

func maybeClose(tls *libc.TLS, pOut uintptr) {
	if pOut != libc.Xstdout && pOut != libc.Xstderr {
		libc.Xfclose(tls, pOut)
	}
}

func errorMessage(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var ap va_list
	_ = ap
	var zMsg uintptr

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]uint8{})), bp+8, ts+8, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+32))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pLog)
	}
	if g.pErrLog != 0 && safe_strcmp(tls, g.zErrLog, g.zLog) != 0 {
		printWithPrefix(tls, g.pErrLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pErrLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
	g.nError++
}

func fatalError(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var ap va_list
	_ = ap
	var zMsg uintptr

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]uint8{})), bp+8, ts+19, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+32))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pLog)
		maybeClose(tls, g.pLog)
	}
	if g.pErrLog != 0 && safe_strcmp(tls, g.zErrLog, g.zLog) != 0 {
		printWithPrefix(tls, g.pErrLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pErrLog)
		maybeClose(tls, g.pErrLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
	if g.db != 0 {
		var nTry int32 = 0
		g.iTimeout = 0
		for trySql(tls, ts+30, 0) == SQLITE_BUSY &&
			libc.PostIncInt32(&nTry, 1) < 100 {
			sqlite3.Xsqlite3_sleep(tls, 10)
		}
	}
	sqlite3.Xsqlite3_close(tls, g.db)
	libc.Xexit(tls, 1)
}

func logMessage(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var ap va_list
	_ = ap
	var zMsg uintptr

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]uint8{})), bp+8, ts+60, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+32))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
}

func clipLength(tls *libc.TLS, z uintptr) int32 {
	var n int32 = int32(libc.Xstrlen(tls, z))
	for n > 0 && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z + uintptr(n-1)))))*2)))&int32(_ISspace) != 0 {
		n--
	}
	return n
}

func vfsNameFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	_ = argc
	_ = argv
	sqlite3.Xsqlite3_file_control(tls, db, ts+65, SQLITE_FCNTL_VFSNAME, bp)
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		sqlite3.Xsqlite3_result_text(tls, context, *(*uintptr)(unsafe.Pointer(bp)), -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func busyHandler(tls *libc.TLS, pCD uintptr, count int32) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	_ = pCD
	if count*10 > g.iTimeout {
		if g.iTimeout > 0 {
			errorMessage(tls, ts+70, libc.VaList(bp, g.iTimeout))
		}
		return 0
	}
	sqlite3.Xsqlite3_sleep(tls, 10)
	return 1
}

func sqlTraceCallback(tls *libc.TLS, NotUsed1 uintptr, zSql uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	_ = NotUsed1
	logMessage(tls, ts+89, libc.VaList(bp, clipLength(tls, zSql), zSql))
}

func sqlErrorCallback(tls *libc.TLS, pArg uintptr, iErrCode int32, zMsg uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = pArg
	if iErrCode == SQLITE_ERROR && g.bIgnoreSqlErrors != 0 {
		return
	}
	if iErrCode&0xff == SQLITE_SCHEMA && g.iTrace < 3 {
		return
	}
	if g.iTimeout == 0 && iErrCode&0xff == SQLITE_BUSY && g.iTrace < 3 {
		return
	}
	if iErrCode&0xff == SQLITE_NOTICE {
		logMessage(tls, ts+96, libc.VaList(bp, zMsg))
	} else {
		errorMessage(tls, ts+106, libc.VaList(bp+8, iErrCode, zMsg))
	}
}

func prepareSql(tls *libc.TLS, zFormat uintptr, va uintptr) uintptr {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_prepare_v2(tls, g.db, zSql, -1, bp+16, uintptr(0))
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
		fatalError(tls, ts+122, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db), zSql))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	return *(*uintptr)(unsafe.Pointer(bp + 16))
}

func runSql(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, uintptr(0), uintptr(0), uintptr(0))
	if rc != SQLITE_OK {
		fatalError(tls, ts+122, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db), zSql))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
}

func trySql(tls *libc.TLS, zFormat uintptr, va uintptr) int32 {
	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	return rc
}

type String1 = struct {
	z      uintptr
	n      int32
	nAlloc int32
}

type String = String1

func stringFree(tls *libc.TLS, p uintptr) {
	if (*String)(unsafe.Pointer(p)).z != 0 {
		sqlite3.Xsqlite3_free(tls, (*String)(unsafe.Pointer(p)).z)
	}
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(String{})))
}

func stringAppend(tls *libc.TLS, p uintptr, z uintptr, n int32) {
	if n < 0 {
		n = int32(libc.Xstrlen(tls, z))
	}
	if (*String)(unsafe.Pointer(p)).n+n >= (*String)(unsafe.Pointer(p)).nAlloc {
		var nAlloc int32 = (*String)(unsafe.Pointer(p)).nAlloc*2 + n + 100
		var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*String)(unsafe.Pointer(p)).z, nAlloc)
		if zNew == uintptr(0) {
			fatalError(tls, ts+129, 0)
		}
		(*String)(unsafe.Pointer(p)).z = zNew
		(*String)(unsafe.Pointer(p)).nAlloc = nAlloc
	}
	libc.Xmemcpy(tls, (*String)(unsafe.Pointer(p)).z+uintptr((*String)(unsafe.Pointer(p)).n), z, uint32(n))
	*(*int32)(unsafe.Pointer(p + 4)) += n
	*(*uint8)(unsafe.Pointer((*String)(unsafe.Pointer(p)).z + uintptr((*String)(unsafe.Pointer(p)).n))) = uint8(0)
}

func stringReset(tls *libc.TLS, p uintptr) {
	if (*String)(unsafe.Pointer(p)).z == uintptr(0) {
		stringAppend(tls, p, ts+143, 1)
	}
	(*String)(unsafe.Pointer(p)).n = 0
	*(*uint8)(unsafe.Pointer((*String)(unsafe.Pointer(p)).z)) = uint8(0)
}

func stringAppendTerm(tls *libc.TLS, p uintptr, z uintptr) {
	var i int32
	if (*String)(unsafe.Pointer(p)).n != 0 {
		stringAppend(tls, p, ts+143, 1)
	}
	if z == uintptr(0) {
		stringAppend(tls, p, ts+145, 3)
		return
	}
	for i = 0; *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 && !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))*2)))&int32(_ISspace) != 0); i++ {
	}
	if i > 0 && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 0 {
		stringAppend(tls, p, z, i)
		return
	}
	stringAppend(tls, p, ts+149, 1)
	for *(*uint8)(unsafe.Pointer(z)) != 0 {
		for i = 0; *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\''; i++ {
		}
		if *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 {
			stringAppend(tls, p, z, i+1)
			stringAppend(tls, p, ts+149, 1)
			z += uintptr(i + 1)
		} else {
			stringAppend(tls, p, z, i)
			break
		}
	}
	stringAppend(tls, p, ts+149, 1)
}

func evalCallback(tls *libc.TLS, pCData uintptr, argc int32, argv uintptr, azCol uintptr) int32 {
	var p uintptr = pCData
	var i int32
	_ = azCol
	for i = 0; i < argc; i++ {
		stringAppendTerm(tls, p, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	}
	return 0
}

func evalSql(tls *libc.TLS, p uintptr, zFormat uintptr, va uintptr) int32 {
	bp := tls.Alloc(42)
	defer tls.Free(42)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(0)
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap

	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{evalCallback})), p, bp+8)
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]uint8{})), bp+12, ts+151, libc.VaList(bp, rc))
		stringAppendTerm(tls, p, bp+12)
		if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
			stringAppendTerm(tls, p, *(*uintptr)(unsafe.Pointer(bp + 8)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		}
	}
	return rc
}

func evalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var zSql uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))

	*(*uintptr)(unsafe.Pointer(bp + 12)) = uintptr(0)
	var rc int32
	_ = argc
	libc.Xmemset(tls, bp, 0, uint32(unsafe.Sizeof(String{})))
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{evalCallback})), bp, bp+12)
	if *(*uintptr)(unsafe.Pointer(bp + 12)) != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, *(*uintptr)(unsafe.Pointer(bp + 12)), -1)
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 12)))
	} else if rc != 0 {
		sqlite3.Xsqlite3_result_error_code(tls, context, rc)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, (*String)(unsafe.Pointer(bp)).z, -1, libc.UintptrFromInt32(-1))
	}
	stringFree(tls, bp)
}

func startScript(tls *libc.TLS, iClient int32, pzScript uintptr, pTaskId uintptr, pzTaskName uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var pStmt uintptr = uintptr(0)
	var taskId int32
	var rc int32
	var totalTime int32 = 0

	*(*uintptr)(unsafe.Pointer(pzScript)) = uintptr(0)
	g.iTimeout = 0
	for 1 != 0 {
		rc = trySql(tls, ts+161, 0)
		if rc == SQLITE_BUSY {
			sqlite3.Xsqlite3_sleep(tls, 10)
			totalTime = totalTime + 10
			continue
		}
		if rc != SQLITE_OK {
			fatalError(tls, ts+177, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db)))
		}
		if g.nError != 0 || g.nTest != 0 {
			runSql(tls, ts+196,
				libc.VaList(bp+8, g.nError, g.nTest))
			g.nError = 0
			g.nTest = 0
		}
		pStmt = prepareSql(tls, ts+249, libc.VaList(bp+24, iClient))
		rc = sqlite3.Xsqlite3_step(tls, pStmt)
		sqlite3.Xsqlite3_finalize(tls, pStmt)
		if rc == SQLITE_ROW {
			runSql(tls, ts+295, libc.VaList(bp+32, iClient))
			g.iTimeout = DEFAULT_TIMEOUT
			runSql(tls, ts+326, 0)
			return SQLITE_DONE
		}
		pStmt = prepareSql(tls,
			ts+346, libc.VaList(bp+40, iClient))
		rc = sqlite3.Xsqlite3_step(tls, pStmt)
		if rc == SQLITE_ROW {
			var n int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 0)
			*(*uintptr)(unsafe.Pointer(pzScript)) = sqlite3.Xsqlite3_malloc(tls, n+1)
			libc.Xstrcpy(tls, *(*uintptr)(unsafe.Pointer(pzScript)), sqlite3.Xsqlite3_column_text(tls, pStmt, 0))
			*(*int32)(unsafe.Pointer(pTaskId)) = libc.AssignInt32(&taskId, sqlite3.Xsqlite3_column_int(tls, pStmt, 1))
			*(*uintptr)(unsafe.Pointer(pzTaskName)) = sqlite3.Xsqlite3_mprintf(tls, ts+438, libc.VaList(bp+48, sqlite3.Xsqlite3_column_text(tls, pStmt, 2)))
			sqlite3.Xsqlite3_finalize(tls, pStmt)
			runSql(tls,
				ts+441, libc.VaList(bp+56, taskId))
			g.iTimeout = DEFAULT_TIMEOUT
			runSql(tls, ts+326, 0)
			return SQLITE_OK
		}
		sqlite3.Xsqlite3_finalize(tls, pStmt)
		if rc == SQLITE_DONE {
			if totalTime > 3000000 {
				errorMessage(tls, ts+524, 0)
				runSql(tls, ts+575, libc.VaList(bp+64, iClient))
				sqlite3.Xsqlite3_close(tls, g.db)
				libc.Xexit(tls, 1)
			}
			for trySql(tls, ts+615, 0) == SQLITE_BUSY {
				sqlite3.Xsqlite3_sleep(tls, 10)
				totalTime = totalTime + 10
			}
			sqlite3.Xsqlite3_sleep(tls, 100)
			totalTime = totalTime + 100
			continue
		}
		fatalError(tls, ts+438, libc.VaList(bp+72, sqlite3.Xsqlite3_errmsg(tls, g.db)))
	}
	g.iTimeout = DEFAULT_TIMEOUT
	return int32(0)
}

func finishScript(tls *libc.TLS, iClient int32, taskId int32, bShutdown int32) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	runSql(tls,
		ts+622, libc.VaList(bp, taskId))
	if bShutdown != 0 {
		runSql(tls, ts+295, libc.VaList(bp+8, iClient))
	}
	return SQLITE_OK
}

func startClient(tls *libc.TLS, iClient int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	runSql(tls, ts+703, libc.VaList(bp, iClient))
	if sqlite3.Xsqlite3_changes(tls, g.db) != 0 {
		var zSys uintptr
		var rc int32
		zSys = sqlite3.Xsqlite3_mprintf(tls, ts+745,
			libc.VaList(bp+8, g.argv0, g.zDbFile, iClient, g.iTrace))
		if g.bSqlTrace != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+776, libc.VaList(bp+40, zSys))
		}
		if g.bSync != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+790, libc.VaList(bp+48, zSys))
		}
		if g.zVfs != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+800, libc.VaList(bp+56, zSys, g.zVfs))
		}
		if g.iTrace >= 2 {
			logMessage(tls, ts+814, libc.VaList(bp+72, zSys))
		}
		zSys = sqlite3.Xsqlite3_mprintf(tls, ts+827, libc.VaList(bp+80, zSys))
		rc = libc.Xsystem(tls, zSys)
		if rc != 0 {
			errorMessage(tls, ts+832, libc.VaList(bp+88, rc))
		}
		sqlite3.Xsqlite3_free(tls, zSys)
	}
}

func readFile(tls *libc.TLS, zFilename uintptr) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var in uintptr = libc.Xfopen(tls, zFilename, ts+866)
	var sz int32
	var z uintptr
	if in == uintptr(0) {
		fatalError(tls, ts+869, libc.VaList(bp, zFilename))
	}
	libc.Xfseek(tls, in, 0, SEEK_END)
	sz = libc.Xftell(tls, in)
	libc.Xrewind(tls, in)
	z = sqlite3.Xsqlite3_malloc(tls, sz+1)
	sz = int32(libc.Xfread(tls, z, uint32(1), uint32(sz), in))
	*(*uint8)(unsafe.Pointer(z + uintptr(sz))) = uint8(0)
	libc.Xfclose(tls, in)
	return z
}

func tokenLength(tls *libc.TLS, z uintptr, pnLine uintptr) int32 {
	var n int32 = 0
	if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z))))*2)))&int32(_ISspace) != 0 || int32(*(*uint8)(unsafe.Pointer(z))) == '/' && int32(*(*uint8)(unsafe.Pointer(z + 1))) == '*' {
		var inC int32 = 0
		var c int32
		if int32(*(*uint8)(unsafe.Pointer(z))) == '/' {
			inC = 1
			n = 2
		}
		for libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&n, 1)))))) != 0 {
			if c == '\n' {
				*(*int32)(unsafe.Pointer(pnLine))++
			}
			if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(uint8(c)))*2)))&int32(_ISspace) != 0 {
				continue
			}
			if inC != 0 && c == '*' && int32(*(*uint8)(unsafe.Pointer(z + uintptr(n)))) == '/' {
				n++
				inC = 0
			} else if !(inC != 0) && c == '/' && int32(*(*uint8)(unsafe.Pointer(z + uintptr(n)))) == '*' {
				n++
				inC = 1
			} else if !(inC != 0) {
				break
			}
		}
		n--
	} else if int32(*(*uint8)(unsafe.Pointer(z))) == '-' && int32(*(*uint8)(unsafe.Pointer(z + 1))) == '-' {
		for n = 2; *(*uint8)(unsafe.Pointer(z + uintptr(n))) != 0 && int32(*(*uint8)(unsafe.Pointer(z + uintptr(n)))) != '\n'; n++ {
		}
		if *(*uint8)(unsafe.Pointer(z + uintptr(n))) != 0 {
			*(*int32)(unsafe.Pointer(pnLine))++
			n++
		}
	} else if int32(*(*uint8)(unsafe.Pointer(z))) == '"' || int32(*(*uint8)(unsafe.Pointer(z))) == '\'' {
		var delim int32 = int32(*(*uint8)(unsafe.Pointer(z)))
		for n = 1; *(*uint8)(unsafe.Pointer(z + uintptr(n))) != 0; n++ {
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(n)))) == '\n' {
				*(*int32)(unsafe.Pointer(pnLine))++
			}
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(n)))) == delim {
				n++
				if int32(*(*uint8)(unsafe.Pointer(z + uintptr(n+1)))) != delim {
					break
				}
			}
		}
	} else {
		var c int32
		for n = 1; libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(n))))) != 0 && !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(uint8(c)))*2)))&int32(_ISspace) != 0) && c != '"' && c != '\'' && c != ';'; n++ {
		}
	}
	return n
}

func extractToken(tls *libc.TLS, zIn uintptr, nIn int32, zOut uintptr, nOut int32) int32 {
	var i int32
	if nIn <= 0 {
		*(*uint8)(unsafe.Pointer(zOut)) = uint8(0)
		return 0
	}
	for i = 0; i < nIn && i < nOut-1 && !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))))*2)))&int32(_ISspace) != 0); i++ {
		*(*uint8)(unsafe.Pointer(zOut + uintptr(i))) = *(*uint8)(unsafe.Pointer(zIn + uintptr(i)))
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(i))) = uint8(0)
	return i
}

func findEnd(tls *libc.TLS, z uintptr, pnLine uintptr) int32 {
	var n int32 = 0
	for *(*uint8)(unsafe.Pointer(z + uintptr(n))) != 0 && (libc.Xstrncmp(tls, z+uintptr(n), ts+898, uint32(5)) != 0 || !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z + uintptr(n+5)))))*2)))&int32(_ISspace) != 0)) {
		n = n + tokenLength(tls, z+uintptr(n), pnLine)
	}
	return n
}

func findEndif(tls *libc.TLS, z uintptr, stopAtElse int32, pnLine uintptr) int32 {
	var n int32 = 0
	for *(*uint8)(unsafe.Pointer(z + uintptr(n))) != 0 {
		var len int32 = tokenLength(tls, z+uintptr(n), pnLine)
		if libc.Xstrncmp(tls, z+uintptr(n), ts+904, uint32(7)) == 0 && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z + uintptr(n+7)))))*2)))&int32(_ISspace) != 0 ||
			stopAtElse != 0 && libc.Xstrncmp(tls, z+uintptr(n), ts+912, uint32(6)) == 0 && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z + uintptr(n+6)))))*2)))&int32(_ISspace) != 0 {
			return n + len
		}
		if libc.Xstrncmp(tls, z+uintptr(n), ts+919, uint32(4)) == 0 && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(z + uintptr(n+4)))))*2)))&int32(_ISspace) != 0 {
			var skip int32 = findEndif(tls, z+uintptr(n)+uintptr(len), 0, pnLine)
			n = n + (skip + len)
		} else {
			n = n + len
		}
	}
	return n
}

func waitForClient(tls *libc.TLS, iClient int32, iTimeout int32, zErrPrefix uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pStmt uintptr
	var rc int32
	if iClient > 0 {
		pStmt = prepareSql(tls,
			ts+924,
			libc.VaList(bp, iClient))
	} else {
		pStmt = prepareSql(tls,
			ts+1020, 0)
	}
	g.iTimeout = 0
	for (libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt)) == SQLITE_BUSY || rc == SQLITE_ROW) &&
		iTimeout > 0 {
		sqlite3.Xsqlite3_reset(tls, pStmt)
		sqlite3.Xsqlite3_sleep(tls, 50)
		iTimeout = iTimeout - 50
	}
	sqlite3.Xsqlite3_finalize(tls, pStmt)
	g.iTimeout = DEFAULT_TIMEOUT
	if rc != SQLITE_DONE {
		if zErrPrefix == uintptr(0) {
			zErrPrefix = ts + 1101
		}
		if iClient > 0 {
			errorMessage(tls, ts+1102, libc.VaList(bp+8, zErrPrefix, iClient))
		} else {
			errorMessage(tls, ts+1134, libc.VaList(bp+24, zErrPrefix))
		}
	}
}

func filenameTail(tls *libc.TLS, z uintptr) uintptr {
	var i int32
	var j int32
	for i = libc.AssignInt32(&j, 0); *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == '/' {
			j = i + 1
		}
	}
	return z + uintptr(j)
}

func booleanValue(tls *libc.TLS, zArg uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	if zArg == uintptr(0) {
		return 0
	}
	for i = 0; int32(*(*uint8)(unsafe.Pointer(zArg + uintptr(i)))) >= '0' && int32(*(*uint8)(unsafe.Pointer(zArg + uintptr(i)))) <= '9'; i++ {
	}
	if i > 0 && int32(*(*uint8)(unsafe.Pointer(zArg + uintptr(i)))) == 0 {
		return libc.Xatoi(tls, zArg)
	}
	if sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1168) == 0 || sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1171) == 0 {
		return 1
	}
	if sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1175) == 0 || sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1179) == 0 {
		return 0
	}
	errorMessage(tls, ts+1182, libc.VaList(bp, zArg))
	return 0
}

func test_breakpoint(tls *libc.TLS) {
	atomic.AddInt32(&cnt, 1)
}

var cnt int32 = 0

func runScript(tls *libc.TLS, iClient int32, taskId int32, zScript uintptr, zFilename uintptr) {
	bp := tls.Alloc(1606)
	defer tls.Free(1606)

	*(*int32)(unsafe.Pointer(bp + 372)) = 1
	var prevLine int32 = 1
	var ii int32 = 0
	var iBegin int32 = 0
	var n int32
	var c int32
	var j int32
	var len int32
	var nArg int32

	libc.Xmemset(tls, bp+360, 0, uint32(unsafe.Sizeof(String{})))
	stringReset(tls, bp+360)
	for libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(zScript + uintptr(ii))))) != 0 {
		prevLine = *(*int32)(unsafe.Pointer(bp + 372))
		len = tokenLength(tls, zScript+uintptr(ii), bp+372)
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(uint8(c)))*2)))&int32(_ISspace) != 0 || c == '/' && int32(*(*uint8)(unsafe.Pointer(zScript + uintptr(ii+1)))) == '*' {
			ii = ii + len
			continue
		}
		if c != '-' || int32(*(*uint8)(unsafe.Pointer(zScript + uintptr(ii+1)))) != '-' || !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zScript + uintptr(ii+2)))))*2)))&int32(_ISalpha) != 0) {
			ii = ii + len
			continue
		}

		if ii > iBegin {
			var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp, ii-iBegin, zScript+uintptr(iBegin)))
			evalSql(tls, bp+360, zSql, 0)
			sqlite3.Xsqlite3_free(tls, zSql)
			iBegin = ii + len
		}

		if g.iTrace >= 2 {
			logMessage(tls, ts+1204, libc.VaList(bp+16, len, zScript+uintptr(ii)))
		}
		n = extractToken(tls, zScript+uintptr(ii)+uintptr(2), len-2, bp+376, int32(unsafe.Sizeof([30]uint8{})))
		for nArg = 0; n < len-2 && nArg < MX_ARG; nArg++ {
			for n < len-2 && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zScript + uintptr(ii+2+n)))))*2)))&int32(_ISspace) != 0 {
				n++
			}
			if n >= len-2 {
				break
			}
			n = n + extractToken(tls, zScript+uintptr(ii)+uintptr(2)+uintptr(n), len-2-n,
				bp+406+uintptr(nArg)*100, int32(unsafe.Sizeof([100]uint8{})))
		}
		for j = nArg; j < MX_ARG; j++ {
			*(*uint8)(unsafe.Pointer(bp + 406 + uintptr(libc.PostIncInt32(&j, 1))*100)) = uint8(0)
		}

		if libc.Xstrcmp(tls, bp+376, ts+1209) == 0 {
			sqlite3.Xsqlite3_sleep(tls, libc.Xatoi(tls, bp+406))
		} else if libc.Xstrcmp(tls, bp+376, ts+1215) == 0 {
			var rc int32 = libc.Xatoi(tls, bp+406)
			finishScript(tls, iClient, taskId, 1)
			if rc == 0 {
				sqlite3.Xsqlite3_close(tls, g.db)
			}
			libc.Xexit(tls, rc)
		} else if libc.Xstrcmp(tls, bp+376, ts+1220) == 0 {
			if g.iTrace == 1 {
				logMessage(tls, ts+1204, libc.VaList(bp+32, len-1, zScript+uintptr(ii)))
			}
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+376, ts+1229) == 0 && iClient > 0 {
			finishScript(tls, iClient, taskId, 1)
		} else if libc.Xstrcmp(tls, bp+376, ts+1236) == 0 {
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+376, ts+1242) == 0 {
			var jj int32
			var zAns uintptr = zScript + uintptr(ii)
			for jj = 7; jj < len-1 && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zAns + uintptr(jj)))))*2)))&int32(_ISspace) != 0; jj++ {
			}
			zAns += uintptr(jj)
			if len-jj-1 != (*String)(unsafe.Pointer(bp+360)).n || libc.Xstrncmp(tls, (*String)(unsafe.Pointer(bp+360)).z, zAns, uint32(len-jj-1)) != 0 {
				errorMessage(tls, ts+1248,
					libc.VaList(bp+48, prevLine, zFilename, len-jj-1, zAns, (*String)(unsafe.Pointer(bp+360)).z))
			}
			g.nTest++
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+376, ts+1293) == 0 || libc.Xstrcmp(tls, bp+376, ts+1298) == 0 {
			var jj int32
			var zAns uintptr = zScript + uintptr(ii)
			var zCopy uintptr
			var isGlob int32 = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(bp + 376))) == 'g')
			for jj = 9 - 3*isGlob; jj < len-1 && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zAns + uintptr(jj)))))*2)))&int32(_ISspace) != 0; jj++ {
			}
			zAns += uintptr(jj)
			zCopy = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp+88, len-jj-1, zAns))
			if libc.Bool32(sqlite3.Xsqlite3_strglob(tls, zCopy, (*String)(unsafe.Pointer(bp+360)).z) == 0)^isGlob != 0 {
				errorMessage(tls, ts+1306,
					libc.VaList(bp+104, prevLine, zFilename, zCopy, (*String)(unsafe.Pointer(bp+360)).z))
			}
			sqlite3.Xsqlite3_free(tls, zCopy)
			g.nTest++
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+376, ts+1349) == 0 {
			logMessage(tls, ts+438, libc.VaList(bp+136, (*String)(unsafe.Pointer(bp+360)).z))
		} else if libc.Xstrcmp(tls, bp+376, ts+1356) == 0 {
			var zNewFile uintptr
			var zNewScript uintptr
			var zToDel uintptr = uintptr(0)
			zNewFile = bp + 406
			if !(int32(*(*uint8)(unsafe.Pointer(zNewFile))) == '/') {
				var k int32
				for k = int32(libc.Xstrlen(tls, zFilename)) - 1; k >= 0 && !(int32(*(*uint8)(unsafe.Pointer(zFilename + uintptr(k)))) == '/'); k-- {
				}
				if k > 0 {
					zNewFile = libc.AssignUintptr(&zToDel, sqlite3.Xsqlite3_mprintf(tls, ts+1363, libc.VaList(bp+144, k, zFilename, zNewFile)))
				}
			}
			zNewScript = readFile(tls, zNewFile)
			if g.iTrace != 0 {
				logMessage(tls, ts+1371, libc.VaList(bp+168, zNewFile))
			}
			runScript(tls, 0, 0, zNewScript, zNewFile)
			sqlite3.Xsqlite3_free(tls, zNewScript)
			if g.iTrace != 0 {
				logMessage(tls, ts+1390, libc.VaList(bp+176, zNewFile))
			}
			sqlite3.Xsqlite3_free(tls, zToDel)
		} else if libc.Xstrcmp(tls, bp+376, ts+1407) == 0 {
			var jj int32
			for jj = 7; jj < len && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zScript + uintptr(ii+jj)))))*2)))&int32(_ISspace) != 0; jj++ {
			}
			logMessage(tls, ts+1204, libc.VaList(bp+184, len-jj, zScript+uintptr(ii)+uintptr(jj)))
		} else if libc.Xstrcmp(tls, bp+376, ts+1413) == 0 {
			var jj int32
			var rc int32
			var pStmt uintptr
			for jj = 4; jj < len && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(zScript + uintptr(ii+jj)))))*2)))&int32(_ISspace) != 0; jj++ {
			}
			pStmt = prepareSql(tls, ts+1416, libc.VaList(bp+200, len-jj, zScript+uintptr(ii)+uintptr(jj)))
			rc = sqlite3.Xsqlite3_step(tls, pStmt)
			if rc != SQLITE_ROW || sqlite3.Xsqlite3_column_int(tls, pStmt, 0) == 0 {
				ii = ii + findEndif(tls, zScript+uintptr(ii)+uintptr(len), 1, bp+372)
			}
			sqlite3.Xsqlite3_finalize(tls, pStmt)
		} else if libc.Xstrcmp(tls, bp+376, ts+1428) == 0 {
			ii = ii + findEndif(tls, zScript+uintptr(ii)+uintptr(len), 0, bp+372)
		} else if libc.Xstrcmp(tls, bp+376, ts+1433) == 0 {
		} else if libc.Xstrcmp(tls, bp+376, ts+1439) == 0 && iClient == 0 {
			var iNewClient int32 = libc.Xatoi(tls, bp+406)
			if iNewClient > 0 {
				startClient(tls, iNewClient)
			}
		} else if libc.Xstrcmp(tls, bp+376, ts+1445) == 0 && iClient == 0 {
			var iTimeout int32
			if nArg >= 2 {
				iTimeout = libc.Xatoi(tls, bp+406+1*100)
			} else {
				iTimeout = DEFAULT_TIMEOUT
			}
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]uint8{})), bp+606, ts+1450,
				libc.VaList(bp+216, prevLine, zFilename))
			waitForClient(tls, libc.Xatoi(tls, bp+406), iTimeout, bp+606)
		} else if libc.Xstrcmp(tls, bp+376, ts+1465) == 0 && iClient == 0 {
			var iTarget int32 = libc.Xatoi(tls, bp+406)
			var iEnd int32
			var zTask uintptr
			var zTName uintptr
			iEnd = findEnd(tls, zScript+uintptr(ii)+uintptr(len), bp+372)
			if iTarget < 0 {
				errorMessage(tls, ts+1470,
					libc.VaList(bp+232, prevLine, zFilename, iTarget))
			} else {
				zTask = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp+256, iEnd, zScript+uintptr(ii)+uintptr(len)))
				if nArg > 1 {
					zTName = sqlite3.Xsqlite3_mprintf(tls, ts+438, libc.VaList(bp+272, bp+406+1*100))
				} else {
					zTName = sqlite3.Xsqlite3_mprintf(tls, ts+1507, libc.VaList(bp+280, filenameTail(tls, zFilename), prevLine))
				}
				startClient(tls, iTarget)
				runSql(tls,
					ts+1513, libc.VaList(bp+296, iTarget, zTask, zTName))
				sqlite3.Xsqlite3_free(tls, zTask)
				sqlite3.Xsqlite3_free(tls, zTName)
			}
			iEnd = iEnd + tokenLength(tls, zScript+uintptr(ii)+uintptr(len)+uintptr(iEnd), bp+372)
			len = len + iEnd
			iBegin = ii + len
		} else if libc.Xstrcmp(tls, bp+376, ts+1569) == 0 {
			test_breakpoint(tls)
		} else if libc.Xstrcmp(tls, bp+376, ts+1580) == 0 {
			g.bIgnoreSqlErrors = func() int32 {
				if nArg >= 1 {
					return libc.BoolInt32(!(booleanValue(tls, bp+406) != 0))
				}
				return 1
			}()
		} else {
			errorMessage(tls, ts+1596,
				libc.VaList(bp+320, prevLine, zFilename, bp+376))
		}
		ii = ii + len
	}
	if iBegin < ii {
		var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp+344, ii-iBegin, zScript+uintptr(iBegin)))
		runSql(tls, zSql, 0)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	stringFree(tls, bp+360)
}

func findOption(tls *libc.TLS, azArg uintptr, pnArg uintptr, zOption uintptr, hasArg int32) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var j int32
	var zReturn uintptr = uintptr(0)
	var nArg int32 = *(*int32)(unsafe.Pointer(pnArg))

	for i = 0; i < nArg; i++ {
		var z uintptr
		if i+hasArg >= nArg {
			break
		}
		z = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))
		if int32(*(*uint8)(unsafe.Pointer(z))) != '-' {
			continue
		}
		z++
		if int32(*(*uint8)(unsafe.Pointer(z))) == '-' {
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) == 0 {
				break
			}
			z++
		}
		if libc.Xstrcmp(tls, z, zOption) == 0 {
			if hasArg != 0 && i == nArg-1 {
				fatalError(tls, ts+1632, libc.VaList(bp, z))
			}
			if hasArg != 0 {
				zReturn = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i+1)*4))
			} else {
				zReturn = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))
			}
			j = i + 1 + libc.Bool32(hasArg != 0)
			for j < nArg {
				*(*uintptr)(unsafe.Pointer(azArg + uintptr(libc.PostIncInt32(&i, 1))*4)) = *(*uintptr)(unsafe.Pointer(azArg + uintptr(libc.PostIncInt32(&j, 1))*4))
			}
			*(*int32)(unsafe.Pointer(pnArg)) = i
			return zReturn
		}
	}
	return zReturn
}

func usage(tls *libc.TLS, argv0 uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var zTail uintptr = argv0
	for i = 0; *(*uint8)(unsafe.Pointer(argv0 + uintptr(i))) != 0; i++ {
		if int32(*(*uint8)(unsafe.Pointer(argv0 + uintptr(i)))) == '/' {
			zTail = argv0 + uintptr(i) + uintptr(1)
		}
	}
	libc.Xfprintf(tls, libc.Xstderr, ts+1680, libc.VaList(bp, zTail))
	libc.Xfprintf(tls, libc.Xstderr,
		ts+1719, 0)
	libc.Xexit(tls, 1)
}

func unrecognizedArguments(tls *libc.TLS, argv0 uintptr, nArg int32, azArg uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	libc.Xfprintf(tls, libc.Xstderr, ts+2291, libc.VaList(bp, argv0))
	for i = 0; i < nArg; i++ {
		libc.Xfprintf(tls, libc.Xstderr, ts+2319, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))))
	}
	libc.Xfprintf(tls, libc.Xstderr, ts+2323, 0)
	libc.Xexit(tls, 1)
}

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(248)
	defer tls.Free(248)

	var zClient uintptr
	var iClient int32

	var i int32
	var openFlags int32 = SQLITE_OPEN_READWRITE
	var rc int32

	var zTrace uintptr
	var zCOption uintptr
	var zJMode uintptr
	var zNRep uintptr
	var nRep int32 = 1
	var iRep int32
	var iTmout int32 = 0
	var zTmout uintptr

	g.argv0 = *(*uintptr)(unsafe.Pointer(argv))
	g.iTrace = 1
	if argc < 2 {
		usage(tls, *(*uintptr)(unsafe.Pointer(argv)))
	}
	g.zDbFile = *(*uintptr)(unsafe.Pointer(argv + 1*4))
	if strglob(tls, ts+2325, g.zDbFile) != 0 {
		usage(tls, *(*uintptr)(unsafe.Pointer(argv)))
	}
	if libc.Xstrcmp(tls, sqlite3.Xsqlite3_sourceid(tls), ts+2332) != 0 {
		libc.Xfprintf(tls, libc.Xstderr,
			ts+2417,
			libc.VaList(bp, sqlite3.Xsqlite3_sourceid(tls), ts+2332))
		libc.Xexit(tls, 1)
	}
	*(*int32)(unsafe.Pointer(bp + 232)) = argc - 2
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]uint8{})), uintptr(unsafe.Pointer(&g))+32, ts+2477, libc.VaList(bp+16, libc.Xgetpid(tls)))
	zJMode = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2489, 1)
	zNRep = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2501, 1)
	if zNRep != 0 {
		nRep = libc.Xatoi(tls, zNRep)
	}
	if nRep < 1 {
		nRep = 1
	}
	g.zVfs = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2508, 1)
	zClient = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2512, 1)
	g.zErrLog = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2519, 1)
	g.zLog = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2526, 1)
	zTrace = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2530, 1)
	if zTrace != 0 {
		g.iTrace = libc.Xatoi(tls, zTrace)
	}
	if findOption(tls, argv+uintptr(2)*4, bp+232, ts+2536, 0) != uintptr(0) {
		g.iTrace = 0
	}
	zTmout = findOption(tls, argv+uintptr(2)*4, bp+232, ts+2542, 1)
	if zTmout != 0 {
		iTmout = libc.Xatoi(tls, zTmout)
	}
	g.bSqlTrace = libc.Bool32(findOption(tls, argv+uintptr(2)*4, bp+232, ts+2550, 0) != uintptr(0))
	g.bSync = libc.Bool32(findOption(tls, argv+uintptr(2)*4, bp+232, ts+2559, 0) != uintptr(0))
	if g.zErrLog != 0 {
		g.pErrLog = libc.Xfopen(tls, g.zErrLog, ts+2564)
	} else {
		g.pErrLog = libc.Xstderr
	}
	if g.zLog != 0 {
		g.pLog = libc.Xfopen(tls, g.zLog, ts+2564)
	} else {
		g.pLog = libc.Xstdout
	}

	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{sqlErrorCallback})), 0))
	if zClient != 0 {
		iClient = libc.Xatoi(tls, zClient)
		if iClient < 1 {
			fatalError(tls, ts+2566, libc.VaList(bp+40, iClient))
		}
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]uint8{})), uintptr(unsafe.Pointer(&g))+32, ts+2593,
			libc.VaList(bp+48, libc.Xgetpid(tls), iClient))
	} else {
		var nTry int32 = 0
		if g.iTrace > 0 {
			libc.Xprintf(tls, ts+2609, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv))))
			for i = 1; i < argc; i++ {
				libc.Xprintf(tls, ts+2319, libc.VaList(bp+72, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
			}
			libc.Xprintf(tls, ts+2323, 0)
			libc.Xprintf(tls, ts+2619, 0)
			for i = 0; libc.AssignUintptr(&zCOption, sqlite3.Xsqlite3_compileoption_get(tls, i)) != uintptr(0); i++ {
				libc.Xprintf(tls, ts+2724, libc.VaList(bp+80, zCOption))
			}
			libc.Xfflush(tls, libc.Xstdout)
		}
		iClient = 0
		for __ccgo := true; __ccgo; __ccgo = rc != 0 && libc.PreIncInt32(&nTry, 1) < 60 && sqlite3.Xsqlite3_sleep(tls, 1000) > 0 {
			if nTry%5 == 4 {
				libc.Xprintf(tls, ts+2737,
					libc.VaList(bp+88, func() uintptr {
						if nTry > 5 {
							return ts + 2766
						}
						return ts + 1101
					}(), g.zDbFile))
			}
			rc = libc.Xunlink(tls, g.zDbFile)
			if rc != 0 && *(*int32)(unsafe.Pointer(libc.X__errno_location(tls))) == ENOENT {
				rc = 0
			}
		}
		if rc != 0 {
			fatalError(tls, ts+2773,
				libc.VaList(bp+104, g.zDbFile, nTry))
		}
		openFlags = openFlags | SQLITE_OPEN_CREATE
	}
	rc = sqlite3.Xsqlite3_open_v2(tls, g.zDbFile, uintptr(unsafe.Pointer(&g))+12, openFlags, g.zVfs)
	if rc != 0 {
		fatalError(tls, ts+2814, libc.VaList(bp+120, g.zDbFile))
	}
	if iTmout > 0 {
		sqlite3.Xsqlite3_busy_timeout(tls, g.db, iTmout)
	}

	if zJMode != 0 {
		runSql(tls, ts+2831, libc.VaList(bp+128, zJMode))
	}
	if !(g.bSync != 0) {
		trySql(tls, ts+2855, 0)
	}
	sqlite3.Xsqlite3_enable_load_extension(tls, g.db, 1)
	sqlite3.Xsqlite3_busy_handler(tls, g.db, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{busyHandler})), uintptr(0))
	sqlite3.Xsqlite3_create_function(tls, g.db, ts+2878, 0, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{vfsNameFunc})), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_create_function(tls, g.db, ts+2886, 1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{evalFunc})), uintptr(0), uintptr(0))
	g.iTimeout = DEFAULT_TIMEOUT
	if g.bSqlTrace != 0 {
		sqlite3.Xsqlite3_trace(tls, g.db, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{sqlTraceCallback})), uintptr(0))
	}
	if iClient > 0 {
		if *(*int32)(unsafe.Pointer(bp + 232)) > 0 {
			unrecognizedArguments(tls, *(*uintptr)(unsafe.Pointer(argv)), *(*int32)(unsafe.Pointer(bp + 232)), argv+uintptr(2)*4)
		}
		if g.iTrace != 0 {
			logMessage(tls, ts+2891, 0)
		}
		for 1 != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 244)) = uintptr(0)
			rc = startScript(tls, iClient, bp+236, bp+240, bp+244)
			if rc == SQLITE_DONE {
				break
			}
			if g.iTrace != 0 {
				logMessage(tls, ts+2904, libc.VaList(bp+136, *(*uintptr)(unsafe.Pointer(bp + 244)), *(*int32)(unsafe.Pointer(bp + 240))))
			}
			runScript(tls, iClient, *(*int32)(unsafe.Pointer(bp + 240)), *(*uintptr)(unsafe.Pointer(bp + 236)), *(*uintptr)(unsafe.Pointer(bp + 244)))
			if g.iTrace != 0 {
				logMessage(tls, ts+2918, libc.VaList(bp+152, *(*uintptr)(unsafe.Pointer(bp + 244)), *(*int32)(unsafe.Pointer(bp + 240))))
			}
			finishScript(tls, iClient, *(*int32)(unsafe.Pointer(bp + 240)), 0)
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 244)))
			sqlite3.Xsqlite3_sleep(tls, 10)
		}
		if g.iTrace != 0 {
			logMessage(tls, ts+2930, 0)
		}
	} else {
		var pStmt uintptr
		var iTimeout int32
		if *(*int32)(unsafe.Pointer(bp + 232)) == 0 {
			fatalError(tls, ts+2941, 0)
		}
		if *(*int32)(unsafe.Pointer(bp + 232)) > 1 {
			unrecognizedArguments(tls, *(*uintptr)(unsafe.Pointer(argv)), *(*int32)(unsafe.Pointer(bp + 232)), argv+uintptr(2)*4)
		}
		runSql(tls,
			ts+2965, 0)
		*(*uintptr)(unsafe.Pointer(bp + 236)) = readFile(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		for iRep = 1; iRep <= nRep; iRep++ {
			if g.iTrace != 0 {
				logMessage(tls, ts+3401, libc.VaList(bp+168, *(*uintptr)(unsafe.Pointer(argv + 2*4)), iRep))
			}
			runScript(tls, 0, 0, *(*uintptr)(unsafe.Pointer(bp + 236)), *(*uintptr)(unsafe.Pointer(argv + 2*4)))
			if g.iTrace != 0 {
				logMessage(tls, ts+3429, libc.VaList(bp+184, *(*uintptr)(unsafe.Pointer(argv + 2*4)), iRep))
			}
		}
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 236)))
		waitForClient(tls, 0, 2000, ts+3455)
		trySql(tls, ts+3475, 0)
		sqlite3.Xsqlite3_sleep(tls, 10)
		g.iTimeout = 0
		iTimeout = 1000
		for (libc.AssignInt32(&rc, trySql(tls, ts+3504, 0)) == SQLITE_BUSY ||
			rc == SQLITE_ROW) && iTimeout > 0 {
			sqlite3.Xsqlite3_sleep(tls, 10)
			iTimeout = iTimeout - 10
		}
		sqlite3.Xsqlite3_sleep(tls, 100)
		pStmt = prepareSql(tls, ts+3525, 0)
		iTimeout = 1000
		for libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt)) == SQLITE_BUSY && iTimeout > 0 {
			sqlite3.Xsqlite3_sleep(tls, 10)
			iTimeout = iTimeout - 10
		}
		if rc == SQLITE_ROW {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 80)) += sqlite3.Xsqlite3_column_int(tls, pStmt, 0)
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 84)) += sqlite3.Xsqlite3_column_int(tls, pStmt, 1)
		}
		sqlite3.Xsqlite3_finalize(tls, pStmt)
	}
	sqlite3.Xsqlite3_close(tls, g.db)
	maybeClose(tls, g.pLog)
	maybeClose(tls, g.pErrLog)
	if iClient == 0 {
		libc.Xprintf(tls, ts+3560, libc.VaList(bp+200, g.nError, g.nTest))
		libc.Xprintf(tls, ts+3596, libc.VaList(bp+216, *(*uintptr)(unsafe.Pointer(argv))))
		for i = 1; i < argc; i++ {
			libc.Xprintf(tls, ts+2319, libc.VaList(bp+224, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
		}
		libc.Xprintf(tls, ts+2323, 0)
	}
	return libc.Bool32(g.nError > 0)
}

var ts1 = "%s%.*s\n\x00%s:ERROR: \x00%s:FATAL: \x00UPDATE client SET wantHalt=1;\x00%s: \x00main\x00timeout after %dms\x00[%.*s]\x00(info) %s\x00(errcode=%d) %s\x00%s\n%s\n\x00out of memory\x00 \x00nil\x00'\x00error(%d)\x00BEGIN IMMEDIATE\x00in startScript: %s\x00UPDATE counters SET nError=nError+%d, nTest=nTest+%d\x00SELECT 1 FROM client WHERE id=%d AND wantHalt\x00DELETE FROM client WHERE id=%d\x00COMMIT TRANSACTION;\x00SELECT script, id, name FROM task WHERE client=%d AND starttime IS NULL ORDER BY id LIMIT 1\x00%s\x00UPDATE task   SET starttime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00Waited over 3000 seconds with no work.  Giving up.\x00DELETE FROM client WHERE id=%d; COMMIT;\x00COMMIT\x00UPDATE task   SET endtime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00INSERT OR IGNORE INTO client VALUES(%d,0)\x00%s \"%s\" --client %d --trace %d\x00%z --sqltrace\x00%z --sync\x00%z --vfs \"%s\"\x00system('%q')\x00%z &\x00system() fails with error code %d\x00rb\x00cannot open \"%s\" for reading\x00--end\x00--endif\x00--else\x00--if\x00SELECT 1 FROM task WHERE client=%d   AND client IN (SELECT id FROM client)  AND endtime IS NULL\x00SELECT 1 FROM task WHERE client IN (SELECT id FROM client)   AND endtime IS NULL\x00\x00%stimeout waiting for client %d\x00%stimeout waiting for all clients\x00on\x00yes\x00off\x00no\x00unknown boolean: [%s]\x00%.*s\x00sleep\x00exit\x00testcase\x00finish\x00reset\x00match\x00line %d of %s:\nExpected [%.*s]\n     Got [%s]\x00glob\x00notglob\x00line %d of %s:\nExpected [%s]\n     Got [%s]\x00output\x00source\x00%.*s/%s\x00begin script [%s]\n\x00end script [%s]\n\x00print\x00if\x00SELECT %.*s\x00else\x00endif\x00start\x00wait\x00line %d of %s\n\x00task\x00line %d of %s: bad client number: %d\x00%s:%d\x00INSERT INTO task(client,script,name) VALUES(%d,'%q',%Q)\x00breakpoint\x00show-sql-errors\x00line %d of %s: unknown command --%s\x00command-line option \"--%s\" requires an argument\x00Usage: %s DATABASE ?OPTIONS? ?SCRIPT?\n\x00Options:\n   --errlog FILENAME           Write errors to FILENAME\n   --journalmode MODE          Use MODE as the journal_mode\n   --log FILENAME              Log messages to FILENAME\n   --quiet                     Suppress unnecessary output\n   --vfs NAME                  Use NAME as the VFS\n   --repeat N                  Repeat the test N times\n   --sqltrace                  Enable SQL tracing\n   --sync                      Enable synchronous disk writes\n   --timeout MILLISEC          Busy timeout is MILLISEC\n   --trace BOOLEAN             Enable or disable tracing\n\x00%s: unrecognized arguments:\x00 %s\x00\n\x00*.test\x002023-03-22 11:56:21 0d1fc92f94cb6b76bffe3ec34d69cffde2924203304e8ffc4155597af0c191da\x00SQLite library and header mismatch\nLibrary: %s\nHeader:  %s\n\x00%05d.mptest\x00journalmode\x00repeat\x00vfs\x00client\x00errlog\x00log\x00trace\x00quiet\x00timeout\x00sqltrace\x00sync\x00a\x00illegal client number: %d\n\x00%05d.client%02d\x00BEGIN: %s\x00With SQLite 3.41.2 2023-03-22 11:56:21 0d1fc92f94cb6b76bffe3ec34d69cffde2924203304e8ffc4155597af0c191da\n\x00-DSQLITE_%s\n\x00... %strying to unlink '%s'\n\x00still \x00unable to unlink '%s' after %d attempts\n\x00cannot open [%s]\x00PRAGMA journal_mode=%Q;\x00PRAGMA synchronous=OFF\x00vfsname\x00eval\x00start-client\x00begin %s (%d)\x00end %s (%d)\x00end-client\x00missing script filename\x00DROP TABLE IF EXISTS task;\nDROP TABLE IF EXISTS counters;\nDROP TABLE IF EXISTS client;\nCREATE TABLE task(\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  client INTEGER,\n  starttime DATE,\n  endtime DATE,\n  script TEXT\n);CREATE INDEX task_i1 ON task(client, starttime);\nCREATE INDEX task_i2 ON task(client, endtime);\nCREATE TABLE counters(nError,nTest);\nINSERT INTO counters VALUES(0,0);\nCREATE TABLE client(id INTEGER PRIMARY KEY, wantHalt);\n\x00begin script [%s] cycle %d\n\x00end script [%s] cycle %d\n\x00during shutdown...\n\x00UPDATE client SET wantHalt=1\x00SELECT 1 FROM client\x00SELECT nError, nTest FROM counters\x00Summary: %d errors out of %d tests\n\x00END: %s\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
