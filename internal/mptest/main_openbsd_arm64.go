// Code generated by 'ccgo -export-defines "" -ignore-unsupported-alignment -o internal/mptest/main_openbsd_arm64.go -trace-translation-units testdata/mptest.c -Itestdata/sqlite-amalgamation-3410200 -l modernc.org/sqlite/lib -full-path-comments -DNDEBUG -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_CORE -DSQLITE_DEFAULT_MEMSTATUS=0 -DSQLITE_ENABLE_COLUMN_METADATA -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_GEOPOLY -DSQLITE_ENABLE_MATH_FUNCTIONS -DSQLITE_ENABLE_MEMORY_MANAGEMENT -DSQLITE_ENABLE_OFFSET_SQL_FUNC -DSQLITE_ENABLE_PREUPDATE_HOOK -DSQLITE_ENABLE_RBU -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_SESSION -DSQLITE_ENABLE_SNAPSHOT -DSQLITE_ENABLE_STAT4 -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_MUTEX_NOOP -DSQLITE_SOUNDEX -DSQLITE_THREADSAFE=1 -DSQLITE_OS_UNIX=1', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/sqlite/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BIG_ENDIAN                            = 4321
	BUFSIZ                                = 1024
	BYTE_ORDER                            = 1234
	DEFAULT_TIMEOUT                       = 1000000
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 48
	EADDRNOTAVAIL                         = 49
	EAFNOSUPPORT                          = 47
	EAGAIN                                = 35
	EALREADY                              = 37
	EAUTH                                 = 80
	EBADF                                 = 9
	EBADMSG                               = 92
	EBADRPC                               = 72
	EBUSY                                 = 16
	ECANCELED                             = 88
	ECHILD                                = 10
	ECONNABORTED                          = 53
	ECONNREFUSED                          = 61
	ECONNRESET                            = 54
	EDEADLK                               = 11
	EDESTADDRREQ                          = 39
	EDOM                                  = 33
	EDQUOT                                = 69
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EFTYPE                                = 79
	EHOSTDOWN                             = 64
	EHOSTUNREACH                          = 65
	EIDRM                                 = 89
	EILSEQ                                = 84
	EINPROGRESS                           = 36
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EIPSEC                                = 82
	EISCONN                               = 56
	EISDIR                                = 21
	ELAST                                 = 95
	ELOOP                                 = 62
	EMEDIUMTYPE                           = 86
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 40
	ENAMETOOLONG                          = 63
	ENEEDAUTH                             = 81
	ENETDOWN                              = 50
	ENETRESET                             = 52
	ENETUNREACH                           = 51
	ENFILE                                = 23
	ENOATTR                               = 83
	ENOBUFS                               = 55
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOLCK                                = 77
	ENOMEDIUM                             = 85
	ENOMEM                                = 12
	ENOMSG                                = 90
	ENOPROTOOPT                           = 42
	ENOSPC                                = 28
	ENOSYS                                = 78
	ENOTBLK                               = 15
	ENOTCONN                              = 57
	ENOTDIR                               = 20
	ENOTEMPTY                             = 66
	ENOTRECOVERABLE                       = 93
	ENOTSOCK                              = 38
	ENOTSUP                               = 91
	ENOTTY                                = 25
	ENXIO                                 = 6
	EOF                                   = -1
	EOPNOTSUPP                            = 45
	EOVERFLOW                             = 87
	EOWNERDEAD                            = 94
	EPERM                                 = 1
	EPFNOSUPPORT                          = 46
	EPIPE                                 = 32
	EPROCLIM                              = 67
	EPROCUNAVAIL                          = 76
	EPROGMISMATCH                         = 75
	EPROGUNAVAIL                          = 74
	EPROTO                                = 95
	EPROTONOSUPPORT                       = 43
	EPROTOTYPE                            = 41
	ERANGE                                = 34
	EREMOTE                               = 71
	EROFS                                 = 30
	ERPCMISMATCH                          = 73
	ESHUTDOWN                             = 58
	ESOCKTNOSUPPORT                       = 44
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESTALE                                = 70
	ETIMEDOUT                             = 60
	ETOOMANYREFS                          = 59
	ETXTBSY                               = 26
	EUSERS                                = 68
	EWOULDBLOCK                           = 35
	EXDEV                                 = 18
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	FILENAME_MAX                          = 1024
	FOPEN_MAX                             = 20
	FTS5_TOKENIZE_AUX                     = 0x0008
	FTS5_TOKENIZE_DOCUMENT                = 0x0004
	FTS5_TOKENIZE_PREFIX                  = 0x0002
	FTS5_TOKENIZE_QUERY                   = 0x0001
	FTS5_TOKEN_COLOCATED                  = 0x0001
	FULLY_WITHIN                          = 2
	F_LOCK                                = 1
	F_OK                                  = 0
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	HAVE_USLEEP                           = 1
	KBIND_BLOCK_MAX                       = 2
	KBIND_DATA_MAX                        = 24
	LITTLE_ENDIAN                         = 1234
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	L_ctermid                             = 1024
	L_tmpnam                              = 1024
	MX_ARG                                = 2
	NDEBUG                                = 1
	NOT_WITHIN                            = 0
	PARTLY_WITHIN                         = 1
	PDP_ENDIAN                            = 3412
	P_tmpdir                              = "/tmp/"
	RAND_MAX                              = 0x7fffffff
	R_OK                                  = 0x04
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	SQLITE3_H                             = 0
	SQLITE3_TEXT                          = 3
	SQLITE_ABORT                          = 4
	SQLITE_ABORT_ROLLBACK                 = 516
	SQLITE_ACCESS_EXISTS                  = 0
	SQLITE_ACCESS_READ                    = 2
	SQLITE_ACCESS_READWRITE               = 1
	SQLITE_ALTER_TABLE                    = 26
	SQLITE_ANALYZE                        = 28
	SQLITE_ANY                            = 5
	SQLITE_API                            = 0
	SQLITE_APICALL                        = 0
	SQLITE_ATTACH                         = 24
	SQLITE_AUTH                           = 23
	SQLITE_AUTH_USER                      = 279
	SQLITE_BLOB                           = 4
	SQLITE_BUSY                           = 5
	SQLITE_BUSY_RECOVERY                  = 261
	SQLITE_BUSY_SNAPSHOT                  = 517
	SQLITE_BUSY_TIMEOUT                   = 773
	SQLITE_CALLBACK                       = 0
	SQLITE_CANTOPEN                       = 14
	SQLITE_CANTOPEN_CONVPATH              = 1038
	SQLITE_CANTOPEN_DIRTYWAL              = 1294
	SQLITE_CANTOPEN_FULLPATH              = 782
	SQLITE_CANTOPEN_ISDIR                 = 526
	SQLITE_CANTOPEN_NOTEMPDIR             = 270
	SQLITE_CANTOPEN_SYMLINK               = 1550
	SQLITE_CDECL                          = 0
	SQLITE_CHANGESETAPPLY_INVERT          = 0x0002
	SQLITE_CHANGESETAPPLY_NOSAVEPOINT     = 0x0001
	SQLITE_CHANGESETSTART_INVERT          = 0x0002
	SQLITE_CHANGESET_ABORT                = 2
	SQLITE_CHANGESET_CONFLICT             = 3
	SQLITE_CHANGESET_CONSTRAINT           = 4
	SQLITE_CHANGESET_DATA                 = 1
	SQLITE_CHANGESET_FOREIGN_KEY          = 5
	SQLITE_CHANGESET_NOTFOUND             = 2
	SQLITE_CHANGESET_OMIT                 = 0
	SQLITE_CHANGESET_REPLACE              = 1
	SQLITE_CHECKPOINT_FULL                = 1
	SQLITE_CHECKPOINT_PASSIVE             = 0
	SQLITE_CHECKPOINT_RESTART             = 2
	SQLITE_CHECKPOINT_TRUNCATE            = 3
	SQLITE_CONFIG_COVERING_INDEX_SCAN     = 20
	SQLITE_CONFIG_GETMALLOC               = 5
	SQLITE_CONFIG_GETMUTEX                = 11
	SQLITE_CONFIG_GETPCACHE               = 15
	SQLITE_CONFIG_GETPCACHE2              = 19
	SQLITE_CONFIG_HEAP                    = 8
	SQLITE_CONFIG_LOG                     = 16
	SQLITE_CONFIG_LOOKASIDE               = 13
	SQLITE_CONFIG_MALLOC                  = 4
	SQLITE_CONFIG_MEMDB_MAXSIZE           = 29
	SQLITE_CONFIG_MEMSTATUS               = 9
	SQLITE_CONFIG_MMAP_SIZE               = 22
	SQLITE_CONFIG_MULTITHREAD             = 2
	SQLITE_CONFIG_MUTEX                   = 10
	SQLITE_CONFIG_PAGECACHE               = 7
	SQLITE_CONFIG_PCACHE                  = 14
	SQLITE_CONFIG_PCACHE2                 = 18
	SQLITE_CONFIG_PCACHE_HDRSZ            = 24
	SQLITE_CONFIG_PMASZ                   = 25
	SQLITE_CONFIG_SCRATCH                 = 6
	SQLITE_CONFIG_SERIALIZED              = 3
	SQLITE_CONFIG_SINGLETHREAD            = 1
	SQLITE_CONFIG_SMALL_MALLOC            = 27
	SQLITE_CONFIG_SORTERREF_SIZE          = 28
	SQLITE_CONFIG_SQLLOG                  = 21
	SQLITE_CONFIG_STMTJRNL_SPILL          = 26
	SQLITE_CONFIG_URI                     = 17
	SQLITE_CONFIG_WIN32_HEAPSIZE          = 23
	SQLITE_CONSTRAINT                     = 19
	SQLITE_CONSTRAINT_CHECK               = 275
	SQLITE_CONSTRAINT_COMMITHOOK          = 531
	SQLITE_CONSTRAINT_DATATYPE            = 3091
	SQLITE_CONSTRAINT_FOREIGNKEY          = 787
	SQLITE_CONSTRAINT_FUNCTION            = 1043
	SQLITE_CONSTRAINT_NOTNULL             = 1299
	SQLITE_CONSTRAINT_PINNED              = 2835
	SQLITE_CONSTRAINT_PRIMARYKEY          = 1555
	SQLITE_CONSTRAINT_ROWID               = 2579
	SQLITE_CONSTRAINT_TRIGGER             = 1811
	SQLITE_CONSTRAINT_UNIQUE              = 2067
	SQLITE_CONSTRAINT_VTAB                = 2323
	SQLITE_COPY                           = 0
	SQLITE_CORE                           = 1
	SQLITE_CORRUPT                        = 11
	SQLITE_CORRUPT_INDEX                  = 779
	SQLITE_CORRUPT_SEQUENCE               = 523
	SQLITE_CORRUPT_VTAB                   = 267
	SQLITE_CREATE_INDEX                   = 1
	SQLITE_CREATE_TABLE                   = 2
	SQLITE_CREATE_TEMP_INDEX              = 3
	SQLITE_CREATE_TEMP_TABLE              = 4
	SQLITE_CREATE_TEMP_TRIGGER            = 5
	SQLITE_CREATE_TEMP_VIEW               = 6
	SQLITE_CREATE_TRIGGER                 = 7
	SQLITE_CREATE_VIEW                    = 8
	SQLITE_CREATE_VTABLE                  = 29
	SQLITE_DBCONFIG_DEFENSIVE             = 1010
	SQLITE_DBCONFIG_DQS_DDL               = 1014
	SQLITE_DBCONFIG_DQS_DML               = 1013
	SQLITE_DBCONFIG_ENABLE_FKEY           = 1002
	SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004
	SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005
	SQLITE_DBCONFIG_ENABLE_QPSG           = 1007
	SQLITE_DBCONFIG_ENABLE_TRIGGER        = 1003
	SQLITE_DBCONFIG_ENABLE_VIEW           = 1015
	SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    = 1012
	SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    = 1016
	SQLITE_DBCONFIG_LOOKASIDE             = 1001
	SQLITE_DBCONFIG_MAINDBNAME            = 1000
	SQLITE_DBCONFIG_MAX                   = 1017
	SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      = 1006
	SQLITE_DBCONFIG_RESET_DATABASE        = 1009
	SQLITE_DBCONFIG_TRIGGER_EQP           = 1008
	SQLITE_DBCONFIG_TRUSTED_SCHEMA        = 1017
	SQLITE_DBCONFIG_WRITABLE_SCHEMA       = 1011
	SQLITE_DBSTATUS_CACHE_HIT             = 7
	SQLITE_DBSTATUS_CACHE_MISS            = 8
	SQLITE_DBSTATUS_CACHE_SPILL           = 12
	SQLITE_DBSTATUS_CACHE_USED            = 1
	SQLITE_DBSTATUS_CACHE_USED_SHARED     = 11
	SQLITE_DBSTATUS_CACHE_WRITE           = 9
	SQLITE_DBSTATUS_DEFERRED_FKS          = 10
	SQLITE_DBSTATUS_LOOKASIDE_HIT         = 4
	SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL   = 6
	SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE   = 5
	SQLITE_DBSTATUS_LOOKASIDE_USED        = 0
	SQLITE_DBSTATUS_MAX                   = 12
	SQLITE_DBSTATUS_SCHEMA_USED           = 2
	SQLITE_DBSTATUS_STMT_USED             = 3
	SQLITE_DEFAULT_MEMSTATUS              = 0
	SQLITE_DELETE                         = 9
	SQLITE_DENY                           = 1
	SQLITE_DEPRECATED                     = 0
	SQLITE_DESERIALIZE_FREEONCLOSE        = 1
	SQLITE_DESERIALIZE_READONLY           = 4
	SQLITE_DESERIALIZE_RESIZEABLE         = 2
	SQLITE_DETACH                         = 25
	SQLITE_DETERMINISTIC                  = 0x000000800
	SQLITE_DIRECTONLY                     = 0x000080000
	SQLITE_DONE                           = 101
	SQLITE_DROP_INDEX                     = 10
	SQLITE_DROP_TABLE                     = 11
	SQLITE_DROP_TEMP_INDEX                = 12
	SQLITE_DROP_TEMP_TABLE                = 13
	SQLITE_DROP_TEMP_TRIGGER              = 14
	SQLITE_DROP_TEMP_VIEW                 = 15
	SQLITE_DROP_TRIGGER                   = 16
	SQLITE_DROP_VIEW                      = 17
	SQLITE_DROP_VTABLE                    = 30
	SQLITE_EMPTY                          = 16
	SQLITE_ENABLE_COLUMN_METADATA         = 1
	SQLITE_ENABLE_FTS5                    = 1
	SQLITE_ENABLE_GEOPOLY                 = 1
	SQLITE_ENABLE_MATH_FUNCTIONS          = 1
	SQLITE_ENABLE_MEMORY_MANAGEMENT       = 1
	SQLITE_ENABLE_OFFSET_SQL_FUNC         = 1
	SQLITE_ENABLE_PREUPDATE_HOOK          = 1
	SQLITE_ENABLE_RBU                     = 1
	SQLITE_ENABLE_RTREE                   = 1
	SQLITE_ENABLE_SESSION                 = 1
	SQLITE_ENABLE_SNAPSHOT                = 1
	SQLITE_ENABLE_STAT4                   = 1
	SQLITE_ENABLE_UNLOCK_NOTIFY           = 1
	SQLITE_ERROR                          = 1
	SQLITE_ERROR_MISSING_COLLSEQ          = 257
	SQLITE_ERROR_RETRY                    = 513
	SQLITE_ERROR_SNAPSHOT                 = 769
	SQLITE_EXPERIMENTAL                   = 0
	SQLITE_FAIL                           = 3
	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE       = 31
	SQLITE_FCNTL_BUSYHANDLER              = 15
	SQLITE_FCNTL_CHUNK_SIZE               = 6
	SQLITE_FCNTL_CKPT_DONE                = 37
	SQLITE_FCNTL_CKPT_START               = 39
	SQLITE_FCNTL_CKSM_FILE                = 41
	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE      = 32
	SQLITE_FCNTL_COMMIT_PHASETWO          = 22
	SQLITE_FCNTL_DATA_VERSION             = 35
	SQLITE_FCNTL_EXTERNAL_READER          = 40
	SQLITE_FCNTL_FILE_POINTER             = 7
	SQLITE_FCNTL_GET_LOCKPROXYFILE        = 2
	SQLITE_FCNTL_HAS_MOVED                = 20
	SQLITE_FCNTL_JOURNAL_POINTER          = 28
	SQLITE_FCNTL_LAST_ERRNO               = 4
	SQLITE_FCNTL_LOCKSTATE                = 1
	SQLITE_FCNTL_LOCK_TIMEOUT             = 34
	SQLITE_FCNTL_MMAP_SIZE                = 18
	SQLITE_FCNTL_OVERWRITE                = 11
	SQLITE_FCNTL_PDB                      = 30
	SQLITE_FCNTL_PERSIST_WAL              = 10
	SQLITE_FCNTL_POWERSAFE_OVERWRITE      = 13
	SQLITE_FCNTL_PRAGMA                   = 14
	SQLITE_FCNTL_RBU                      = 26
	SQLITE_FCNTL_RESERVE_BYTES            = 38
	SQLITE_FCNTL_RESET_CACHE              = 42
	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE    = 33
	SQLITE_FCNTL_SET_LOCKPROXYFILE        = 3
	SQLITE_FCNTL_SIZE_HINT                = 5
	SQLITE_FCNTL_SIZE_LIMIT               = 36
	SQLITE_FCNTL_SYNC                     = 21
	SQLITE_FCNTL_SYNC_OMITTED             = 8
	SQLITE_FCNTL_TEMPFILENAME             = 16
	SQLITE_FCNTL_TRACE                    = 19
	SQLITE_FCNTL_VFSNAME                  = 12
	SQLITE_FCNTL_VFS_POINTER              = 27
	SQLITE_FCNTL_WAL_BLOCK                = 24
	SQLITE_FCNTL_WIN32_AV_RETRY           = 9
	SQLITE_FCNTL_WIN32_GET_HANDLE         = 29
	SQLITE_FCNTL_WIN32_SET_HANDLE         = 23
	SQLITE_FCNTL_ZIPVFS                   = 25
	SQLITE_FLOAT                          = 2
	SQLITE_FORMAT                         = 24
	SQLITE_FULL                           = 13
	SQLITE_FUNCTION                       = 31
	SQLITE_GET_LOCKPROXYFILE              = 2
	SQLITE_IGNORE                         = 2
	SQLITE_INDEX_CONSTRAINT_EQ            = 2
	SQLITE_INDEX_CONSTRAINT_FUNCTION      = 150
	SQLITE_INDEX_CONSTRAINT_GE            = 32
	SQLITE_INDEX_CONSTRAINT_GLOB          = 66
	SQLITE_INDEX_CONSTRAINT_GT            = 4
	SQLITE_INDEX_CONSTRAINT_IS            = 72
	SQLITE_INDEX_CONSTRAINT_ISNOT         = 69
	SQLITE_INDEX_CONSTRAINT_ISNOTNULL     = 70
	SQLITE_INDEX_CONSTRAINT_ISNULL        = 71
	SQLITE_INDEX_CONSTRAINT_LE            = 8
	SQLITE_INDEX_CONSTRAINT_LIKE          = 65
	SQLITE_INDEX_CONSTRAINT_LIMIT         = 73
	SQLITE_INDEX_CONSTRAINT_LT            = 16
	SQLITE_INDEX_CONSTRAINT_MATCH         = 64
	SQLITE_INDEX_CONSTRAINT_NE            = 68
	SQLITE_INDEX_CONSTRAINT_OFFSET        = 74
	SQLITE_INDEX_CONSTRAINT_REGEXP        = 67
	SQLITE_INDEX_SCAN_UNIQUE              = 1
	SQLITE_INNOCUOUS                      = 0x000200000
	SQLITE_INSERT                         = 18
	SQLITE_INTEGER                        = 1
	SQLITE_INTERNAL                       = 2
	SQLITE_INTERRUPT                      = 9
	SQLITE_IOCAP_ATOMIC                   = 0x00000001
	SQLITE_IOCAP_ATOMIC16K                = 0x00000040
	SQLITE_IOCAP_ATOMIC1K                 = 0x00000004
	SQLITE_IOCAP_ATOMIC2K                 = 0x00000008
	SQLITE_IOCAP_ATOMIC32K                = 0x00000080
	SQLITE_IOCAP_ATOMIC4K                 = 0x00000010
	SQLITE_IOCAP_ATOMIC512                = 0x00000002
	SQLITE_IOCAP_ATOMIC64K                = 0x00000100
	SQLITE_IOCAP_ATOMIC8K                 = 0x00000020
	SQLITE_IOCAP_BATCH_ATOMIC             = 0x00004000
	SQLITE_IOCAP_IMMUTABLE                = 0x00002000
	SQLITE_IOCAP_POWERSAFE_OVERWRITE      = 0x00001000
	SQLITE_IOCAP_SAFE_APPEND              = 0x00000200
	SQLITE_IOCAP_SEQUENTIAL               = 0x00000400
	SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN    = 0x00000800
	SQLITE_IOERR                          = 10
	SQLITE_IOERR_ACCESS                   = 3338
	SQLITE_IOERR_AUTH                     = 7178
	SQLITE_IOERR_BEGIN_ATOMIC             = 7434
	SQLITE_IOERR_BLOCKED                  = 2826
	SQLITE_IOERR_CHECKRESERVEDLOCK        = 3594
	SQLITE_IOERR_CLOSE                    = 4106
	SQLITE_IOERR_COMMIT_ATOMIC            = 7690
	SQLITE_IOERR_CONVPATH                 = 6666
	SQLITE_IOERR_CORRUPTFS                = 8458
	SQLITE_IOERR_DATA                     = 8202
	SQLITE_IOERR_DELETE                   = 2570
	SQLITE_IOERR_DELETE_NOENT             = 5898
	SQLITE_IOERR_DIR_CLOSE                = 4362
	SQLITE_IOERR_DIR_FSYNC                = 1290
	SQLITE_IOERR_FSTAT                    = 1802
	SQLITE_IOERR_FSYNC                    = 1034
	SQLITE_IOERR_GETTEMPPATH              = 6410
	SQLITE_IOERR_LOCK                     = 3850
	SQLITE_IOERR_MMAP                     = 6154
	SQLITE_IOERR_NOMEM                    = 3082
	SQLITE_IOERR_RDLOCK                   = 2314
	SQLITE_IOERR_READ                     = 266
	SQLITE_IOERR_ROLLBACK_ATOMIC          = 7946
	SQLITE_IOERR_SEEK                     = 5642
	SQLITE_IOERR_SHMLOCK                  = 5130
	SQLITE_IOERR_SHMMAP                   = 5386
	SQLITE_IOERR_SHMOPEN                  = 4618
	SQLITE_IOERR_SHMSIZE                  = 4874
	SQLITE_IOERR_SHORT_READ               = 522
	SQLITE_IOERR_TRUNCATE                 = 1546
	SQLITE_IOERR_UNLOCK                   = 2058
	SQLITE_IOERR_VNODE                    = 6922
	SQLITE_IOERR_WRITE                    = 778
	SQLITE_LAST_ERRNO                     = 4
	SQLITE_LIKE_DOESNT_MATCH_BLOBS        = 1
	SQLITE_LIMIT_ATTACHED                 = 7
	SQLITE_LIMIT_COLUMN                   = 2
	SQLITE_LIMIT_COMPOUND_SELECT          = 4
	SQLITE_LIMIT_EXPR_DEPTH               = 3
	SQLITE_LIMIT_FUNCTION_ARG             = 6
	SQLITE_LIMIT_LENGTH                   = 0
	SQLITE_LIMIT_LIKE_PATTERN_LENGTH      = 8
	SQLITE_LIMIT_SQL_LENGTH               = 1
	SQLITE_LIMIT_TRIGGER_DEPTH            = 10
	SQLITE_LIMIT_VARIABLE_NUMBER          = 9
	SQLITE_LIMIT_VDBE_OP                  = 5
	SQLITE_LIMIT_WORKER_THREADS           = 11
	SQLITE_LOCKED                         = 6
	SQLITE_LOCKED_SHAREDCACHE             = 262
	SQLITE_LOCKED_VTAB                    = 518
	SQLITE_LOCK_EXCLUSIVE                 = 4
	SQLITE_LOCK_NONE                      = 0
	SQLITE_LOCK_PENDING                   = 3
	SQLITE_LOCK_RESERVED                  = 2
	SQLITE_LOCK_SHARED                    = 1
	SQLITE_MISMATCH                       = 20
	SQLITE_MISUSE                         = 21
	SQLITE_MUTEX_APPDEF                   = 1
	SQLITE_MUTEX_FAST                     = 0
	SQLITE_MUTEX_NOOP                     = 1
	SQLITE_MUTEX_RECURSIVE                = 1
	SQLITE_MUTEX_STATIC_APP1              = 8
	SQLITE_MUTEX_STATIC_APP2              = 9
	SQLITE_MUTEX_STATIC_APP3              = 10
	SQLITE_MUTEX_STATIC_LRU               = 6
	SQLITE_MUTEX_STATIC_LRU2              = 7
	SQLITE_MUTEX_STATIC_MAIN              = 2
	SQLITE_MUTEX_STATIC_MASTER            = 2
	SQLITE_MUTEX_STATIC_MEM               = 3
	SQLITE_MUTEX_STATIC_MEM2              = 4
	SQLITE_MUTEX_STATIC_OPEN              = 4
	SQLITE_MUTEX_STATIC_PMEM              = 7
	SQLITE_MUTEX_STATIC_PRNG              = 5
	SQLITE_MUTEX_STATIC_VFS1              = 11
	SQLITE_MUTEX_STATIC_VFS2              = 12
	SQLITE_MUTEX_STATIC_VFS3              = 13
	SQLITE_NOLFS                          = 22
	SQLITE_NOMEM                          = 7
	SQLITE_NOTADB                         = 26
	SQLITE_NOTFOUND                       = 12
	SQLITE_NOTICE                         = 27
	SQLITE_NOTICE_RBU                     = 795
	SQLITE_NOTICE_RECOVER_ROLLBACK        = 539
	SQLITE_NOTICE_RECOVER_WAL             = 283
	SQLITE_NULL                           = 5
	SQLITE_OK                             = 0
	SQLITE_OK_LOAD_PERMANENTLY            = 256
	SQLITE_OK_SYMLINK                     = 512
	SQLITE_OPEN_AUTOPROXY                 = 0x00000020
	SQLITE_OPEN_CREATE                    = 0x00000004
	SQLITE_OPEN_DELETEONCLOSE             = 0x00000008
	SQLITE_OPEN_EXCLUSIVE                 = 0x00000010
	SQLITE_OPEN_EXRESCODE                 = 0x02000000
	SQLITE_OPEN_FULLMUTEX                 = 0x00010000
	SQLITE_OPEN_MAIN_DB                   = 0x00000100
	SQLITE_OPEN_MAIN_JOURNAL              = 0x00000800
	SQLITE_OPEN_MASTER_JOURNAL            = 0x00004000
	SQLITE_OPEN_MEMORY                    = 0x00000080
	SQLITE_OPEN_NOFOLLOW                  = 0x01000000
	SQLITE_OPEN_NOMUTEX                   = 0x00008000
	SQLITE_OPEN_PRIVATECACHE              = 0x00040000
	SQLITE_OPEN_READONLY                  = 0x00000001
	SQLITE_OPEN_READWRITE                 = 0x00000002
	SQLITE_OPEN_SHAREDCACHE               = 0x00020000
	SQLITE_OPEN_SUBJOURNAL                = 0x00002000
	SQLITE_OPEN_SUPER_JOURNAL             = 0x00004000
	SQLITE_OPEN_TEMP_DB                   = 0x00000200
	SQLITE_OPEN_TEMP_JOURNAL              = 0x00001000
	SQLITE_OPEN_TRANSIENT_DB              = 0x00000400
	SQLITE_OPEN_URI                       = 0x00000040
	SQLITE_OPEN_WAL                       = 0x00080000
	SQLITE_OS_UNIX                        = 1
	SQLITE_PERM                           = 3
	SQLITE_PRAGMA                         = 19
	SQLITE_PREPARE_NORMALIZE              = 0x02
	SQLITE_PREPARE_NO_VTAB                = 0x04
	SQLITE_PREPARE_PERSISTENT             = 0x01
	SQLITE_PROTOCOL                       = 15
	SQLITE_RANGE                          = 25
	SQLITE_READ                           = 20
	SQLITE_READONLY                       = 8
	SQLITE_READONLY_CANTINIT              = 1288
	SQLITE_READONLY_CANTLOCK              = 520
	SQLITE_READONLY_DBMOVED               = 1032
	SQLITE_READONLY_DIRECTORY             = 1544
	SQLITE_READONLY_RECOVERY              = 264
	SQLITE_READONLY_ROLLBACK              = 776
	SQLITE_RECURSIVE                      = 33
	SQLITE_REINDEX                        = 27
	SQLITE_REPLACE                        = 5
	SQLITE_ROLLBACK                       = 1
	SQLITE_ROW                            = 100
	SQLITE_SAVEPOINT                      = 32
	SQLITE_SCANSTAT_COMPLEX               = 0x0001
	SQLITE_SCANSTAT_EST                   = 2
	SQLITE_SCANSTAT_EXPLAIN               = 4
	SQLITE_SCANSTAT_NAME                  = 3
	SQLITE_SCANSTAT_NCYCLE                = 7
	SQLITE_SCANSTAT_NLOOP                 = 0
	SQLITE_SCANSTAT_NVISIT                = 1
	SQLITE_SCANSTAT_PARENTID              = 6
	SQLITE_SCANSTAT_SELECTID              = 5
	SQLITE_SCHEMA                         = 17
	SQLITE_SELECT                         = 21
	SQLITE_SERIALIZE_NOCOPY               = 0x001
	SQLITE_SESSION_CONFIG_STRMSIZE        = 1
	SQLITE_SESSION_OBJCONFIG_SIZE         = 1
	SQLITE_SET_LOCKPROXYFILE              = 3
	SQLITE_SHM_EXCLUSIVE                  = 8
	SQLITE_SHM_LOCK                       = 2
	SQLITE_SHM_NLOCK                      = 8
	SQLITE_SHM_SHARED                     = 4
	SQLITE_SHM_UNLOCK                     = 1
	SQLITE_SOUNDEX                        = 1
	SQLITE_SOURCE_ID                      = "2023-03-22 11:56:21 0d1fc92f94cb6b76bffe3ec34d69cffde2924203304e8ffc4155597af0c191da"
	SQLITE_STATUS_MALLOC_COUNT            = 9
	SQLITE_STATUS_MALLOC_SIZE             = 5
	SQLITE_STATUS_MEMORY_USED             = 0
	SQLITE_STATUS_PAGECACHE_OVERFLOW      = 2
	SQLITE_STATUS_PAGECACHE_SIZE          = 7
	SQLITE_STATUS_PAGECACHE_USED          = 1
	SQLITE_STATUS_PARSER_STACK            = 6
	SQLITE_STATUS_SCRATCH_OVERFLOW        = 4
	SQLITE_STATUS_SCRATCH_SIZE            = 8
	SQLITE_STATUS_SCRATCH_USED            = 3
	SQLITE_STDCALL                        = 0
	SQLITE_STMTSTATUS_AUTOINDEX           = 3
	SQLITE_STMTSTATUS_FILTER_HIT          = 8
	SQLITE_STMTSTATUS_FILTER_MISS         = 7
	SQLITE_STMTSTATUS_FULLSCAN_STEP       = 1
	SQLITE_STMTSTATUS_MEMUSED             = 99
	SQLITE_STMTSTATUS_REPREPARE           = 5
	SQLITE_STMTSTATUS_RUN                 = 6
	SQLITE_STMTSTATUS_SORT                = 2
	SQLITE_STMTSTATUS_VM_STEP             = 4
	SQLITE_SUBTYPE                        = 0x000100000
	SQLITE_SYNC_DATAONLY                  = 0x00010
	SQLITE_SYNC_FULL                      = 0x00003
	SQLITE_SYNC_NORMAL                    = 0x00002
	SQLITE_SYSAPI                         = 0
	SQLITE_TESTCTRL_ALWAYS                = 13
	SQLITE_TESTCTRL_ASSERT                = 12
	SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS   = 10
	SQLITE_TESTCTRL_BITVEC_TEST           = 8
	SQLITE_TESTCTRL_BYTEORDER             = 22
	SQLITE_TESTCTRL_EXPLAIN_STMT          = 19
	SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS   = 29
	SQLITE_TESTCTRL_FAULT_INSTALL         = 9
	SQLITE_TESTCTRL_FIRST                 = 5
	SQLITE_TESTCTRL_IMPOSTER              = 25
	SQLITE_TESTCTRL_INTERNAL_FUNCTIONS    = 17
	SQLITE_TESTCTRL_ISINIT                = 23
	SQLITE_TESTCTRL_ISKEYWORD             = 16
	SQLITE_TESTCTRL_LAST                  = 33
	SQLITE_TESTCTRL_LOCALTIME_FAULT       = 18
	SQLITE_TESTCTRL_LOGEST                = 33
	SQLITE_TESTCTRL_NEVER_CORRUPT         = 20
	SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD  = 19
	SQLITE_TESTCTRL_OPTIMIZATIONS         = 15
	SQLITE_TESTCTRL_PARSER_COVERAGE       = 26
	SQLITE_TESTCTRL_PENDING_BYTE          = 11
	SQLITE_TESTCTRL_PRNG_RESET            = 7
	SQLITE_TESTCTRL_PRNG_RESTORE          = 6
	SQLITE_TESTCTRL_PRNG_SAVE             = 5
	SQLITE_TESTCTRL_PRNG_SEED             = 28
	SQLITE_TESTCTRL_RESERVE               = 14
	SQLITE_TESTCTRL_RESULT_INTREAL        = 27
	SQLITE_TESTCTRL_SCRATCHMALLOC         = 17
	SQLITE_TESTCTRL_SEEK_COUNT            = 30
	SQLITE_TESTCTRL_SORTER_MMAP           = 24
	SQLITE_TESTCTRL_TRACEFLAGS            = 31
	SQLITE_TESTCTRL_TUNE                  = 32
	SQLITE_TESTCTRL_VDBE_COVERAGE         = 21
	SQLITE_TEXT                           = 3
	SQLITE_THREADSAFE                     = 1
	SQLITE_TOOBIG                         = 18
	SQLITE_TRACE_CLOSE                    = 0x08
	SQLITE_TRACE_PROFILE                  = 0x02
	SQLITE_TRACE_ROW                      = 0x04
	SQLITE_TRACE_STMT                     = 0x01
	SQLITE_TRANSACTION                    = 22
	SQLITE_TXN_NONE                       = 0
	SQLITE_TXN_READ                       = 1
	SQLITE_TXN_WRITE                      = 2
	SQLITE_UPDATE                         = 23
	SQLITE_UTF16                          = 4
	SQLITE_UTF16BE                        = 3
	SQLITE_UTF16LE                        = 2
	SQLITE_UTF16_ALIGNED                  = 8
	SQLITE_UTF8                           = 1
	SQLITE_VERSION                        = "3.41.2"
	SQLITE_VERSION_NUMBER                 = 3041002
	SQLITE_VTAB_CONSTRAINT_SUPPORT        = 1
	SQLITE_VTAB_DIRECTONLY                = 3
	SQLITE_VTAB_INNOCUOUS                 = 2
	SQLITE_WARNING                        = 28
	SQLITE_WARNING_AUTOINDEX              = 284
	SQLITE_WIN32_DATA_DIRECTORY_TYPE      = 1
	SQLITE_WIN32_TEMP_DIRECTORY_TYPE      = 2
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	TMP_MAX                               = 0x7fffffff
	W_OK                                  = 0x02
	X_OK                                  = 0x01
	X_ASSERT_H_                           = 0
	X_B                                   = 0x80
	X_BIG_ENDIAN                          = 4321
	X_BYTE_ORDER                          = 1234
	X_C                                   = 0x20
	X_CLOCKID_T_DEFINED_                  = 0
	X_CLOCK_T_DEFINED_                    = 0
	X_CS_PATH                             = 1
	X_CS_POSIX_V6_ILP32_OFF32_CFLAGS      = 2
	X_CS_POSIX_V6_ILP32_OFF32_LDFLAGS     = 3
	X_CS_POSIX_V6_ILP32_OFF32_LIBS        = 4
	X_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS     = 5
	X_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS    = 6
	X_CS_POSIX_V6_ILP32_OFFBIG_LIBS       = 7
	X_CS_POSIX_V6_LP64_OFF64_CFLAGS       = 8
	X_CS_POSIX_V6_LP64_OFF64_LDFLAGS      = 9
	X_CS_POSIX_V6_LP64_OFF64_LIBS         = 10
	X_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS     = 11
	X_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS    = 12
	X_CS_POSIX_V6_LPBIG_OFFBIG_LIBS       = 13
	X_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS   = 14
	X_CS_POSIX_V7_ILP32_OFF32_CFLAGS      = 16
	X_CS_POSIX_V7_ILP32_OFF32_LDFLAGS     = 17
	X_CS_POSIX_V7_ILP32_OFF32_LIBS        = 18
	X_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS     = 19
	X_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS    = 20
	X_CS_POSIX_V7_ILP32_OFFBIG_LIBS       = 21
	X_CS_POSIX_V7_LP64_OFF64_CFLAGS       = 22
	X_CS_POSIX_V7_LP64_OFF64_LDFLAGS      = 23
	X_CS_POSIX_V7_LP64_OFF64_LIBS         = 24
	X_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS     = 25
	X_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS    = 26
	X_CS_POSIX_V7_LPBIG_OFFBIG_LIBS       = 27
	X_CS_POSIX_V7_THREADS_CFLAGS          = 28
	X_CS_POSIX_V7_THREADS_LDFLAGS         = 29
	X_CS_POSIX_V7_WIDTH_RESTRICTED_ENVS   = 30
	X_CS_V6_ENV                           = 15
	X_CS_V7_ENV                           = 31
	X_CTYPE_H_                            = 0
	X_ERRNO_H_                            = 0
	X_FILE_OFFSET_BITS                    = 64
	X_FSTDIO                              = 0
	X_FTS5_H                              = 0
	X_GETOPT_DEFINED_                     = 0
	X_INT16_T_DEFINED_                    = 0
	X_INT32_T_DEFINED_                    = 0
	X_INT64_T_DEFINED_                    = 0
	X_INT8_T_DEFINED_                     = 0
	X_INTPTR_T_DEFINED_                   = 0
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_L                                   = 0x02
	X_LITTLE_ENDIAN                       = 1234
	X_LOCALE_T_DEFINED_                   = 0
	X_LP64                                = 1
	X_MACHINE_CDEFS_H_                    = 0
	X_MACHINE_ENDIAN_H_                   = 0
	X_MACHINE__TYPES_H_                   = 0
	X_MAX_PAGE_SHIFT                      = 12
	X_N                                   = 0x04
	X_OFF_T_DEFINED_                      = 0
	X_P                                   = 0x10
	X_PC_2_SYMLINKS                       = 10
	X_PC_ALLOC_SIZE_MIN                   = 11
	X_PC_ASYNC_IO                         = 12
	X_PC_CHOWN_RESTRICTED                 = 7
	X_PC_FILESIZEBITS                     = 13
	X_PC_LINK_MAX                         = 1
	X_PC_MAX_CANON                        = 2
	X_PC_MAX_INPUT                        = 3
	X_PC_NAME_MAX                         = 4
	X_PC_NO_TRUNC                         = 8
	X_PC_PATH_MAX                         = 5
	X_PC_PIPE_BUF                         = 6
	X_PC_PRIO_IO                          = 14
	X_PC_REC_INCR_XFER_SIZE               = 15
	X_PC_REC_MAX_XFER_SIZE                = 16
	X_PC_REC_MIN_XFER_SIZE                = 17
	X_PC_REC_XFER_ALIGN                   = 18
	X_PC_SYMLINK_MAX                      = 19
	X_PC_SYNC_IO                          = 20
	X_PC_TIMESTAMP_RESOLUTION             = 21
	X_PC_VDISABLE                         = 9
	X_PDP_ENDIAN                          = 3412
	X_PID_T_DEFINED_                      = 0
	X_POSIX2_CHAR_TERM                    = 1
	X_POSIX2_C_BIND                       = 200112
	X_POSIX2_C_DEV                        = -1
	X_POSIX2_FORT_DEV                     = -1
	X_POSIX2_FORT_RUN                     = -1
	X_POSIX2_LOCALEDEF                    = -1
	X_POSIX2_PBS                          = -1
	X_POSIX2_PBS_ACCOUNTING               = -1
	X_POSIX2_PBS_CHECKPOINT               = -1
	X_POSIX2_PBS_LOCATE                   = -1
	X_POSIX2_PBS_MESSAGE                  = -1
	X_POSIX2_PBS_TRACK                    = -1
	X_POSIX2_SW_DEV                       = 200112
	X_POSIX2_UPE                          = 200112
	X_POSIX2_VERSION                      = 200809
	X_POSIX_ADVISORY_INFO                 = -1
	X_POSIX_ASYNCHRONOUS_IO               = -1
	X_POSIX_ASYNC_IO                      = -1
	X_POSIX_BARRIERS                      = 200112
	X_POSIX_CHOWN_RESTRICTED              = 1
	X_POSIX_CLOCK_SELECTION               = -1
	X_POSIX_CPUTIME                       = 200809
	X_POSIX_FSYNC                         = 200112
	X_POSIX_IPV6                          = 0
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_MAPPED_FILES                  = 200112
	X_POSIX_MEMLOCK                       = 200112
	X_POSIX_MEMLOCK_RANGE                 = 200112
	X_POSIX_MEMORY_PROTECTION             = 200112
	X_POSIX_MESSAGE_PASSING               = -1
	X_POSIX_MONOTONIC_CLOCK               = 200112
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_PRIORITIZED_IO                = -1
	X_POSIX_PRIORITY_SCHEDULING           = -1
	X_POSIX_PRIO_IO                       = -1
	X_POSIX_RAW_SOCKETS                   = 200112
	X_POSIX_READER_WRITER_LOCKS           = 200112
	X_POSIX_REALTIME_SIGNALS              = -1
	X_POSIX_REGEXP                        = 1
	X_POSIX_SAVED_IDS                     = 1
	X_POSIX_SEMAPHORES                    = 200112
	X_POSIX_SHARED_MEMORY_OBJECTS         = 200809
	X_POSIX_SHELL                         = 1
	X_POSIX_SPAWN                         = 200112
	X_POSIX_SPIN_LOCKS                    = 200112
	X_POSIX_SPORADIC_SERVER               = -1
	X_POSIX_SYNCHRONIZED_IO               = -1
	X_POSIX_SYNC_IO                       = -1
	X_POSIX_THREADS                       = 200112
	X_POSIX_THREAD_ATTR_STACKADDR         = 200112
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200112
	X_POSIX_THREAD_CPUTIME                = 200809
	X_POSIX_THREAD_PRIORITY_SCHEDULING    = -1
	X_POSIX_THREAD_PRIO_INHERIT           = -1
	X_POSIX_THREAD_PRIO_PROTECT           = -1
	X_POSIX_THREAD_PROCESS_SHARED         = -1
	X_POSIX_THREAD_ROBUST_PRIO_INHERIT    = -1
	X_POSIX_THREAD_ROBUST_PRIO_PROTECT    = -1
	X_POSIX_THREAD_SAFE_FUNCTIONS         = 200112
	X_POSIX_THREAD_SPORADIC_SERVER        = -1
	X_POSIX_TIMEOUTS                      = 200112
	X_POSIX_TIMERS                        = -1
	X_POSIX_TRACE                         = -1
	X_POSIX_TRACE_EVENT_FILTER            = -1
	X_POSIX_TRACE_INHERIT                 = -1
	X_POSIX_TRACE_LOG                     = -1
	X_POSIX_TYPED_MEMORY_OBJECTS          = -1
	X_POSIX_V6_ILP32_OFF32                = -1
	X_POSIX_V6_ILP32_OFFBIG               = 0
	X_POSIX_V6_LP64_OFF64                 = 0
	X_POSIX_V6_LPBIG_OFFBIG               = 0
	X_POSIX_V7_ILP32_OFF32                = -1
	X_POSIX_V7_ILP32_OFFBIG               = 0
	X_POSIX_V7_LP64_OFF64                 = 0
	X_POSIX_V7_LPBIG_OFFBIG               = 0
	X_POSIX_VDISABLE                      = 255
	X_POSIX_VERSION                       = 200809
	X_QUAD_HIGHWORD                       = 1
	X_QUAD_LOWWORD                        = 0
	X_RET_PROTECTOR                       = 1
	X_S                                   = 0x08
	X_SC_2_CHAR_TERM                      = 20
	X_SC_2_C_BIND                         = 18
	X_SC_2_C_DEV                          = 19
	X_SC_2_FORT_DEV                       = 21
	X_SC_2_FORT_RUN                       = 22
	X_SC_2_LOCALEDEF                      = 23
	X_SC_2_PBS                            = 35
	X_SC_2_PBS_ACCOUNTING                 = 36
	X_SC_2_PBS_CHECKPOINT                 = 37
	X_SC_2_PBS_LOCATE                     = 38
	X_SC_2_PBS_MESSAGE                    = 39
	X_SC_2_PBS_TRACK                      = 40
	X_SC_2_SW_DEV                         = 24
	X_SC_2_UPE                            = 25
	X_SC_2_VERSION                        = 17
	X_SC_ADVISORY_INFO                    = 41
	X_SC_AIO_LISTIO_MAX                   = 42
	X_SC_AIO_MAX                          = 43
	X_SC_AIO_PRIO_DELTA_MAX               = 44
	X_SC_ARG_MAX                          = 1
	X_SC_ASYNCHRONOUS_IO                  = 45
	X_SC_ATEXIT_MAX                       = 46
	X_SC_AVPHYS_PAGES                     = 501
	X_SC_BARRIERS                         = 47
	X_SC_BC_BASE_MAX                      = 9
	X_SC_BC_DIM_MAX                       = 10
	X_SC_BC_SCALE_MAX                     = 11
	X_SC_BC_STRING_MAX                    = 12
	X_SC_CHILD_MAX                        = 2
	X_SC_CLK_TCK                          = 3
	X_SC_CLOCK_SELECTION                  = 48
	X_SC_COLL_WEIGHTS_MAX                 = 13
	X_SC_CPUTIME                          = 49
	X_SC_DELAYTIMER_MAX                   = 50
	X_SC_EXPR_NEST_MAX                    = 14
	X_SC_FSYNC                            = 29
	X_SC_GETGR_R_SIZE_MAX                 = 100
	X_SC_GETPW_R_SIZE_MAX                 = 101
	X_SC_HOST_NAME_MAX                    = 33
	X_SC_IOV_MAX                          = 51
	X_SC_IPV6                             = 52
	X_SC_JOB_CONTROL                      = 6
	X_SC_LINE_MAX                         = 15
	X_SC_LOGIN_NAME_MAX                   = 102
	X_SC_MAPPED_FILES                     = 53
	X_SC_MEMLOCK                          = 54
	X_SC_MEMLOCK_RANGE                    = 55
	X_SC_MEMORY_PROTECTION                = 56
	X_SC_MESSAGE_PASSING                  = 57
	X_SC_MONOTONIC_CLOCK                  = 34
	X_SC_MQ_OPEN_MAX                      = 58
	X_SC_MQ_PRIO_MAX                      = 59
	X_SC_NGROUPS_MAX                      = 4
	X_SC_NPROCESSORS_CONF                 = 502
	X_SC_NPROCESSORS_ONLN                 = 503
	X_SC_OPEN_MAX                         = 5
	X_SC_PAGESIZE                         = 28
	X_SC_PAGE_SIZE                        = 28
	X_SC_PHYS_PAGES                       = 500
	X_SC_PRIORITIZED_IO                   = 60
	X_SC_PRIORITY_SCHEDULING              = 61
	X_SC_RAW_SOCKETS                      = 62
	X_SC_READER_WRITER_LOCKS              = 63
	X_SC_REALTIME_SIGNALS                 = 64
	X_SC_REGEXP                           = 65
	X_SC_RE_DUP_MAX                       = 16
	X_SC_RTSIG_MAX                        = 66
	X_SC_SAVED_IDS                        = 7
	X_SC_SEMAPHORES                       = 67
	X_SC_SEM_NSEMS_MAX                    = 31
	X_SC_SEM_VALUE_MAX                    = 32
	X_SC_SHARED_MEMORY_OBJECTS            = 68
	X_SC_SHELL                            = 69
	X_SC_SIGQUEUE_MAX                     = 70
	X_SC_SPAWN                            = 71
	X_SC_SPIN_LOCKS                       = 72
	X_SC_SPORADIC_SERVER                  = 73
	X_SC_SS_REPL_MAX                      = 74
	X_SC_STREAM_MAX                       = 26
	X_SC_SYMLOOP_MAX                      = 76
	X_SC_SYNCHRONIZED_IO                  = 75
	X_SC_THREADS                          = 91
	X_SC_THREAD_ATTR_STACKADDR            = 77
	X_SC_THREAD_ATTR_STACKSIZE            = 78
	X_SC_THREAD_CPUTIME                   = 79
	X_SC_THREAD_DESTRUCTOR_ITERATIONS     = 80
	X_SC_THREAD_KEYS_MAX                  = 81
	X_SC_THREAD_PRIORITY_SCHEDULING       = 84
	X_SC_THREAD_PRIO_INHERIT              = 82
	X_SC_THREAD_PRIO_PROTECT              = 83
	X_SC_THREAD_PROCESS_SHARED            = 85
	X_SC_THREAD_ROBUST_PRIO_INHERIT       = 86
	X_SC_THREAD_ROBUST_PRIO_PROTECT       = 87
	X_SC_THREAD_SAFE_FUNCTIONS            = 103
	X_SC_THREAD_SPORADIC_SERVER           = 88
	X_SC_THREAD_STACK_MIN                 = 89
	X_SC_THREAD_THREADS_MAX               = 90
	X_SC_TIMEOUTS                         = 92
	X_SC_TIMERS                           = 94
	X_SC_TIMER_MAX                        = 93
	X_SC_TRACE                            = 95
	X_SC_TRACE_EVENT_FILTER               = 96
	X_SC_TRACE_EVENT_NAME_MAX             = 97
	X_SC_TRACE_INHERIT                    = 98
	X_SC_TRACE_LOG                        = 99
	X_SC_TRACE_NAME_MAX                   = 104
	X_SC_TRACE_SYS_MAX                    = 105
	X_SC_TRACE_USER_EVENT_MAX             = 106
	X_SC_TTY_NAME_MAX                     = 107
	X_SC_TYPED_MEMORY_OBJECTS             = 108
	X_SC_TZNAME_MAX                       = 27
	X_SC_V6_ILP32_OFF32                   = 109
	X_SC_V6_ILP32_OFFBIG                  = 110
	X_SC_V6_LP64_OFF64                    = 111
	X_SC_V6_LPBIG_OFFBIG                  = 112
	X_SC_V7_ILP32_OFF32                   = 113
	X_SC_V7_ILP32_OFFBIG                  = 114
	X_SC_V7_LP64_OFF64                    = 115
	X_SC_V7_LPBIG_OFFBIG                  = 116
	X_SC_VERSION                          = 8
	X_SC_XOPEN_CRYPT                      = 117
	X_SC_XOPEN_ENH_I18N                   = 118
	X_SC_XOPEN_LEGACY                     = 119
	X_SC_XOPEN_REALTIME                   = 120
	X_SC_XOPEN_REALTIME_THREADS           = 121
	X_SC_XOPEN_SHM                        = 30
	X_SC_XOPEN_STREAMS                    = 122
	X_SC_XOPEN_UNIX                       = 123
	X_SC_XOPEN_UUCP                       = 124
	X_SC_XOPEN_VERSION                    = 125
	X_SIZE_T_DEFINED_                     = 0
	X_SQLITE3RTREE_H_                     = 0
	X_SSIZE_T_DEFINED_                    = 0
	X_STACKALIGNBYTES                     = 15
	X_STDARG_H_                           = 0
	X_STDIO_H_                            = 0
	X_STDLIB_H_                           = 0
	X_STRINGS_H_                          = 0
	X_STRING_H_                           = 0
	X_SYS_CDEFS_H_                        = 0
	X_SYS_ENDIAN_H_                       = 0
	X_SYS_TYPES_H_                        = 0
	X_SYS_UNISTD_H_                       = 0
	X_SYS__ENDIAN_H_                      = 0
	X_SYS__TYPES_H_                       = 0
	X_TIMER_T_DEFINED_                    = 0
	X_TIME_T_DEFINED_                     = 0
	X_U                                   = 0x01
	X_UINT16_T_DEFINED_                   = 0
	X_UINT32_T_DEFINED_                   = 0
	X_UINT64_T_DEFINED_                   = 0
	X_UINT8_T_DEFINED_                    = 0
	X_UNISTD_H_                           = 0
	X_WCHAR_T_DEFINED_                    = 0
	X_X                                   = 0x40
	X_XOPEN_CRYPT                         = 1
	X_XOPEN_ENH_I18N                      = -1
	X_XOPEN_LEGACY                        = -1
	X_XOPEN_REALTIME                      = -1
	X_XOPEN_REALTIME_THREADS              = -1
	X_XOPEN_SHM                           = 1
	X_XOPEN_STREAMS                       = -1
	X_XOPEN_UNIX                          = -1
	X_XOPEN_UUCP                          = -1
	Unix                                  = 1
)

type ptrdiff_t = int64

type size_t = uint64

type wchar_t = int32

type va_list = uintptr

type sqlite_int64 = int64
type sqlite_uint64 = uint64
type sqlite3_int64 = sqlite_int64
type sqlite3_uint64 = sqlite_uint64

type sqlite3_callback = uintptr

type sqlite3_file1 = struct{ pMethods uintptr }

type sqlite3_file = sqlite3_file1
type sqlite3_io_methods1 = struct {
	iVersion               int32
	_                      [4]byte
	xClose                 uintptr
	xRead                  uintptr
	xWrite                 uintptr
	xTruncate              uintptr
	xSync                  uintptr
	xFileSize              uintptr
	xLock                  uintptr
	xUnlock                uintptr
	xCheckReservedLock     uintptr
	xFileControl           uintptr
	xSectorSize            uintptr
	xDeviceCharacteristics uintptr
	xShmMap                uintptr
	xShmLock               uintptr
	xShmBarrier            uintptr
	xShmUnmap              uintptr
	xFetch                 uintptr
	xUnfetch               uintptr
}

type sqlite3_io_methods = sqlite3_io_methods1

type sqlite3_filename = uintptr

type sqlite3_vfs1 = struct {
	iVersion          int32
	szOsFile          int32
	mxPathname        int32
	_                 [4]byte
	pNext             uintptr
	zName             uintptr
	pAppData          uintptr
	xOpen             uintptr
	xDelete           uintptr
	xAccess           uintptr
	xFullPathname     uintptr
	xDlOpen           uintptr
	xDlError          uintptr
	xDlSym            uintptr
	xDlClose          uintptr
	xRandomness       uintptr
	xSleep            uintptr
	xCurrentTime      uintptr
	xGetLastError     uintptr
	xCurrentTimeInt64 uintptr
	xSetSystemCall    uintptr
	xGetSystemCall    uintptr
	xNextSystemCall   uintptr
}

type sqlite3_vfs = sqlite3_vfs1
type sqlite3_syscall_ptr = uintptr

type sqlite3_mem_methods1 = struct {
	xMalloc   uintptr
	xFree     uintptr
	xRealloc  uintptr
	xSize     uintptr
	xRoundup  uintptr
	xInit     uintptr
	xShutdown uintptr
	pAppData  uintptr
}

type sqlite3_mem_methods = sqlite3_mem_methods1

type sqlite3_destructor_type = uintptr

type sqlite3_vtab1 = struct {
	pModule uintptr
	nRef    int32
	_       [4]byte
	zErrMsg uintptr
}

type sqlite3_vtab = sqlite3_vtab1
type sqlite3_index_info1 = struct {
	nConstraint      int32
	_                [4]byte
	aConstraint      uintptr
	nOrderBy         int32
	_                [4]byte
	aOrderBy         uintptr
	aConstraintUsage uintptr
	idxNum           int32
	_                [4]byte
	idxStr           uintptr
	needToFreeIdxStr int32
	orderByConsumed  int32
	estimatedCost    float64
	estimatedRows    sqlite3_int64
	idxFlags         int32
	_                [4]byte
	colUsed          sqlite3_uint64
}

type sqlite3_index_info = sqlite3_index_info1
type sqlite3_vtab_cursor1 = struct{ pVtab uintptr }

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1
type sqlite3_module1 = struct {
	iVersion      int32
	_             [4]byte
	xCreate       uintptr
	xConnect      uintptr
	xBestIndex    uintptr
	xDisconnect   uintptr
	xDestroy      uintptr
	xOpen         uintptr
	xClose        uintptr
	xFilter       uintptr
	xNext         uintptr
	xEof          uintptr
	xColumn       uintptr
	xRowid        uintptr
	xUpdate       uintptr
	xBegin        uintptr
	xSync         uintptr
	xCommit       uintptr
	xRollback     uintptr
	xFindFunction uintptr
	xRename       uintptr
	xSavepoint    uintptr
	xRelease      uintptr
	xRollbackTo   uintptr
	xShadowName   uintptr
}

type sqlite3_module = sqlite3_module1

type sqlite3_index_constraint = struct {
	iColumn     int32
	op          uint8
	usable      uint8
	_           [2]byte
	iTermOffset int32
}

type sqlite3_index_orderby = struct {
	iColumn int32
	desc    uint8
	_       [3]byte
}

type sqlite3_index_constraint_usage = struct {
	argvIndex int32
	omit      uint8
	_         [3]byte
}

type sqlite3_mutex_methods1 = struct {
	xMutexInit    uintptr
	xMutexEnd     uintptr
	xMutexAlloc   uintptr
	xMutexFree    uintptr
	xMutexEnter   uintptr
	xMutexTry     uintptr
	xMutexLeave   uintptr
	xMutexHeld    uintptr
	xMutexNotheld uintptr
}

type sqlite3_mutex_methods = sqlite3_mutex_methods1

type sqlite3_pcache_page1 = struct {
	pBuf   uintptr
	pExtra uintptr
}

type sqlite3_pcache_page = sqlite3_pcache_page1

type sqlite3_pcache_methods21 = struct {
	iVersion   int32
	_          [4]byte
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
	xShrink    uintptr
}

type sqlite3_pcache_methods2 = sqlite3_pcache_methods21

type sqlite3_pcache_methods1 = struct {
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
}

type sqlite3_pcache_methods = sqlite3_pcache_methods1

type sqlite3_snapshot1 = struct{ hidden [48]uint8 }

type sqlite3_snapshot = sqlite3_snapshot1

type sqlite3_rtree_geometry1 = struct {
	pContext uintptr
	nParam   int32
	_        [4]byte
	aParam   uintptr
	pUser    uintptr
	xDelUser uintptr
}

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1
type sqlite3_rtree_query_info1 = struct {
	pContext      uintptr
	nParam        int32
	_             [4]byte
	aParam        uintptr
	pUser         uintptr
	xDelUser      uintptr
	aCoord        uintptr
	anQueue       uintptr
	nCoord        int32
	iLevel        int32
	mxLevel       int32
	_             [4]byte
	iRowid        sqlite3_int64
	rParentScore  sqlite3_rtree_dbl
	eParentWithin int32
	eWithin       int32
	rScore        sqlite3_rtree_dbl
	apSqlParam    uintptr
}

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1

type sqlite3_rtree_dbl = float64

type Fts5ExtensionApi1 = struct {
	iVersion           int32
	_                  [4]byte
	xUserData          uintptr
	xColumnCount       uintptr
	xRowCount          uintptr
	xColumnTotalSize   uintptr
	xTokenize          uintptr
	xPhraseCount       uintptr
	xPhraseSize        uintptr
	xInstCount         uintptr
	xInst              uintptr
	xRowid             uintptr
	xColumnText        uintptr
	xColumnSize        uintptr
	xQueryPhrase       uintptr
	xSetAuxdata        uintptr
	xGetAuxdata        uintptr
	xPhraseFirst       uintptr
	xPhraseNext        uintptr
	xPhraseFirstColumn uintptr
	xPhraseNextColumn  uintptr
}

type Fts5ExtensionApi = Fts5ExtensionApi1
type Fts5PhraseIter1 = struct {
	a uintptr
	b uintptr
}

type Fts5PhraseIter = Fts5PhraseIter1

type fts5_extension_function = uintptr
type fts5_tokenizer1 = struct {
	xCreate   uintptr
	xDelete   uintptr
	xTokenize uintptr
}

type fts5_tokenizer = fts5_tokenizer1

type fts5_api1 = struct {
	iVersion         int32
	_                [4]byte
	xCreateTokenizer uintptr
	xFindTokenizer   uintptr
	xCreateFunction  uintptr
}

type fts5_api = fts5_api1

type u_char = uint8
type u_short = uint16
type u_int = uint32
type u_long = uint64

type unchar = uint8
type ushort = uint16
type uint = uint32
type ulong = uint64

type cpuid_t = uint64
type register_t = int64

type int8_t = int8

type uint8_t = uint8

type int16_t = int16

type uint16_t = uint16

type int32_t = int32

type uint32_t = uint32

type int64_t = int64

type uint64_t = uint64

type u_int8_t = uint8
type u_int16_t = uint16
type u_int32_t = uint32
type u_int64_t = uint64

type quad_t = int64
type u_quad_t = uint64

type vaddr_t = uint64
type paddr_t = uint64
type vsize_t = uint64
type psize_t = uint64

type blkcnt_t = int64
type blksize_t = int32
type caddr_t = uintptr
type daddr32_t = int32
type daddr_t = int64
type dev_t = int32
type fixpt_t = uint32
type gid_t = uint32
type id_t = uint32
type ino_t = uint64
type key_t = int64
type mode_t = uint32
type nlink_t = uint32
type rlim_t = uint64
type segsz_t = int32
type uid_t = uint32
type useconds_t = uint32
type suseconds_t = int64
type fsblkcnt_t = uint64
type fsfilcnt_t = uint64

type clock_t = int64

type clockid_t = int32

type pid_t = int32

type ssize_t = int64

type time_t = int64

type timer_t = int32

type off_t = int64

type fpos_t = off_t

type __sbuf = struct {
	_base uintptr
	_size int32
	_     [4]byte
}

type __sFILE = struct {
	_p     uintptr
	_r     int32
	_w     int32
	_flags int16
	_file  int16
	_      [4]byte
	_bf    struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_lbfsize int32
	_        [4]byte
	_cookie  uintptr
	_close   uintptr
	_read    uintptr
	_seek    uintptr
	_write   uintptr
	_ext     struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_up   uintptr
	_ur   int32
	_ubuf [3]uint8
	_nbuf [1]uint8
	_lb   struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_blksize int32
	_        [4]byte
	_offset  fpos_t
}

type FILE = __sFILE

type __tfork = struct {
	tf_tcb   uintptr
	tf_tid   uintptr
	tf_stack uintptr
}

type __kbind = struct {
	kb_addr uintptr
	kb_size size_t
}

type intptr_t = int64

type div_t = struct {
	quot int32
	rem  int32
}

type ldiv_t = struct {
	quot int64
	rem  int64
}

type lldiv_t = struct {
	quot int64
	rem  int64
}

type qdiv_t = struct {
	quot quad_t
	rem  quad_t
}

type locale_t = uintptr

type Global = struct {
	argv0            uintptr
	zVfs             uintptr
	zDbFile          uintptr
	db               uintptr
	zErrLog          uintptr
	pErrLog          uintptr
	zLog             uintptr
	pLog             uintptr
	zName            [32]int8
	taskId           int32
	iTrace           int32
	bSqlTrace        int32
	bIgnoreSqlErrors int32
	nError           int32
	nTest            int32
	iTimeout         int32
	bSync            int32
}

var g Global

func printWithPrefix(tls *libc.TLS, pOut uintptr, zPrefix uintptr, zMsg uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	for zMsg != 0 && *(*int8)(unsafe.Pointer(zMsg)) != 0 {
		var i int32
		for i = 0; *(*int8)(unsafe.Pointer(zMsg + uintptr(i))) != 0 && int32(*(*int8)(unsafe.Pointer(zMsg + uintptr(i)))) != '\n' && int32(*(*int8)(unsafe.Pointer(zMsg + uintptr(i)))) != '\r'; i++ {
		}
		libc.Xfprintf(tls, pOut, ts, libc.VaList(bp, zPrefix, i, zMsg))
		zMsg += uintptr(i)
		for int32(*(*int8)(unsafe.Pointer(zMsg))) == '\n' || int32(*(*int8)(unsafe.Pointer(zMsg))) == '\r' {
			zMsg++
		}
	}
}

func safe_strcmp(tls *libc.TLS, a uintptr, b uintptr) int32 {
	if a == b {
		return 0
	}
	if a == uintptr(0) {
		return -1
	}
	if b == uintptr(0) {
		return 1
	}
	return libc.Xstrcmp(tls, a, b)
}

func strglob(tls *libc.TLS, zGlob uintptr, z uintptr) int32 {
	var c int32
	var c2 int32
	var invert int32
	var seen int32

	for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) != 0 {
		if c == '*' {
			for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) == '*' || c == '?' {
				if c == '?' && int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
					return 0
				}
			}
			if c == 0 {
				return 1
			} else if c == '[' {
				for *(*int8)(unsafe.Pointer(z)) != 0 && strglob(tls, zGlob-uintptr(1), z) != 0 {
					z++
				}
				return libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) != 0)
			}
			for libc.AssignInt32(&c2, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) != 0 {
				for c2 != c {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
					if c2 == 0 {
						return 0
					}
				}
				if strglob(tls, zGlob, z) != 0 {
					return 1
				}
			}
			return 0
		} else if c == '?' {
			if int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
				return 0
			}
		} else if c == '[' {
			var prior_c int32 = 0
			seen = 0
			invert = 0
			c = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
			if c == 0 {
				return 0
			}
			c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			if c2 == '^' {
				invert = 1
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == ']' {
				if c == ']' {
					seen = 1
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			for c2 != 0 && c2 != ']' {
				if c2 == '-' && int32(*(*int8)(unsafe.Pointer(zGlob))) != ']' && int32(*(*int8)(unsafe.Pointer(zGlob))) != 0 && prior_c > 0 {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
					if c >= prior_c && c <= c2 {
						seen = 1
					}
					prior_c = 0
				} else {
					if c == c2 {
						seen = 1
					}
					prior_c = c2
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == 0 || seen^invert == 0 {
				return 0
			}
		} else if c == '#' {
			if (int32(*(*int8)(unsafe.Pointer(z))) == '-' || int32(*(*int8)(unsafe.Pointer(z))) == '+') && libc.Xisdigit(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + 1))))) != 0 {
				z++
			}
			if !(libc.Xisdigit(tls, int32(uint8(*(*int8)(unsafe.Pointer(z))))) != 0) {
				return 0
			}
			z++
			for libc.Xisdigit(tls, int32(uint8(*(*int8)(unsafe.Pointer(z))))) != 0 {
				z++
			}
		} else {
			if c != int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) {
				return 0
			}
		}
	}
	return libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) == 0)
}

func maybeClose(tls *libc.TLS, pOut uintptr) {
	if pOut != uintptr(unsafe.Pointer(&libc.X__sF))+1*152 && pOut != uintptr(unsafe.Pointer(&libc.X__sF))+2*152 {
		libc.Xfclose(tls, pOut)
	}
}

func errorMessage(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var ap va_list
	_ = ap
	var zMsg uintptr

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8, ts+8, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+64))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pLog)
	}
	if g.pErrLog != 0 && safe_strcmp(tls, g.zErrLog, g.zLog) != 0 {
		printWithPrefix(tls, g.pErrLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pErrLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
	g.nError++
}

func fatalError(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var ap va_list
	_ = ap
	var zMsg uintptr

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8, ts+19, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+64))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pLog)
		maybeClose(tls, g.pLog)
	}
	if g.pErrLog != 0 && safe_strcmp(tls, g.zErrLog, g.zLog) != 0 {
		printWithPrefix(tls, g.pErrLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pErrLog)
		maybeClose(tls, g.pErrLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
	if g.db != 0 {
		var nTry int32 = 0
		g.iTimeout = 0
		for trySql(tls, ts+30, 0) == SQLITE_BUSY &&
			libc.PostIncInt32(&nTry, 1) < 100 {
			sqlite3.Xsqlite3_sleep(tls, 10)
		}
	}
	sqlite3.Xsqlite3_close(tls, g.db)
	libc.Xexit(tls, 1)
}

func logMessage(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var ap va_list
	_ = ap
	var zMsg uintptr

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8, ts+60, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+64))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+8, zMsg)
		libc.Xfflush(tls, g.pLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
}

func clipLength(tls *libc.TLS, z uintptr) int32 {
	var n int32 = int32(libc.Xstrlen(tls, z))
	for n > 0 && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n-1)))))) != 0 {
		n--
	}
	return n
}

func vfsNameFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	_ = argc
	_ = argv
	sqlite3.Xsqlite3_file_control(tls, db, ts+65, SQLITE_FCNTL_VFSNAME, bp)
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		sqlite3.Xsqlite3_result_text(tls, context, *(*uintptr)(unsafe.Pointer(bp)), -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func busyHandler(tls *libc.TLS, pCD uintptr, count int32) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	_ = pCD
	if count*10 > g.iTimeout {
		if g.iTimeout > 0 {
			errorMessage(tls, ts+70, libc.VaList(bp, g.iTimeout))
		}
		return 0
	}
	sqlite3.Xsqlite3_sleep(tls, 10)
	return 1
}

func sqlTraceCallback(tls *libc.TLS, NotUsed1 uintptr, zSql uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	_ = NotUsed1
	logMessage(tls, ts+89, libc.VaList(bp, clipLength(tls, zSql), zSql))
}

func sqlErrorCallback(tls *libc.TLS, pArg uintptr, iErrCode int32, zMsg uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = pArg
	if iErrCode == SQLITE_ERROR && g.bIgnoreSqlErrors != 0 {
		return
	}
	if iErrCode&0xff == SQLITE_SCHEMA && g.iTrace < 3 {
		return
	}
	if g.iTimeout == 0 && iErrCode&0xff == SQLITE_BUSY && g.iTrace < 3 {
		return
	}
	if iErrCode&0xff == SQLITE_NOTICE {
		logMessage(tls, ts+96, libc.VaList(bp, zMsg))
	} else {
		errorMessage(tls, ts+106, libc.VaList(bp+8, iErrCode, zMsg))
	}
}

func prepareSql(tls *libc.TLS, zFormat uintptr, va uintptr) uintptr {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_prepare_v2(tls, g.db, zSql, -1, bp+16, uintptr(0))
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
		fatalError(tls, ts+122, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db), zSql))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	return *(*uintptr)(unsafe.Pointer(bp + 16))
}

func runSql(tls *libc.TLS, zFormat uintptr, va uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, uintptr(0), uintptr(0), uintptr(0))
	if rc != SQLITE_OK {
		fatalError(tls, ts+122, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db), zSql))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
}

func trySql(tls *libc.TLS, zFormat uintptr, va uintptr) int32 {
	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	return rc
}

type String1 = struct {
	z      uintptr
	n      int32
	nAlloc int32
}

type String = String1

func stringFree(tls *libc.TLS, p uintptr) {
	if (*String)(unsafe.Pointer(p)).z != 0 {
		sqlite3.Xsqlite3_free(tls, (*String)(unsafe.Pointer(p)).z)
	}
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(String{})))
}

func stringAppend(tls *libc.TLS, p uintptr, z uintptr, n int32) {
	if n < 0 {
		n = int32(libc.Xstrlen(tls, z))
	}
	if (*String)(unsafe.Pointer(p)).n+n >= (*String)(unsafe.Pointer(p)).nAlloc {
		var nAlloc int32 = (*String)(unsafe.Pointer(p)).nAlloc*2 + n + 100
		var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*String)(unsafe.Pointer(p)).z, nAlloc)
		if zNew == uintptr(0) {
			fatalError(tls, ts+129, 0)
		}
		(*String)(unsafe.Pointer(p)).z = zNew
		(*String)(unsafe.Pointer(p)).nAlloc = nAlloc
	}
	libc.Xmemcpy(tls, (*String)(unsafe.Pointer(p)).z+uintptr((*String)(unsafe.Pointer(p)).n), z, uint64(n))
	*(*int32)(unsafe.Pointer(p + 8)) += n
	*(*int8)(unsafe.Pointer((*String)(unsafe.Pointer(p)).z + uintptr((*String)(unsafe.Pointer(p)).n))) = int8(0)
}

func stringReset(tls *libc.TLS, p uintptr) {
	if (*String)(unsafe.Pointer(p)).z == uintptr(0) {
		stringAppend(tls, p, ts+143, 1)
	}
	(*String)(unsafe.Pointer(p)).n = 0
	*(*int8)(unsafe.Pointer((*String)(unsafe.Pointer(p)).z)) = int8(0)
}

func stringAppendTerm(tls *libc.TLS, p uintptr, z uintptr) {
	var i int32
	if (*String)(unsafe.Pointer(p)).n != 0 {
		stringAppend(tls, p, ts+143, 1)
	}
	if z == uintptr(0) {
		stringAppend(tls, p, ts+145, 3)
		return
	}
	for i = 0; *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0 && !(libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))))) != 0); i++ {
	}
	if i > 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == 0 {
		stringAppend(tls, p, z, i)
		return
	}
	stringAppend(tls, p, ts+149, 1)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		for i = 0; *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '\''; i++ {
		}
		if *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0 {
			stringAppend(tls, p, z, i+1)
			stringAppend(tls, p, ts+149, 1)
			z += uintptr(i + 1)
		} else {
			stringAppend(tls, p, z, i)
			break
		}
	}
	stringAppend(tls, p, ts+149, 1)
}

func evalCallback(tls *libc.TLS, pCData uintptr, argc int32, argv uintptr, azCol uintptr) int32 {
	var p uintptr = pCData
	var i int32
	_ = azCol
	for i = 0; i < argc; i++ {
		stringAppendTerm(tls, p, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}
	return 0
}

func evalSql(tls *libc.TLS, p uintptr, zFormat uintptr, va uintptr) int32 {
	bp := tls.Alloc(46)
	defer tls.Free(46)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(0)
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap

	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{evalCallback})), p, bp+8)
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+16, ts+151, libc.VaList(bp, rc))
		stringAppendTerm(tls, p, bp+16)
		if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
			stringAppendTerm(tls, p, *(*uintptr)(unsafe.Pointer(bp + 8)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		}
	}
	return rc
}

func evalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var zSql uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))

	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	var rc int32
	_ = argc
	libc.Xmemset(tls, bp, 0, uint64(unsafe.Sizeof(String{})))
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{evalCallback})), bp, bp+16)
	if *(*uintptr)(unsafe.Pointer(bp + 16)) != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, *(*uintptr)(unsafe.Pointer(bp + 16)), -1)
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	} else if rc != 0 {
		sqlite3.Xsqlite3_result_error_code(tls, context, rc)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, (*String)(unsafe.Pointer(bp)).z, -1, libc.UintptrFromInt32(-1))
	}
	stringFree(tls, bp)
}

func startScript(tls *libc.TLS, iClient int32, pzScript uintptr, pTaskId uintptr, pzTaskName uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var pStmt uintptr = uintptr(0)
	var taskId int32
	var rc int32
	var totalTime int32 = 0

	*(*uintptr)(unsafe.Pointer(pzScript)) = uintptr(0)
	g.iTimeout = 0
	for 1 != 0 {
		rc = trySql(tls, ts+161, 0)
		if rc == SQLITE_BUSY {
			sqlite3.Xsqlite3_sleep(tls, 10)
			totalTime = totalTime + 10
			continue
		}
		if rc != SQLITE_OK {
			fatalError(tls, ts+177, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db)))
		}
		if g.nError != 0 || g.nTest != 0 {
			runSql(tls, ts+196,
				libc.VaList(bp+8, g.nError, g.nTest))
			g.nError = 0
			g.nTest = 0
		}
		pStmt = prepareSql(tls, ts+249, libc.VaList(bp+24, iClient))
		rc = sqlite3.Xsqlite3_step(tls, pStmt)
		sqlite3.Xsqlite3_finalize(tls, pStmt)
		if rc == SQLITE_ROW {
			runSql(tls, ts+295, libc.VaList(bp+32, iClient))
			g.iTimeout = DEFAULT_TIMEOUT
			runSql(tls, ts+326, 0)
			return SQLITE_DONE
		}
		pStmt = prepareSql(tls,
			ts+346, libc.VaList(bp+40, iClient))
		rc = sqlite3.Xsqlite3_step(tls, pStmt)
		if rc == SQLITE_ROW {
			var n int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 0)
			*(*uintptr)(unsafe.Pointer(pzScript)) = sqlite3.Xsqlite3_malloc(tls, n+1)
			libc.Xstrcpy(tls, *(*uintptr)(unsafe.Pointer(pzScript)), sqlite3.Xsqlite3_column_text(tls, pStmt, 0))
			*(*int32)(unsafe.Pointer(pTaskId)) = libc.AssignInt32(&taskId, sqlite3.Xsqlite3_column_int(tls, pStmt, 1))
			*(*uintptr)(unsafe.Pointer(pzTaskName)) = sqlite3.Xsqlite3_mprintf(tls, ts+438, libc.VaList(bp+48, sqlite3.Xsqlite3_column_text(tls, pStmt, 2)))
			sqlite3.Xsqlite3_finalize(tls, pStmt)
			runSql(tls,
				ts+441, libc.VaList(bp+56, taskId))
			g.iTimeout = DEFAULT_TIMEOUT
			runSql(tls, ts+326, 0)
			return SQLITE_OK
		}
		sqlite3.Xsqlite3_finalize(tls, pStmt)
		if rc == SQLITE_DONE {
			if totalTime > 3000000 {
				errorMessage(tls, ts+524, 0)
				runSql(tls, ts+575, libc.VaList(bp+64, iClient))
				sqlite3.Xsqlite3_close(tls, g.db)
				libc.Xexit(tls, 1)
			}
			for trySql(tls, ts+615, 0) == SQLITE_BUSY {
				sqlite3.Xsqlite3_sleep(tls, 10)
				totalTime = totalTime + 10
			}
			sqlite3.Xsqlite3_sleep(tls, 100)
			totalTime = totalTime + 100
			continue
		}
		fatalError(tls, ts+438, libc.VaList(bp+72, sqlite3.Xsqlite3_errmsg(tls, g.db)))
	}
	g.iTimeout = DEFAULT_TIMEOUT
	return int32(0)
}

func finishScript(tls *libc.TLS, iClient int32, taskId int32, bShutdown int32) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	runSql(tls,
		ts+622, libc.VaList(bp, taskId))
	if bShutdown != 0 {
		runSql(tls, ts+295, libc.VaList(bp+8, iClient))
	}
	return SQLITE_OK
}

func startClient(tls *libc.TLS, iClient int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	runSql(tls, ts+703, libc.VaList(bp, iClient))
	if sqlite3.Xsqlite3_changes(tls, g.db) != 0 {
		var zSys uintptr
		var rc int32
		zSys = sqlite3.Xsqlite3_mprintf(tls, ts+745,
			libc.VaList(bp+8, g.argv0, g.zDbFile, iClient, g.iTrace))
		if g.bSqlTrace != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+776, libc.VaList(bp+40, zSys))
		}
		if g.bSync != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+790, libc.VaList(bp+48, zSys))
		}
		if g.zVfs != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+800, libc.VaList(bp+56, zSys, g.zVfs))
		}
		if g.iTrace >= 2 {
			logMessage(tls, ts+814, libc.VaList(bp+72, zSys))
		}
		zSys = sqlite3.Xsqlite3_mprintf(tls, ts+827, libc.VaList(bp+80, zSys))
		rc = libc.Xsystem(tls, zSys)
		if rc != 0 {
			errorMessage(tls, ts+832, libc.VaList(bp+88, rc))
		}
		sqlite3.Xsqlite3_free(tls, zSys)
	}
}

func readFile(tls *libc.TLS, zFilename uintptr) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var in uintptr = libc.Xfopen(tls, zFilename, ts+866)
	var sz int64
	var z uintptr
	if in == uintptr(0) {
		fatalError(tls, ts+869, libc.VaList(bp, zFilename))
	}
	libc.Xfseek(tls, in, int64(0), SEEK_END)
	sz = libc.Xftell(tls, in)
	libc.Xrewind(tls, in)
	z = sqlite3.Xsqlite3_malloc(tls, int32(sz+int64(1)))
	sz = int64(libc.Xfread(tls, z, uint64(1), uint64(sz), in))
	*(*int8)(unsafe.Pointer(z + uintptr(sz))) = int8(0)
	libc.Xfclose(tls, in)
	return z
}

func tokenLength(tls *libc.TLS, z uintptr, pnLine uintptr) int32 {
	var n int32 = 0
	if libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z))))) != 0 || int32(*(*int8)(unsafe.Pointer(z))) == '/' && int32(*(*int8)(unsafe.Pointer(z + 1))) == '*' {
		var inC int32 = 0
		var c int32
		if int32(*(*int8)(unsafe.Pointer(z))) == '/' {
			inC = 1
			n = 2
		}
		for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&n, 1)))))) != 0 {
			if c == '\n' {
				*(*int32)(unsafe.Pointer(pnLine))++
			}
			if libc.Xisspace(tls, int32(uint8(c))) != 0 {
				continue
			}
			if inC != 0 && c == '*' && int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == '/' {
				n++
				inC = 0
			} else if !(inC != 0) && c == '/' && int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == '*' {
				n++
				inC = 1
			} else if !(inC != 0) {
				break
			}
		}
		n--
	} else if int32(*(*int8)(unsafe.Pointer(z))) == '-' && int32(*(*int8)(unsafe.Pointer(z + 1))) == '-' {
		for n = 2; *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) != '\n'; n++ {
		}
		if *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 {
			*(*int32)(unsafe.Pointer(pnLine))++
			n++
		}
	} else if int32(*(*int8)(unsafe.Pointer(z))) == '"' || int32(*(*int8)(unsafe.Pointer(z))) == '\'' {
		var delim int32 = int32(*(*int8)(unsafe.Pointer(z)))
		for n = 1; *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0; n++ {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == '\n' {
				*(*int32)(unsafe.Pointer(pnLine))++
			}
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == delim {
				n++
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(n+1)))) != delim {
					break
				}
			}
		}
	} else {
		var c int32
		for n = 1; libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(z + uintptr(n))))) != 0 && !(libc.Xisspace(tls, int32(uint8(c))) != 0) && c != '"' && c != '\'' && c != ';'; n++ {
		}
	}
	return n
}

func extractToken(tls *libc.TLS, zIn uintptr, nIn int32, zOut uintptr, nOut int32) int32 {
	var i int32
	if nIn <= 0 {
		*(*int8)(unsafe.Pointer(zOut)) = int8(0)
		return 0
	}
	for i = 0; i < nIn && i < nOut-1 && !(libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))))) != 0); i++ {
		*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = *(*int8)(unsafe.Pointer(zIn + uintptr(i)))
	}
	*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = int8(0)
	return i
}

func findEnd(tls *libc.TLS, z uintptr, pnLine uintptr) int32 {
	var n int32 = 0
	for *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 && (libc.Xstrncmp(tls, z+uintptr(n), ts+898, uint64(5)) != 0 || !(libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n+5)))))) != 0)) {
		n = n + tokenLength(tls, z+uintptr(n), pnLine)
	}
	return n
}

func findEndif(tls *libc.TLS, z uintptr, stopAtElse int32, pnLine uintptr) int32 {
	var n int32 = 0
	for *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 {
		var len int32 = tokenLength(tls, z+uintptr(n), pnLine)
		if libc.Xstrncmp(tls, z+uintptr(n), ts+904, uint64(7)) == 0 && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n+7)))))) != 0 ||
			stopAtElse != 0 && libc.Xstrncmp(tls, z+uintptr(n), ts+912, uint64(6)) == 0 && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n+6)))))) != 0 {
			return n + len
		}
		if libc.Xstrncmp(tls, z+uintptr(n), ts+919, uint64(4)) == 0 && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n+4)))))) != 0 {
			var skip int32 = findEndif(tls, z+uintptr(n)+uintptr(len), 0, pnLine)
			n = n + (skip + len)
		} else {
			n = n + len
		}
	}
	return n
}

func waitForClient(tls *libc.TLS, iClient int32, iTimeout int32, zErrPrefix uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pStmt uintptr
	var rc int32
	if iClient > 0 {
		pStmt = prepareSql(tls,
			ts+924,
			libc.VaList(bp, iClient))
	} else {
		pStmt = prepareSql(tls,
			ts+1020, 0)
	}
	g.iTimeout = 0
	for (libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt)) == SQLITE_BUSY || rc == SQLITE_ROW) &&
		iTimeout > 0 {
		sqlite3.Xsqlite3_reset(tls, pStmt)
		sqlite3.Xsqlite3_sleep(tls, 50)
		iTimeout = iTimeout - 50
	}
	sqlite3.Xsqlite3_finalize(tls, pStmt)
	g.iTimeout = DEFAULT_TIMEOUT
	if rc != SQLITE_DONE {
		if zErrPrefix == uintptr(0) {
			zErrPrefix = ts + 1101
		}
		if iClient > 0 {
			errorMessage(tls, ts+1102, libc.VaList(bp+8, zErrPrefix, iClient))
		} else {
			errorMessage(tls, ts+1134, libc.VaList(bp+24, zErrPrefix))
		}
	}
}

func filenameTail(tls *libc.TLS, z uintptr) uintptr {
	var i int32
	var j int32
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == '/' {
			j = i + 1
		}
	}
	return z + uintptr(j)
}

func booleanValue(tls *libc.TLS, zArg uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	if zArg == uintptr(0) {
		return 0
	}
	for i = 0; int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i)))) >= '0' && int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i)))) <= '9'; i++ {
	}
	if i > 0 && int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i)))) == 0 {
		return libc.Xatoi(tls, zArg)
	}
	if sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1168) == 0 || sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1171) == 0 {
		return 1
	}
	if sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1175) == 0 || sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1179) == 0 {
		return 0
	}
	errorMessage(tls, ts+1182, libc.VaList(bp, zArg))
	return 0
}

func test_breakpoint(tls *libc.TLS) {
	atomic.AddInt32(&cnt, 1)
}

var cnt int32 = 0

func runScript(tls *libc.TLS, iClient int32, taskId int32, zScript uintptr, zFilename uintptr) {
	bp := tls.Alloc(1610)
	defer tls.Free(1610)

	*(*int32)(unsafe.Pointer(bp + 376)) = 1
	var prevLine int32 = 1
	var ii int32 = 0
	var iBegin int32 = 0
	var n int32
	var c int32
	var j int32
	var len int32
	var nArg int32

	libc.Xmemset(tls, bp+360, 0, uint64(unsafe.Sizeof(String{})))
	stringReset(tls, bp+360)
	for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(zScript + uintptr(ii))))) != 0 {
		prevLine = *(*int32)(unsafe.Pointer(bp + 376))
		len = tokenLength(tls, zScript+uintptr(ii), bp+376)
		if libc.Xisspace(tls, int32(uint8(c))) != 0 || c == '/' && int32(*(*int8)(unsafe.Pointer(zScript + uintptr(ii+1)))) == '*' {
			ii = ii + len
			continue
		}
		if c != '-' || int32(*(*int8)(unsafe.Pointer(zScript + uintptr(ii+1)))) != '-' || !(libc.Xisalpha(tls, int32(*(*int8)(unsafe.Pointer(zScript + uintptr(ii+2))))) != 0) {
			ii = ii + len
			continue
		}

		if ii > iBegin {
			var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp, ii-iBegin, zScript+uintptr(iBegin)))
			evalSql(tls, bp+360, zSql, 0)
			sqlite3.Xsqlite3_free(tls, zSql)
			iBegin = ii + len
		}

		if g.iTrace >= 2 {
			logMessage(tls, ts+1204, libc.VaList(bp+16, len, zScript+uintptr(ii)))
		}
		n = extractToken(tls, zScript+uintptr(ii)+uintptr(2), len-2, bp+380, int32(unsafe.Sizeof([30]int8{})))
		for nArg = 0; n < len-2 && nArg < MX_ARG; nArg++ {
			for n < len-2 && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zScript + uintptr(ii+2+n)))))) != 0 {
				n++
			}
			if n >= len-2 {
				break
			}
			n = n + extractToken(tls, zScript+uintptr(ii)+uintptr(2)+uintptr(n), len-2-n,
				bp+410+uintptr(nArg)*100, int32(unsafe.Sizeof([100]int8{})))
		}
		for j = nArg; j < MX_ARG; j++ {
			*(*int8)(unsafe.Pointer(bp + 410 + uintptr(libc.PostIncInt32(&j, 1))*100)) = int8(0)
		}

		if libc.Xstrcmp(tls, bp+380, ts+1209) == 0 {
			sqlite3.Xsqlite3_sleep(tls, libc.Xatoi(tls, bp+410))
		} else if libc.Xstrcmp(tls, bp+380, ts+1215) == 0 {
			var rc int32 = libc.Xatoi(tls, bp+410)
			finishScript(tls, iClient, taskId, 1)
			if rc == 0 {
				sqlite3.Xsqlite3_close(tls, g.db)
			}
			libc.Xexit(tls, rc)
		} else if libc.Xstrcmp(tls, bp+380, ts+1220) == 0 {
			if g.iTrace == 1 {
				logMessage(tls, ts+1204, libc.VaList(bp+32, len-1, zScript+uintptr(ii)))
			}
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+380, ts+1229) == 0 && iClient > 0 {
			finishScript(tls, iClient, taskId, 1)
		} else if libc.Xstrcmp(tls, bp+380, ts+1236) == 0 {
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+380, ts+1242) == 0 {
			var jj int32
			var zAns uintptr = zScript + uintptr(ii)
			for jj = 7; jj < len-1 && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zAns + uintptr(jj)))))) != 0; jj++ {
			}
			zAns += uintptr(jj)
			if len-jj-1 != (*String)(unsafe.Pointer(bp+360)).n || libc.Xstrncmp(tls, (*String)(unsafe.Pointer(bp+360)).z, zAns, uint64(len-jj-1)) != 0 {
				errorMessage(tls, ts+1248,
					libc.VaList(bp+48, prevLine, zFilename, len-jj-1, zAns, (*String)(unsafe.Pointer(bp+360)).z))
			}
			g.nTest++
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+380, ts+1293) == 0 || libc.Xstrcmp(tls, bp+380, ts+1298) == 0 {
			var jj int32
			var zAns uintptr = zScript + uintptr(ii)
			var zCopy uintptr
			var isGlob int32 = libc.Bool32(int32(*(*int8)(unsafe.Pointer(bp + 380))) == 'g')
			for jj = 9 - 3*isGlob; jj < len-1 && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zAns + uintptr(jj)))))) != 0; jj++ {
			}
			zAns += uintptr(jj)
			zCopy = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp+88, len-jj-1, zAns))
			if libc.Bool32(sqlite3.Xsqlite3_strglob(tls, zCopy, (*String)(unsafe.Pointer(bp+360)).z) == 0)^isGlob != 0 {
				errorMessage(tls, ts+1306,
					libc.VaList(bp+104, prevLine, zFilename, zCopy, (*String)(unsafe.Pointer(bp+360)).z))
			}
			sqlite3.Xsqlite3_free(tls, zCopy)
			g.nTest++
			stringReset(tls, bp+360)
		} else if libc.Xstrcmp(tls, bp+380, ts+1349) == 0 {
			logMessage(tls, ts+438, libc.VaList(bp+136, (*String)(unsafe.Pointer(bp+360)).z))
		} else if libc.Xstrcmp(tls, bp+380, ts+1356) == 0 {
			var zNewFile uintptr
			var zNewScript uintptr
			var zToDel uintptr = uintptr(0)
			zNewFile = bp + 410
			if !(int32(*(*int8)(unsafe.Pointer(zNewFile))) == '/') {
				var k int32
				for k = int32(libc.Xstrlen(tls, zFilename)) - 1; k >= 0 && !(int32(*(*int8)(unsafe.Pointer(zFilename + uintptr(k)))) == '/'); k-- {
				}
				if k > 0 {
					zNewFile = libc.AssignUintptr(&zToDel, sqlite3.Xsqlite3_mprintf(tls, ts+1363, libc.VaList(bp+144, k, zFilename, zNewFile)))
				}
			}
			zNewScript = readFile(tls, zNewFile)
			if g.iTrace != 0 {
				logMessage(tls, ts+1371, libc.VaList(bp+168, zNewFile))
			}
			runScript(tls, 0, 0, zNewScript, zNewFile)
			sqlite3.Xsqlite3_free(tls, zNewScript)
			if g.iTrace != 0 {
				logMessage(tls, ts+1390, libc.VaList(bp+176, zNewFile))
			}
			sqlite3.Xsqlite3_free(tls, zToDel)
		} else if libc.Xstrcmp(tls, bp+380, ts+1407) == 0 {
			var jj int32
			for jj = 7; jj < len && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zScript + uintptr(ii+jj)))))) != 0; jj++ {
			}
			logMessage(tls, ts+1204, libc.VaList(bp+184, len-jj, zScript+uintptr(ii)+uintptr(jj)))
		} else if libc.Xstrcmp(tls, bp+380, ts+1413) == 0 {
			var jj int32
			var rc int32
			var pStmt uintptr
			for jj = 4; jj < len && libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zScript + uintptr(ii+jj)))))) != 0; jj++ {
			}
			pStmt = prepareSql(tls, ts+1416, libc.VaList(bp+200, len-jj, zScript+uintptr(ii)+uintptr(jj)))
			rc = sqlite3.Xsqlite3_step(tls, pStmt)
			if rc != SQLITE_ROW || sqlite3.Xsqlite3_column_int(tls, pStmt, 0) == 0 {
				ii = ii + findEndif(tls, zScript+uintptr(ii)+uintptr(len), 1, bp+376)
			}
			sqlite3.Xsqlite3_finalize(tls, pStmt)
		} else if libc.Xstrcmp(tls, bp+380, ts+1428) == 0 {
			ii = ii + findEndif(tls, zScript+uintptr(ii)+uintptr(len), 0, bp+376)
		} else if libc.Xstrcmp(tls, bp+380, ts+1433) == 0 {
		} else if libc.Xstrcmp(tls, bp+380, ts+1439) == 0 && iClient == 0 {
			var iNewClient int32 = libc.Xatoi(tls, bp+410)
			if iNewClient > 0 {
				startClient(tls, iNewClient)
			}
		} else if libc.Xstrcmp(tls, bp+380, ts+1445) == 0 && iClient == 0 {
			var iTimeout int32
			if nArg >= 2 {
				iTimeout = libc.Xatoi(tls, bp+410+1*100)
			} else {
				iTimeout = DEFAULT_TIMEOUT
			}
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+610, ts+1450,
				libc.VaList(bp+216, prevLine, zFilename))
			waitForClient(tls, libc.Xatoi(tls, bp+410), iTimeout, bp+610)
		} else if libc.Xstrcmp(tls, bp+380, ts+1465) == 0 && iClient == 0 {
			var iTarget int32 = libc.Xatoi(tls, bp+410)
			var iEnd int32
			var zTask uintptr
			var zTName uintptr
			iEnd = findEnd(tls, zScript+uintptr(ii)+uintptr(len), bp+376)
			if iTarget < 0 {
				errorMessage(tls, ts+1470,
					libc.VaList(bp+232, prevLine, zFilename, iTarget))
			} else {
				zTask = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp+256, iEnd, zScript+uintptr(ii)+uintptr(len)))
				if nArg > 1 {
					zTName = sqlite3.Xsqlite3_mprintf(tls, ts+438, libc.VaList(bp+272, bp+410+1*100))
				} else {
					zTName = sqlite3.Xsqlite3_mprintf(tls, ts+1507, libc.VaList(bp+280, filenameTail(tls, zFilename), prevLine))
				}
				startClient(tls, iTarget)
				runSql(tls,
					ts+1513, libc.VaList(bp+296, iTarget, zTask, zTName))
				sqlite3.Xsqlite3_free(tls, zTask)
				sqlite3.Xsqlite3_free(tls, zTName)
			}
			iEnd = iEnd + tokenLength(tls, zScript+uintptr(ii)+uintptr(len)+uintptr(iEnd), bp+376)
			len = len + iEnd
			iBegin = ii + len
		} else if libc.Xstrcmp(tls, bp+380, ts+1569) == 0 {
			test_breakpoint(tls)
		} else if libc.Xstrcmp(tls, bp+380, ts+1580) == 0 {
			g.bIgnoreSqlErrors = func() int32 {
				if nArg >= 1 {
					return libc.BoolInt32(!(booleanValue(tls, bp+410) != 0))
				}
				return 1
			}()
		} else {
			errorMessage(tls, ts+1596,
				libc.VaList(bp+320, prevLine, zFilename, bp+380))
		}
		ii = ii + len
	}
	if iBegin < ii {
		var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+1204, libc.VaList(bp+344, ii-iBegin, zScript+uintptr(iBegin)))
		runSql(tls, zSql, 0)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	stringFree(tls, bp+360)
}

func findOption(tls *libc.TLS, azArg uintptr, pnArg uintptr, zOption uintptr, hasArg int32) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var j int32
	var zReturn uintptr = uintptr(0)
	var nArg int32 = *(*int32)(unsafe.Pointer(pnArg))

	for i = 0; i < nArg; i++ {
		var z uintptr
		if i+hasArg >= nArg {
			break
		}
		z = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8))
		if int32(*(*int8)(unsafe.Pointer(z))) != '-' {
			continue
		}
		z++
		if int32(*(*int8)(unsafe.Pointer(z))) == '-' {
			if int32(*(*int8)(unsafe.Pointer(z + 1))) == 0 {
				break
			}
			z++
		}
		if libc.Xstrcmp(tls, z, zOption) == 0 {
			if hasArg != 0 && i == nArg-1 {
				fatalError(tls, ts+1632, libc.VaList(bp, z))
			}
			if hasArg != 0 {
				zReturn = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i+1)*8))
			} else {
				zReturn = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8))
			}
			j = i + 1 + libc.Bool32(hasArg != 0)
			for j < nArg {
				*(*uintptr)(unsafe.Pointer(azArg + uintptr(libc.PostIncInt32(&i, 1))*8)) = *(*uintptr)(unsafe.Pointer(azArg + uintptr(libc.PostIncInt32(&j, 1))*8))
			}
			*(*int32)(unsafe.Pointer(pnArg)) = i
			return zReturn
		}
	}
	return zReturn
}

func usage(tls *libc.TLS, argv0 uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var zTail uintptr = argv0
	for i = 0; *(*int8)(unsafe.Pointer(argv0 + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(argv0 + uintptr(i)))) == '/' {
			zTail = argv0 + uintptr(i) + uintptr(1)
		}
	}
	libc.Xfprintf(tls, uintptr(unsafe.Pointer(&libc.X__sF))+2*152, ts+1680, libc.VaList(bp, zTail))
	libc.Xfprintf(tls, uintptr(unsafe.Pointer(&libc.X__sF))+2*152,
		ts+1719, 0)
	libc.Xexit(tls, 1)
}

func unrecognizedArguments(tls *libc.TLS, argv0 uintptr, nArg int32, azArg uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	libc.Xfprintf(tls, uintptr(unsafe.Pointer(&libc.X__sF))+2*152, ts+2291, libc.VaList(bp, argv0))
	for i = 0; i < nArg; i++ {
		libc.Xfprintf(tls, uintptr(unsafe.Pointer(&libc.X__sF))+2*152, ts+2319, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8))))
	}
	libc.Xfprintf(tls, uintptr(unsafe.Pointer(&libc.X__sF))+2*152, ts+2323, 0)
	libc.Xexit(tls, 1)
}

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(264)
	defer tls.Free(264)

	var zClient uintptr
	var iClient int32

	var i int32
	var openFlags int32 = SQLITE_OPEN_READWRITE
	var rc int32

	var zTrace uintptr
	var zCOption uintptr
	var zJMode uintptr
	var zNRep uintptr
	var nRep int32 = 1
	var iRep int32
	var iTmout int32 = 0
	var zTmout uintptr

	g.argv0 = *(*uintptr)(unsafe.Pointer(argv))
	g.iTrace = 1
	if argc < 2 {
		usage(tls, *(*uintptr)(unsafe.Pointer(argv)))
	}
	g.zDbFile = *(*uintptr)(unsafe.Pointer(argv + 1*8))
	if strglob(tls, ts+2325, g.zDbFile) != 0 {
		usage(tls, *(*uintptr)(unsafe.Pointer(argv)))
	}
	if libc.Xstrcmp(tls, sqlite3.Xsqlite3_sourceid(tls), ts+2332) != 0 {
		libc.Xfprintf(tls, uintptr(unsafe.Pointer(&libc.X__sF))+2*152,
			ts+2417,
			libc.VaList(bp, sqlite3.Xsqlite3_sourceid(tls), ts+2332))
		libc.Xexit(tls, 1)
	}
	*(*int32)(unsafe.Pointer(bp + 232)) = argc - 2
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), uintptr(unsafe.Pointer(&g))+64, ts+2477, libc.VaList(bp+16, libc.Xgetpid(tls)))
	zJMode = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2489, 1)
	zNRep = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2501, 1)
	if zNRep != 0 {
		nRep = libc.Xatoi(tls, zNRep)
	}
	if nRep < 1 {
		nRep = 1
	}
	g.zVfs = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2508, 1)
	zClient = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2512, 1)
	g.zErrLog = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2519, 1)
	g.zLog = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2526, 1)
	zTrace = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2530, 1)
	if zTrace != 0 {
		g.iTrace = libc.Xatoi(tls, zTrace)
	}
	if findOption(tls, argv+uintptr(2)*8, bp+232, ts+2536, 0) != uintptr(0) {
		g.iTrace = 0
	}
	zTmout = findOption(tls, argv+uintptr(2)*8, bp+232, ts+2542, 1)
	if zTmout != 0 {
		iTmout = libc.Xatoi(tls, zTmout)
	}
	g.bSqlTrace = libc.Bool32(findOption(tls, argv+uintptr(2)*8, bp+232, ts+2550, 0) != uintptr(0))
	g.bSync = libc.Bool32(findOption(tls, argv+uintptr(2)*8, bp+232, ts+2559, 0) != uintptr(0))
	if g.zErrLog != 0 {
		g.pErrLog = libc.Xfopen(tls, g.zErrLog, ts+2564)
	} else {
		g.pErrLog = uintptr(unsafe.Pointer(&libc.X__sF)) + 2*152
	}
	if g.zLog != 0 {
		g.pLog = libc.Xfopen(tls, g.zLog, ts+2564)
	} else {
		g.pLog = uintptr(unsafe.Pointer(&libc.X__sF)) + 1*152
	}

	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{sqlErrorCallback})), 0))
	if zClient != 0 {
		iClient = libc.Xatoi(tls, zClient)
		if iClient < 1 {
			fatalError(tls, ts+2566, libc.VaList(bp+40, iClient))
		}
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), uintptr(unsafe.Pointer(&g))+64, ts+2593,
			libc.VaList(bp+48, libc.Xgetpid(tls), iClient))
	} else {
		var nTry int32 = 0
		if g.iTrace > 0 {
			libc.Xprintf(tls, ts+2609, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv))))
			for i = 1; i < argc; i++ {
				libc.Xprintf(tls, ts+2319, libc.VaList(bp+72, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
			}
			libc.Xprintf(tls, ts+2323, 0)
			libc.Xprintf(tls, ts+2619, 0)
			for i = 0; libc.AssignUintptr(&zCOption, sqlite3.Xsqlite3_compileoption_get(tls, i)) != uintptr(0); i++ {
				libc.Xprintf(tls, ts+2724, libc.VaList(bp+80, zCOption))
			}
			libc.Xfflush(tls, uintptr(unsafe.Pointer(&libc.X__sF))+1*152)
		}
		iClient = 0
		for __ccgo := true; __ccgo; __ccgo = rc != 0 && libc.PreIncInt32(&nTry, 1) < 60 && sqlite3.Xsqlite3_sleep(tls, 1000) > 0 {
			if nTry%5 == 4 {
				libc.Xprintf(tls, ts+2737,
					libc.VaList(bp+88, func() uintptr {
						if nTry > 5 {
							return ts + 2766
						}
						return ts + 1101
					}(), g.zDbFile))
			}
			rc = libc.Xunlink(tls, g.zDbFile)
			if rc != 0 && *(*int32)(unsafe.Pointer(libc.X__errno(tls))) == ENOENT {
				rc = 0
			}
		}
		if rc != 0 {
			fatalError(tls, ts+2773,
				libc.VaList(bp+104, g.zDbFile, nTry))
		}
		openFlags = openFlags | SQLITE_OPEN_CREATE
	}
	rc = sqlite3.Xsqlite3_open_v2(tls, g.zDbFile, uintptr(unsafe.Pointer(&g))+24, openFlags, g.zVfs)
	if rc != 0 {
		fatalError(tls, ts+2814, libc.VaList(bp+120, g.zDbFile))
	}
	if iTmout > 0 {
		sqlite3.Xsqlite3_busy_timeout(tls, g.db, iTmout)
	}

	if zJMode != 0 {
		runSql(tls, ts+2831, libc.VaList(bp+128, zJMode))
	}
	if !(g.bSync != 0) {
		trySql(tls, ts+2855, 0)
	}
	sqlite3.Xsqlite3_enable_load_extension(tls, g.db, 1)
	sqlite3.Xsqlite3_busy_handler(tls, g.db, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{busyHandler})), uintptr(0))
	sqlite3.Xsqlite3_create_function(tls, g.db, ts+2878, 0, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{vfsNameFunc})), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_create_function(tls, g.db, ts+2886, 1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{evalFunc})), uintptr(0), uintptr(0))
	g.iTimeout = DEFAULT_TIMEOUT
	if g.bSqlTrace != 0 {
		sqlite3.Xsqlite3_trace(tls, g.db, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{sqlTraceCallback})), uintptr(0))
	}
	if iClient > 0 {
		if *(*int32)(unsafe.Pointer(bp + 232)) > 0 {
			unrecognizedArguments(tls, *(*uintptr)(unsafe.Pointer(argv)), *(*int32)(unsafe.Pointer(bp + 232)), argv+uintptr(2)*8)
		}
		if g.iTrace != 0 {
			logMessage(tls, ts+2891, 0)
		}
		for 1 != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 256)) = uintptr(0)
			rc = startScript(tls, iClient, bp+240, bp+248, bp+256)
			if rc == SQLITE_DONE {
				break
			}
			if g.iTrace != 0 {
				logMessage(tls, ts+2904, libc.VaList(bp+136, *(*uintptr)(unsafe.Pointer(bp + 256)), *(*int32)(unsafe.Pointer(bp + 248))))
			}
			runScript(tls, iClient, *(*int32)(unsafe.Pointer(bp + 248)), *(*uintptr)(unsafe.Pointer(bp + 240)), *(*uintptr)(unsafe.Pointer(bp + 256)))
			if g.iTrace != 0 {
				logMessage(tls, ts+2918, libc.VaList(bp+152, *(*uintptr)(unsafe.Pointer(bp + 256)), *(*int32)(unsafe.Pointer(bp + 248))))
			}
			finishScript(tls, iClient, *(*int32)(unsafe.Pointer(bp + 248)), 0)
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 256)))
			sqlite3.Xsqlite3_sleep(tls, 10)
		}
		if g.iTrace != 0 {
			logMessage(tls, ts+2930, 0)
		}
	} else {
		var pStmt uintptr
		var iTimeout int32
		if *(*int32)(unsafe.Pointer(bp + 232)) == 0 {
			fatalError(tls, ts+2941, 0)
		}
		if *(*int32)(unsafe.Pointer(bp + 232)) > 1 {
			unrecognizedArguments(tls, *(*uintptr)(unsafe.Pointer(argv)), *(*int32)(unsafe.Pointer(bp + 232)), argv+uintptr(2)*8)
		}
		runSql(tls,
			ts+2965, 0)
		*(*uintptr)(unsafe.Pointer(bp + 240)) = readFile(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		for iRep = 1; iRep <= nRep; iRep++ {
			if g.iTrace != 0 {
				logMessage(tls, ts+3401, libc.VaList(bp+168, *(*uintptr)(unsafe.Pointer(argv + 2*8)), iRep))
			}
			runScript(tls, 0, 0, *(*uintptr)(unsafe.Pointer(bp + 240)), *(*uintptr)(unsafe.Pointer(argv + 2*8)))
			if g.iTrace != 0 {
				logMessage(tls, ts+3429, libc.VaList(bp+184, *(*uintptr)(unsafe.Pointer(argv + 2*8)), iRep))
			}
		}
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 240)))
		waitForClient(tls, 0, 2000, ts+3455)
		trySql(tls, ts+3475, 0)
		sqlite3.Xsqlite3_sleep(tls, 10)
		g.iTimeout = 0
		iTimeout = 1000
		for (libc.AssignInt32(&rc, trySql(tls, ts+3504, 0)) == SQLITE_BUSY ||
			rc == SQLITE_ROW) && iTimeout > 0 {
			sqlite3.Xsqlite3_sleep(tls, 10)
			iTimeout = iTimeout - 10
		}
		sqlite3.Xsqlite3_sleep(tls, 100)
		pStmt = prepareSql(tls, ts+3525, 0)
		iTimeout = 1000
		for libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt)) == SQLITE_BUSY && iTimeout > 0 {
			sqlite3.Xsqlite3_sleep(tls, 10)
			iTimeout = iTimeout - 10
		}
		if rc == SQLITE_ROW {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 112)) += sqlite3.Xsqlite3_column_int(tls, pStmt, 0)
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 116)) += sqlite3.Xsqlite3_column_int(tls, pStmt, 1)
		}
		sqlite3.Xsqlite3_finalize(tls, pStmt)
	}
	sqlite3.Xsqlite3_close(tls, g.db)
	maybeClose(tls, g.pLog)
	maybeClose(tls, g.pErrLog)
	if iClient == 0 {
		libc.Xprintf(tls, ts+3560, libc.VaList(bp+200, g.nError, g.nTest))
		libc.Xprintf(tls, ts+3596, libc.VaList(bp+216, *(*uintptr)(unsafe.Pointer(argv))))
		for i = 1; i < argc; i++ {
			libc.Xprintf(tls, ts+2319, libc.VaList(bp+224, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
		}
		libc.Xprintf(tls, ts+2323, 0)
	}
	return libc.Bool32(g.nError > 0)
}

var ts1 = "%s%.*s\n\x00%s:ERROR: \x00%s:FATAL: \x00UPDATE client SET wantHalt=1;\x00%s: \x00main\x00timeout after %dms\x00[%.*s]\x00(info) %s\x00(errcode=%d) %s\x00%s\n%s\n\x00out of memory\x00 \x00nil\x00'\x00error(%d)\x00BEGIN IMMEDIATE\x00in startScript: %s\x00UPDATE counters SET nError=nError+%d, nTest=nTest+%d\x00SELECT 1 FROM client WHERE id=%d AND wantHalt\x00DELETE FROM client WHERE id=%d\x00COMMIT TRANSACTION;\x00SELECT script, id, name FROM task WHERE client=%d AND starttime IS NULL ORDER BY id LIMIT 1\x00%s\x00UPDATE task   SET starttime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00Waited over 3000 seconds with no work.  Giving up.\x00DELETE FROM client WHERE id=%d; COMMIT;\x00COMMIT\x00UPDATE task   SET endtime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00INSERT OR IGNORE INTO client VALUES(%d,0)\x00%s \"%s\" --client %d --trace %d\x00%z --sqltrace\x00%z --sync\x00%z --vfs \"%s\"\x00system('%q')\x00%z &\x00system() fails with error code %d\x00rb\x00cannot open \"%s\" for reading\x00--end\x00--endif\x00--else\x00--if\x00SELECT 1 FROM task WHERE client=%d   AND client IN (SELECT id FROM client)  AND endtime IS NULL\x00SELECT 1 FROM task WHERE client IN (SELECT id FROM client)   AND endtime IS NULL\x00\x00%stimeout waiting for client %d\x00%stimeout waiting for all clients\x00on\x00yes\x00off\x00no\x00unknown boolean: [%s]\x00%.*s\x00sleep\x00exit\x00testcase\x00finish\x00reset\x00match\x00line %d of %s:\nExpected [%.*s]\n     Got [%s]\x00glob\x00notglob\x00line %d of %s:\nExpected [%s]\n     Got [%s]\x00output\x00source\x00%.*s/%s\x00begin script [%s]\n\x00end script [%s]\n\x00print\x00if\x00SELECT %.*s\x00else\x00endif\x00start\x00wait\x00line %d of %s\n\x00task\x00line %d of %s: bad client number: %d\x00%s:%d\x00INSERT INTO task(client,script,name) VALUES(%d,'%q',%Q)\x00breakpoint\x00show-sql-errors\x00line %d of %s: unknown command --%s\x00command-line option \"--%s\" requires an argument\x00Usage: %s DATABASE ?OPTIONS? ?SCRIPT?\n\x00Options:\n   --errlog FILENAME           Write errors to FILENAME\n   --journalmode MODE          Use MODE as the journal_mode\n   --log FILENAME              Log messages to FILENAME\n   --quiet                     Suppress unnecessary output\n   --vfs NAME                  Use NAME as the VFS\n   --repeat N                  Repeat the test N times\n   --sqltrace                  Enable SQL tracing\n   --sync                      Enable synchronous disk writes\n   --timeout MILLISEC          Busy timeout is MILLISEC\n   --trace BOOLEAN             Enable or disable tracing\n\x00%s: unrecognized arguments:\x00 %s\x00\n\x00*.test\x002023-03-22 11:56:21 0d1fc92f94cb6b76bffe3ec34d69cffde2924203304e8ffc4155597af0c191da\x00SQLite library and header mismatch\nLibrary: %s\nHeader:  %s\n\x00%05d.mptest\x00journalmode\x00repeat\x00vfs\x00client\x00errlog\x00log\x00trace\x00quiet\x00timeout\x00sqltrace\x00sync\x00a\x00illegal client number: %d\n\x00%05d.client%02d\x00BEGIN: %s\x00With SQLite 3.41.2 2023-03-22 11:56:21 0d1fc92f94cb6b76bffe3ec34d69cffde2924203304e8ffc4155597af0c191da\n\x00-DSQLITE_%s\n\x00... %strying to unlink '%s'\n\x00still \x00unable to unlink '%s' after %d attempts\n\x00cannot open [%s]\x00PRAGMA journal_mode=%Q;\x00PRAGMA synchronous=OFF\x00vfsname\x00eval\x00start-client\x00begin %s (%d)\x00end %s (%d)\x00end-client\x00missing script filename\x00DROP TABLE IF EXISTS task;\nDROP TABLE IF EXISTS counters;\nDROP TABLE IF EXISTS client;\nCREATE TABLE task(\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  client INTEGER,\n  starttime DATE,\n  endtime DATE,\n  script TEXT\n);CREATE INDEX task_i1 ON task(client, starttime);\nCREATE INDEX task_i2 ON task(client, endtime);\nCREATE TABLE counters(nError,nTest);\nINSERT INTO counters VALUES(0,0);\nCREATE TABLE client(id INTEGER PRIMARY KEY, wantHalt);\n\x00begin script [%s] cycle %d\n\x00end script [%s] cycle %d\n\x00during shutdown...\n\x00UPDATE client SET wantHalt=1\x00SELECT 1 FROM client\x00SELECT nError, nTest FROM counters\x00Summary: %d errors out of %d tests\n\x00END: %s\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
