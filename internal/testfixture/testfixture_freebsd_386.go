// Code generated by 'ccgo -DBUILD_sqlite -DNDEBUG -DSQLITE_CKSUMVFS_STATIC -DSQLITE_CORE -DSQLITE_CRASH_TEST=1 -DSQLITE_DEFAULT_PAGE_SIZE=1024 -DSQLITE_ENABLE_BYTECODE_VTAB -DSQLITE_ENABLE_DBPAGE_VTAB -DSQLITE_ENABLE_MATH_FUNCTIONS -DSQLITE_ENABLE_STMTVTAB -DSQLITE_NO_SYNC=1 -DSQLITE_OMIT_LOAD_EXTENSION -DSQLITE_PRIVATE="" -DSQLITE_SERIES_CONSTRAINT_VERIFY=1 -DSQLITE_SERVER=1 -DSQLITE_TEMP_STORE=1 -DSQLITE_TEST=1 -DSQLITE_THREADSAFE=1 -DTCLSH_INIT_PROC=sqlite3TestInit -D_HAVE_SQLITE_CONFIG_H -I/usr/local/include/tcl8.6 -export-defines "" -export-fields F -ignore-unsupported-alignment -trace-translation-units -volatile=sqlite3_io_error_pending,sqlite3_open_file_count,sqlite3_pager_readdb_count,sqlite3_pager_writedb_count,sqlite3_pager_writej_count,sqlite3_search_count,sqlite3_sort_count,saved_cnt,randomnessPid -lmodernc.org/sqlite/libtest -lmodernc.org/tcl/lib -lmodernc.org/z/lib -o internal/testfixture/testfixture_freebsd_386.go -Itestdata/sqlite-src-3410200/ext/async -Itestdata/sqlite-src-3410200/ext/fts3 -Itestdata/sqlite-src-3410200/ext/icu -Itestdata/sqlite-src-3410200/ext/rtree -Itestdata/sqlite-src-3410200/ext/session -Itestdata/sqlite-src-3410200/ext/userauth -Itestdata/sqlite-src-3410200/src -Itestdata/sqlite-amalgamation-3410200 -Itestdata/sqlite-src-3410200 -full-path-comments testdata/sqlite-src-3410200/ext/expert/sqlite3expert.c testdata/sqlite-src-3410200/ext/expert/test_expert.c testdata/sqlite-src-3410200/ext/fts3/fts3_term.c testdata/sqlite-src-3410200/ext/fts3/fts3_test.c testdata/sqlite-src-3410200/ext/fts5/fts5_tcl.c testdata/sqlite-src-3410200/ext/fts5/fts5_test_mi.c testdata/sqlite-src-3410200/ext/fts5/fts5_test_tok.c testdata/sqlite-src-3410200/ext/misc/amatch.c testdata/sqlite-src-3410200/ext/misc/appendvfs.c testdata/sqlite-src-3410200/ext/misc/basexx.c testdata/sqlite-src-3410200/ext/misc/carray.c testdata/sqlite-src-3410200/ext/misc/cksumvfs.c testdata/sqlite-src-3410200/ext/misc/closure.c testdata/sqlite-src-3410200/ext/misc/csv.c testdata/sqlite-src-3410200/ext/misc/decimal.c testdata/sqlite-src-3410200/ext/misc/eval.c testdata/sqlite-src-3410200/ext/misc/explain.c testdata/sqlite-src-3410200/ext/misc/fileio.c testdata/sqlite-src-3410200/ext/misc/fuzzer.c testdata/sqlite-src-3410200/ext/misc/ieee754.c testdata/sqlite-src-3410200/ext/misc/mmapwarm.c testdata/sqlite-src-3410200/ext/misc/nextchar.c testdata/sqlite-src-3410200/ext/misc/normalize.c testdata/sqlite-src-3410200/ext/misc/percentile.c testdata/sqlite-src-3410200/ext/misc/prefixes.c testdata/sqlite-src-3410200/ext/misc/qpvtab.c testdata/sqlite-src-3410200/ext/misc/regexp.c testdata/sqlite-src-3410200/ext/misc/remember.c testdata/sqlite-src-3410200/ext/misc/series.c testdata/sqlite-src-3410200/ext/misc/spellfix.c testdata/sqlite-src-3410200/ext/misc/totype.c testdata/sqlite-src-3410200/ext/misc/unionvtab.c testdata/sqlite-src-3410200/ext/misc/wholenumber.c testdata/sqlite-src-3410200/ext/rbu/test_rbu.c testdata/sqlite-src-3410200/ext/recover/dbdata.c testdata/sqlite-src-3410200/ext/recover/sqlite3recover.c testdata/sqlite-src-3410200/ext/recover/test_recover.c testdata/sqlite-src-3410200/ext/rtree/test_rtreedoc.c testdata/sqlite-src-3410200/ext/session/test_session.c testdata/sqlite-src-3410200/ext/userauth/userauth.c testdata/sqlite-src-3410200/src/tclsqlite.c testdata/sqlite-src-3410200/src/test1.c testdata/sqlite-src-3410200/src/test2.c testdata/sqlite-src-3410200/src/test3.c testdata/sqlite-src-3410200/src/test4.c testdata/sqlite-src-3410200/src/test5.c testdata/sqlite-src-3410200/src/test6.c testdata/sqlite-src-3410200/src/test8.c testdata/sqlite-src-3410200/src/test9.c testdata/sqlite-src-3410200/src/test_async.c testdata/sqlite-src-3410200/src/test_autoext.c testdata/sqlite-src-3410200/src/test_backup.c testdata/sqlite-src-3410200/src/test_bestindex.c testdata/sqlite-src-3410200/src/test_blob.c testdata/sqlite-src-3410200/src/test_btree.c testdata/sqlite-src-3410200/src/test_config.c testdata/sqlite-src-3410200/src/test_delete.c testdata/sqlite-src-3410200/src/test_demovfs.c testdata/sqlite-src-3410200/src/test_devsym.c testdata/sqlite-src-3410200/src/test_fs.c testdata/sqlite-src-3410200/src/test_func.c testdata/sqlite-src-3410200/src/test_hexio.c testdata/sqlite-src-3410200/src/test_init.c testdata/sqlite-src-3410200/src/test_intarray.c testdata/sqlite-src-3410200/src/test_journal.c testdata/sqlite-src-3410200/src/test_malloc.c testdata/sqlite-src-3410200/src/test_md5.c testdata/sqlite-src-3410200/src/test_multiplex.c testdata/sqlite-src-3410200/src/test_mutex.c testdata/sqlite-src-3410200/src/test_onefile.c testdata/sqlite-src-3410200/src/test_osinst.c testdata/sqlite-src-3410200/src/test_pcache.c testdata/sqlite-src-3410200/src/test_quota.c testdata/sqlite-src-3410200/src/test_rtree.c testdata/sqlite-src-3410200/src/test_schema.c testdata/sqlite-src-3410200/src/test_superlock.c testdata/sqlite-src-3410200/src/test_syscall.c testdata/sqlite-src-3410200/src/test_tclsh.c testdata/sqlite-src-3410200/src/test_tclvar.c testdata/sqlite-src-3410200/src/test_thread.c testdata/sqlite-src-3410200/src/test_vdbecov.c testdata/sqlite-src-3410200/src/test_vfs.c testdata/sqlite-src-3410200/src/test_windirent.c testdata/sqlite-src-3410200/src/test_window.c testdata/sqlite-src-3410200/src/test_wsd.c -DNDEBUG -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_CKSUMVFS_STATIC -DSQLITE_CORE -DSQLITE_DEFAULT_MEMSTATUS=1 -DSQLITE_DEFAULT_PAGE_SIZE=1024 -DSQLITE_ENABLE_BYTECODE_VTAB -DSQLITE_ENABLE_COLUMN_METADATA -DSQLITE_ENABLE_DBPAGE_VTAB -DSQLITE_ENABLE_DBSTAT_VTAB -DSQLITE_ENABLE_DESERIALIZE -DSQLITE_ENABLE_EXPLAIN_COMMENTS -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_GEOPOLY -DSQLITE_ENABLE_MATH_FUNCTIONS -DSQLITE_ENABLE_MEMORY_MANAGEMENT -DSQLITE_ENABLE_OFFSET_SQL_FUNC -DSQLITE_ENABLE_PREUPDATE_HOOK -DSQLITE_ENABLE_RBU -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_SESSION -DSQLITE_ENABLE_STAT4 -DSQLITE_ENABLE_STMTVTAB -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_MUTEX_NOOP -DSQLITE_SOUNDEX -DSQLITE_TEMP_STORE=1 -DSQLITE_TEST -DSQLITE_THREADSAFE=1', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/sqlite/libtest"
	"modernc.org/tcl/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BUFSIZ                                = 1024
	BUILD_sqlite                          = 1
	EOF                                   = -1
	EXPERT_CONFIG_SAMPLE                  = 1
	EXPERT_REPORT_CANDIDATES              = 4
	EXPERT_REPORT_INDEXES                 = 2
	EXPERT_REPORT_PLAN                    = 3
	EXPERT_REPORT_SQL                     = 1
	FILENAME_MAX                          = 1024
	FOPEN_MAX                             = 20
	FTS5_TOKENIZE_AUX                     = 0x0008
	FTS5_TOKENIZE_DOCUMENT                = 0x0004
	FTS5_TOKENIZE_PREFIX                  = 0x0002
	FTS5_TOKENIZE_QUERY                   = 0x0001
	FTS5_TOKEN_COLOCATED                  = 0x0001
	FULLY_WITHIN                          = 2
	HAVE_USLEEP                           = 1
	IDX_HASH_SIZE                         = 1023
	L_ctermid                             = 1024
	L_cuserid                             = 17
	L_tmpnam                              = 1024
	NDEBUG                                = 1
	NOT_WITHIN                            = 0
	PARTLY_WITHIN                         = 1
	P_tmpdir                              = "/tmp/"
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	SQLITE3_H                             = 0
	SQLITE3_TEXT                          = 3
	SQLITEEXPERT_H                        = 1
	SQLITE_ABORT                          = 4
	SQLITE_ABORT_ROLLBACK                 = 516
	SQLITE_ACCESS_EXISTS                  = 0
	SQLITE_ACCESS_READ                    = 2
	SQLITE_ACCESS_READWRITE               = 1
	SQLITE_ALTER_TABLE                    = 26
	SQLITE_ANALYZE                        = 28
	SQLITE_ANY                            = 5
	SQLITE_API                            = 0
	SQLITE_APICALL                        = 0
	SQLITE_ATTACH                         = 24
	SQLITE_AUTH                           = 23
	SQLITE_AUTH_USER                      = 279
	SQLITE_BLOB                           = 4
	SQLITE_BUSY                           = 5
	SQLITE_BUSY_RECOVERY                  = 261
	SQLITE_BUSY_SNAPSHOT                  = 517
	SQLITE_BUSY_TIMEOUT                   = 773
	SQLITE_CALLBACK                       = 0
	SQLITE_CANTOPEN                       = 14
	SQLITE_CANTOPEN_CONVPATH              = 1038
	SQLITE_CANTOPEN_DIRTYWAL              = 1294
	SQLITE_CANTOPEN_FULLPATH              = 782
	SQLITE_CANTOPEN_ISDIR                 = 526
	SQLITE_CANTOPEN_NOTEMPDIR             = 270
	SQLITE_CANTOPEN_SYMLINK               = 1550
	SQLITE_CDECL                          = 0
	SQLITE_CHANGESETAPPLY_INVERT          = 0x0002
	SQLITE_CHANGESETAPPLY_NOSAVEPOINT     = 0x0001
	SQLITE_CHANGESETSTART_INVERT          = 0x0002
	SQLITE_CHANGESET_ABORT                = 2
	SQLITE_CHANGESET_CONFLICT             = 3
	SQLITE_CHANGESET_CONSTRAINT           = 4
	SQLITE_CHANGESET_DATA                 = 1
	SQLITE_CHANGESET_FOREIGN_KEY          = 5
	SQLITE_CHANGESET_NOTFOUND             = 2
	SQLITE_CHANGESET_OMIT                 = 0
	SQLITE_CHANGESET_REPLACE              = 1
	SQLITE_CHECKPOINT_FULL                = 1
	SQLITE_CHECKPOINT_PASSIVE             = 0
	SQLITE_CHECKPOINT_RESTART             = 2
	SQLITE_CHECKPOINT_TRUNCATE            = 3
	SQLITE_CKSUMVFS_STATIC                = 1
	SQLITE_CONFIG_COVERING_INDEX_SCAN     = 20
	SQLITE_CONFIG_GETMALLOC               = 5
	SQLITE_CONFIG_GETMUTEX                = 11
	SQLITE_CONFIG_GETPCACHE               = 15
	SQLITE_CONFIG_GETPCACHE2              = 19
	SQLITE_CONFIG_HEAP                    = 8
	SQLITE_CONFIG_LOG                     = 16
	SQLITE_CONFIG_LOOKASIDE               = 13
	SQLITE_CONFIG_MALLOC                  = 4
	SQLITE_CONFIG_MEMDB_MAXSIZE           = 29
	SQLITE_CONFIG_MEMSTATUS               = 9
	SQLITE_CONFIG_MMAP_SIZE               = 22
	SQLITE_CONFIG_MULTITHREAD             = 2
	SQLITE_CONFIG_MUTEX                   = 10
	SQLITE_CONFIG_PAGECACHE               = 7
	SQLITE_CONFIG_PCACHE                  = 14
	SQLITE_CONFIG_PCACHE2                 = 18
	SQLITE_CONFIG_PCACHE_HDRSZ            = 24
	SQLITE_CONFIG_PMASZ                   = 25
	SQLITE_CONFIG_SCRATCH                 = 6
	SQLITE_CONFIG_SERIALIZED              = 3
	SQLITE_CONFIG_SINGLETHREAD            = 1
	SQLITE_CONFIG_SMALL_MALLOC            = 27
	SQLITE_CONFIG_SORTERREF_SIZE          = 28
	SQLITE_CONFIG_SQLLOG                  = 21
	SQLITE_CONFIG_STMTJRNL_SPILL          = 26
	SQLITE_CONFIG_URI                     = 17
	SQLITE_CONFIG_WIN32_HEAPSIZE          = 23
	SQLITE_CONSTRAINT                     = 19
	SQLITE_CONSTRAINT_CHECK               = 275
	SQLITE_CONSTRAINT_COMMITHOOK          = 531
	SQLITE_CONSTRAINT_DATATYPE            = 3091
	SQLITE_CONSTRAINT_FOREIGNKEY          = 787
	SQLITE_CONSTRAINT_FUNCTION            = 1043
	SQLITE_CONSTRAINT_NOTNULL             = 1299
	SQLITE_CONSTRAINT_PINNED              = 2835
	SQLITE_CONSTRAINT_PRIMARYKEY          = 1555
	SQLITE_CONSTRAINT_ROWID               = 2579
	SQLITE_CONSTRAINT_TRIGGER             = 1811
	SQLITE_CONSTRAINT_UNIQUE              = 2067
	SQLITE_CONSTRAINT_VTAB                = 2323
	SQLITE_COPY                           = 0
	SQLITE_CORE                           = 1
	SQLITE_CORRUPT                        = 11
	SQLITE_CORRUPT_INDEX                  = 779
	SQLITE_CORRUPT_SEQUENCE               = 523
	SQLITE_CORRUPT_VTAB                   = 267
	SQLITE_CRASH_TEST                     = 1
	SQLITE_CREATE_INDEX                   = 1
	SQLITE_CREATE_TABLE                   = 2
	SQLITE_CREATE_TEMP_INDEX              = 3
	SQLITE_CREATE_TEMP_TABLE              = 4
	SQLITE_CREATE_TEMP_TRIGGER            = 5
	SQLITE_CREATE_TEMP_VIEW               = 6
	SQLITE_CREATE_TRIGGER                 = 7
	SQLITE_CREATE_VIEW                    = 8
	SQLITE_CREATE_VTABLE                  = 29
	SQLITE_DBCONFIG_DEFENSIVE             = 1010
	SQLITE_DBCONFIG_DQS_DDL               = 1014
	SQLITE_DBCONFIG_DQS_DML               = 1013
	SQLITE_DBCONFIG_ENABLE_FKEY           = 1002
	SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004
	SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005
	SQLITE_DBCONFIG_ENABLE_QPSG           = 1007
	SQLITE_DBCONFIG_ENABLE_TRIGGER        = 1003
	SQLITE_DBCONFIG_ENABLE_VIEW           = 1015
	SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    = 1012
	SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    = 1016
	SQLITE_DBCONFIG_LOOKASIDE             = 1001
	SQLITE_DBCONFIG_MAINDBNAME            = 1000
	SQLITE_DBCONFIG_MAX                   = 1017
	SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      = 1006
	SQLITE_DBCONFIG_RESET_DATABASE        = 1009
	SQLITE_DBCONFIG_TRIGGER_EQP           = 1008
	SQLITE_DBCONFIG_TRUSTED_SCHEMA        = 1017
	SQLITE_DBCONFIG_WRITABLE_SCHEMA       = 1011
	SQLITE_DBSTATUS_CACHE_HIT             = 7
	SQLITE_DBSTATUS_CACHE_MISS            = 8
	SQLITE_DBSTATUS_CACHE_SPILL           = 12
	SQLITE_DBSTATUS_CACHE_USED            = 1
	SQLITE_DBSTATUS_CACHE_USED_SHARED     = 11
	SQLITE_DBSTATUS_CACHE_WRITE           = 9
	SQLITE_DBSTATUS_DEFERRED_FKS          = 10
	SQLITE_DBSTATUS_LOOKASIDE_HIT         = 4
	SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL   = 6
	SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE   = 5
	SQLITE_DBSTATUS_LOOKASIDE_USED        = 0
	SQLITE_DBSTATUS_MAX                   = 12
	SQLITE_DBSTATUS_SCHEMA_USED           = 2
	SQLITE_DBSTATUS_STMT_USED             = 3
	SQLITE_DEFAULT_MEMSTATUS              = 1
	SQLITE_DEFAULT_PAGE_SIZE              = 1024
	SQLITE_DELETE                         = 9
	SQLITE_DENY                           = 1
	SQLITE_DEPRECATED                     = 0
	SQLITE_DESERIALIZE_FREEONCLOSE        = 1
	SQLITE_DESERIALIZE_READONLY           = 4
	SQLITE_DESERIALIZE_RESIZEABLE         = 2
	SQLITE_DETACH                         = 25
	SQLITE_DETERMINISTIC                  = 0x000000800
	SQLITE_DIRECTONLY                     = 0x000080000
	SQLITE_DONE                           = 101
	SQLITE_DROP_INDEX                     = 10
	SQLITE_DROP_TABLE                     = 11
	SQLITE_DROP_TEMP_INDEX                = 12
	SQLITE_DROP_TEMP_TABLE                = 13
	SQLITE_DROP_TEMP_TRIGGER              = 14
	SQLITE_DROP_TEMP_VIEW                 = 15
	SQLITE_DROP_TRIGGER                   = 16
	SQLITE_DROP_VIEW                      = 17
	SQLITE_DROP_VTABLE                    = 30
	SQLITE_EMPTY                          = 16
	SQLITE_ENABLE_BYTECODE_VTAB           = 1
	SQLITE_ENABLE_COLUMN_METADATA         = 1
	SQLITE_ENABLE_DBPAGE_VTAB             = 1
	SQLITE_ENABLE_DBSTAT_VTAB             = 1
	SQLITE_ENABLE_DESERIALIZE             = 1
	SQLITE_ENABLE_EXPLAIN_COMMENTS        = 1
	SQLITE_ENABLE_FTS5                    = 1
	SQLITE_ENABLE_GEOPOLY                 = 1
	SQLITE_ENABLE_MATH_FUNCTIONS          = 1
	SQLITE_ENABLE_MEMORY_MANAGEMENT       = 1
	SQLITE_ENABLE_OFFSET_SQL_FUNC         = 1
	SQLITE_ENABLE_PREUPDATE_HOOK          = 1
	SQLITE_ENABLE_RBU                     = 1
	SQLITE_ENABLE_RTREE                   = 1
	SQLITE_ENABLE_SESSION                 = 1
	SQLITE_ENABLE_STAT4                   = 1
	SQLITE_ENABLE_STMTVTAB                = 1
	SQLITE_ENABLE_UNLOCK_NOTIFY           = 1
	SQLITE_ERROR                          = 1
	SQLITE_ERROR_MISSING_COLLSEQ          = 257
	SQLITE_ERROR_RETRY                    = 513
	SQLITE_ERROR_SNAPSHOT                 = 769
	SQLITE_EXPERIMENTAL                   = 0
	SQLITE_FAIL                           = 3
	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE       = 31
	SQLITE_FCNTL_BUSYHANDLER              = 15
	SQLITE_FCNTL_CHUNK_SIZE               = 6
	SQLITE_FCNTL_CKPT_DONE                = 37
	SQLITE_FCNTL_CKPT_START               = 39
	SQLITE_FCNTL_CKSM_FILE                = 41
	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE      = 32
	SQLITE_FCNTL_COMMIT_PHASETWO          = 22
	SQLITE_FCNTL_DATA_VERSION             = 35
	SQLITE_FCNTL_EXTERNAL_READER          = 40
	SQLITE_FCNTL_FILE_POINTER             = 7
	SQLITE_FCNTL_GET_LOCKPROXYFILE        = 2
	SQLITE_FCNTL_HAS_MOVED                = 20
	SQLITE_FCNTL_JOURNAL_POINTER          = 28
	SQLITE_FCNTL_LAST_ERRNO               = 4
	SQLITE_FCNTL_LOCKSTATE                = 1
	SQLITE_FCNTL_LOCK_TIMEOUT             = 34
	SQLITE_FCNTL_MMAP_SIZE                = 18
	SQLITE_FCNTL_OVERWRITE                = 11
	SQLITE_FCNTL_PDB                      = 30
	SQLITE_FCNTL_PERSIST_WAL              = 10
	SQLITE_FCNTL_POWERSAFE_OVERWRITE      = 13
	SQLITE_FCNTL_PRAGMA                   = 14
	SQLITE_FCNTL_RBU                      = 26
	SQLITE_FCNTL_RESERVE_BYTES            = 38
	SQLITE_FCNTL_RESET_CACHE              = 42
	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE    = 33
	SQLITE_FCNTL_SET_LOCKPROXYFILE        = 3
	SQLITE_FCNTL_SIZE_HINT                = 5
	SQLITE_FCNTL_SIZE_LIMIT               = 36
	SQLITE_FCNTL_SYNC                     = 21
	SQLITE_FCNTL_SYNC_OMITTED             = 8
	SQLITE_FCNTL_TEMPFILENAME             = 16
	SQLITE_FCNTL_TRACE                    = 19
	SQLITE_FCNTL_VFSNAME                  = 12
	SQLITE_FCNTL_VFS_POINTER              = 27
	SQLITE_FCNTL_WAL_BLOCK                = 24
	SQLITE_FCNTL_WIN32_AV_RETRY           = 9
	SQLITE_FCNTL_WIN32_GET_HANDLE         = 29
	SQLITE_FCNTL_WIN32_SET_HANDLE         = 23
	SQLITE_FCNTL_ZIPVFS                   = 25
	SQLITE_FLOAT                          = 2
	SQLITE_FORMAT                         = 24
	SQLITE_FULL                           = 13
	SQLITE_FUNCTION                       = 31
	SQLITE_GET_LOCKPROXYFILE              = 2
	SQLITE_IGNORE                         = 2
	SQLITE_INDEX_CONSTRAINT_EQ            = 2
	SQLITE_INDEX_CONSTRAINT_FUNCTION      = 150
	SQLITE_INDEX_CONSTRAINT_GE            = 32
	SQLITE_INDEX_CONSTRAINT_GLOB          = 66
	SQLITE_INDEX_CONSTRAINT_GT            = 4
	SQLITE_INDEX_CONSTRAINT_IS            = 72
	SQLITE_INDEX_CONSTRAINT_ISNOT         = 69
	SQLITE_INDEX_CONSTRAINT_ISNOTNULL     = 70
	SQLITE_INDEX_CONSTRAINT_ISNULL        = 71
	SQLITE_INDEX_CONSTRAINT_LE            = 8
	SQLITE_INDEX_CONSTRAINT_LIKE          = 65
	SQLITE_INDEX_CONSTRAINT_LIMIT         = 73
	SQLITE_INDEX_CONSTRAINT_LT            = 16
	SQLITE_INDEX_CONSTRAINT_MATCH         = 64
	SQLITE_INDEX_CONSTRAINT_NE            = 68
	SQLITE_INDEX_CONSTRAINT_OFFSET        = 74
	SQLITE_INDEX_CONSTRAINT_REGEXP        = 67
	SQLITE_INDEX_SCAN_UNIQUE              = 1
	SQLITE_INNOCUOUS                      = 0x000200000
	SQLITE_INSERT                         = 18
	SQLITE_INTEGER                        = 1
	SQLITE_INTERNAL                       = 2
	SQLITE_INTERRUPT                      = 9
	SQLITE_IOCAP_ATOMIC                   = 0x00000001
	SQLITE_IOCAP_ATOMIC16K                = 0x00000040
	SQLITE_IOCAP_ATOMIC1K                 = 0x00000004
	SQLITE_IOCAP_ATOMIC2K                 = 0x00000008
	SQLITE_IOCAP_ATOMIC32K                = 0x00000080
	SQLITE_IOCAP_ATOMIC4K                 = 0x00000010
	SQLITE_IOCAP_ATOMIC512                = 0x00000002
	SQLITE_IOCAP_ATOMIC64K                = 0x00000100
	SQLITE_IOCAP_ATOMIC8K                 = 0x00000020
	SQLITE_IOCAP_BATCH_ATOMIC             = 0x00004000
	SQLITE_IOCAP_IMMUTABLE                = 0x00002000
	SQLITE_IOCAP_POWERSAFE_OVERWRITE      = 0x00001000
	SQLITE_IOCAP_SAFE_APPEND              = 0x00000200
	SQLITE_IOCAP_SEQUENTIAL               = 0x00000400
	SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN    = 0x00000800
	SQLITE_IOERR                          = 10
	SQLITE_IOERR_ACCESS                   = 3338
	SQLITE_IOERR_AUTH                     = 7178
	SQLITE_IOERR_BEGIN_ATOMIC             = 7434
	SQLITE_IOERR_BLOCKED                  = 2826
	SQLITE_IOERR_CHECKRESERVEDLOCK        = 3594
	SQLITE_IOERR_CLOSE                    = 4106
	SQLITE_IOERR_COMMIT_ATOMIC            = 7690
	SQLITE_IOERR_CONVPATH                 = 6666
	SQLITE_IOERR_CORRUPTFS                = 8458
	SQLITE_IOERR_DATA                     = 8202
	SQLITE_IOERR_DELETE                   = 2570
	SQLITE_IOERR_DELETE_NOENT             = 5898
	SQLITE_IOERR_DIR_CLOSE                = 4362
	SQLITE_IOERR_DIR_FSYNC                = 1290
	SQLITE_IOERR_FSTAT                    = 1802
	SQLITE_IOERR_FSYNC                    = 1034
	SQLITE_IOERR_GETTEMPPATH              = 6410
	SQLITE_IOERR_LOCK                     = 3850
	SQLITE_IOERR_MMAP                     = 6154
	SQLITE_IOERR_NOMEM                    = 3082
	SQLITE_IOERR_RDLOCK                   = 2314
	SQLITE_IOERR_READ                     = 266
	SQLITE_IOERR_ROLLBACK_ATOMIC          = 7946
	SQLITE_IOERR_SEEK                     = 5642
	SQLITE_IOERR_SHMLOCK                  = 5130
	SQLITE_IOERR_SHMMAP                   = 5386
	SQLITE_IOERR_SHMOPEN                  = 4618
	SQLITE_IOERR_SHMSIZE                  = 4874
	SQLITE_IOERR_SHORT_READ               = 522
	SQLITE_IOERR_TRUNCATE                 = 1546
	SQLITE_IOERR_UNLOCK                   = 2058
	SQLITE_IOERR_VNODE                    = 6922
	SQLITE_IOERR_WRITE                    = 778
	SQLITE_LAST_ERRNO                     = 4
	SQLITE_LIKE_DOESNT_MATCH_BLOBS        = 1
	SQLITE_LIMIT_ATTACHED                 = 7
	SQLITE_LIMIT_COLUMN                   = 2
	SQLITE_LIMIT_COMPOUND_SELECT          = 4
	SQLITE_LIMIT_EXPR_DEPTH               = 3
	SQLITE_LIMIT_FUNCTION_ARG             = 6
	SQLITE_LIMIT_LENGTH                   = 0
	SQLITE_LIMIT_LIKE_PATTERN_LENGTH      = 8
	SQLITE_LIMIT_SQL_LENGTH               = 1
	SQLITE_LIMIT_TRIGGER_DEPTH            = 10
	SQLITE_LIMIT_VARIABLE_NUMBER          = 9
	SQLITE_LIMIT_VDBE_OP                  = 5
	SQLITE_LIMIT_WORKER_THREADS           = 11
	SQLITE_LOCKED                         = 6
	SQLITE_LOCKED_SHAREDCACHE             = 262
	SQLITE_LOCKED_VTAB                    = 518
	SQLITE_LOCK_EXCLUSIVE                 = 4
	SQLITE_LOCK_NONE                      = 0
	SQLITE_LOCK_PENDING                   = 3
	SQLITE_LOCK_RESERVED                  = 2
	SQLITE_LOCK_SHARED                    = 1
	SQLITE_MISMATCH                       = 20
	SQLITE_MISUSE                         = 21
	SQLITE_MUTEX_APPDEF                   = 1
	SQLITE_MUTEX_FAST                     = 0
	SQLITE_MUTEX_NOOP                     = 1
	SQLITE_MUTEX_RECURSIVE                = 1
	SQLITE_MUTEX_STATIC_APP1              = 8
	SQLITE_MUTEX_STATIC_APP2              = 9
	SQLITE_MUTEX_STATIC_APP3              = 10
	SQLITE_MUTEX_STATIC_LRU               = 6
	SQLITE_MUTEX_STATIC_LRU2              = 7
	SQLITE_MUTEX_STATIC_MAIN              = 2
	SQLITE_MUTEX_STATIC_MASTER            = 2
	SQLITE_MUTEX_STATIC_MEM               = 3
	SQLITE_MUTEX_STATIC_MEM2              = 4
	SQLITE_MUTEX_STATIC_OPEN              = 4
	SQLITE_MUTEX_STATIC_PMEM              = 7
	SQLITE_MUTEX_STATIC_PRNG              = 5
	SQLITE_MUTEX_STATIC_VFS1              = 11
	SQLITE_MUTEX_STATIC_VFS2              = 12
	SQLITE_MUTEX_STATIC_VFS3              = 13
	SQLITE_NOLFS                          = 22
	SQLITE_NOMEM                          = 7
	SQLITE_NOTADB                         = 26
	SQLITE_NOTFOUND                       = 12
	SQLITE_NOTICE                         = 27
	SQLITE_NOTICE_RBU                     = 795
	SQLITE_NOTICE_RECOVER_ROLLBACK        = 539
	SQLITE_NOTICE_RECOVER_WAL             = 283
	SQLITE_NO_SYNC                        = 1
	SQLITE_NULL                           = 5
	SQLITE_OK                             = 0
	SQLITE_OK_LOAD_PERMANENTLY            = 256
	SQLITE_OK_SYMLINK                     = 512
	SQLITE_OMIT_LOAD_EXTENSION            = 1
	SQLITE_OPEN_AUTOPROXY                 = 0x00000020
	SQLITE_OPEN_CREATE                    = 0x00000004
	SQLITE_OPEN_DELETEONCLOSE             = 0x00000008
	SQLITE_OPEN_EXCLUSIVE                 = 0x00000010
	SQLITE_OPEN_EXRESCODE                 = 0x02000000
	SQLITE_OPEN_FULLMUTEX                 = 0x00010000
	SQLITE_OPEN_MAIN_DB                   = 0x00000100
	SQLITE_OPEN_MAIN_JOURNAL              = 0x00000800
	SQLITE_OPEN_MASTER_JOURNAL            = 0x00004000
	SQLITE_OPEN_MEMORY                    = 0x00000080
	SQLITE_OPEN_NOFOLLOW                  = 0x01000000
	SQLITE_OPEN_NOMUTEX                   = 0x00008000
	SQLITE_OPEN_PRIVATECACHE              = 0x00040000
	SQLITE_OPEN_READONLY                  = 0x00000001
	SQLITE_OPEN_READWRITE                 = 0x00000002
	SQLITE_OPEN_SHAREDCACHE               = 0x00020000
	SQLITE_OPEN_SUBJOURNAL                = 0x00002000
	SQLITE_OPEN_SUPER_JOURNAL             = 0x00004000
	SQLITE_OPEN_TEMP_DB                   = 0x00000200
	SQLITE_OPEN_TEMP_JOURNAL              = 0x00001000
	SQLITE_OPEN_TRANSIENT_DB              = 0x00000400
	SQLITE_OPEN_URI                       = 0x00000040
	SQLITE_OPEN_WAL                       = 0x00080000
	SQLITE_PERM                           = 3
	SQLITE_PRAGMA                         = 19
	SQLITE_PREPARE_NORMALIZE              = 0x02
	SQLITE_PREPARE_NO_VTAB                = 0x04
	SQLITE_PREPARE_PERSISTENT             = 0x01
	SQLITE_PRIVATE                        = ""
	SQLITE_PROTOCOL                       = 15
	SQLITE_RANGE                          = 25
	SQLITE_READ                           = 20
	SQLITE_READONLY                       = 8
	SQLITE_READONLY_CANTINIT              = 1288
	SQLITE_READONLY_CANTLOCK              = 520
	SQLITE_READONLY_DBMOVED               = 1032
	SQLITE_READONLY_DIRECTORY             = 1544
	SQLITE_READONLY_RECOVERY              = 264
	SQLITE_READONLY_ROLLBACK              = 776
	SQLITE_RECURSIVE                      = 33
	SQLITE_REINDEX                        = 27
	SQLITE_REPLACE                        = 5
	SQLITE_ROLLBACK                       = 1
	SQLITE_ROW                            = 100
	SQLITE_SAVEPOINT                      = 32
	SQLITE_SCANSTAT_COMPLEX               = 0x0001
	SQLITE_SCANSTAT_EST                   = 2
	SQLITE_SCANSTAT_EXPLAIN               = 4
	SQLITE_SCANSTAT_NAME                  = 3
	SQLITE_SCANSTAT_NCYCLE                = 7
	SQLITE_SCANSTAT_NLOOP                 = 0
	SQLITE_SCANSTAT_NVISIT                = 1
	SQLITE_SCANSTAT_PARENTID              = 6
	SQLITE_SCANSTAT_SELECTID              = 5
	SQLITE_SCHEMA                         = 17
	SQLITE_SELECT                         = 21
	SQLITE_SERIALIZE_NOCOPY               = 0x001
	SQLITE_SERIES_CONSTRAINT_VERIFY       = 1
	SQLITE_SERVER                         = 1
	SQLITE_SESSION_CONFIG_STRMSIZE        = 1
	SQLITE_SESSION_OBJCONFIG_SIZE         = 1
	SQLITE_SET_LOCKPROXYFILE              = 3
	SQLITE_SHM_EXCLUSIVE                  = 8
	SQLITE_SHM_LOCK                       = 2
	SQLITE_SHM_NLOCK                      = 8
	SQLITE_SHM_SHARED                     = 4
	SQLITE_SHM_UNLOCK                     = 1
	SQLITE_SOUNDEX                        = 1
	SQLITE_SOURCE_ID                      = "2023-03-22 11:56:21 0d1fc92f94cb6b76bffe3ec34d69cffde2924203304e8ffc4155597af0c191da"
	SQLITE_STATUS_MALLOC_COUNT            = 9
	SQLITE_STATUS_MALLOC_SIZE             = 5
	SQLITE_STATUS_MEMORY_USED             = 0
	SQLITE_STATUS_PAGECACHE_OVERFLOW      = 2
	SQLITE_STATUS_PAGECACHE_SIZE          = 7
	SQLITE_STATUS_PAGECACHE_USED          = 1
	SQLITE_STATUS_PARSER_STACK            = 6
	SQLITE_STATUS_SCRATCH_OVERFLOW        = 4
	SQLITE_STATUS_SCRATCH_SIZE            = 8
	SQLITE_STATUS_SCRATCH_USED            = 3
	SQLITE_STDCALL                        = 0
	SQLITE_STMTSTATUS_AUTOINDEX           = 3
	SQLITE_STMTSTATUS_FILTER_HIT          = 8
	SQLITE_STMTSTATUS_FILTER_MISS         = 7
	SQLITE_STMTSTATUS_FULLSCAN_STEP       = 1
	SQLITE_STMTSTATUS_MEMUSED             = 99
	SQLITE_STMTSTATUS_REPREPARE           = 5
	SQLITE_STMTSTATUS_RUN                 = 6
	SQLITE_STMTSTATUS_SORT                = 2
	SQLITE_STMTSTATUS_VM_STEP             = 4
	SQLITE_SUBTYPE                        = 0x000100000
	SQLITE_SYNC_DATAONLY                  = 0x00010
	SQLITE_SYNC_FULL                      = 0x00003
	SQLITE_SYNC_NORMAL                    = 0x00002
	SQLITE_SYSAPI                         = 0
	SQLITE_TEMP_STORE                     = 1
	SQLITE_TEST                           = 1
	SQLITE_TESTCTRL_ALWAYS                = 13
	SQLITE_TESTCTRL_ASSERT                = 12
	SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS   = 10
	SQLITE_TESTCTRL_BITVEC_TEST           = 8
	SQLITE_TESTCTRL_BYTEORDER             = 22
	SQLITE_TESTCTRL_EXPLAIN_STMT          = 19
	SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS   = 29
	SQLITE_TESTCTRL_FAULT_INSTALL         = 9
	SQLITE_TESTCTRL_FIRST                 = 5
	SQLITE_TESTCTRL_IMPOSTER              = 25
	SQLITE_TESTCTRL_INTERNAL_FUNCTIONS    = 17
	SQLITE_TESTCTRL_ISINIT                = 23
	SQLITE_TESTCTRL_ISKEYWORD             = 16
	SQLITE_TESTCTRL_LAST                  = 33
	SQLITE_TESTCTRL_LOCALTIME_FAULT       = 18
	SQLITE_TESTCTRL_LOGEST                = 33
	SQLITE_TESTCTRL_NEVER_CORRUPT         = 20
	SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD  = 19
	SQLITE_TESTCTRL_OPTIMIZATIONS         = 15
	SQLITE_TESTCTRL_PARSER_COVERAGE       = 26
	SQLITE_TESTCTRL_PENDING_BYTE          = 11
	SQLITE_TESTCTRL_PRNG_RESET            = 7
	SQLITE_TESTCTRL_PRNG_RESTORE          = 6
	SQLITE_TESTCTRL_PRNG_SAVE             = 5
	SQLITE_TESTCTRL_PRNG_SEED             = 28
	SQLITE_TESTCTRL_RESERVE               = 14
	SQLITE_TESTCTRL_RESULT_INTREAL        = 27
	SQLITE_TESTCTRL_SCRATCHMALLOC         = 17
	SQLITE_TESTCTRL_SEEK_COUNT            = 30
	SQLITE_TESTCTRL_SORTER_MMAP           = 24
	SQLITE_TESTCTRL_TRACEFLAGS            = 31
	SQLITE_TESTCTRL_TUNE                  = 32
	SQLITE_TESTCTRL_VDBE_COVERAGE         = 21
	SQLITE_TEXT                           = 3
	SQLITE_THREADSAFE                     = 1
	SQLITE_TOOBIG                         = 18
	SQLITE_TRACE_CLOSE                    = 0x08
	SQLITE_TRACE_PROFILE                  = 0x02
	SQLITE_TRACE_ROW                      = 0x04
	SQLITE_TRACE_STMT                     = 0x01
	SQLITE_TRANSACTION                    = 22
	SQLITE_TXN_NONE                       = 0
	SQLITE_TXN_READ                       = 1
	SQLITE_TXN_WRITE                      = 2
	SQLITE_UPDATE                         = 23
	SQLITE_UTF16                          = 4
	SQLITE_UTF16BE                        = 3
	SQLITE_UTF16LE                        = 2
	SQLITE_UTF16_ALIGNED                  = 8
	SQLITE_UTF8                           = 1
	SQLITE_VERSION                        = "3.41.2"
	SQLITE_VERSION_NUMBER                 = 3041002
	SQLITE_VTAB_CONSTRAINT_SUPPORT        = 1
	SQLITE_VTAB_DIRECTONLY                = 3
	SQLITE_VTAB_INNOCUOUS                 = 2
	SQLITE_WARNING                        = 28
	SQLITE_WARNING_AUTOINDEX              = 284
	SQLITE_WIN32_DATA_DIRECTORY_TYPE      = 1
	SQLITE_WIN32_TEMP_DIRECTORY_TYPE      = 2
	TMP_MAX                               = 308915776
	UNIQUE_TABLE_NAME                     = "t592690916721053953805701627921227776"
	X_ASSERT_H_                           = 0
	X_ERRNO_T_DEFINED                     = 0
	X_FILE_OFFSET_BITS                    = 64
	X_FSTDIO                              = 0
	X_FTRUNCATE_DECLARED                  = 0
	X_FTS5_H                              = 0
	X_HAVE_SQLITE_CONFIG_H                = 1
	X_ILP32                               = 1
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_LOCALE_T_DEFINED                    = 0
	X_LSEEK_DECLARED                      = 0
	X_MACHINE_STDARG_H_                   = 0
	X_MACHINE__LIMITS_H_                  = 0
	X_MACHINE__TYPES_H_                   = 0
	X_MMAP_DECLARED                       = 0
	X_Nonnull                             = 0
	X_Null_unspecified                    = 0
	X_Nullable                            = 0
	X_OFF64_T_DECLARED                    = 0
	X_OFF_T_DECLARED                      = 0
	X_RSIZE_T_DEFINED                     = 0
	X_SIZE_T_DECLARED                     = 0
	X_SQLITE3RTREE_H_                     = 0
	X_SSIZE_T_DECLARED                    = 0
	X_STDFILE_DECLARED                    = 0
	X_STDIO_H_                            = 0
	X_STDSTREAM_DECLARED                  = 0
	X_STRINGS_H_                          = 0
	X_STRING_H_                           = 0
	X_SWAB_DECLARED                       = 0
	X_SYS_CDEFS_H_                        = 0
	X_SYS__STDARG_H_                      = 0
	X_SYS__TYPES_H_                       = 0
	X_TRUNCATE_DECLARED                   = 0
	X_VA_LIST_DECLARED                    = 0
	X_XLOCALE_STRING1_H                   = 0
	X_XLOCALE_STRINGS1_H                  = 0
	I386                                  = 1
	Unix                                  = 1
	CRTIMPORT                             = 0
	DLLIMPORT                             = 0
	INLINE                                = 0
	MP_DIGIT_DECLARED                     = 0
	MP_INT_DECLARED                       = 0
	NUM_STATIC_TOKENS                     = 20
	SQLITE_TCLAPI                         = 0
	TCL_ALLOW_INLINE_COMPILATION          = 0x20000
	TCL_ALL_EVENTS                        = -3
	TCL_ALPHA_RELEASE                     = 0
	TCL_APPEND_VALUE                      = 4
	TCL_ARGV_CONSTANT                     = 15
	TCL_ARGV_END                          = 23
	TCL_ARGV_FLOAT                        = 19
	TCL_ARGV_FUNC                         = 20
	TCL_ARGV_GENFUNC                      = 21
	TCL_ARGV_HELP                         = 22
	TCL_ARGV_INT                          = 16
	TCL_ARGV_REST                         = 18
	TCL_ARGV_STRING                       = 17
	TCL_BETA_RELEASE                      = 1
	TCL_BREAK                             = 3
	TCL_CANCEL_UNWIND                     = 0x100000
	TCL_CHANNEL_THREAD_INSERT             = 0
	TCL_CHANNEL_THREAD_REMOVE             = 1
	TCL_CLOSE_READ                        = 2
	TCL_CLOSE_WRITE                       = 4
	TCL_CONTINUE                          = 4
	TCL_CONVERT_MULTIBYTE                 = -1
	TCL_CONVERT_NOSPACE                   = -4
	TCL_CONVERT_SYNTAX                    = -2
	TCL_CONVERT_UNKNOWN                   = -3
	TCL_CREATE_HARD_LINK                  = 0x02
	TCL_CREATE_SYMBOLIC_LINK              = 0x01
	TCL_CUSTOM_PTR_KEYS                   = -1
	TCL_CUSTOM_TYPE_KEYS                  = -2
	TCL_DONT_QUOTE_HASH                   = 8
	TCL_DONT_USE_BRACES                   = 1
	TCL_DONT_WAIT                         = 2
	TCL_DOUBLE_SPACE                      = 27
	TCL_DSTRING_STATIC_SIZE               = 200
	TCL_ENCODING_CHAR_LIMIT               = 0x10
	TCL_ENCODING_END                      = 0x02
	TCL_ENCODING_NO_TERMINATE             = 0x08
	TCL_ENCODING_START                    = 0x01
	TCL_ENCODING_STOPONERROR              = 0x04
	TCL_ENFORCE_MODE                      = 16
	TCL_ENSEMBLE_PREFIX                   = 0x02
	TCL_ERROR                             = 1
	TCL_EVAL_DIRECT                       = 0x040000
	TCL_EVAL_GLOBAL                       = 0x020000
	TCL_EVAL_INVOKE                       = 0x080000
	TCL_EVAL_NOERR                        = 0x200000
	TCL_EXACT                             = 1
	TCL_EXCEPTION                         = 8
	TCL_FILE_EVENTS                       = 8
	TCL_FINAL_RELEASE                     = 2
	TCL_GLOBAL_ONLY                       = 1
	TCL_GLOB_PERM_HIDDEN                  = 2
	TCL_GLOB_PERM_R                       = 4
	TCL_GLOB_PERM_RONLY                   = 1
	TCL_GLOB_PERM_W                       = 8
	TCL_GLOB_PERM_X                       = 16
	TCL_GLOB_TYPE_BLOCK                   = 1
	TCL_GLOB_TYPE_CHAR                    = 2
	TCL_GLOB_TYPE_DIR                     = 4
	TCL_GLOB_TYPE_FILE                    = 16
	TCL_GLOB_TYPE_LINK                    = 32
	TCL_GLOB_TYPE_MOUNT                   = 128
	TCL_GLOB_TYPE_PIPE                    = 8
	TCL_GLOB_TYPE_SOCK                    = 64
	TCL_HASH_KEY_RANDOMIZE_HASH           = 0x1
	TCL_HASH_KEY_STORE_HASH               = 1
	TCL_HASH_KEY_SYSTEM_HASH              = 0x2
	TCL_HASH_KEY_TYPE_VERSION             = 1
	TCL_IDLE_EVENTS                       = 32
	TCL_INTEGER_SPACE                     = 24
	TCL_INTERP_DESTROYED                  = 0x100
	TCL_LEAVE_ERR_MSG                     = 0x200
	TCL_LIMIT_COMMANDS                    = 0x01
	TCL_LIMIT_TIME                        = 0x02
	TCL_LINK_BOOLEAN                      = 3
	TCL_LINK_CHAR                         = 6
	TCL_LINK_DOUBLE                       = 2
	TCL_LINK_FLOAT                        = 13
	TCL_LINK_INT                          = 1
	TCL_LINK_LONG                         = 11
	TCL_LINK_READ_ONLY                    = 0x80
	TCL_LINK_SHORT                        = 8
	TCL_LINK_STRING                       = 4
	TCL_LINK_UCHAR                        = 7
	TCL_LINK_UINT                         = 10
	TCL_LINK_ULONG                        = 12
	TCL_LINK_USHORT                       = 9
	TCL_LINK_WIDE_INT                     = 5
	TCL_LINK_WIDE_UINT                    = 14
	TCL_LIST_ELEMENT                      = 8
	TCL_LL_MODIFIER                       = "ll"
	TCL_LOAD_GLOBAL                       = 1
	TCL_LOAD_LAZY                         = 2
	TCL_MAJOR_VERSION                     = 8
	TCL_MATCH_NOCASE                      = 1
	TCL_MAX_PREC                          = 17
	TCL_MINOR_VERSION                     = 6
	TCL_MODE_BLOCKING                     = 0
	TCL_MODE_NONBLOCKING                  = 1
	TCL_NAMESPACE_ONLY                    = 2
	TCL_NORETURN1                         = 0
	TCL_NO_EVAL                           = 0x010000
	TCL_OK                                = 0
	TCL_ONE_WORD_KEYS                     = 1
	TCL_PARSE_BAD_NUMBER                  = 9
	TCL_PARSE_BRACE_EXTRA                 = 2
	TCL_PARSE_MISSING_BRACE               = 3
	TCL_PARSE_MISSING_BRACKET             = 4
	TCL_PARSE_MISSING_PAREN               = 5
	TCL_PARSE_MISSING_QUOTE               = 6
	TCL_PARSE_MISSING_VAR_BRACE           = 7
	TCL_PARSE_PART1                       = 0x400
	TCL_PARSE_QUOTE_EXTRA                 = 1
	TCL_PARSE_SUCCESS                     = 0
	TCL_PARSE_SYNTAX                      = 8
	TCL_PATCH_LEVEL                       = "8.6.13"
	TCL_READABLE                          = 2
	TCL_REG_ADVANCED                      = 000003
	TCL_REG_ADVF                          = 000002
	TCL_REG_BASIC                         = 000000
	TCL_REG_CANMATCH                      = 001000
	TCL_REG_EXPANDED                      = 000040
	TCL_REG_EXTENDED                      = 000001
	TCL_REG_NEWLINE                       = 000300
	TCL_REG_NLANCH                        = 000200
	TCL_REG_NLSTOP                        = 000100
	TCL_REG_NOCASE                        = 000010
	TCL_REG_NOSUB                         = 000020
	TCL_REG_NOTBOL                        = 0001
	TCL_REG_NOTEOL                        = 0002
	TCL_REG_QUOTE                         = 000004
	TCL_RELEASE_LEVEL                     = 2
	TCL_RELEASE_SERIAL                    = 13
	TCL_RESULT_SIZE                       = 200
	TCL_RETURN                            = 2
	TCL_SERVICE_ALL                       = 1
	TCL_SERVICE_NONE                      = 0
	TCL_SMALL_HASH_TABLE                  = 4
	TCL_STDERR                            = 8
	TCL_STDIN                             = 2
	TCL_STDOUT                            = 4
	TCL_STORAGE_CLASS                     = 0
	TCL_STRING_KEYS                       = 0
	TCL_SUBST_ALL                         = 007
	TCL_SUBST_BACKSLASHES                 = 004
	TCL_SUBST_COMMANDS                    = 001
	TCL_SUBST_VARIABLES                   = 002
	TCL_THREAD_CREATE_RETURN              = 0
	TCL_THREAD_JOINABLE                   = 1
	TCL_THREAD_NOFLAGS                    = 0
	TCL_THREAD_STACK_DEFAULT              = 0
	TCL_TIMER_EVENTS                      = 16
	TCL_TOKEN_BS                          = 8
	TCL_TOKEN_COMMAND                     = 16
	TCL_TOKEN_EXPAND_WORD                 = 256
	TCL_TOKEN_OPERATOR                    = 128
	TCL_TOKEN_SIMPLE_WORD                 = 2
	TCL_TOKEN_SUB_EXPR                    = 64
	TCL_TOKEN_TEXT                        = 4
	TCL_TOKEN_VARIABLE                    = 32
	TCL_TOKEN_WORD                        = 1
	TCL_TRACE_ARRAY                       = 0x800
	TCL_TRACE_DELETE                      = 0x4000
	TCL_TRACE_DESTROYED                   = 0x80
	TCL_TRACE_OLD_STYLE                   = 0x1000
	TCL_TRACE_READS                       = 0x10
	TCL_TRACE_RENAME                      = 0x2000
	TCL_TRACE_RESULT_DYNAMIC              = 0x8000
	TCL_TRACE_RESULT_OBJECT               = 0x10000
	TCL_TRACE_UNSETS                      = 0x40
	TCL_TRACE_WRITES                      = 0x20
	TCL_UNLOAD_DETACH_FROM_INTERPRETER    = 1
	TCL_UNLOAD_DETACH_FROM_PROCESS        = 2
	TCL_UTF_MAX                           = 3
	TCL_VERSION                           = "8.6"
	TCL_WINDOW_EVENTS                     = 4
	TCL_WRITABLE                          = 4
	TCL_ZLIB_COMPRESS_BEST                = 9
	TCL_ZLIB_COMPRESS_DEFAULT             = -1
	TCL_ZLIB_COMPRESS_FAST                = 1
	TCL_ZLIB_COMPRESS_NONE                = 0
	TCL_ZLIB_FINALIZE                     = 4
	TCL_ZLIB_FLUSH                        = 2
	TCL_ZLIB_FORMAT_AUTO                  = 8
	TCL_ZLIB_FORMAT_GZIP                  = 4
	TCL_ZLIB_FORMAT_RAW                   = 1
	TCL_ZLIB_FORMAT_ZLIB                  = 2
	TCL_ZLIB_FULLFLUSH                    = 3
	TCL_ZLIB_NO_FLUSH                     = 0
	TCL_ZLIB_STREAM_DEFLATE               = 16
	TCL_ZLIB_STREAM_INFLATE               = 32
	X_CLIENTDATA                          = 0
	X_TCL                                 = 0
	X_TCLDECLS                            = 0
	X_TCLPLATDECLS                        = 0
	X_FTSINT_H                            = 0
	FTS3_TOK_SCHEMA                       = "CREATE TABLE x(input HIDDEN, token, start, end, position)"
	AMATCH_COL_COMMAND                    = 3
	AMATCH_COL_DISTANCE                   = 1
	AMATCH_COL_LANGUAGE                   = 2
	AMATCH_COL_NWORD                      = 4
	AMATCH_COL_WORD                       = 0
	AMATCH_MX_COST                        = 1000
	AMATCH_MX_LANGID                      = 2147483647
	AMATCH_MX_LENGTH                      = 50
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	RAND_MAX                              = 0x7fffffff
	SQLITE3EXT_H                          = 0
	SQLITE_EXTENSION_INIT1                = 0
	SQLITE_EXTENSION_INIT3                = 0
	X_CACHED_RUNES                        = 256
	X_CRMASK                              = -256
	X_CTYPE_A                             = 0x00000100
	X_CTYPE_B                             = 0x00020000
	X_CTYPE_C                             = 0x00000200
	X_CTYPE_D                             = 0x00000400
	X_CTYPE_G                             = 0x00000800
	X_CTYPE_H_                            = 0
	X_CTYPE_I                             = 0x00080000
	X_CTYPE_L                             = 0x00001000
	X_CTYPE_N                             = 0x00400000
	X_CTYPE_P                             = 0x00002000
	X_CTYPE_Q                             = 0x00200000
	X_CTYPE_R                             = 0x00040000
	X_CTYPE_S                             = 0x00004000
	X_CTYPE_SW0                           = 0x20000000
	X_CTYPE_SW1                           = 0x40000000
	X_CTYPE_SW2                           = 0x80000000
	X_CTYPE_SW3                           = 0xc0000000
	X_CTYPE_SWM                           = 0xe0000000
	X_CTYPE_SWS                           = 30
	X_CTYPE_T                             = 0x00100000
	X_CTYPE_U                             = 0x00008000
	X_CTYPE_X                             = 0x00010000
	X_MKDTEMP_DECLARED                    = 0
	X_MKSTEMP_DECLARED                    = 0
	X_MKTEMP_DECLARED                     = 0
	X_RUNETYPE_H_                         = 0
	X_RUNE_MAGIC_1                        = "RuneMagi"
	X_RUNE_T_DECLARED                     = 0
	X_STDLIB_H_                           = 0
	X_WCHAR_T_DECLARED                    = 0
	X_XLOCALE_CTYPE_H                     = 0
	X_XLOCALE_RUN_FUNCTIONS_DEFINED       = 1
	APND_MARK_FOS_SZ                      = 8
	APND_MARK_PREFIX                      = "Start-Of-SQLite3-"
	APND_MARK_PREFIX_SZ                   = 17
	APND_MARK_SIZE                        = 25
	APND_MAX_SIZE                         = 1073741824
	APND_ROUNDUP                          = 4096
	B64_DARK_MAX                          = 72
	B85_DARK_MAX                          = 80
	ND                                    = 0x82
	PAD_CHAR                              = 61
	PC                                    = 0x80
	U8_TYPEDEF                            = 0
	WS                                    = 0x81
	Deliberate_fall_through               = 0
	CARRAY_BLOB                           = 4
	CARRAY_COLUMN_COUNT                   = 2
	CARRAY_COLUMN_CTYPE                   = 3
	CARRAY_COLUMN_POINTER                 = 1
	CARRAY_COLUMN_VALUE                   = 0
	CARRAY_DOUBLE                         = 2
	CARRAY_INT32                          = 0
	CARRAY_INT64                          = 1
	CARRAY_TEXT                           = 3
	X_SYS_UIO_H_                          = 0
	X_SYS__IOVEC_H_                       = 0
	X_SYS__UIO_H_                         = 0
	CLOSURE_COL_DEPTH                     = 1
	CLOSURE_COL_ID                        = 0
	CLOSURE_COL_IDCOLUMN                  = 4
	CLOSURE_COL_PARENTCOLUMN              = 5
	CLOSURE_COL_ROOT                      = 2
	CLOSURE_COL_TABLENAME                 = 3
	CSVTEST_FIDX                          = 0x0001
	CSV_INBUFSZ                           = 1024
	CSV_MXERR                             = 200
	EXPLN_COLUMN_ADDR                     = 0
	EXPLN_COLUMN_COMMENT                  = 7
	EXPLN_COLUMN_OPCODE                   = 1
	EXPLN_COLUMN_P1                       = 2
	EXPLN_COLUMN_P2                       = 3
	EXPLN_COLUMN_P3                       = 4
	EXPLN_COLUMN_P4                       = 5
	EXPLN_COLUMN_P5                       = 6
	EXPLN_COLUMN_SQL                      = 8
	ACCESSPERMS                           = 511
	ALLPERMS                              = 4095
	AT_EACCESS                            = 0x0100
	AT_EMPTY_PATH                         = 0x4000
	AT_FDCWD                              = -100
	AT_REMOVEDIR                          = 0x0800
	AT_RESOLVE_BENEATH                    = 0x2000
	AT_SYMLINK_FOLLOW                     = 0x0400
	AT_SYMLINK_NOFOLLOW                   = 0x0200
	BIG_ENDIAN                            = 4321
	BYTE_ORDER                            = 1234
	CLK_TCK                               = 128
	CLOCKS_PER_SEC                        = 128
	CLOCK_BOOTTIME                        = 5
	CLOCK_MONOTONIC                       = 4
	CLOCK_MONOTONIC_COARSE                = 12
	CLOCK_MONOTONIC_FAST                  = 12
	CLOCK_MONOTONIC_PRECISE               = 11
	CLOCK_PROCESS_CPUTIME_ID              = 15
	CLOCK_PROF                            = 2
	CLOCK_REALTIME                        = 0
	CLOCK_REALTIME_COARSE                 = 10
	CLOCK_REALTIME_FAST                   = 10
	CLOCK_REALTIME_PRECISE                = 9
	CLOCK_SECOND                          = 13
	CLOCK_THREAD_CPUTIME_ID               = 14
	CLOCK_UPTIME                          = 5
	CLOCK_UPTIME_FAST                     = 8
	CLOCK_UPTIME_PRECISE                  = 7
	CLOCK_VIRTUAL                         = 1
	CLOSE_RANGE_CLOEXEC                   = 4
	CPUCLOCK_WHICH_PID                    = 0
	CPUCLOCK_WHICH_TID                    = 1
	DEFFILEMODE                           = 438
	DIRBLKSIZ                             = 1024
	DST_AUST                              = 2
	DST_CAN                               = 6
	DST_EET                               = 5
	DST_MET                               = 4
	DST_NONE                              = 0
	DST_USA                               = 1
	DST_WET                               = 3
	DTF_HIDEW                             = 0x0001
	DTF_NODUP                             = 0x0002
	DTF_REWIND                            = 0x0004
	DT_BLK                                = 6
	DT_CHR                                = 2
	DT_DIR                                = 4
	DT_FIFO                               = 1
	DT_LNK                                = 10
	DT_REG                                = 8
	DT_SOCK                               = 12
	DT_UNKNOWN                            = 0
	DT_WHT                                = 14
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 48
	EADDRNOTAVAIL                         = 49
	EAFNOSUPPORT                          = 47
	EAGAIN                                = 35
	EALREADY                              = 37
	EAUTH                                 = 80
	EBADF                                 = 9
	EBADMSG                               = 89
	EBADRPC                               = 72
	EBUSY                                 = 16
	ECANCELED                             = 85
	ECAPMODE                              = 94
	ECHILD                                = 10
	ECONNABORTED                          = 53
	ECONNREFUSED                          = 61
	ECONNRESET                            = 54
	EDEADLK                               = 11
	EDESTADDRREQ                          = 39
	EDOM                                  = 33
	EDOOFUS                               = 88
	EDQUOT                                = 69
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EFTYPE                                = 79
	EHOSTDOWN                             = 64
	EHOSTUNREACH                          = 65
	EIDRM                                 = 82
	EILSEQ                                = 86
	EINPROGRESS                           = 36
	EINTEGRITY                            = 97
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EISCONN                               = 56
	EISDIR                                = 21
	ELAST                                 = 97
	ELOOP                                 = 62
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 40
	EMULTIHOP                             = 90
	ENAMETOOLONG                          = 63
	ENEEDAUTH                             = 81
	ENETDOWN                              = 50
	ENETRESET                             = 52
	ENETUNREACH                           = 51
	ENFILE                                = 23
	ENOATTR                               = 87
	ENOBUFS                               = 55
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOLCK                                = 77
	ENOLINK                               = 91
	ENOMEM                                = 12
	ENOMSG                                = 83
	ENOPROTOOPT                           = 42
	ENOSPC                                = 28
	ENOSYS                                = 78
	ENOTBLK                               = 15
	ENOTCAPABLE                           = 93
	ENOTCONN                              = 57
	ENOTDIR                               = 20
	ENOTEMPTY                             = 66
	ENOTRECOVERABLE                       = 95
	ENOTSOCK                              = 38
	ENOTSUP                               = 45
	ENOTTY                                = 25
	ENXIO                                 = 6
	EOPNOTSUPP                            = 45
	EOVERFLOW                             = 84
	EOWNERDEAD                            = 96
	EPERM                                 = 1
	EPFNOSUPPORT                          = 46
	EPIPE                                 = 32
	EPROCLIM                              = 67
	EPROCUNAVAIL                          = 76
	EPROGMISMATCH                         = 75
	EPROGUNAVAIL                          = 74
	EPROTO                                = 92
	EPROTONOSUPPORT                       = 43
	EPROTOTYPE                            = 41
	ERANGE                                = 34
	EREMOTE                               = 71
	EROFS                                 = 30
	ERPCMISMATCH                          = 73
	ESHUTDOWN                             = 58
	ESOCKTNOSUPPORT                       = 44
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESTALE                                = 70
	ETIMEDOUT                             = 60
	ETOOMANYREFS                          = 59
	ETXTBSY                               = 26
	EUSERS                                = 68
	EWOULDBLOCK                           = 35
	EXDEV                                 = 18
	FAPPEND                               = 8
	FASYNC                                = 64
	FDSYNC                                = 16777216
	FD_CLOEXEC                            = 1
	FD_NONE                               = -200
	FD_SETSIZE                            = 1024
	FFSYNC                                = 128
	FNDELAY                               = 4
	FNONBLOCK                             = 4
	FRDAHEAD                              = 512
	FREAD                                 = 0x0001
	FSDIR_COLUMN_DATA                     = 3
	FSDIR_COLUMN_DIR                      = 5
	FSDIR_COLUMN_MODE                     = 1
	FSDIR_COLUMN_MTIME                    = 2
	FSDIR_COLUMN_NAME                     = 0
	FSDIR_COLUMN_PATH                     = 4
	FSDIR_SCHEMA                          = "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"
	FWRITE                                = 0x0002
	F_ADD_SEALS                           = 19
	F_CANCEL                              = 5
	F_DUP2FD                              = 10
	F_DUP2FD_CLOEXEC                      = 18
	F_DUPFD                               = 0
	F_DUPFD_CLOEXEC                       = 17
	F_GETFD                               = 1
	F_GETFL                               = 3
	F_GETLK                               = 11
	F_GETOWN                              = 5
	F_GET_SEALS                           = 20
	F_ISUNIONSTACK                        = 21
	F_KINFO                               = 22
	F_LOCK                                = 1
	F_OGETLK                              = 7
	F_OK                                  = 0
	F_OSETLK                              = 8
	F_OSETLKW                             = 9
	F_RDAHEAD                             = 16
	F_RDLCK                               = 1
	F_READAHEAD                           = 15
	F_SEAL_GROW                           = 0x0004
	F_SEAL_SEAL                           = 0x0001
	F_SEAL_SHRINK                         = 0x0002
	F_SEAL_WRITE                          = 0x0008
	F_SETFD                               = 2
	F_SETFL                               = 4
	F_SETLK                               = 12
	F_SETLKW                              = 13
	F_SETLK_REMOTE                        = 14
	F_SETOWN                              = 6
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	F_UNLCK                               = 2
	F_UNLCKSYS                            = 4
	F_WRLCK                               = 3
	ITIMER_PROF                           = 2
	ITIMER_REAL                           = 0
	ITIMER_VIRTUAL                        = 1
	LITTLE_ENDIAN                         = 1234
	LOCK_EX                               = 0x02
	LOCK_NB                               = 0x04
	LOCK_SH                               = 0x01
	LOCK_UN                               = 0x08
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	MAXNAMLEN                             = 255
	O_ACCMODE                             = 0x0003
	O_APPEND                              = 0x0008
	O_ASYNC                               = 0x0040
	O_CLOEXEC                             = 0x00100000
	O_CREAT                               = 0x0200
	O_DIRECT                              = 0x00010000
	O_DIRECTORY                           = 0x00020000
	O_DSYNC                               = 0x01000000
	O_EMPTY_PATH                          = 0x02000000
	O_EXCL                                = 0x0800
	O_EXEC                                = 0x00040000
	O_EXLOCK                              = 0x0020
	O_FSYNC                               = 0x0080
	O_NDELAY                              = 4
	O_NOCTTY                              = 0x8000
	O_NOFOLLOW                            = 0x0100
	O_NONBLOCK                            = 0x0004
	O_PATH                                = 0x00400000
	O_RDONLY                              = 0x0000
	O_RDWR                                = 0x0002
	O_RESOLVE_BENEATH                     = 0x00800000
	O_SEARCH                              = 262144
	O_SHLOCK                              = 0x0010
	O_SYNC                                = 0x0080
	O_TRUNC                               = 0x0400
	O_TTY_INIT                            = 0x00080000
	O_VERIFY                              = 0x00200000
	O_WRONLY                              = 0x0001
	PDP_ENDIAN                            = 3412
	POSIX_FADV_DONTNEED                   = 4
	POSIX_FADV_NOREUSE                    = 5
	POSIX_FADV_NORMAL                     = 0
	POSIX_FADV_RANDOM                     = 1
	POSIX_FADV_SEQUENTIAL                 = 2
	POSIX_FADV_WILLNEED                   = 3
	RFCENVG                               = 2048
	RFCFDG                                = 4096
	RFCNAMEG                              = 1024
	RFENVG                                = 2
	RFFDG                                 = 4
	RFFLAGS                               = 2416930932
	RFHIGHPID                             = 262144
	RFKERNELONLY                          = 268828672
	RFLINUXTHPN                           = 65536
	RFMEM                                 = 32
	RFNAMEG                               = 1
	RFNOTEG                               = 8
	RFNOWAIT                              = 64
	RFPPWAIT                              = 2147483648
	RFPROC                                = 16
	RFPROCDESC                            = 268435456
	RFSIGSHARE                            = 16384
	RFSPAWN                               = 2147483648
	RFSTOPPED                             = 131072
	RFTHREAD                              = 8192
	RFTSIGMASK                            = 0xFF
	RFTSIGSHIFT                           = 20
	RFTSIGZMB                             = 524288
	R_OK                                  = 0x04
	SBT_MAX                               = 0x7fffffffffffffff
	SEEK_DATA                             = 3
	SEEK_HOLE                             = 4
	SF_APPEND                             = 0x00040000
	SF_ARCHIVED                           = 0x00010000
	SF_IMMUTABLE                          = 0x00020000
	SF_NOUNLINK                           = 0x00100000
	SF_SETTABLE                           = 0xffff0000
	SF_SNAPSHOT                           = 0x00200000
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	SWAPOFF_FORCE                         = 0x00000001
	S_BLKSIZE                             = 512
	S_IEXEC                               = 64
	S_IFBLK                               = 0060000
	S_IFCHR                               = 0020000
	S_IFDIR                               = 0040000
	S_IFIFO                               = 0010000
	S_IFLNK                               = 0120000
	S_IFMT                                = 0170000
	S_IFREG                               = 0100000
	S_IFSOCK                              = 0140000
	S_IFWHT                               = 0160000
	S_IREAD                               = 256
	S_IRGRP                               = 0000040
	S_IROTH                               = 0000004
	S_IRUSR                               = 0000400
	S_IRWXG                               = 0000070
	S_IRWXO                               = 0000007
	S_IRWXU                               = 0000700
	S_ISGID                               = 0002000
	S_ISTXT                               = 0001000
	S_ISUID                               = 0004000
	S_ISVTX                               = 0001000
	S_IWGRP                               = 0000020
	S_IWOTH                               = 0000002
	S_IWRITE                              = 128
	S_IWUSR                               = 0000200
	S_IXGRP                               = 0000010
	S_IXOTH                               = 0000001
	S_IXUSR                               = 0000100
	TIMER_ABSTIME                         = 0x1
	TIMER_RELTIME                         = 0x0
	TIME_UTC                              = 1
	UF_APPEND                             = 0x00000004
	UF_ARCHIVE                            = 0x00000800
	UF_HIDDEN                             = 0x00008000
	UF_IMMUTABLE                          = 0x00000002
	UF_NODUMP                             = 0x00000001
	UF_NOUNLINK                           = 0x00000010
	UF_OFFLINE                            = 0x00000200
	UF_OPAQUE                             = 0x00000008
	UF_READONLY                           = 0x00001000
	UF_REPARSE                            = 0x00000400
	UF_SETTABLE                           = 0x0000ffff
	UF_SPARSE                             = 0x00000100
	UF_SYSTEM                             = 0x00000080
	UTIME_NOW                             = -1
	UTIME_OMIT                            = -2
	W_OK                                  = 0x02
	X_OK                                  = 0x01
	X_ACCMODE_T_DECLARED                  = 0
	X_BIG_ENDIAN                          = 4321
	X_BLKCNT_T_DECLARED                   = 0
	X_BLKSIZE_T_DECLARED                  = 0
	X_BYTE_ORDER                          = 1234
	X_CAP_IOCTL_T_DECLARED                = 0
	X_CAP_RIGHTS_T_DECLARED               = 0
	X_CLOCKID_T_DECLARED                  = 0
	X_CLOCK_T_DECLARED                    = 0
	X_CS_PATH                             = 1
	X_CS_POSIX_V6_ILP32_OFF32_CFLAGS      = 2
	X_CS_POSIX_V6_ILP32_OFF32_LDFLAGS     = 3
	X_CS_POSIX_V6_ILP32_OFF32_LIBS        = 4
	X_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS     = 5
	X_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS    = 6
	X_CS_POSIX_V6_ILP32_OFFBIG_LIBS       = 7
	X_CS_POSIX_V6_LP64_OFF64_CFLAGS       = 8
	X_CS_POSIX_V6_LP64_OFF64_LDFLAGS      = 9
	X_CS_POSIX_V6_LP64_OFF64_LIBS         = 10
	X_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS     = 11
	X_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS    = 12
	X_CS_POSIX_V6_LPBIG_OFFBIG_LIBS       = 13
	X_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS   = 14
	X_DEV_T_DECLARED                      = 0
	X_DIRENT_H_                           = 0
	X_FFLAGS_T_DECLARED                   = 0
	X_FSBLKCNT_T_DECLARED                 = 0
	X_GETOPT_DECLARED                     = 0
	X_GID_T_DECLARED                      = 0
	X_ID_T_DECLARED                       = 0
	X_INO_T_DECLARED                      = 0
	X_INT16_T_DECLARED                    = 0
	X_INT32_T_DECLARED                    = 0
	X_INT64_T_DECLARED                    = 0
	X_INT8_T_DECLARED                     = 0
	X_INTMAX_T_DECLARED                   = 0
	X_INTPTR_T_DECLARED                   = 0
	X_IN_ADDR_T_DECLARED                  = 0
	X_IN_PORT_T_DECLARED                  = 0
	X_KEY_T_DECLARED                      = 0
	X_LITTLE_ENDIAN                       = 1234
	X_LWPID_T_DECLARED                    = 0
	X_MACHINE_ENDIAN_H_                   = 0
	X_MKNOD_DECLARED                      = 0
	X_MODE_T_DECLARED                     = 0
	X_MQD_T_DECLARED                      = 0
	X_NLINK_T_DECLARED                    = 0
	X_OPTRESET_DECLARED                   = 0
	X_PC_ACL_EXTENDED                     = 59
	X_PC_ACL_NFS4                         = 64
	X_PC_ACL_PATH_MAX                     = 60
	X_PC_ALLOC_SIZE_MIN                   = 10
	X_PC_ASYNC_IO                         = 53
	X_PC_CAP_PRESENT                      = 61
	X_PC_CHOWN_RESTRICTED                 = 7
	X_PC_FILESIZEBITS                     = 12
	X_PC_INF_PRESENT                      = 62
	X_PC_LINK_MAX                         = 1
	X_PC_MAC_PRESENT                      = 63
	X_PC_MAX_CANON                        = 2
	X_PC_MAX_INPUT                        = 3
	X_PC_MIN_HOLE_SIZE                    = 21
	X_PC_NAME_MAX                         = 4
	X_PC_NO_TRUNC                         = 8
	X_PC_PATH_MAX                         = 5
	X_PC_PIPE_BUF                         = 6
	X_PC_PRIO_IO                          = 54
	X_PC_REC_INCR_XFER_SIZE               = 14
	X_PC_REC_MAX_XFER_SIZE                = 15
	X_PC_REC_MIN_XFER_SIZE                = 16
	X_PC_REC_XFER_ALIGN                   = 17
	X_PC_SYMLINK_MAX                      = 18
	X_PC_SYNC_IO                          = 55
	X_PC_VDISABLE                         = 9
	X_PDP_ENDIAN                          = 3412
	X_PID_T_DECLARED                      = 0
	X_POSIX2_CHAR_TERM                    = 1
	X_POSIX2_C_BIND                       = 200112
	X_POSIX2_C_DEV                        = -1
	X_POSIX2_FORT_DEV                     = -1
	X_POSIX2_FORT_RUN                     = 200112
	X_POSIX2_LOCALEDEF                    = -1
	X_POSIX2_PBS                          = -1
	X_POSIX2_PBS_ACCOUNTING               = -1
	X_POSIX2_PBS_CHECKPOINT               = -1
	X_POSIX2_PBS_LOCATE                   = -1
	X_POSIX2_PBS_MESSAGE                  = -1
	X_POSIX2_PBS_TRACK                    = -1
	X_POSIX2_SW_DEV                       = -1
	X_POSIX2_UPE                          = 200112
	X_POSIX2_VERSION                      = 199212
	X_POSIX_ADVISORY_INFO                 = 200112
	X_POSIX_ASYNCHRONOUS_IO               = 200112
	X_POSIX_BARRIERS                      = 200112
	X_POSIX_CHOWN_RESTRICTED              = 1
	X_POSIX_CLOCK_SELECTION               = -1
	X_POSIX_CPUTIME                       = 200112
	X_POSIX_FSYNC                         = 200112
	X_POSIX_IPV6                          = 0
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_MAPPED_FILES                  = 200112
	X_POSIX_MEMLOCK                       = -1
	X_POSIX_MEMLOCK_RANGE                 = 200112
	X_POSIX_MEMORY_PROTECTION             = 200112
	X_POSIX_MESSAGE_PASSING               = 200112
	X_POSIX_MONOTONIC_CLOCK               = 200112
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_PRIORITIZED_IO                = -1
	X_POSIX_PRIORITY_SCHEDULING           = 0
	X_POSIX_RAW_SOCKETS                   = 200112
	X_POSIX_READER_WRITER_LOCKS           = 200112
	X_POSIX_REALTIME_SIGNALS              = 200112
	X_POSIX_REGEXP                        = 1
	X_POSIX_SEMAPHORES                    = 200112
	X_POSIX_SHARED_MEMORY_OBJECTS         = 200112
	X_POSIX_SHELL                         = 1
	X_POSIX_SPAWN                         = 200112
	X_POSIX_SPIN_LOCKS                    = 200112
	X_POSIX_SPORADIC_SERVER               = -1
	X_POSIX_SYNCHRONIZED_IO               = -1
	X_POSIX_THREADS                       = 200112
	X_POSIX_THREAD_ATTR_STACKADDR         = 200112
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200112
	X_POSIX_THREAD_CPUTIME                = 200112
	X_POSIX_THREAD_PRIORITY_SCHEDULING    = 200112
	X_POSIX_THREAD_PRIO_INHERIT           = 200112
	X_POSIX_THREAD_PRIO_PROTECT           = 200112
	X_POSIX_THREAD_PROCESS_SHARED         = 200112
	X_POSIX_THREAD_SAFE_FUNCTIONS         = -1
	X_POSIX_THREAD_SPORADIC_SERVER        = -1
	X_POSIX_TIMEOUTS                      = 200112
	X_POSIX_TIMERS                        = 200112
	X_POSIX_TRACE                         = -1
	X_POSIX_TRACE_EVENT_FILTER            = -1
	X_POSIX_TRACE_INHERIT                 = -1
	X_POSIX_TRACE_LOG                     = -1
	X_POSIX_TYPED_MEMORY_OBJECTS          = -1
	X_POSIX_VDISABLE                      = 0xff
	X_POSIX_VERSION                       = 200112
	X_PTHREAD_T_DECLARED                  = 0
	X_QUAD_HIGHWORD                       = 1
	X_QUAD_LOWWORD                        = 0
	X_RLIM_T_DECLARED                     = 0
	X_SC_2_CHAR_TERM                      = 20
	X_SC_2_C_BIND                         = 18
	X_SC_2_C_DEV                          = 19
	X_SC_2_FORT_DEV                       = 21
	X_SC_2_FORT_RUN                       = 22
	X_SC_2_LOCALEDEF                      = 23
	X_SC_2_PBS                            = 59
	X_SC_2_PBS_ACCOUNTING                 = 60
	X_SC_2_PBS_CHECKPOINT                 = 61
	X_SC_2_PBS_LOCATE                     = 62
	X_SC_2_PBS_MESSAGE                    = 63
	X_SC_2_PBS_TRACK                      = 64
	X_SC_2_SW_DEV                         = 24
	X_SC_2_UPE                            = 25
	X_SC_2_VERSION                        = 17
	X_SC_ADVISORY_INFO                    = 65
	X_SC_AIO_LISTIO_MAX                   = 42
	X_SC_AIO_MAX                          = 43
	X_SC_AIO_PRIO_DELTA_MAX               = 44
	X_SC_ARG_MAX                          = 1
	X_SC_ASYNCHRONOUS_IO                  = 28
	X_SC_ATEXIT_MAX                       = 107
	X_SC_BARRIERS                         = 66
	X_SC_BC_BASE_MAX                      = 9
	X_SC_BC_DIM_MAX                       = 10
	X_SC_BC_SCALE_MAX                     = 11
	X_SC_BC_STRING_MAX                    = 12
	X_SC_CHILD_MAX                        = 2
	X_SC_CLK_TCK                          = 3
	X_SC_CLOCK_SELECTION                  = 67
	X_SC_COLL_WEIGHTS_MAX                 = 13
	X_SC_CPUSET_SIZE                      = 122
	X_SC_CPUTIME                          = 68
	X_SC_DELAYTIMER_MAX                   = 45
	X_SC_EXPR_NEST_MAX                    = 14
	X_SC_FILE_LOCKING                     = 69
	X_SC_FSYNC                            = 38
	X_SC_GETGR_R_SIZE_MAX                 = 70
	X_SC_GETPW_R_SIZE_MAX                 = 71
	X_SC_HOST_NAME_MAX                    = 72
	X_SC_IOV_MAX                          = 56
	X_SC_IPV6                             = 118
	X_SC_JOB_CONTROL                      = 6
	X_SC_LINE_MAX                         = 15
	X_SC_LOGIN_NAME_MAX                   = 73
	X_SC_MAPPED_FILES                     = 29
	X_SC_MEMLOCK                          = 30
	X_SC_MEMLOCK_RANGE                    = 31
	X_SC_MEMORY_PROTECTION                = 32
	X_SC_MESSAGE_PASSING                  = 33
	X_SC_MONOTONIC_CLOCK                  = 74
	X_SC_MQ_OPEN_MAX                      = 46
	X_SC_MQ_PRIO_MAX                      = 75
	X_SC_NGROUPS_MAX                      = 4
	X_SC_NPROCESSORS_CONF                 = 57
	X_SC_NPROCESSORS_ONLN                 = 58
	X_SC_OPEN_MAX                         = 5
	X_SC_PAGESIZE                         = 47
	X_SC_PAGE_SIZE                        = 47
	X_SC_PHYS_PAGES                       = 121
	X_SC_PRIORITIZED_IO                   = 34
	X_SC_PRIORITY_SCHEDULING              = 35
	X_SC_RAW_SOCKETS                      = 119
	X_SC_READER_WRITER_LOCKS              = 76
	X_SC_REALTIME_SIGNALS                 = 36
	X_SC_REGEXP                           = 77
	X_SC_RE_DUP_MAX                       = 16
	X_SC_RTSIG_MAX                        = 48
	X_SC_SAVED_IDS                        = 7
	X_SC_SEMAPHORES                       = 37
	X_SC_SEM_NSEMS_MAX                    = 49
	X_SC_SEM_VALUE_MAX                    = 50
	X_SC_SHARED_MEMORY_OBJECTS            = 39
	X_SC_SHELL                            = 78
	X_SC_SIGQUEUE_MAX                     = 51
	X_SC_SPAWN                            = 79
	X_SC_SPIN_LOCKS                       = 80
	X_SC_SPORADIC_SERVER                  = 81
	X_SC_STREAM_MAX                       = 26
	X_SC_SYMLOOP_MAX                      = 120
	X_SC_SYNCHRONIZED_IO                  = 40
	X_SC_THREADS                          = 96
	X_SC_THREAD_ATTR_STACKADDR            = 82
	X_SC_THREAD_ATTR_STACKSIZE            = 83
	X_SC_THREAD_CPUTIME                   = 84
	X_SC_THREAD_DESTRUCTOR_ITERATIONS     = 85
	X_SC_THREAD_KEYS_MAX                  = 86
	X_SC_THREAD_PRIORITY_SCHEDULING       = 89
	X_SC_THREAD_PRIO_INHERIT              = 87
	X_SC_THREAD_PRIO_PROTECT              = 88
	X_SC_THREAD_PROCESS_SHARED            = 90
	X_SC_THREAD_SAFE_FUNCTIONS            = 91
	X_SC_THREAD_SPORADIC_SERVER           = 92
	X_SC_THREAD_STACK_MIN                 = 93
	X_SC_THREAD_THREADS_MAX               = 94
	X_SC_TIMEOUTS                         = 95
	X_SC_TIMERS                           = 41
	X_SC_TIMER_MAX                        = 52
	X_SC_TRACE                            = 97
	X_SC_TRACE_EVENT_FILTER               = 98
	X_SC_TRACE_INHERIT                    = 99
	X_SC_TRACE_LOG                        = 100
	X_SC_TTY_NAME_MAX                     = 101
	X_SC_TYPED_MEMORY_OBJECTS             = 102
	X_SC_TZNAME_MAX                       = 27
	X_SC_V6_ILP32_OFF32                   = 103
	X_SC_V6_ILP32_OFFBIG                  = 104
	X_SC_V6_LP64_OFF64                    = 105
	X_SC_V6_LPBIG_OFFBIG                  = 106
	X_SC_VERSION                          = 8
	X_SC_XOPEN_CRYPT                      = 108
	X_SC_XOPEN_ENH_I18N                   = 109
	X_SC_XOPEN_LEGACY                     = 110
	X_SC_XOPEN_REALTIME                   = 111
	X_SC_XOPEN_REALTIME_THREADS           = 112
	X_SC_XOPEN_SHM                        = 113
	X_SC_XOPEN_STREAMS                    = 114
	X_SC_XOPEN_UNIX                       = 115
	X_SC_XOPEN_VERSION                    = 116
	X_SC_XOPEN_XCU_VERSION                = 117
	X_SELECT_DECLARED                     = 0
	X_SIGSET_T_DECLARED                   = 0
	X_SIG_MAXSIG                          = 128
	X_SIG_WORDS                           = 4
	X_SUSECONDS_T_DECLARED                = 0
	X_SYS_DIRENT_H_                       = 0
	X_SYS_ERRNO_H_                        = 0
	X_SYS_FCNTL_H_                        = 0
	X_SYS_SELECT_H_                       = 0
	X_SYS_STAT_H_                         = 0
	X_SYS_SYS__CLOCK_ID_H                 = 0
	X_SYS_TIMESPEC_H_                     = 0
	X_SYS_TIME_H_                         = 0
	X_SYS_TYPES_H_                        = 0
	X_SYS_UNISTD_H_                       = 0
	X_SYS__ENDIAN_H_                      = 0
	X_SYS__PTHREADTYPES_H_                = 0
	X_SYS__SIGSET_H_                      = 0
	X_SYS__STDINT_H_                      = 0
	X_SYS__TIMESPEC_H_                    = 0
	X_SYS__TIMEVAL_H_                     = 0
	X_TIMER_T_DECLARED                    = 0
	X_TIME_H_                             = 0
	X_TIME_T_DECLARED                     = 0
	X_UID_T_DECLARED                      = 0
	X_UINT16_T_DECLARED                   = 0
	X_UINT32_T_DECLARED                   = 0
	X_UINT64_T_DECLARED                   = 0
	X_UINT8_T_DECLARED                    = 0
	X_UINTMAX_T_DECLARED                  = 0
	X_UINTPTR_T_DECLARED                  = 0
	X_UNISTD_H_                           = 0
	X_USECONDS_T_DECLARED                 = 0
	X_UTIME_H_                            = 0
	X_V6_ILP32_OFF32                      = -1
	X_V6_ILP32_OFFBIG                     = 0
	X_V6_LP64_OFF64                       = 0
	X_V6_LPBIG_OFFBIG                     = -1
	X_XLOCALE_LOCALE1_H                   = 0
	X_XOPEN_CRYPT                         = -1
	X_XOPEN_ENH_I18N                      = -1
	X_XOPEN_LEGACY                        = -1
	X_XOPEN_REALTIME                      = -1
	X_XOPEN_REALTIME_THREADS              = -1
	X_XOPEN_SHM                           = 1
	X_XOPEN_STREAMS                       = -1
	X_XOPEN_UNIX                          = -1
	FUZZER_HASH                           = 4001
	FUZZER_MX_COST                        = 1000
	FUZZER_MX_LENGTH                      = 50
	FUZZER_MX_OUTPUT_LENGTH               = 100
	FUZZER_MX_RULEID                      = 2147483647
	FUZZER_NQUEUE                         = 20
	CC_AND                                = 24
	CC_BANG                               = 15
	CC_COMMA                              = 23
	CC_DIGIT                              = 3
	CC_DOLLAR                             = 4
	CC_DOT                                = 26
	CC_EQ                                 = 14
	CC_GT                                 = 13
	CC_ID                                 = 2
	CC_ILLEGAL                            = 27
	CC_KYWD                               = 1
	CC_LP                                 = 17
	CC_LT                                 = 12
	CC_MINUS                              = 11
	CC_PERCENT                            = 22
	CC_PIPE                               = 10
	CC_PLUS                               = 20
	CC_QUOTE                              = 8
	CC_QUOTE2                             = 9
	CC_RP                                 = 18
	CC_SEMI                               = 19
	CC_SLASH                              = 16
	CC_SPACE                              = 7
	CC_STAR                               = 21
	CC_TILDA                              = 25
	CC_VARALPHA                           = 5
	CC_VARNUM                             = 6
	CC_X                                  = 0
	TK_BITAND                             = 3
	TK_BITNOT                             = 3
	TK_BITOR                              = 3
	TK_BLOB                               = 2
	TK_COMMA                              = 3
	TK_CONCAT                             = 3
	TK_DOT                                = 3
	TK_EQ                                 = 3
	TK_ERROR                              = 4
	TK_FLOAT                              = 2
	TK_GE                                 = 3
	TK_GT                                 = 3
	TK_ID                                 = 1
	TK_ILLEGAL                            = 4
	TK_INTEGER                            = 2
	TK_LE                                 = 3
	TK_LITERAL                            = 2
	TK_LP                                 = 3
	TK_LSHIFT                             = 3
	TK_LT                                 = 3
	TK_MINUS                              = 3
	TK_NAME                               = 1
	TK_NE                                 = 3
	TK_PLUS                               = 3
	TK_PUNCT                              = 3
	TK_REM                                = 3
	TK_RP                                 = 3
	TK_RSHIFT                             = 3
	TK_SEMI                               = 3
	TK_SLASH                              = 3
	TK_SPACE                              = 0
	TK_STAR                               = 3
	TK_STRING                             = 2
	TK_VARIABLE                           = 2
	QPVTAB_A                              = 6
	QPVTAB_B                              = 7
	QPVTAB_C                              = 8
	QPVTAB_CN                             = 2
	QPVTAB_D                              = 9
	QPVTAB_E                              = 10
	QPVTAB_FLAGS                          = 11
	QPVTAB_IX                             = 1
	QPVTAB_NONE                           = 12
	QPVTAB_OP                             = 3
	QPVTAB_RHS                            = 5
	QPVTAB_UX                             = 4
	QPVTAB_VN                             = 0
	RE_EOF                                = 0
	RE_OP_ACCEPT                          = 6
	RE_OP_ANY                             = 2
	RE_OP_ANYSTAR                         = 3
	RE_OP_ATSTART                         = 18
	RE_OP_BOUNDARY                        = 17
	RE_OP_CC_EXC                          = 8
	RE_OP_CC_INC                          = 7
	RE_OP_CC_RANGE                        = 10
	RE_OP_CC_VALUE                        = 9
	RE_OP_DIGIT                           = 13
	RE_OP_FORK                            = 4
	RE_OP_GOTO                            = 5
	RE_OP_MATCH                           = 1
	RE_OP_NOTDIGIT                        = 14
	RE_OP_NOTSPACE                        = 16
	RE_OP_NOTWORD                         = 12
	RE_OP_SPACE                           = 15
	RE_OP_WORD                            = 11
	RE_START                              = 0xfffffff
	SERIES_COLUMN_START                   = 1
	SERIES_COLUMN_STEP                    = 3
	SERIES_COLUMN_STOP                    = 2
	SERIES_COLUMN_VALUE                   = 0
	CCLASS_B                              = 2
	CCLASS_C                              = 3
	CCLASS_D                              = 4
	CCLASS_DIGIT                          = 10
	CCLASS_H                              = 5
	CCLASS_L                              = 6
	CCLASS_M                              = 8
	CCLASS_OTHER                          = 12
	CCLASS_R                              = 7
	CCLASS_SILENT                         = 0
	CCLASS_SPACE                          = 11
	CCLASS_VOWEL                          = 1
	CCLASS_Y                              = 9
	FINAL_INS_COST_DIV                    = 4
	SCRIPT_ARABIC                         = 0x0010
	SCRIPT_CYRILLIC                       = 0x0002
	SCRIPT_GREEK                          = 0x0004
	SCRIPT_HEBREW                         = 0x0008
	SCRIPT_LATIN                          = 0x0001
	SPELLFIX_COL_COMMAND                  = 11
	SPELLFIX_COL_DISTANCE                 = 2
	SPELLFIX_COL_LANGID                   = 3
	SPELLFIX_COL_MATCHLEN                 = 5
	SPELLFIX_COL_PHONEHASH                = 6
	SPELLFIX_COL_RANK                     = 1
	SPELLFIX_COL_SCOPE                    = 8
	SPELLFIX_COL_SCORE                    = 4
	SPELLFIX_COL_SOUNDSLIKE               = 10
	SPELLFIX_COL_SRCHCNT                  = 9
	SPELLFIX_COL_TOP                      = 7
	SPELLFIX_COL_WORD                     = 0
	SPELLFIX_IDXNUM_DIST                  = 48
	SPELLFIX_IDXNUM_DISTLE                = 0x20
	SPELLFIX_IDXNUM_DISTLT                = 0x10
	SPELLFIX_IDXNUM_LANGID                = 0x02
	SPELLFIX_IDXNUM_MATCH                 = 0x01
	SPELLFIX_IDXNUM_ROWID                 = 0x40
	SPELLFIX_IDXNUM_SCOPE                 = 0x08
	SPELLFIX_IDXNUM_TOP                   = 0x04
	SPELLFIX_MX_HASH                      = 32
	SPELLFIX_MX_RUN                       = 1
	SQLITE_SPELLFIX_STACKALLOC_SZ         = 1024
	TOTYPE_BIGENDIAN                      = 0
	TOTYPE_LITTLEENDIAN                   = 1
	SWARMVTAB_MAX_OPEN                    = 9
	SQLITE_RBU_STATE_CHECKPOINT           = 3
	SQLITE_RBU_STATE_DONE                 = 4
	SQLITE_RBU_STATE_ERROR                = 5
	SQLITE_RBU_STATE_MOVE                 = 2
	SQLITE_RBU_STATE_OAL                  = 1
	X_SQLITE3RBU_H                        = 0
	DBDATA_COLUMN_CELL                    = 1
	DBDATA_COLUMN_FIELD                   = 2
	DBDATA_COLUMN_PGNO                    = 0
	DBDATA_COLUMN_SCHEMA                  = 4
	DBDATA_COLUMN_VALUE                   = 3
	DBDATA_PADDING_BYTES                  = 100
	DBPTR_COLUMN_CHILD                    = 1
	DBPTR_COLUMN_PGNO                     = 0
	DBPTR_COLUMN_SCHEMA                   = 2
	RECOVER_EHIDDEN_HIDDEN                = 1
	RECOVER_EHIDDEN_NONE                  = 0
	RECOVER_EHIDDEN_STORED                = 3
	RECOVER_EHIDDEN_VIRTUAL               = 2
	RECOVER_MUTEX_ID                      = 9
	RECOVER_ROWID_DEFAULT                 = 1
	RECOVER_STATE_DONE                    = 6
	RECOVER_STATE_INIT                    = 0
	RECOVER_STATE_LOSTANDFOUND1           = 2
	RECOVER_STATE_LOSTANDFOUND2           = 3
	RECOVER_STATE_LOSTANDFOUND3           = 4
	RECOVER_STATE_SCHEMA2                 = 5
	RECOVER_STATE_WRITING                 = 1
	SQLITE_RECOVER_FREELIST_CORRUPT       = 2
	SQLITE_RECOVER_LOST_AND_FOUND         = 1
	SQLITE_RECOVER_ROWIDS                 = 3
	SQLITE_RECOVER_SLOWINDEXES            = 4
	X_SQLITE_RECOVER_H                    = 0
	BTREE_APPEND                          = 0x08
	BTREE_APPLICATION_ID                  = 8
	BTREE_AUTOVACUUM_FULL                 = 1
	BTREE_AUTOVACUUM_INCR                 = 2
	BTREE_AUTOVACUUM_NONE                 = 0
	BTREE_AUXDELETE                       = 0x04
	BTREE_BLOBKEY                         = 2
	BTREE_BULKLOAD                        = 0x00000001
	BTREE_DATA_VERSION                    = 15
	BTREE_DEFAULT_CACHE_SIZE              = 3
	BTREE_FILE_FORMAT                     = 2
	BTREE_FORDELETE                       = 0x00000008
	BTREE_FREE_PAGE_COUNT                 = 0
	BTREE_HINT_RANGE                      = 0
	BTREE_INCR_VACUUM                     = 7
	BTREE_INTKEY                          = 1
	BTREE_LARGEST_ROOT_PAGE               = 4
	BTREE_MEMORY                          = 2
	BTREE_OMIT_JOURNAL                    = 1
	BTREE_PREFORMAT                       = 0x80
	BTREE_SAVEPOSITION                    = 0x02
	BTREE_SCHEMA_VERSION                  = 1
	BTREE_SEEK_EQ                         = 0x00000002
	BTREE_SINGLE                          = 4
	BTREE_TEXT_ENCODING                   = 5
	BTREE_UNORDERED                       = 8
	BTREE_USER_VERSION                    = 6
	BTREE_WRCSR                           = 0x00000004
	COLFLAG_BUSY                          = 0x0100
	COLFLAG_GENERATED                     = 0x0060
	COLFLAG_HASCOLL                       = 0x0200
	COLFLAG_HASTYPE                       = 0x0004
	COLFLAG_HIDDEN                        = 0x0002
	COLFLAG_NOEXPAND                      = 0x0400
	COLFLAG_NOINSERT                      = 0x0062
	COLFLAG_NOTAVAIL                      = 0x0080
	COLFLAG_PRIMKEY                       = 0x0001
	COLFLAG_SORTERREF                     = 0x0010
	COLFLAG_STORED                        = 0x0040
	COLFLAG_UNIQUE                        = 0x0008
	COLFLAG_VIRTUAL                       = 0x0020
	COLNAME_COLUMN                        = 4
	COLNAME_DATABASE                      = 2
	COLNAME_DECLTYPE                      = 1
	COLNAME_N                             = 5
	COLNAME_NAME                          = 0
	COLNAME_TABLE                         = 3
	COLTYPE_ANY                           = 1
	COLTYPE_BLOB                          = 2
	COLTYPE_CUSTOM                        = 0
	COLTYPE_INT                           = 3
	COLTYPE_INTEGER                       = 4
	COLTYPE_REAL                          = 5
	COLTYPE_TEXT                          = 6
	DBFLAG_EncodingFixed                  = 0x0040
	DBFLAG_InternalFunc                   = 0x0020
	DBFLAG_PreferBuiltin                  = 0x0002
	DBFLAG_SchemaChange                   = 0x0001
	DBFLAG_SchemaKnownOk                  = 0x0010
	DBFLAG_Vacuum                         = 0x0004
	DBFLAG_VacuumInto                     = 0x0008
	DB_ResetWanted                        = 0x0008
	DB_SchemaLoaded                       = 0x0001
	DB_UnresetViews                       = 0x0002
	ENAME_NAME                            = 0
	ENAME_SPAN                            = 1
	ENAME_TAB                             = 2
	EP_Agg                                = 0x000010
	EP_CanBeNull                          = 0x200000
	EP_Collate                            = 0x000200
	EP_Commuted                           = 0x000400
	EP_ConstFunc                          = 0x100000
	EP_DblQuoted                          = 0x000080
	EP_Distinct                           = 0x000004
	EP_FixedCol                           = 0x000020
	EP_FromDDL                            = 0x40000000
	EP_HasFunc                            = 0x000008
	EP_IfNullRow                          = 0x040000
	EP_Immutable                          = 0x02
	EP_InfixFunc                          = 0x000100
	EP_InnerON                            = 0x000002
	EP_IntValue                           = 0x000800
	EP_IsFalse                            = 0x20000000
	EP_IsTrue                             = 0x10000000
	EP_Leaf                               = 0x800000
	EP_NoReduce                           = 0x01
	EP_OuterON                            = 0x000001
	EP_Propagate                          = 4194824
	EP_Quoted                             = 0x4000000
	EP_Reduced                            = 0x004000
	EP_Skip                               = 0x002000
	EP_Static                             = 0x8000000
	EP_Subquery                           = 0x400000
	EP_Subrtn                             = 0x2000000
	EP_TokenOnly                          = 0x010000
	EP_Unlikely                           = 0x080000
	EP_VarSelect                          = 0x000040
	EP_Win                                = 0x008000
	EP_WinFunc                            = 0x1000000
	EP_xIsSelect                          = 0x001000
	EU4_EXPR                              = 2
	EU4_IDX                               = 1
	EU4_NONE                              = 0
	EXCLUSIVE_LOCK                        = 4
	EXPRDUP_REDUCE                        = 0x0001
	GCC_VERSION                           = 4002001
	HAVE_DLFCN_H                          = 1
	HAVE_FCHOWN                           = 1
	HAVE_FDATASYNC                        = 1
	HAVE_GMTIME_R                         = 1
	HAVE_INT16_T                          = 1
	HAVE_INT32_T                          = 1
	HAVE_INT64_T                          = 1
	HAVE_INT8_T                           = 1
	HAVE_INTPTR_T                         = 1
	HAVE_INTTYPES_H                       = 1
	HAVE_ISNAN                            = 1
	HAVE_LOCALTIME_R                      = 1
	HAVE_LSTAT                            = 1
	HAVE_MALLOC_H                         = 1
	HAVE_MALLOC_USABLE_SIZE               = 1
	HAVE_MEMORY_H                         = 1
	HAVE_PREAD                            = 1
	HAVE_PWRITE                           = 1
	HAVE_READLINK                         = 1
	HAVE_STDINT_H                         = 1
	HAVE_STDLIB_H                         = 1
	HAVE_STRCHRNUL                        = 1
	HAVE_STRINGS_H                        = 1
	HAVE_STRING_H                         = 1
	HAVE_SYS_STAT_H                       = 1
	HAVE_SYS_TYPES_H                      = 1
	HAVE_UINT16_T                         = 1
	HAVE_UINT32_T                         = 1
	HAVE_UINT64_T                         = 1
	HAVE_UINT8_T                          = 1
	HAVE_UINTPTR_T                        = 1
	HAVE_UNISTD_H                         = 1
	HAVE_UTIME                            = 1
	HAVE_ZLIB_H                           = 1
	INITFLAG_AlterAdd                     = 0x0003
	INITFLAG_AlterDrop                    = 0x0002
	INITFLAG_AlterMask                    = 0x0003
	INITFLAG_AlterRename                  = 0x0001
	INLINEFUNC_affinity                   = 4
	INLINEFUNC_coalesce                   = 0
	INLINEFUNC_expr_compare               = 3
	INLINEFUNC_expr_implies_expr          = 2
	INLINEFUNC_iif                        = 5
	INLINEFUNC_implies_nonnull_row        = 1
	INLINEFUNC_sqlite_offset              = 6
	INLINEFUNC_unlikely                   = 99
	INT16_MAX                             = 0x7fff
	INT16_MIN                             = -32768
	INT32_MAX                             = 0x7fffffff
	INT32_MIN                             = -2147483648
	INT64_MAX                             = 0x7fffffffffffffff
	INT64_MIN                             = -9223372036854775808
	INT8_MAX                              = 0x7f
	INT8_MIN                              = -128
	INTMAX_MAX                            = 9223372036854775807
	INTMAX_MIN                            = -9223372036854775808
	INTPTR_MAX                            = 2147483647
	INTPTR_MIN                            = -2147483648
	INT_FAST16_MAX                        = 2147483647
	INT_FAST16_MIN                        = -2147483648
	INT_FAST32_MAX                        = 2147483647
	INT_FAST32_MIN                        = -2147483648
	INT_FAST64_MAX                        = 9223372036854775807
	INT_FAST64_MIN                        = -9223372036854775808
	INT_FAST8_MAX                         = 2147483647
	INT_FAST8_MIN                         = -2147483648
	INT_LEAST16_MAX                       = 32767
	INT_LEAST16_MIN                       = -32768
	INT_LEAST32_MAX                       = 2147483647
	INT_LEAST32_MIN                       = -2147483648
	INT_LEAST64_MAX                       = 9223372036854775807
	INT_LEAST64_MIN                       = -9223372036854775808
	INT_LEAST8_MAX                        = 127
	INT_LEAST8_MIN                        = -128
	IN_INDEX_EPH                          = 2
	IN_INDEX_INDEX_ASC                    = 3
	IN_INDEX_INDEX_DESC                   = 4
	IN_INDEX_LOOP                         = 0x0004
	IN_INDEX_MEMBERSHIP                   = 0x0002
	IN_INDEX_NOOP                         = 5
	IN_INDEX_NOOP_OK                      = 0x0001
	IN_INDEX_ROWID                        = 1
	JT_CROSS                              = 0x02
	JT_ERROR                              = 0x80
	JT_INNER                              = 0x01
	JT_LEFT                               = 0x08
	JT_LTORJ                              = 0x40
	JT_NATURAL                            = 0x04
	JT_OUTER                              = 0x20
	JT_RIGHT                              = 0x10
	KEYINFO_ORDER_BIGNULL                 = 0x02
	KEYINFO_ORDER_DESC                    = 0x01
	LEGACY_SCHEMA_TABLE                   = "sqlite_master"
	LEGACY_TEMP_SCHEMA_TABLE              = "sqlite_temp_master"
	LOCATE_NOERR                          = 0x02
	LOCATE_VIEW                           = 0x01
	LOOKASIDE_SMALL                       = 128
	LT_OBJDIR                             = ".libs/"
	M10d_Any                              = 1
	M10d_No                               = 2
	M10d_Yes                              = 0
	MEMTYPE_HEAP                          = 0x01
	MEMTYPE_LOOKASIDE                     = 0x02
	MEMTYPE_PCACHE                        = 0x04
	MSVC_VERSION                          = 0
	NC_AllowAgg                           = 0x000001
	NC_AllowWin                           = 0x004000
	NC_Complex                            = 0x002000
	NC_FromDDL                            = 0x040000
	NC_GenCol                             = 0x000008
	NC_HasAgg                             = 0x000010
	NC_HasWin                             = 0x008000
	NC_IdxExpr                            = 0x000020
	NC_InAggFunc                          = 0x020000
	NC_IsCheck                            = 0x000004
	NC_IsDDL                              = 0x010000
	NC_MinMaxAgg                          = 0x001000
	NC_NoSelect                           = 0x080000
	NC_OrderAgg                           = 0x8000000
	NC_PartIdx                            = 0x000002
	NC_SelfRef                            = 0x00002e
	NC_Subquery                           = 0x000040
	NC_UAggInfo                           = 0x000100
	NC_UBaseReg                           = 0x000400
	NC_UEList                             = 0x000080
	NC_UUpsert                            = 0x000200
	NO_LOCK                               = 0
	OE_Abort                              = 2
	OE_Cascade                            = 10
	OE_Default                            = 11
	OE_Fail                               = 3
	OE_Ignore                             = 4
	OE_None                               = 0
	OE_Replace                            = 5
	OE_Restrict                           = 7
	OE_Rollback                           = 1
	OE_SetDflt                            = 9
	OE_SetNull                            = 8
	OE_Update                             = 6
	OMIT_TEMPDB                           = 0
	ONEPASS_MULTI                         = 2
	ONEPASS_OFF                           = 0
	ONEPASS_SINGLE                        = 1
	OPFLAG_APPEND                         = 0x08
	OPFLAG_AUXDELETE                      = 0x04
	OPFLAG_BULKCSR                        = 0x01
	OPFLAG_EPHEM                          = 0x01
	OPFLAG_FORDELETE                      = 0x08
	OPFLAG_ISNOOP                         = 0x40
	OPFLAG_ISUPDATE                       = 0x04
	OPFLAG_LASTROWID                      = 0x20
	OPFLAG_LENGTHARG                      = 0x40
	OPFLAG_NCHANGE                        = 0x01
	OPFLAG_NOCHNG                         = 0x01
	OPFLAG_NOCHNG_MAGIC                   = 0x6d
	OPFLAG_P2ISREG                        = 0x10
	OPFLAG_PERMUTE                        = 0x01
	OPFLAG_PREFORMAT                      = 0x80
	OPFLAG_SAVEPOSITION                   = 0x02
	OPFLAG_SEEKEQ                         = 0x02
	OPFLAG_TYPEOFARG                      = 0x80
	OPFLAG_USESEEKRESULT                  = 0x10
	OPFLG_IN1                             = 0x02
	OPFLG_IN2                             = 0x04
	OPFLG_IN3                             = 0x08
	OPFLG_JUMP                            = 0x01
	OPFLG_NCYCLE                          = 0x40
	OPFLG_OUT2                            = 0x10
	OPFLG_OUT3                            = 0x20
	OP_Abortable                          = 186
	OP_Add                                = 106
	OP_AddImm                             = 86
	OP_Affinity                           = 96
	OP_AggFinal                           = 165
	OP_AggInverse                         = 161
	OP_AggStep                            = 162
	OP_AggStep1                           = 163
	OP_AggValue                           = 164
	OP_And                                = 44
	OP_AutoCommit                         = 1
	OP_BeginSubrtn                        = 74
	OP_BitAnd                             = 102
	OP_BitNot                             = 114
	OP_BitOr                              = 103
	OP_Blob                               = 77
	OP_Cast                               = 88
	OP_Checkpoint                         = 3
	OP_Clear                              = 145
	OP_Close                              = 122
	OP_ClrSubtype                         = 179
	OP_CollSeq                            = 85
	OP_Column                             = 94
	OP_ColumnsUsed                        = 123
	OP_Compare                            = 90
	OP_Concat                             = 111
	OP_Copy                               = 80
	OP_Count                              = 98
	OP_CreateBtree                        = 147
	OP_CursorHint                         = 182
	OP_CursorLock                         = 167
	OP_CursorUnlock                       = 168
	OP_DecrJumpZero                       = 61
	OP_DeferredSeek                       = 141
	OP_Delete                             = 130
	OP_Destroy                            = 144
	OP_Divide                             = 109
	OP_DropIndex                          = 152
	OP_DropTable                          = 151
	OP_DropTrigger                        = 154
	OP_ElseEq                             = 58
	OP_EndCoroutine                       = 68
	OP_Eq                                 = 53
	OP_Expire                             = 166
	OP_Explain                            = 185
	OP_Filter                             = 64
	OP_FilterAdd                          = 180
	OP_FinishSeek                         = 143
	OP_FkCheck                            = 83
	OP_FkCounter                          = 158
	OP_FkIfZero                           = 49
	OP_Found                              = 29
	OP_Function                           = 66
	OP_Ge                                 = 57
	OP_Gosub                              = 10
	OP_Goto                               = 9
	OP_Gt                                 = 54
	OP_Halt                               = 70
	OP_HaltIfNull                         = 69
	OP_IdxDelete                          = 140
	OP_IdxGE                              = 45
	OP_IdxGT                              = 41
	OP_IdxInsert                          = 138
	OP_IdxLE                              = 40
	OP_IdxLT                              = 42
	OP_IdxRowid                           = 142
	OP_If                                 = 16
	OP_IfNoHope                           = 26
	OP_IfNot                              = 17
	OP_IfNotOpen                          = 25
	OP_IfNotZero                          = 60
	OP_IfNullRow                          = 20
	OP_IfPos                              = 59
	OP_IfSmaller                          = 33
	OP_IncrVacuum                         = 62
	OP_Init                               = 8
	OP_InitCoroutine                      = 11
	OP_Insert                             = 128
	OP_Int64                              = 72
	OP_IntCopy                            = 82
	OP_Integer                            = 71
	OP_IntegrityCk                        = 155
	OP_IsNull                             = 50
	OP_IsTrue                             = 91
	OP_IsType                             = 18
	OP_JournalMode                        = 4
	OP_Jump                               = 14
	OP_Last                               = 32
	OP_Le                                 = 55
	OP_LoadAnalysis                       = 150
	OP_Lt                                 = 56
	OP_MakeRecord                         = 97
	OP_MaxPgcnt                           = 178
	OP_MemMax                             = 159
	OP_Move                               = 79
	OP_Multiply                           = 108
	OP_MustBeInt                          = 13
	OP_Ne                                 = 52
	OP_NewRowid                           = 127
	OP_Next                               = 39
	OP_NoConflict                         = 27
	OP_Noop                               = 184
	OP_Not                                = 19
	OP_NotExists                          = 31
	OP_NotFound                           = 28
	OP_NotNull                            = 51
	OP_Null                               = 75
	OP_NullRow                            = 136
	OP_Offset                             = 93
	OP_OffsetLimit                        = 160
	OP_Once                               = 15
	OP_OpenAutoindex                      = 116
	OP_OpenDup                            = 115
	OP_OpenEphemeral                      = 118
	OP_OpenPseudo                         = 121
	OP_OpenRead                           = 112
	OP_OpenWrite                          = 113
	OP_Or                                 = 43
	OP_Pagecount                          = 177
	OP_Param                              = 157
	OP_ParseSchema                        = 149
	OP_Permutation                        = 89
	OP_Prev                               = 38
	OP_Program                            = 48
	OP_PureFunc                           = 65
	OP_ReadCookie                         = 99
	OP_Real                               = 153
	OP_RealAffinity                       = 87
	OP_ReleaseReg                         = 183
	OP_Remainder                          = 110
	OP_ReopenIdx                          = 101
	OP_ResetCount                         = 131
	OP_ResetSorter                        = 146
	OP_ResultRow                          = 84
	OP_Return                             = 67
	OP_Rewind                             = 36
	OP_RowCell                            = 129
	OP_RowData                            = 134
	OP_RowSetAdd                          = 156
	OP_RowSetRead                         = 46
	OP_RowSetTest                         = 47
	OP_Rowid                              = 135
	OP_SCopy                              = 81
	OP_Savepoint                          = 0
	OP_SeekEnd                            = 137
	OP_SeekGE                             = 23
	OP_SeekGT                             = 24
	OP_SeekHit                            = 125
	OP_SeekLE                             = 22
	OP_SeekLT                             = 21
	OP_SeekRowid                          = 30
	OP_SeekScan                           = 124
	OP_Sequence                           = 126
	OP_SequenceTest                       = 120
	OP_SetCookie                          = 100
	OP_ShiftLeft                          = 104
	OP_ShiftRight                         = 105
	OP_SoftNull                           = 76
	OP_Sort                               = 35
	OP_SorterCompare                      = 132
	OP_SorterData                         = 133
	OP_SorterInsert                       = 139
	OP_SorterNext                         = 37
	OP_SorterOpen                         = 119
	OP_SorterSort                         = 34
	OP_SqlExec                            = 148
	OP_String                             = 73
	OP_String8                            = 117
	OP_Subtract                           = 107
	OP_TableLock                          = 169
	OP_Trace                              = 181
	OP_Transaction                        = 2
	OP_TypeCheck                          = 95
	OP_VBegin                             = 170
	OP_VColumn                            = 175
	OP_VCreate                            = 171
	OP_VDestroy                           = 172
	OP_VFilter                            = 6
	OP_VInitIn                            = 174
	OP_VNext                              = 63
	OP_VOpen                              = 173
	OP_VRename                            = 176
	OP_VUpdate                            = 7
	OP_Vacuum                             = 5
	OP_Variable                           = 78
	OP_Yield                              = 12
	OP_ZeroOrNull                         = 92
	OS_VXWORKS                            = 0
	P4_COLLSEQ                            = -2
	P4_DYNAMIC                            = -6
	P4_EXPR                               = -9
	P4_FREE_IF_LE                         = -6
	P4_FUNCCTX                            = -15
	P4_FUNCDEF                            = -7
	P4_INT32                              = -3
	P4_INT64                              = -13
	P4_INTARRAY                           = -14
	P4_KEYINFO                            = -8
	P4_MEM                                = -10
	P4_NOTUSED                            = 0
	P4_REAL                               = -12
	P4_STATIC                             = -1
	P4_SUBPROGRAM                         = -4
	P4_TABLE                              = -5
	P4_TRANSIENT                          = 0
	P4_VTAB                               = -11
	P5_ConstraintCheck                    = 3
	P5_ConstraintFK                       = 4
	P5_ConstraintNotNull                  = 1
	P5_ConstraintUnique                   = 2
	PACKAGE_BUGREPORT                     = ""
	PACKAGE_NAME                          = "sqlite"
	PACKAGE_STRING                        = "sqlite 3.41.2"
	PACKAGE_TARNAME                       = "sqlite"
	PACKAGE_URL                           = ""
	PACKAGE_VERSION                       = "3.41.2"
	PAGER_CACHESPILL                      = 0x20
	PAGER_CKPT_FULLFSYNC                  = 0x10
	PAGER_FLAGS_MASK                      = 0x38
	PAGER_FULLFSYNC                       = 0x08
	PAGER_GET_NOCONTENT                   = 0x01
	PAGER_GET_READONLY                    = 0x02
	PAGER_JOURNALMODE_DELETE              = 0
	PAGER_JOURNALMODE_MEMORY              = 4
	PAGER_JOURNALMODE_OFF                 = 2
	PAGER_JOURNALMODE_PERSIST             = 1
	PAGER_JOURNALMODE_QUERY               = -1
	PAGER_JOURNALMODE_TRUNCATE            = 3
	PAGER_JOURNALMODE_WAL                 = 5
	PAGER_LOCKINGMODE_EXCLUSIVE           = 1
	PAGER_LOCKINGMODE_NORMAL              = 0
	PAGER_LOCKINGMODE_QUERY               = -1
	PAGER_MEMORY                          = 0x0002
	PAGER_OMIT_JOURNAL                    = 0x0001
	PAGER_SYNCHRONOUS_EXTRA               = 0x04
	PAGER_SYNCHRONOUS_FULL                = 0x03
	PAGER_SYNCHRONOUS_MASK                = 0x07
	PAGER_SYNCHRONOUS_NORMAL              = 0x02
	PAGER_SYNCHRONOUS_OFF                 = 0x01
	PARSE_MODE_DECLARE_VTAB               = 1
	PARSE_MODE_NORMAL                     = 0
	PARSE_MODE_RENAME                     = 2
	PARSE_MODE_UNMAP                      = 3
	PENDING_LOCK                          = 3
	PGHDR_CLEAN                           = 0x001
	PGHDR_DIRTY                           = 0x002
	PGHDR_DONT_WRITE                      = 0x010
	PGHDR_MMAP                            = 0x020
	PGHDR_NEED_SYNC                       = 0x008
	PGHDR_WAL_APPEND                      = 0x040
	PGHDR_WRITEABLE                       = 0x004
	PREFERRED_SCHEMA_TABLE                = "sqlite_schema"
	PREFERRED_TEMP_SCHEMA_TABLE           = "sqlite_temp_schema"
	PRIX16                                = "X"
	PRIX32                                = "X"
	PRIX8                                 = "X"
	PRIXFAST16                            = "X"
	PRIXFAST32                            = "X"
	PRIXFAST8                             = "X"
	PRIXLEAST16                           = "X"
	PRIXLEAST32                           = "X"
	PRIXLEAST8                            = "X"
	PRIXMAX                               = "jX"
	PRId16                                = "d"
	PRId32                                = "d"
	PRId8                                 = "d"
	PRIdFAST16                            = "d"
	PRIdFAST32                            = "d"
	PRIdFAST8                             = "d"
	PRIdLEAST16                           = "d"
	PRIdLEAST32                           = "d"
	PRIdLEAST8                            = "d"
	PRIdMAX                               = "jd"
	PRIi16                                = "i"
	PRIi32                                = "i"
	PRIi8                                 = "i"
	PRIiFAST16                            = "i"
	PRIiFAST32                            = "i"
	PRIiFAST8                             = "i"
	PRIiLEAST16                           = "i"
	PRIiLEAST32                           = "i"
	PRIiLEAST8                            = "i"
	PRIiMAX                               = "ji"
	PRIo16                                = "o"
	PRIo32                                = "o"
	PRIo8                                 = "o"
	PRIoFAST16                            = "o"
	PRIoFAST32                            = "o"
	PRIoFAST8                             = "o"
	PRIoLEAST16                           = "o"
	PRIoLEAST32                           = "o"
	PRIoLEAST8                            = "o"
	PRIoMAX                               = "jo"
	PRIu16                                = "u"
	PRIu32                                = "u"
	PRIu8                                 = "u"
	PRIuFAST16                            = "u"
	PRIuFAST32                            = "u"
	PRIuFAST8                             = "u"
	PRIuLEAST16                           = "u"
	PRIuLEAST32                           = "u"
	PRIuLEAST8                            = "u"
	PRIuMAX                               = "ju"
	PRIx16                                = "x"
	PRIx32                                = "x"
	PRIx8                                 = "x"
	PRIxFAST16                            = "x"
	PRIxFAST32                            = "x"
	PRIxFAST8                             = "x"
	PRIxLEAST16                           = "x"
	PRIxLEAST32                           = "x"
	PRIxLEAST8                            = "x"
	PRIxMAX                               = "jx"
	PTRDIFF_MAX                           = 2147483647
	PTRDIFF_MIN                           = -2147483648
	RESERVED_LOCK                         = 2
	RSIZE_MAX                             = 2147483647
	SAVEPOINT_BEGIN                       = 0
	SAVEPOINT_RELEASE                     = 1
	SAVEPOINT_ROLLBACK                    = 2
	SCHEMA_ROOT                           = 1
	SCNd16                                = "hd"
	SCNd32                                = "d"
	SCNd8                                 = "hhd"
	SCNdFAST16                            = "d"
	SCNdFAST32                            = "d"
	SCNdFAST8                             = "d"
	SCNdLEAST16                           = "hd"
	SCNdLEAST32                           = "d"
	SCNdLEAST8                            = "hhd"
	SCNdMAX                               = "jd"
	SCNi16                                = "hi"
	SCNi32                                = "i"
	SCNi8                                 = "hhi"
	SCNiFAST16                            = "i"
	SCNiFAST32                            = "i"
	SCNiFAST8                             = "i"
	SCNiLEAST16                           = "hi"
	SCNiLEAST32                           = "i"
	SCNiLEAST8                            = "hhi"
	SCNiMAX                               = "ji"
	SCNo16                                = "ho"
	SCNo32                                = "o"
	SCNo8                                 = "hho"
	SCNoFAST16                            = "o"
	SCNoFAST32                            = "o"
	SCNoFAST8                             = "o"
	SCNoLEAST16                           = "ho"
	SCNoLEAST32                           = "o"
	SCNoLEAST8                            = "hho"
	SCNoMAX                               = "jo"
	SCNu16                                = "hu"
	SCNu32                                = "u"
	SCNu8                                 = "hhu"
	SCNuFAST16                            = "u"
	SCNuFAST32                            = "u"
	SCNuFAST8                             = "u"
	SCNuLEAST16                           = "hu"
	SCNuLEAST32                           = "u"
	SCNuLEAST8                            = "hhu"
	SCNuMAX                               = "ju"
	SCNx16                                = "hx"
	SCNx32                                = "x"
	SCNx8                                 = "hhx"
	SCNxFAST16                            = "x"
	SCNxFAST32                            = "x"
	SCNxFAST8                             = "x"
	SCNxLEAST16                           = "hx"
	SCNxLEAST32                           = "x"
	SCNxLEAST8                            = "hhx"
	SCNxMAX                               = "jx"
	SF_Aggregate                          = 0x0000008
	SF_All                                = 0x0000002
	SF_ComplexResult                      = 0x0040000
	SF_Compound                           = 0x0000100
	SF_Converted                          = 0x0010000
	SF_CopyCte                            = 0x4000000
	SF_Distinct                           = 0x0000001
	SF_Expanded                           = 0x0000040
	SF_FixedLimit                         = 0x0004000
	SF_HasAgg                             = 0x0000010
	SF_HasTypeInfo                        = 0x0000080
	SF_IncludeHidden                      = 0x0020000
	SF_MaybeConvert                       = 0x0008000
	SF_MinMaxAgg                          = 0x0001000
	SF_MultiPart                          = 0x2000000
	SF_MultiValue                         = 0x0000400
	SF_NestedFrom                         = 0x0000800
	SF_NoopOrderBy                        = 0x0400000
	SF_OrderByReqd                        = 0x8000000
	SF_PushDown                           = 0x1000000
	SF_Recursive                          = 0x0002000
	SF_Resolved                           = 0x0000004
	SF_UFSrcCheck                         = 0x0800000
	SF_UpdateFrom                         = 0x10000000
	SF_UsesEphemeral                      = 0x0000020
	SF_Values                             = 0x0000200
	SF_View                               = 0x0200000
	SF_WhereBegin                         = 0x0080000
	SF_WinRewrite                         = 0x0100000
	SHARED_LOCK                           = 1
	SHARED_SIZE                           = 510
	SIG_ATOMIC_MAX                        = 2147483647
	SIG_ATOMIC_MIN                        = -2147483648
	SIZE_MAX                              = 4294967295
	SQLITECONFIG_H                        = 1
	SQLITEINT_H                           = 0
	SQLITE_AFF_BLOB                       = 0x41
	SQLITE_AFF_FLEXNUM                    = 0x46
	SQLITE_AFF_INTEGER                    = 0x44
	SQLITE_AFF_MASK                       = 0x47
	SQLITE_AFF_NONE                       = 0x40
	SQLITE_AFF_NUMERIC                    = 0x43
	SQLITE_AFF_REAL                       = 0x45
	SQLITE_AFF_TEXT                       = 0x42
	SQLITE_ASCII                          = 1
	SQLITE_ATOMIC_INTRINSICS              = 0
	SQLITE_AllOpts                        = 0xffffffff
	SQLITE_AutoIndex                      = 0x00008000
	SQLITE_BIGENDIAN                      = 0
	SQLITE_BTREE_H                        = 0
	SQLITE_BYTEORDER                      = 1234
	SQLITE_BalancedMerge                  = 0x00200000
	SQLITE_BloomFilter                    = 0x00080000
	SQLITE_BloomPulldown                  = 0x00100000
	SQLITE_CacheSpill                     = 0x00000020
	SQLITE_CellSizeCk                     = 0x00200000
	SQLITE_CkptFullFSync                  = 0x00000010
	SQLITE_Coroutines                     = 0x02000000
	SQLITE_CountOfView                    = 0x00000200
	SQLITE_CoverIdxScan                   = 0x00000020
	SQLITE_CursorHints                    = 0x00000400
	SQLITE_DEFAULT_AUTOVACUUM             = 0
	SQLITE_DEFAULT_CACHE_SIZE             = -2000
	SQLITE_DEFAULT_FILE_FORMAT            = 4
	SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT     = -1
	SQLITE_DEFAULT_MMAP_SIZE              = 0
	SQLITE_DEFAULT_PCACHE_INITSZ          = 20
	SQLITE_DEFAULT_RECURSIVE_TRIGGERS     = 0
	SQLITE_DEFAULT_SECTOR_SIZE            = 4096
	SQLITE_DEFAULT_SORTERREF_SIZE         = 0x7fffffff
	SQLITE_DEFAULT_SYNCHRONOUS            = 2
	SQLITE_DEFAULT_WAL_AUTOCHECKPOINT     = 1000
	SQLITE_DEFAULT_WAL_SYNCHRONOUS        = 2
	SQLITE_DEFAULT_WORKER_THREADS         = 0
	SQLITE_Defensive                      = 0x10000000
	SQLITE_DeferFKs                       = 0x00080000
	SQLITE_DistinctOpt                    = 0x00000010
	SQLITE_DqsDDL                         = 0x20000000
	SQLITE_DqsDML                         = 0x40000000
	SQLITE_ECEL_DUP                       = 0x01
	SQLITE_ECEL_FACTOR                    = 0x02
	SQLITE_ECEL_OMITREF                   = 0x08
	SQLITE_ECEL_REF                       = 0x04
	SQLITE_EnableQPSG                     = 0x00800000
	SQLITE_EnableTrigger                  = 0x00040000
	SQLITE_EnableView                     = 0x80000000
	SQLITE_FAULTINJECTOR_COUNT            = 1
	SQLITE_FAULTINJECTOR_MALLOC           = 0
	SQLITE_FCNTL_DB_UNCHANGED             = 0xca093fa0
	SQLITE_FUNC_ANYORDER                  = 0x08000000
	SQLITE_FUNC_BUILTIN                   = 0x00800000
	SQLITE_FUNC_CASE                      = 0x0008
	SQLITE_FUNC_CONSTANT                  = 0x0800
	SQLITE_FUNC_COUNT                     = 0x0100
	SQLITE_FUNC_DIRECT                    = 0x00080000
	SQLITE_FUNC_ENCMASK                   = 0x0003
	SQLITE_FUNC_EPHEM                     = 0x0010
	SQLITE_FUNC_HASH_SZ                   = 23
	SQLITE_FUNC_INLINE                    = 0x00400000
	SQLITE_FUNC_INTERNAL                  = 0x00040000
	SQLITE_FUNC_LENGTH                    = 0x0040
	SQLITE_FUNC_LIKE                      = 0x0004
	SQLITE_FUNC_MINMAX                    = 0x1000
	SQLITE_FUNC_NEEDCOLL                  = 0x0020
	SQLITE_FUNC_SLOCHNG                   = 0x2000
	SQLITE_FUNC_SUBTYPE                   = 0x00100000
	SQLITE_FUNC_TEST                      = 0x4000
	SQLITE_FUNC_TYPEOF                    = 0x0080
	SQLITE_FUNC_UNLIKELY                  = 0x0400
	SQLITE_FUNC_UNSAFE                    = 0x00200000
	SQLITE_FUNC_WINDOW                    = 0x00010000
	SQLITE_FactorOutConst                 = 0x00000008
	SQLITE_FlttnUnionAll                  = 0x00800000
	SQLITE_ForeignKeys                    = 0x00004000
	SQLITE_Fts3Tokenizer                  = 0x00400000
	SQLITE_FullColNames                   = 0x00000004
	SQLITE_FullFSync                      = 0x00000008
	SQLITE_GroupByOrder                   = 0x00000004
	SQLITE_HASH_H                         = 0
	SQLITE_HAVE_C99_MATH_FUNCS            = 1
	SQLITE_HAVE_OS_TRACE                  = 0
	SQLITE_IDXTYPE_APPDEF                 = 0
	SQLITE_IDXTYPE_IPK                    = 3
	SQLITE_IDXTYPE_PRIMARYKEY             = 2
	SQLITE_IDXTYPE_UNIQUE                 = 1
	SQLITE_IOERR_NOMEM_BKPT               = 3082
	SQLITE_IgnoreChecks                   = 0x00000200
	SQLITE_IndexedExpr                    = 0x01000000
	SQLITE_JUMPIFNULL                     = 0x10
	SQLITE_LITTLEENDIAN                   = 1
	SQLITE_LegacyAlter                    = 0x04000000
	SQLITE_LegacyFileFmt                  = 0x00000002
	SQLITE_LoadExtFunc                    = 0x00020000
	SQLITE_LoadExtension                  = 0x00010000
	SQLITE_MALLOC_SOFT_LIMIT              = 1024
	SQLITE_MAX_ATTACHED                   = 10
	SQLITE_MAX_COLUMN                     = 2000
	SQLITE_MAX_COMPOUND_SELECT            = 500
	SQLITE_MAX_DB                         = 12
	SQLITE_MAX_DEFAULT_PAGE_SIZE          = 8192
	SQLITE_MAX_EXPR_DEPTH                 = 1000
	SQLITE_MAX_FILE_FORMAT                = 4
	SQLITE_MAX_FUNCTION_ARG               = 127
	SQLITE_MAX_LENGTH                     = 1000000000
	SQLITE_MAX_LIKE_PATTERN_LENGTH        = 50000
	SQLITE_MAX_MMAP_SIZE                  = 0x7fff0000
	SQLITE_MAX_PAGE_COUNT                 = 1073741823
	SQLITE_MAX_PAGE_SIZE                  = 65536
	SQLITE_MAX_PATHLEN                    = 1024
	SQLITE_MAX_SQL_LENGTH                 = 1000000000
	SQLITE_MAX_SYMLINK                    = 200
	SQLITE_MAX_TRIGGER_DEPTH              = 1000
	SQLITE_MAX_VARIABLE_NUMBER            = 32766
	SQLITE_MAX_VDBE_OP                    = 250000000
	SQLITE_MAX_WORKER_THREADS             = 8
	SQLITE_MSVC_H                         = 0
	SQLITE_MUTEX_STATIC_TEMPDIR           = 11
	SQLITE_MX_JUMP_OPCODE                 = 64
	SQLITE_MinMaxOpt                      = 0x00010000
	SQLITE_NEED_ERR_NAME                  = 0
	SQLITE_NOMEM_BKPT                     = 7
	SQLITE_NOTNULL                        = 0x90
	SQLITE_NTUNE                          = 6
	SQLITE_NULLEQ                         = 0x80
	SQLITE_N_BTREE_META                   = 16
	SQLITE_N_LIMIT                        = 12
	SQLITE_N_STDTYPE                      = 6
	SQLITE_NoCkptOnClose                  = 0x00000800
	SQLITE_NoSchemaError                  = 0x08000000
	SQLITE_NullCallback                   = 0x00000100
	SQLITE_OS_KV                          = 0
	SQLITE_OS_OTHER                       = 0
	SQLITE_OS_SETUP_H                     = 0
	SQLITE_OS_UNIX                        = 1
	SQLITE_OS_WIN                         = 0
	SQLITE_OmitNoopJoin                   = 0x00000100
	SQLITE_OmitOrderBy                    = 0x00040000
	SQLITE_OrderByIdxJoin                 = 0x00000040
	SQLITE_PAGER_H                        = 0
	SQLITE_POWERSAFE_OVERWRITE            = 1
	SQLITE_PREPARE_MASK                   = 0x0f
	SQLITE_PREPARE_SAVESQL                = 0x80
	SQLITE_PRINTF_INTERNAL                = 0x01
	SQLITE_PRINTF_MALLOCED                = 0x04
	SQLITE_PRINTF_SQLFUNC                 = 0x02
	SQLITE_PTRSIZE                        = 4
	SQLITE_PropagateConst                 = 0x00008000
	SQLITE_PushDown                       = 0x00001000
	SQLITE_QueryFlattener                 = 0x00000001
	SQLITE_QueryOnly                      = 0x00100000
	SQLITE_ReadUncommit                   = 0x00000400
	SQLITE_RecTriggers                    = 0x00002000
	SQLITE_ReleaseReg                     = 0x00400000
	SQLITE_ResetDatabase                  = 0x02000000
	SQLITE_ReverseOrder                   = 0x00001000
	SQLITE_SO_ASC                         = 0
	SQLITE_SO_DESC                        = 1
	SQLITE_SO_UNDEFINED                   = -1
	SQLITE_STATE_BUSY                     = 0x6d
	SQLITE_STATE_CLOSED                   = 0xce
	SQLITE_STATE_ERROR                    = 0xd5
	SQLITE_STATE_OPEN                     = 0x76
	SQLITE_STATE_SICK                     = 0xba
	SQLITE_STATE_ZOMBIE                   = 0xa7
	SQLITE_SYSTEM_MALLOC                  = 1
	SQLITE_SeekScan                       = 0x00020000
	SQLITE_ShortColNames                  = 0x00000040
	SQLITE_SimplifyJoin                   = 0x00002000
	SQLITE_SkipScan                       = 0x00004000
	SQLITE_Stat4                          = 0x00000800
	SQLITE_TEMP_FILE_PREFIX               = "etilqs_"
	SQLITE_TOKEN_KEYWORD                  = 0x2
	SQLITE_TOKEN_QUOTED                   = 0x1
	SQLITE_TRACE_LEGACY                   = 0x40
	SQLITE_TRACE_NONLEGACY_MASK           = 0x0f
	SQLITE_TRACE_XPROFILE                 = 0x80
	SQLITE_Transitive                     = 0x00000080
	SQLITE_TriggerEQP                     = 0x01000000
	SQLITE_TrustedSchema                  = 0x00000080
	SQLITE_UTF16NATIVE                    = 2
	SQLITE_VDBE_H                         = 0
	SQLITE_VTABRISK_High                  = 2
	SQLITE_VTABRISK_Low                   = 0
	SQLITE_VTABRISK_Normal                = 1
	SQLITE_WSD                            = 0
	SQLITE_WindowFunc                     = 0x00000002
	SQLITE_WriteSchema                    = 0x00000001
	SRT_Coroutine                         = 13
	SRT_Discard                           = 4
	SRT_DistFifo                          = 5
	SRT_DistQueue                         = 6
	SRT_EphemTab                          = 12
	SRT_Except                            = 2
	SRT_Exists                            = 3
	SRT_Fifo                              = 8
	SRT_Mem                               = 10
	SRT_Output                            = 9
	SRT_Queue                             = 7
	SRT_Set                               = 11
	SRT_Table                             = 14
	SRT_Union                             = 1
	SRT_Upfrom                            = 15
	STDC_HEADERS                          = 1
	TABTYP_NORM                           = 0
	TABTYP_VIEW                           = 2
	TABTYP_VTAB                           = 1
	TF_Autoincrement                      = 0x00000008
	TF_Ephemeral                          = 0x00004000
	TF_Eponymous                          = 0x00008000
	TF_HasGenerated                       = 0x00000060
	TF_HasHidden                          = 0x00000002
	TF_HasNotNull                         = 0x00000800
	TF_HasPrimaryKey                      = 0x00000004
	TF_HasStat1                           = 0x00000010
	TF_HasStat4                           = 0x00002000
	TF_HasStored                          = 0x00000040
	TF_HasVirtual                         = 0x00000020
	TF_NoVisibleRowid                     = 0x00000200
	TF_OOOHidden                          = 0x00000400
	TF_Readonly                           = 0x00000001
	TF_Shadow                             = 0x00001000
	TF_StatsUsed                          = 0x00000100
	TF_Strict                             = 0x00010000
	TF_WithoutRowid                       = 0x00000080
	TK_ABORT                              = 27
	TK_ACTION                             = 28
	TK_ADD                                = 163
	TK_AFTER                              = 29
	TK_AGG_COLUMN                         = 169
	TK_AGG_FUNCTION                       = 168
	TK_ALL                                = 135
	TK_ALTER                              = 162
	TK_ALWAYS                             = 96
	TK_ANALYZE                            = 30
	TK_AND                                = 44
	TK_ANY                                = 101
	TK_AS                                 = 24
	TK_ASC                                = 31
	TK_ASTERISK                           = 180
	TK_ATTACH                             = 32
	TK_AUTOINCR                           = 126
	TK_BEFORE                             = 33
	TK_BEGIN                              = 5
	TK_BETWEEN                            = 48
	TK_BY                                 = 34
	TK_CASCADE                            = 35
	TK_CASE                               = 157
	TK_CAST                               = 36
	TK_CHECK                              = 124
	TK_COLLATE                            = 113
	TK_COLUMN                             = 167
	TK_COLUMNKW                           = 60
	TK_COMMIT                             = 10
	TK_CONFLICT                           = 37
	TK_CONSTRAINT                         = 119
	TK_CREATE                             = 17
	TK_CTIME_KW                           = 100
	TK_CURRENT                            = 85
	TK_DATABASE                           = 38
	TK_DEFAULT                            = 120
	TK_DEFERRABLE                         = 131
	TK_DEFERRED                           = 7
	TK_DELETE                             = 128
	TK_DESC                               = 39
	TK_DETACH                             = 40
	TK_DISTINCT                           = 140
	TK_DO                                 = 61
	TK_DROP                               = 133
	TK_EACH                               = 41
	TK_ELSE                               = 160
	TK_END                                = 11
	TK_ESCAPE                             = 58
	TK_EXCEPT                             = 136
	TK_EXCLUDE                            = 91
	TK_EXCLUSIVE                          = 9
	TK_EXISTS                             = 20
	TK_EXPLAIN                            = 2
	TK_FAIL                               = 42
	TK_FILTER                             = 166
	TK_FIRST                              = 83
	TK_FOLLOWING                          = 86
	TK_FOR                                = 62
	TK_FOREIGN                            = 132
	TK_FROM                               = 142
	TK_FUNCTION                           = 172
	TK_GENERATED                          = 95
	TK_GROUP                              = 146
	TK_GROUPS                             = 92
	TK_HAVING                             = 147
	TK_IF                                 = 18
	TK_IF_NULL_ROW                        = 179
	TK_IGNORE                             = 63
	TK_IMMEDIATE                          = 8
	TK_IN                                 = 49
	TK_INDEX                              = 161
	TK_INDEXED                            = 116
	TK_INITIALLY                          = 64
	TK_INSERT                             = 127
	TK_INSTEAD                            = 65
	TK_INTERSECT                          = 137
	TK_INTO                               = 151
	TK_IS                                 = 45
	TK_ISNOT                              = 171
	TK_ISNULL                             = 50
	TK_JOIN                               = 143
	TK_JOIN_KW                            = 118
	TK_KEY                                = 67
	TK_LAST                               = 84
	TK_LIKE_KW                            = 47
	TK_LIMIT                              = 148
	TK_MATCH                              = 46
	TK_MATERIALIZED                       = 97
	TK_NO                                 = 66
	TK_NOT                                = 19
	TK_NOTHING                            = 152
	TK_NOTNULL                            = 51
	TK_NULL                               = 121
	TK_NULLS                              = 82
	TK_OF                                 = 68
	TK_OFFSET                             = 69
	TK_ON                                 = 115
	TK_OR                                 = 43
	TK_ORDER                              = 145
	TK_OTHERS                             = 93
	TK_OVER                               = 165
	TK_PARTITION                          = 87
	TK_PLAN                               = 4
	TK_PRAGMA                             = 70
	TK_PRECEDING                          = 88
	TK_PRIMARY                            = 122
	TK_PTR                                = 112
	TK_QUERY                              = 3
	TK_RAISE                              = 71
	TK_RANGE                              = 89
	TK_RECURSIVE                          = 72
	TK_REFERENCES                         = 125
	TK_REGISTER                           = 176
	TK_REINDEX                            = 98
	TK_RELEASE                            = 14
	TK_RENAME                             = 99
	TK_REPLACE                            = 73
	TK_RESTRICT                           = 74
	TK_RETURNING                          = 150
	TK_ROLLBACK                           = 12
	TK_ROW                                = 75
	TK_ROWS                               = 76
	TK_SAVEPOINT                          = 13
	TK_SELECT                             = 138
	TK_SELECT_COLUMN                      = 178
	TK_SET                                = 130
	TK_SPAN                               = 181
	TK_TABLE                              = 16
	TK_TEMP                               = 21
	TK_THEN                               = 159
	TK_TIES                               = 94
	TK_TO                                 = 15
	TK_TRANSACTION                        = 6
	TK_TRIGGER                            = 77
	TK_TRUEFALSE                          = 170
	TK_TRUTH                              = 175
	TK_UMINUS                             = 173
	TK_UNBOUNDED                          = 90
	TK_UNION                              = 134
	TK_UNIQUE                             = 123
	TK_UPDATE                             = 129
	TK_UPLUS                              = 174
	TK_USING                              = 144
	TK_VACUUM                             = 78
	TK_VALUES                             = 139
	TK_VECTOR                             = 177
	TK_VIEW                               = 79
	TK_VIRTUAL                            = 80
	TK_WHEN                               = 158
	TK_WHERE                              = 149
	TK_WINDOW                             = 164
	TK_WITH                               = 81
	TK_WITHOUT                            = 26
	TREETRACE_ENABLED                     = 0
	TRIGGER_AFTER                         = 2
	TRIGGER_BEFORE                        = 1
	UINT16_MAX                            = 0xffff
	UINT32_MAX                            = 0xffffffff
	UINT64_MAX                            = 0xffffffffffffffff
	UINT8_MAX                             = 0xff
	UINTMAX_MAX                           = 18446744073709551615
	UINTPTR_MAX                           = 4294967295
	UINT_FAST16_MAX                       = 4294967295
	UINT_FAST32_MAX                       = 4294967295
	UINT_FAST64_MAX                       = 18446744073709551615
	UINT_FAST8_MAX                        = 4294967295
	UINT_LEAST16_MAX                      = 65535
	UINT_LEAST32_MAX                      = 4294967295
	UINT_LEAST64_MAX                      = 18446744073709551615
	UINT_LEAST8_MAX                       = 255
	WCHAR_MAX                             = 2147483647
	WCHAR_MIN                             = -2147483648
	WHERE_AGG_DISTINCT                    = 0x0400
	WHERE_DISTINCTBY                      = 0x0080
	WHERE_DISTINCT_NOOP                   = 0
	WHERE_DISTINCT_ORDERED                = 2
	WHERE_DISTINCT_UNIQUE                 = 1
	WHERE_DISTINCT_UNORDERED              = 3
	WHERE_DUPLICATES_OK                   = 0x0010
	WHERE_GROUPBY                         = 0x0040
	WHERE_ONEPASS_DESIRED                 = 0x0004
	WHERE_ONEPASS_MULTIROW                = 0x0008
	WHERE_ORDERBY_LIMIT                   = 0x0800
	WHERE_ORDERBY_MAX                     = 0x0002
	WHERE_ORDERBY_MIN                     = 0x0001
	WHERE_ORDERBY_NORMAL                  = 0x0000
	WHERE_OR_SUBCLAUSE                    = 0x0020
	WHERE_RIGHT_JOIN                      = 0x1000
	WHERE_SORTBYGROUP                     = 0x0200
	WHERE_USE_LIMIT                       = 0x4000
	WHERE_WANT_DISTINCT                   = 0x0100
	WINT_MAX                              = 2147483647
	WINT_MIN                              = -2147483648
	WRC_Abort                             = 2
	WRC_Continue                          = 0
	WRC_Prune                             = 1
	XN_EXPR                               = -2
	XN_ROWID                              = -1
	X_DARWIN_USE_64_BIT_INODE             = 1
	X_GCC_MAX_ALIGN_T                     = 0
	X_GNU_SOURCE                          = 0
	X_INTTYPES_H_                         = 0
	X_LARGEFILE_SOURCE                    = 1
	X_LARGE_FILE                          = 1
	X_MACHINE_INTTYPES_H_                 = 0
	X_MACHINE__STDINT_H_                  = 0
	X_PTRDIFF_T_DECLARED                  = 0
	X_SQLITE_OS_H_                        = 0
	X_STDDEF_H_                           = 0
	X_SYS_STDINT_H_                       = 0
	X_XOPEN_SOURCE                        = 600
	SESSION_STREAM_TCL_VAR                = "sqlite3session_streams"
	BUS_ADRALN                            = 1
	BUS_ADRERR                            = 2
	BUS_OBJERR                            = 3
	BUS_OOMERR                            = 100
	CLD_CONTINUED                         = 6
	CLD_DUMPED                            = 3
	CLD_EXITED                            = 1
	CLD_KILLED                            = 2
	CLD_STOPPED                           = 5
	CLD_TRAPPED                           = 4
	FPE_FLTDIV                            = 3
	FPE_FLTINV                            = 7
	FPE_FLTOVF                            = 4
	FPE_FLTRES                            = 6
	FPE_FLTSUB                            = 8
	FPE_FLTUND                            = 5
	FPE_INTDIV                            = 2
	FPE_INTOVF                            = 1
	ILL_BADSTK                            = 8
	ILL_COPROC                            = 7
	ILL_ILLADR                            = 3
	ILL_ILLOPC                            = 1
	ILL_ILLOPN                            = 2
	ILL_ILLTRP                            = 4
	ILL_PRVOPC                            = 5
	ILL_PRVREG                            = 6
	MAX_PREPARED_STMTS                    = 100
	MINSIGSTKSZ                           = 2048
	NSIG                                  = 32
	NUM_PREPARED_STMTS                    = 10
	POLL_ERR                              = 4
	POLL_HUP                              = 6
	POLL_IN                               = 1
	POLL_MSG                              = 3
	POLL_OUT                              = 2
	POLL_PRI                              = 5
	SA_NOCLDSTOP                          = 0x0008
	SA_NOCLDWAIT                          = 0x0020
	SA_NODEFER                            = 0x0010
	SA_ONSTACK                            = 0x0001
	SA_RESETHAND                          = 0x0004
	SA_RESTART                            = 0x0002
	SA_SIGINFO                            = 0x0040
	SEGV_ACCERR                           = 2
	SEGV_MAPERR                           = 1
	SEGV_PKUERR                           = 100
	SIGABRT                               = 6
	SIGALRM                               = 14
	SIGBUS                                = 10
	SIGCHLD                               = 20
	SIGCONT                               = 19
	SIGEMT                                = 7
	SIGEV_KEVENT                          = 3
	SIGEV_NONE                            = 0
	SIGEV_SIGNAL                          = 1
	SIGEV_THREAD                          = 2
	SIGEV_THREAD_ID                       = 4
	SIGFPE                                = 8
	SIGHUP                                = 1
	SIGILL                                = 4
	SIGINFO                               = 29
	SIGINT                                = 2
	SIGIO                                 = 23
	SIGIOT                                = 6
	SIGKILL                               = 9
	SIGLIBRT                              = 33
	SIGLWP                                = 32
	SIGPIPE                               = 13
	SIGPROF                               = 27
	SIGQUIT                               = 3
	SIGRTMAX                              = 126
	SIGRTMIN                              = 65
	SIGSEGV                               = 11
	SIGSTKSZ                              = 34816
	SIGSTOP                               = 17
	SIGSYS                                = 12
	SIGTERM                               = 15
	SIGTHR                                = 32
	SIGTRAP                               = 5
	SIGTSTP                               = 18
	SIGTTIN                               = 21
	SIGTTOU                               = 22
	SIGURG                                = 16
	SIGUSR1                               = 30
	SIGUSR2                               = 31
	SIGVTALRM                             = 26
	SIGWINCH                              = 28
	SIGXCPU                               = 24
	SIGXFSZ                               = 25
	SIG_BLOCK                             = 1
	SIG_SETMASK                           = 3
	SIG_UNBLOCK                           = 2
	SI_ASYNCIO                            = 0x10004
	SI_KERNEL                             = 0x10006
	SI_LWP                                = 0x10007
	SI_MESGQ                              = 0x10005
	SI_NOINFO                             = 0
	SI_QUEUE                              = 0x10002
	SI_TIMER                              = 0x10003
	SI_UNDEFINED                          = 0
	SI_USER                               = 0x10001
	SQLITE_EVAL_WITHOUTNULLS              = 0x00001
	SQLITE_TCL_NRE                        = 1
	SS_DISABLE                            = 0x0004
	SS_ONSTACK                            = 0x0001
	SV_INTERRUPT                          = 2
	SV_NOCLDSTOP                          = 8
	SV_NODEFER                            = 16
	SV_ONSTACK                            = 1
	SV_RESETHAND                          = 4
	SV_SIGINFO                            = 64
	TCLSH                                 = 1
	TRAP_BRKPT                            = 1
	TRAP_CAP                              = 4
	TRAP_DTRACE                           = 3
	TRAP_TRACE                            = 2
	X_MACHINE_SIGNAL_H_                   = 0
	X_MACHINE_UCONTEXT_H_                 = 0
	X_MC_FLAG_MASK                        = 7
	X_MC_FPFMT_387                        = 0x10001
	X_MC_FPFMT_NODEV                      = 0x10000
	X_MC_FPFMT_XMM                        = 0x10002
	X_MC_FPOWNED_FPU                      = 0x20001
	X_MC_FPOWNED_NONE                     = 0x20000
	X_MC_FPOWNED_PCB                      = 0x20002
	X_MC_HASBASES                         = 0x2
	X_MC_HASFPXSTATE                      = 0x4
	X_MC_HASSEGS                          = 0x1
	X_SIGNAL_H_                           = 0
	X_SYS_SIGNAL_H_                       = 0
	X_SYS__UCONTEXT_H_                    = 0
	X_X86_SIGNAL_H                        = 1
	X_X86_UCONTEXT_H_                     = 0
	CACHE_STALE                           = 0
	CPUSTATES                             = 5
	CP_IDLE                               = 4
	CP_INTR                               = 3
	CP_NICE                               = 1
	CP_SYS                                = 2
	CP_USER                               = 0
	CURTYPE_BTREE                         = 0
	CURTYPE_PSEUDO                        = 3
	CURTYPE_SORTER                        = 1
	CURTYPE_VTAB                          = 2
	MEM_AffMask                           = 0x003f
	MEM_Agg                               = 0x8000
	MEM_Blob                              = 0x0010
	MEM_Cleared                           = 0x0100
	MEM_Dyn                               = 0x1000
	MEM_Ephem                             = 0x4000
	MEM_FromBind                          = 0x0040
	MEM_Int                               = 0x0004
	MEM_IntReal                           = 0x0020
	MEM_Null                              = 0x0001
	MEM_Real                              = 0x0008
	MEM_Static                            = 0x2000
	MEM_Str                               = 0x0002
	MEM_Subtype                           = 0x0800
	MEM_Term                              = 0x0200
	MEM_TypeMask                          = 0x0dbf
	MEM_Undefined                         = 0x0000
	MEM_Zero                              = 0x0400
	PRIO_MAX                              = 20
	PRIO_MIN                              = -20
	PRIO_PGRP                             = 1
	PRIO_PROCESS                          = 0
	PRIO_USER                             = 2
	RLIMIT_AS                             = 10
	RLIMIT_CORE                           = 4
	RLIMIT_CPU                            = 0
	RLIMIT_DATA                           = 2
	RLIMIT_FSIZE                          = 1
	RLIMIT_KQUEUES                        = 13
	RLIMIT_MEMLOCK                        = 6
	RLIMIT_NOFILE                         = 8
	RLIMIT_NPROC                          = 7
	RLIMIT_NPTS                           = 11
	RLIMIT_RSS                            = 5
	RLIMIT_SBSIZE                         = 9
	RLIMIT_STACK                          = 3
	RLIMIT_SWAP                           = 12
	RLIMIT_UMTXP                          = 14
	RLIMIT_VMEM                           = 10
	RLIM_NLIMITS                          = 15
	RUSAGE_CHILDREN                       = -1
	RUSAGE_SELF                           = 0
	RUSAGE_THREAD                         = 1
	SQLITE_ENABLE_LOCKING_STYLE           = 0
	SQLITE_FRAME_MAGIC                    = 0x879fb71e
	SQLITE_MAX_SCHEMA_RETRY               = 50
	SQLITE_VDBEINT_H                      = 0
	VDBE_DISPLAY_P4                       = 1
	VDBE_HALT_STATE                       = 3
	VDBE_INIT_STATE                       = 0
	VDBE_READY_STATE                      = 1
	VDBE_RUN_STATE                        = 2
	X_SYS_RESOURCE_H_                     = 0
	BTCF_AtLast                           = 0x08
	BTCF_Incrblob                         = 0x10
	BTCF_Multiple                         = 0x20
	BTCF_Pinned                           = 0x40
	BTCF_ValidNKey                        = 0x02
	BTCF_ValidOvfl                        = 0x04
	BTCF_WriteFlag                        = 0x01
	BTCURSOR_MAX_DEPTH                    = 20
	BTS_EXCLUSIVE                         = 0x0040
	BTS_FAST_SECURE                       = 0x000c
	BTS_INITIALLY_EMPTY                   = 0x0010
	BTS_NO_WAL                            = 0x0020
	BTS_OVERWRITE                         = 0x0008
	BTS_PAGESIZE_FIXED                    = 0x0002
	BTS_PENDING                           = 0x0080
	BTS_READ_ONLY                         = 0x0001
	BTS_SECURE_DELETE                     = 0x0004
	CURSOR_FAULT                          = 4
	CURSOR_INVALID                        = 1
	CURSOR_REQUIRESEEK                    = 3
	CURSOR_SKIPNEXT                       = 2
	CURSOR_VALID                          = 0
	PTF_INTKEY                            = 0x01
	PTF_LEAF                              = 0x08
	PTF_LEAFDATA                          = 0x04
	PTF_ZERODATA                          = 0x02
	PTRMAP_BTREE                          = 5
	PTRMAP_FREEPAGE                       = 2
	PTRMAP_OVERFLOW1                      = 3
	PTRMAP_OVERFLOW2                      = 4
	PTRMAP_ROOTPAGE                       = 1
	READ_LOCK                             = 1
	SQLITE_FILE_HEADER                    = "SQLite format 3"
	TRANS_NONE                            = 0
	TRANS_READ                            = 1
	TRANS_WRITE                           = 2
	WRITE_LOCK                            = 2
	CPUSET_DEFAULT                        = 0
	CPUSET_INVALID                        = -1
	CPU_LEVEL_CPUSET                      = 2
	CPU_LEVEL_ROOT                        = 1
	CPU_LEVEL_WHICH                       = 3
	CPU_MAXSIZE                           = 256
	CPU_SETSIZE                           = 256
	CPU_WHICH_CPUSET                      = 3
	CPU_WHICH_DOMAIN                      = 6
	CPU_WHICH_INTRHANDLER                 = 7
	CPU_WHICH_IRQ                         = 4
	CPU_WHICH_ITHREAD                     = 8
	CPU_WHICH_JAIL                        = 5
	CPU_WHICH_PID                         = 2
	CPU_WHICH_TID                         = 1
	N_THREAD                              = 26
	PTHREAD_BARRIER_SERIAL_THREAD         = -1
	PTHREAD_CANCEL_ASYNCHRONOUS           = 2
	PTHREAD_CANCEL_DEFERRED               = 0
	PTHREAD_CANCEL_DISABLE                = 1
	PTHREAD_CANCEL_ENABLE                 = 0
	PTHREAD_CREATE_DETACHED               = 1
	PTHREAD_CREATE_JOINABLE               = 0
	PTHREAD_DESTRUCTOR_ITERATIONS         = 4
	PTHREAD_DETACHED                      = 0x1
	PTHREAD_DONE_INIT                     = 1
	PTHREAD_EXPLICIT_SCHED                = 0
	PTHREAD_INHERIT_SCHED                 = 0x4
	PTHREAD_KEYS_MAX                      = 256
	PTHREAD_MUTEX_ROBUST                  = 1
	PTHREAD_MUTEX_STALLED                 = 0
	PTHREAD_NEEDS_INIT                    = 0
	PTHREAD_NOFLOAT                       = 0x8
	PTHREAD_PRIO_INHERIT                  = 1
	PTHREAD_PRIO_NONE                     = 0
	PTHREAD_PRIO_PROTECT                  = 2
	PTHREAD_PROCESS_PRIVATE               = 0
	PTHREAD_PROCESS_SHARED                = 1
	PTHREAD_SCOPE_PROCESS                 = 0
	PTHREAD_SCOPE_SYSTEM                  = 0x2
	PTHREAD_STACK_MIN                     = 2048
	PTHREAD_THREADS_MAX                   = 4294967295
	SCHED_FIFO                            = 1
	SCHED_OTHER                           = 2
	SCHED_RR                              = 3
	X_PTHREAD_H_                          = 0
	X_SCHED_H_                            = 0
	X_SYS_BITSET_H_                       = 0
	X_SYS_CPUSET_H_                       = 0
	X_SYS__BITSET_H_                      = 0
	X_SYS__CPUSET_H_                      = 0
	TCL_THREADS                           = 0
	MX_CHUNK_NUMBER                       = 299
	SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET   = 400
	SQLITE_MULTIPLEX_WAL_8_3_OFFSET       = 700
	DEVSYM_MAX_PATHNAME                   = 512
	DEVSYM_VFS_NAME                       = "devsym"
	WRITECRASH_NAME                       = "writecrash"
	SQLITE_INTARRAY_H                     = 0
	JT_MAX_PATHNAME                       = 512
	JT_VFS_NAME                           = "jt"
	MALLOC_LOG_FRAMES                     = 10
	DEFAULT_SECTOR_SIZE                   = 0x1000
	MAX_PAGE_SIZE                         = 0x10000
	MULTIPLEX_CTRL_ENABLE                 = 214014
	MULTIPLEX_CTRL_SET_CHUNK_SIZE         = 214015
	MULTIPLEX_CTRL_SET_MAX_CHUNKS         = 214016
	SQLITE_MULTIPLEX_CHUNK_SIZE           = 2147418112
	SQLITE_MULTIPLEX_MAX_CHUNKS           = 12
	SQLITE_MULTIPLEX_VFS_NAME             = "multiplex"
	SQLITE_TEST_MULTIPLEX_H               = 0
	MAX_MUTEXES                           = 14
	STATIC_MUTEXES                        = 12
	BLOBSIZE                              = 10485760
	BLOCKSIZE                             = 512
	DATABASE_FILE                         = 1
	FS_VFS_NAME                           = "fs"
	JOURNAL_FILE                          = 2
	INST_MAX_PATHNAME                     = 512
	OS_ACCESS                             = 1
	OS_ANNOTATE                           = 28
	OS_CHECKRESERVEDLOCK                  = 2
	OS_CLOSE                              = 3
	OS_CURRENTTIME                        = 4
	OS_DELETE                             = 5
	OS_DEVCHAR                            = 6
	OS_FILECONTROL                        = 7
	OS_FILESIZE                           = 8
	OS_FULLPATHNAME                       = 9
	OS_LOCK                               = 11
	OS_NUMEVENTS                          = 29
	OS_OPEN                               = 12
	OS_RANDOMNESS                         = 13
	OS_READ                               = 14
	OS_SECTORSIZE                         = 15
	OS_SHMBARRIER                         = 26
	OS_SHMLOCK                            = 25
	OS_SHMMAP                             = 23
	OS_SHMUNMAP                           = 22
	OS_SLEEP                              = 16
	OS_SYNC                               = 17
	OS_TRUNCATE                           = 18
	OS_UNLOCK                             = 19
	OS_WRITE                              = 20
	VFSLOG_BUFFERSIZE                     = 8192
	TESTPCACHE_CLEAR                      = 0xd42670d4
	TESTPCACHE_NPAGE                      = 217
	TESTPCACHE_RESERVE                    = 17
	TESTPCACHE_VALID                      = 0x364585fd
	INHERIT_COPY                          = 1
	INHERIT_NONE                          = 2
	INHERIT_SHARE                         = 0
	INHERIT_ZERO                          = 3
	MADV_AUTOSYNC                         = 7
	MADV_CORE                             = 9
	MADV_DONTNEED                         = 4
	MADV_FREE                             = 5
	MADV_NOCORE                           = 8
	MADV_NORMAL                           = 0
	MADV_NOSYNC                           = 6
	MADV_PROTECT                          = 10
	MADV_RANDOM                           = 1
	MADV_SEQUENTIAL                       = 2
	MADV_WILLNEED                         = 3
	MAP_ALIGNED_SUPER                     = 16777216
	MAP_ALIGNMENT_MASK                    = 4278190080
	MAP_ALIGNMENT_SHIFT                   = 24
	MAP_ANON                              = 0x1000
	MAP_ANONYMOUS                         = 4096
	MAP_COPY                              = 2
	MAP_EXCL                              = 0x00004000
	MAP_FILE                              = 0x0000
	MAP_FIXED                             = 0x0010
	MAP_GUARD                             = 0x00002000
	MAP_HASSEMAPHORE                      = 0x0200
	MAP_NOCORE                            = 0x00020000
	MAP_NOSYNC                            = 0x0800
	MAP_PREFAULT_READ                     = 0x00040000
	MAP_PRIVATE                           = 0x0002
	MAP_RESERVED0020                      = 0x0020
	MAP_RESERVED0040                      = 0x0040
	MAP_RESERVED0080                      = 0x0080
	MAP_RESERVED0100                      = 0x0100
	MAP_SHARED                            = 0x0001
	MAP_STACK                             = 0x0400
	MCL_CURRENT                           = 0x0001
	MCL_FUTURE                            = 0x0002
	MFD_ALLOW_SEALING                     = 0x00000002
	MFD_CLOEXEC                           = 0x00000001
	MFD_HUGETLB                           = 0x00000004
	MFD_HUGE_16GB                         = 2281701376
	MFD_HUGE_16MB                         = 1610612736
	MFD_HUGE_1GB                          = 2013265920
	MFD_HUGE_1MB                          = 1342177280
	MFD_HUGE_256MB                        = 1879048192
	MFD_HUGE_2GB                          = 2080374784
	MFD_HUGE_2MB                          = 1409286144
	MFD_HUGE_32MB                         = 1677721600
	MFD_HUGE_512KB                        = 1275068416
	MFD_HUGE_512MB                        = 1946157056
	MFD_HUGE_64KB                         = 1073741824
	MFD_HUGE_8MB                          = 1543503872
	MFD_HUGE_MASK                         = 0xFC000000
	MFD_HUGE_SHIFT                        = 26
	MINCORE_INCORE                        = 0x1
	MINCORE_MODIFIED                      = 0x4
	MINCORE_MODIFIED_OTHER                = 0x10
	MINCORE_REFERENCED                    = 0x2
	MINCORE_REFERENCED_OTHER              = 0x8
	MINCORE_SUPER                         = 0x60
	MS_ASYNC                              = 0x0001
	MS_INVALIDATE                         = 0x0002
	MS_SYNC                               = 0x0000
	POSIX_MADV_DONTNEED                   = 4
	POSIX_MADV_NORMAL                     = 0
	POSIX_MADV_RANDOM                     = 1
	POSIX_MADV_SEQUENTIAL                 = 2
	POSIX_MADV_WILLNEED                   = 3
	PROT_EXEC                             = 0x04
	PROT_NONE                             = 0x00
	PROT_READ                             = 0x01
	PROT_WRITE                            = 0x02
	SHM_ALLOW_SEALING                     = 0x00000001
	SHM_GROW_ON_WRITE                     = 0x00000002
	SHM_LARGEPAGE                         = 0x00000004
	SHM_LARGEPAGE_ALLOC_DEFAULT           = 0
	SHM_LARGEPAGE_ALLOC_HARD              = 2
	SHM_LARGEPAGE_ALLOC_NOWAIT            = 1
	SHM_RENAME_EXCHANGE                   = 2
	SHM_RENAME_NOREPLACE                  = 1
	X_MADV_DONTNEED                       = 4
	X_MADV_NORMAL                         = 0
	X_MADV_RANDOM                         = 1
	X_MADV_SEQUENTIAL                     = 2
	X_MADV_WILLNEED                       = 3
	X_PROT_ALL                            = 7
	X_PROT_MAX_SHIFT                      = 16
	X_SYS_MMAN_H_                         = 0
	TCLVAR_NAME_EQ                        = 101
	TCLVAR_NAME_MATCH                     = 109
	TCLVAR_VALUE_GLOB                     = 103
	TCLVAR_VALUE_LIKE                     = 108
	TCLVAR_VALUE_REGEXP                   = 114
	FAULT_INJECT_NONE                     = 0
	FAULT_INJECT_PERSISTENT               = 2
	FAULT_INJECT_TRANSIENT                = 1
	TESTVFS_ACCESS_MASK                   = 0x00004000
	TESTVFS_ALL_MASK                      = 0x001FFFFF
	TESTVFS_CKLOCK_MASK                   = 0x00080000
	TESTVFS_CLOSE_MASK                    = 0x00000800
	TESTVFS_DELETE_MASK                   = 0x00000400
	TESTVFS_FCNTL_MASK                    = 0x00100000
	TESTVFS_FULLPATHNAME_MASK             = 0x00008000
	TESTVFS_LOCK_MASK                     = 0x00040000
	TESTVFS_MAX_ARGS                      = 12
	TESTVFS_MAX_PAGES                     = 1024
	TESTVFS_OPEN_MASK                     = 0x00000100
	TESTVFS_READ_MASK                     = 0x00010000
	TESTVFS_SHMBARRIER_MASK               = 0x00000040
	TESTVFS_SHMCLOSE_MASK                 = 0x00000080
	TESTVFS_SHMLOCK_MASK                  = 0x00000010
	TESTVFS_SHMMAP_MASK                   = 0x00000020
	TESTVFS_SHMOPEN_MASK                  = 0x00000001
	TESTVFS_SYNC_MASK                     = 0x00000200
	TESTVFS_TRUNCATE_MASK                 = 0x00002000
	TESTVFS_UNLOCK_MASK                   = 0x00020000
	TESTVFS_WRITE_MASK                    = 0x00001000
)

const (
	PTHREAD_MUTEX_ERRORCHECK  = 1
	PTHREAD_MUTEX_RECURSIVE   = 2
	PTHREAD_MUTEX_NORMAL      = 3
	PTHREAD_MUTEX_ADAPTIVE_NP = 4
	PTHREAD_MUTEX_TYPE_MAX    = 5
)

const (
	UIO_READ  = 0
	UIO_WRITE = 1
)

const (
	UIO_USERSPACE = 0
	UIO_SYSSPACE  = 1
	UIO_NOCOPY    = 2
)

const (
	TCL_QUEUE_TAIL = 0
	TCL_QUEUE_HEAD = 1
	TCL_QUEUE_MARK = 2
)

const (
	TCL_PATH_ABSOLUTE        = 0
	TCL_PATH_RELATIVE        = 1
	TCL_PATH_VOLUME_RELATIVE = 2
)

const (
	TCL_INT      = 0
	TCL_DOUBLE   = 1
	TCL_EITHER   = 2
	TCL_WIDE_INT = 3
)

type ptrdiff_t = int32

type size_t = uint32

type wchar_t = int32

type va_list = uintptr

type sqlite32 = struct {
	FpVfs                   uintptr
	FpVdbe                  uintptr
	FpDfltColl              uintptr
	Fmutex                  uintptr
	FaDb                    uintptr
	FnDb                    int32
	FmDbFlags               u32
	Fflags                  u64
	FlastRowid              i64
	FszMmap                 i64
	FnSchemaLock            u32
	FopenFlags              uint32
	FerrCode                int32
	FerrByteOffset          int32
	FerrMask                int32
	FiSysErrno              int32
	FdbOptFlags             u32
	Fenc                    u8
	FautoCommit             u8
	Ftemp_store             u8
	FmallocFailed           u8
	FbBenignMalloc          u8
	FdfltLockMode           u8
	FnextAutovac            int8
	FsuppressErr            u8
	FvtabOnConflict         u8
	FisTransactionSavepoint u8
	FmTrace                 u8
	FnoSharedCache          u8
	FnSqlExec               u8
	FeOpenState             u8
	F__ccgo_pad1            [2]byte
	FnextPagesize           int32
	FnChange                i64
	FnTotalChange           i64
	FaLimit                 [12]int32
	FnMaxSorterMmap         int32
	Finit                   struct {
		FnewTnum       Pgno
		FiDb           u8
		Fbusy          u8
		F__ccgo_pad1   [2]byte
		ForphanTrigger uint8
		F__ccgo_pad2   [3]byte
		FazInit        uintptr
	}
	FnVdbeActive        int32
	FnVdbeRead          int32
	FnVdbeWrite         int32
	FnVdbeExec          int32
	FnVDestroy          int32
	FnExtension         int32
	FaExtension         uintptr
	Ftrace              struct{ FxLegacy uintptr }
	FpTraceArg          uintptr
	FxProfile           uintptr
	FpProfileArg        uintptr
	FpCommitArg         uintptr
	FxCommitCallback    uintptr
	FpRollbackArg       uintptr
	FxRollbackCallback  uintptr
	FpUpdateArg         uintptr
	FxUpdateCallback    uintptr
	FpAutovacPagesArg   uintptr
	FxAutovacDestr      uintptr
	FxAutovacPages      uintptr
	FpParse             uintptr
	FpPreUpdateArg      uintptr
	FxPreUpdateCallback uintptr
	FpPreUpdate         uintptr
	FxWalCallback       uintptr
	FpWalArg            uintptr
	FxCollNeeded        uintptr
	FxCollNeeded16      uintptr
	FpCollNeededArg     uintptr
	FpErr               uintptr
	Fu1                 struct {
		FisInterrupted int32
		F__ccgo_pad1   [4]byte
	}
	Flookaside           Lookaside
	FxAuth               sqlite3_xauth
	FpAuthArg            uintptr
	FxProgress           uintptr
	FpProgressArg        uintptr
	FnProgressOps        uint32
	FnVTrans             int32
	FaModule             Hash
	FpVtabCtx            uintptr
	FaVTrans             uintptr
	FpDisconnect         uintptr
	FaFunc               Hash
	FaCollSeq            Hash
	FbusyHandler         BusyHandler
	FaDbStatic           [2]Db
	FpSavepoint          uintptr
	FnAnalysisLimit      int32
	FbusyTimeout         int32
	FnSavepoint          int32
	FnStatement          int32
	FnDeferredCons       i64
	FnDeferredImmCons    i64
	FpnBytesFreed        uintptr
	FpBlockingConnection uintptr
	FpUnlockConnection   uintptr
	FpUnlockArg          uintptr
	FxUnlockNotify       uintptr
	FpNextBlocked        uintptr
}

type sqlite_int64 = int64
type sqlite_uint64 = uint64
type sqlite3_int64 = sqlite_int64
type sqlite3_uint64 = sqlite_uint64

type sqlite3_callback = uintptr

type sqlite3_file1 = struct{ FpMethods uintptr }

type sqlite3_file = sqlite3_file1
type sqlite3_io_methods1 = struct {
	FiVersion               int32
	FxClose                 uintptr
	FxRead                  uintptr
	FxWrite                 uintptr
	FxTruncate              uintptr
	FxSync                  uintptr
	FxFileSize              uintptr
	FxLock                  uintptr
	FxUnlock                uintptr
	FxCheckReservedLock     uintptr
	FxFileControl           uintptr
	FxSectorSize            uintptr
	FxDeviceCharacteristics uintptr
	FxShmMap                uintptr
	FxShmLock               uintptr
	FxShmBarrier            uintptr
	FxShmUnmap              uintptr
	FxFetch                 uintptr
	FxUnfetch               uintptr
}

type sqlite3_io_methods = sqlite3_io_methods1

type sqlite3_mutex1 = struct {
	FpReal uintptr
	FeType int32
}

type sqlite3_api_routines1 = struct {
	Faggregate_context      uintptr
	Faggregate_count        uintptr
	Fbind_blob              uintptr
	Fbind_double            uintptr
	Fbind_int               uintptr
	Fbind_int64             uintptr
	Fbind_null              uintptr
	Fbind_parameter_count   uintptr
	Fbind_parameter_index   uintptr
	Fbind_parameter_name    uintptr
	Fbind_text              uintptr
	Fbind_text16            uintptr
	Fbind_value             uintptr
	Fbusy_handler           uintptr
	Fbusy_timeout           uintptr
	Fchanges                uintptr
	Fclose                  uintptr
	Fcollation_needed       uintptr
	Fcollation_needed16     uintptr
	Fcolumn_blob            uintptr
	Fcolumn_bytes           uintptr
	Fcolumn_bytes16         uintptr
	Fcolumn_count           uintptr
	Fcolumn_database_name   uintptr
	Fcolumn_database_name16 uintptr
	Fcolumn_decltype        uintptr
	Fcolumn_decltype16      uintptr
	Fcolumn_double          uintptr
	Fcolumn_int             uintptr
	Fcolumn_int64           uintptr
	Fcolumn_name            uintptr
	Fcolumn_name16          uintptr
	Fcolumn_origin_name     uintptr
	Fcolumn_origin_name16   uintptr
	Fcolumn_table_name      uintptr
	Fcolumn_table_name16    uintptr
	Fcolumn_text            uintptr
	Fcolumn_text16          uintptr
	Fcolumn_type            uintptr
	Fcolumn_value           uintptr
	Fcommit_hook            uintptr
	Fcomplete               uintptr
	Fcomplete16             uintptr
	Fcreate_collation       uintptr
	Fcreate_collation16     uintptr
	Fcreate_function        uintptr
	Fcreate_function16      uintptr
	Fcreate_module          uintptr
	Fdata_count             uintptr
	Fdb_handle              uintptr
	Fdeclare_vtab           uintptr
	Fenable_shared_cache    uintptr
	Ferrcode                uintptr
	Ferrmsg                 uintptr
	Ferrmsg16               uintptr
	Fexec                   uintptr
	Fexpired                uintptr
	Ffinalize               uintptr
	Ffree                   uintptr
	Ffree_table             uintptr
	Fget_autocommit         uintptr
	Fget_auxdata            uintptr
	Fget_table              uintptr
	Fglobal_recover         uintptr
	Finterruptx             uintptr
	Flast_insert_rowid      uintptr
	Flibversion             uintptr
	Flibversion_number      uintptr
	Fmalloc                 uintptr
	Fmprintf                uintptr
	Fopen                   uintptr
	Fopen16                 uintptr
	Fprepare                uintptr
	Fprepare16              uintptr
	Fprofile                uintptr
	Fprogress_handler       uintptr
	Frealloc                uintptr
	Freset                  uintptr
	Fresult_blob            uintptr
	Fresult_double          uintptr
	Fresult_error           uintptr
	Fresult_error16         uintptr
	Fresult_int             uintptr
	Fresult_int64           uintptr
	Fresult_null            uintptr
	Fresult_text            uintptr
	Fresult_text16          uintptr
	Fresult_text16be        uintptr
	Fresult_text16le        uintptr
	Fresult_value           uintptr
	Frollback_hook          uintptr
	Fset_authorizer         uintptr
	Fset_auxdata            uintptr
	Fxsnprintf              uintptr
	Fstep                   uintptr
	Ftable_column_metadata  uintptr
	Fthread_cleanup         uintptr
	Ftotal_changes          uintptr
	Ftrace                  uintptr
	Ftransfer_bindings      uintptr
	Fupdate_hook            uintptr
	Fuser_data              uintptr
	Fvalue_blob             uintptr
	Fvalue_bytes            uintptr
	Fvalue_bytes16          uintptr
	Fvalue_double           uintptr
	Fvalue_int              uintptr
	Fvalue_int64            uintptr
	Fvalue_numeric_type     uintptr
	Fvalue_text             uintptr
	Fvalue_text16           uintptr
	Fvalue_text16be         uintptr
	Fvalue_text16le         uintptr
	Fvalue_type             uintptr
	Fvmprintf               uintptr
	Foverload_function      uintptr
	Fprepare_v2             uintptr
	Fprepare16_v2           uintptr
	Fclear_bindings         uintptr
	Fcreate_module_v2       uintptr
	Fbind_zeroblob          uintptr
	Fblob_bytes             uintptr
	Fblob_close             uintptr
	Fblob_open              uintptr
	Fblob_read              uintptr
	Fblob_write             uintptr
	Fcreate_collation_v2    uintptr
	Ffile_control           uintptr
	Fmemory_highwater       uintptr
	Fmemory_used            uintptr
	Fmutex_alloc            uintptr
	Fmutex_enter            uintptr
	Fmutex_free             uintptr
	Fmutex_leave            uintptr
	Fmutex_try              uintptr
	Fopen_v2                uintptr
	Frelease_memory         uintptr
	Fresult_error_nomem     uintptr
	Fresult_error_toobig    uintptr
	Fsleep                  uintptr
	Fsoft_heap_limit        uintptr
	Fvfs_find               uintptr
	Fvfs_register           uintptr
	Fvfs_unregister         uintptr
	Fxthreadsafe            uintptr
	Fresult_zeroblob        uintptr
	Fresult_error_code      uintptr
	Ftest_control           uintptr
	Frandomness             uintptr
	Fcontext_db_handle      uintptr
	Fextended_result_codes  uintptr
	Flimit                  uintptr
	Fnext_stmt              uintptr
	Fsql                    uintptr
	Fstatus                 uintptr
	Fbackup_finish          uintptr
	Fbackup_init            uintptr
	Fbackup_pagecount       uintptr
	Fbackup_remaining       uintptr
	Fbackup_step            uintptr
	Fcompileoption_get      uintptr
	Fcompileoption_used     uintptr
	Fcreate_function_v2     uintptr
	Fdb_config              uintptr
	Fdb_mutex               uintptr
	Fdb_status              uintptr
	Fextended_errcode       uintptr
	Flog                    uintptr
	Fsoft_heap_limit64      uintptr
	Fsourceid               uintptr
	Fstmt_status            uintptr
	Fstrnicmp               uintptr
	Funlock_notify          uintptr
	Fwal_autocheckpoint     uintptr
	Fwal_checkpoint         uintptr
	Fwal_hook               uintptr
	Fblob_reopen            uintptr
	Fvtab_config            uintptr
	Fvtab_on_conflict       uintptr
	Fclose_v2               uintptr
	Fdb_filename            uintptr
	Fdb_readonly            uintptr
	Fdb_release_memory      uintptr
	Ferrstr                 uintptr
	Fstmt_busy              uintptr
	Fstmt_readonly          uintptr
	Fstricmp                uintptr
	Furi_boolean            uintptr
	Furi_int64              uintptr
	Furi_parameter          uintptr
	Fxvsnprintf             uintptr
	Fwal_checkpoint_v2      uintptr
	Fauto_extension         uintptr
	Fbind_blob64            uintptr
	Fbind_text64            uintptr
	Fcancel_auto_extension  uintptr
	Fload_extension         uintptr
	Fmalloc64               uintptr
	Fmsize                  uintptr
	Frealloc64              uintptr
	Freset_auto_extension   uintptr
	Fresult_blob64          uintptr
	Fresult_text64          uintptr
	Fstrglob                uintptr
	Fvalue_dup              uintptr
	Fvalue_free             uintptr
	Fresult_zeroblob64      uintptr
	Fbind_zeroblob64        uintptr
	Fvalue_subtype          uintptr
	Fresult_subtype         uintptr
	Fstatus64               uintptr
	Fstrlike                uintptr
	Fdb_cacheflush          uintptr
	Fsystem_errno           uintptr
	Ftrace_v2               uintptr
	Fexpanded_sql           uintptr
	Fset_last_insert_rowid  uintptr
	Fprepare_v3             uintptr
	Fprepare16_v3           uintptr
	Fbind_pointer           uintptr
	Fresult_pointer         uintptr
	Fvalue_pointer          uintptr
	Fvtab_nochange          uintptr
	Fvalue_nochange         uintptr
	Fvtab_collation         uintptr
	Fkeyword_count          uintptr
	Fkeyword_name           uintptr
	Fkeyword_check          uintptr
	Fstr_new                uintptr
	Fstr_finish             uintptr
	Fstr_appendf            uintptr
	Fstr_vappendf           uintptr
	Fstr_append             uintptr
	Fstr_appendall          uintptr
	Fstr_appendchar         uintptr
	Fstr_reset              uintptr
	Fstr_errcode            uintptr
	Fstr_length             uintptr
	Fstr_value              uintptr
	Fcreate_window_function uintptr
	Fnormalized_sql         uintptr
	Fstmt_isexplain         uintptr
	Fvalue_frombind         uintptr
	Fdrop_modules           uintptr
	Fhard_heap_limit64      uintptr
	Furi_key                uintptr
	Ffilename_database      uintptr
	Ffilename_journal       uintptr
	Ffilename_wal           uintptr
	Fcreate_filename        uintptr
	Ffree_filename          uintptr
	Fdatabase_file_object   uintptr
	Ftxn_state              uintptr
	Fchanges64              uintptr
	Ftotal_changes64        uintptr
	Fautovacuum_pages       uintptr
	Ferror_offset           uintptr
	Fvtab_rhs_value         uintptr
	Fvtab_distinct          uintptr
	Fvtab_in                uintptr
	Fvtab_in_first          uintptr
	Fvtab_in_next           uintptr
	Fdeserialize            uintptr
	Fserialize              uintptr
	Fdb_name                uintptr
	Fvalue_encoding         uintptr
	Fis_interrupted         uintptr
}

type sqlite3_filename = uintptr

type sqlite3_vfs1 = struct {
	FiVersion          int32
	FszOsFile          int32
	FmxPathname        int32
	FpNext             uintptr
	FzName             uintptr
	FpAppData          uintptr
	FxOpen             uintptr
	FxDelete           uintptr
	FxAccess           uintptr
	FxFullPathname     uintptr
	FxDlOpen           uintptr
	FxDlError          uintptr
	FxDlSym            uintptr
	FxDlClose          uintptr
	FxRandomness       uintptr
	FxSleep            uintptr
	FxCurrentTime      uintptr
	FxGetLastError     uintptr
	FxCurrentTimeInt64 uintptr
	FxSetSystemCall    uintptr
	FxGetSystemCall    uintptr
	FxNextSystemCall   uintptr
}

type sqlite3_vfs = sqlite3_vfs1
type sqlite3_syscall_ptr = uintptr

type sqlite3_mem_methods1 = struct {
	FxMalloc   uintptr
	FxFree     uintptr
	FxRealloc  uintptr
	FxSize     uintptr
	FxRoundup  uintptr
	FxInit     uintptr
	FxShutdown uintptr
	FpAppData  uintptr
}

type sqlite3_mem_methods = sqlite3_mem_methods1

type sqlite3_value1 = struct {
	Fu        struct{ Fr float64 }
	Fz        uintptr
	Fn        int32
	Fflags    u16
	Fenc      u8
	FeSubtype u8
	Fdb       uintptr
	FszMalloc int32
	FuTemp    u32
	FzMalloc  uintptr
	FxDel     uintptr
}

type sqlite3_context1 = struct {
	FpOut        uintptr
	FpFunc       uintptr
	FpMem        uintptr
	FpVdbe       uintptr
	FiOp         int32
	FisError     int32
	Fenc         u8
	FskipFlag    u8
	Fargc        u8
	F__ccgo_pad1 [1]byte
	Fargv        [1]uintptr
}

type sqlite3_destructor_type = uintptr

type sqlite3_vtab1 = struct {
	FpModule uintptr
	FnRef    int32
	FzErrMsg uintptr
}

type sqlite3_vtab = sqlite3_vtab1
type sqlite3_index_info1 = struct {
	FnConstraint      int32
	FaConstraint      uintptr
	FnOrderBy         int32
	FaOrderBy         uintptr
	FaConstraintUsage uintptr
	FidxNum           int32
	FidxStr           uintptr
	FneedToFreeIdxStr int32
	ForderByConsumed  int32
	FestimatedCost    float64
	FestimatedRows    sqlite3_int64
	FidxFlags         int32
	FcolUsed          sqlite3_uint64
}

type sqlite3_index_info = sqlite3_index_info1
type sqlite3_vtab_cursor1 = struct{ FpVtab uintptr }

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1
type sqlite3_module1 = struct {
	FiVersion      int32
	FxCreate       uintptr
	FxConnect      uintptr
	FxBestIndex    uintptr
	FxDisconnect   uintptr
	FxDestroy      uintptr
	FxOpen         uintptr
	FxClose        uintptr
	FxFilter       uintptr
	FxNext         uintptr
	FxEof          uintptr
	FxColumn       uintptr
	FxRowid        uintptr
	FxUpdate       uintptr
	FxBegin        uintptr
	FxSync         uintptr
	FxCommit       uintptr
	FxRollback     uintptr
	FxFindFunction uintptr
	FxRename       uintptr
	FxSavepoint    uintptr
	FxRelease      uintptr
	FxRollbackTo   uintptr
	FxShadowName   uintptr
}

type sqlite3_module = sqlite3_module1

type sqlite3_index_constraint = struct {
	FiColumn     int32
	Fop          uint8
	Fusable      uint8
	F__ccgo_pad1 [2]byte
	FiTermOffset int32
}

type sqlite3_index_orderby = struct {
	FiColumn     int32
	Fdesc        uint8
	F__ccgo_pad1 [3]byte
}

type sqlite3_index_constraint_usage = struct {
	FargvIndex   int32
	Fomit        uint8
	F__ccgo_pad1 [3]byte
}

type sqlite3_mutex_methods1 = struct {
	FxMutexInit    uintptr
	FxMutexEnd     uintptr
	FxMutexAlloc   uintptr
	FxMutexFree    uintptr
	FxMutexEnter   uintptr
	FxMutexTry     uintptr
	FxMutexLeave   uintptr
	FxMutexHeld    uintptr
	FxMutexNotheld uintptr
}

type sqlite3_mutex_methods = sqlite3_mutex_methods1

type sqlite3_str1 = struct {
	Fdb          uintptr
	FzText       uintptr
	FnAlloc      u32
	FmxAlloc     u32
	FnChar       u32
	FaccError    u8
	FprintfFlags u8
	F__ccgo_pad1 [2]byte
}

type sqlite3_pcache_page1 = struct {
	FpBuf   uintptr
	FpExtra uintptr
}

type sqlite3_pcache_page = sqlite3_pcache_page1

type sqlite3_pcache_methods21 = struct {
	FiVersion   int32
	FpArg       uintptr
	FxInit      uintptr
	FxShutdown  uintptr
	FxCreate    uintptr
	FxCachesize uintptr
	FxPagecount uintptr
	FxFetch     uintptr
	FxUnpin     uintptr
	FxRekey     uintptr
	FxTruncate  uintptr
	FxDestroy   uintptr
	FxShrink    uintptr
}

type sqlite3_pcache_methods2 = sqlite3_pcache_methods21

type sqlite3_pcache_methods1 = struct {
	FpArg       uintptr
	FxInit      uintptr
	FxShutdown  uintptr
	FxCreate    uintptr
	FxCachesize uintptr
	FxPagecount uintptr
	FxFetch     uintptr
	FxUnpin     uintptr
	FxRekey     uintptr
	FxTruncate  uintptr
	FxDestroy   uintptr
}

type sqlite3_pcache_methods = sqlite3_pcache_methods1

type sqlite3_snapshot1 = struct{ Fhidden [48]uint8 }

type sqlite3_snapshot = sqlite3_snapshot1

type sqlite3_rtree_geometry1 = struct {
	FpContext uintptr
	FnParam   int32
	FaParam   uintptr
	FpUser    uintptr
	FxDelUser uintptr
}

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1
type sqlite3_rtree_query_info1 = struct {
	FpContext      uintptr
	FnParam        int32
	FaParam        uintptr
	FpUser         uintptr
	FxDelUser      uintptr
	FaCoord        uintptr
	FanQueue       uintptr
	FnCoord        int32
	FiLevel        int32
	FmxLevel       int32
	FiRowid        sqlite3_int64
	FrParentScore  sqlite3_rtree_dbl
	FeParentWithin int32
	FeWithin       int32
	FrScore        sqlite3_rtree_dbl
	FapSqlParam    uintptr
}

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1

type sqlite3_rtree_dbl = float64

type Fts5ExtensionApi1 = struct {
	FiVersion           int32
	FxUserData          uintptr
	FxColumnCount       uintptr
	FxRowCount          uintptr
	FxColumnTotalSize   uintptr
	FxTokenize          uintptr
	FxPhraseCount       uintptr
	FxPhraseSize        uintptr
	FxInstCount         uintptr
	FxInst              uintptr
	FxRowid             uintptr
	FxColumnText        uintptr
	FxColumnSize        uintptr
	FxQueryPhrase       uintptr
	FxSetAuxdata        uintptr
	FxGetAuxdata        uintptr
	FxPhraseFirst       uintptr
	FxPhraseNext        uintptr
	FxPhraseFirstColumn uintptr
	FxPhraseNextColumn  uintptr
}

type Fts5ExtensionApi = Fts5ExtensionApi1
type Fts5PhraseIter1 = struct {
	Fa uintptr
	Fb uintptr
}

type Fts5PhraseIter = Fts5PhraseIter1

type fts5_extension_function = uintptr
type fts5_tokenizer1 = struct {
	FxCreate   uintptr
	FxDelete   uintptr
	FxTokenize uintptr
}

type fts5_tokenizer = fts5_tokenizer1

type fts5_api1 = struct {
	FiVersion         int32
	FxCreateTokenizer uintptr
	FxFindTokenizer   uintptr
	FxCreateFunction  uintptr
}

type fts5_api = fts5_api1

type sqlite3expert1 = struct {
	FiSample     int32
	Fdb          uintptr
	Fdbm         uintptr
	Fdbv         uintptr
	FpTable      uintptr
	FpScan       uintptr
	FpWrite      uintptr
	FpStatement  uintptr
	FbRun        int32
	FpzErrmsg    uintptr
	Frc          int32
	FhIdx        IdxHash
	FzCandidates uintptr
}

type sqlite3expert = sqlite3expert1

type locale_t = uintptr

type ssize_t = int32

type rsize_t = size_t

type errno_t = int32

type fpos_t = int64

type off_t = int64

type off64_t = int64

type __sbuf = struct {
	F_base uintptr
	F_size int32
}

type __sFILE = struct {
	F_p     uintptr
	F_r     int32
	F_w     int32
	F_flags int16
	F_file  int16
	F_bf    struct {
		F_base uintptr
		F_size int32
	}
	F_lbfsize int32
	F_cookie  uintptr
	F_close   uintptr
	F_read    uintptr
	F_seek    uintptr
	F_write   uintptr
	F_ub      struct {
		F_base uintptr
		F_size int32
	}
	F_up   uintptr
	F_ur   int32
	F_ubuf [3]uint8
	F_nbuf [1]uint8
	F_lb   struct {
		F_base uintptr
		F_size int32
	}
	F_blksize     int32
	F_offset      fpos_t
	F_fl_mutex    uintptr
	F_fl_owner    uintptr
	F_fl_count    int32
	F_orientation int32
	F_mbstate     struct {
		F__ccgo_pad1 [0]uint32
		F__mbstate8  [128]int8
	}
	F_flags2 int32
}

type FILE = __sFILE
type cookie_io_functions_t = struct {
	Fread  uintptr
	Fwrite uintptr
	Fseek  uintptr
	Fclose uintptr
}

type i64 = sqlite3_int64
type u64 = sqlite3_uint64

type IdxColumn1 = struct {
	FzName uintptr
	FzColl uintptr
	FiPk   int32
}

type IdxColumn = IdxColumn1
type IdxConstraint1 = struct {
	FzColl  uintptr
	FbRange int32
	FiCol   int32
	FbFlag  int32
	FbDesc  int32
	FpNext  uintptr
	FpLink  uintptr
}

type IdxConstraint = IdxConstraint1
type IdxScan1 = struct {
	FpTab      uintptr
	FiDb       int32
	Fcovering  i64
	FpOrder    uintptr
	FpEq       uintptr
	FpRange    uintptr
	FpNextScan uintptr
}

type IdxScan = IdxScan1
type IdxStatement1 = struct {
	FiId   int32
	FzSql  uintptr
	FzIdx  uintptr
	FzEQP  uintptr
	FpNext uintptr
}

type IdxStatement = IdxStatement1
type IdxTable1 = struct {
	FnCol  int32
	FzName uintptr
	FaCol  uintptr
	FpNext uintptr
}

type IdxTable = IdxTable1
type IdxWrite1 = struct {
	FpTab  uintptr
	FeOp   int32
	FpNext uintptr
}

type IdxWrite = IdxWrite1

type IdxHashEntry1 = struct {
	FzKey      uintptr
	FzVal      uintptr
	FzVal2     uintptr
	FpHashNext uintptr
	FpNext     uintptr
}

type IdxHashEntry = IdxHashEntry1
type IdxHash1 = struct {
	FpFirst uintptr
	FaHash  [1023]uintptr
}

type IdxHash = IdxHash1

func idxMalloc(tls *libc.TLS, pRc uintptr, nByte int32) uintptr {
	var pRet uintptr

	pRet = sqlite3.Xsqlite3_malloc(tls, nByte)
	if pRet != 0 {
		libc.Xmemset(tls, pRet, 0, uint32(nByte))
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	}
	return pRet
}

func idxHashInit(tls *libc.TLS, pHash uintptr) {
	libc.Xmemset(tls, pHash, 0, uint32(unsafe.Sizeof(IdxHash{})))
}

func idxHashClear(tls *libc.TLS, pHash uintptr) {
	var i int32
	for i = 0; i < IDX_HASH_SIZE; i++ {
		var pEntry uintptr
		var pNext uintptr
		for pEntry = *(*uintptr)(unsafe.Pointer(pHash + 4 + uintptr(i)*4)); pEntry != 0; pEntry = pNext {
			pNext = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext
			sqlite3.Xsqlite3_free(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2)
			sqlite3.Xsqlite3_free(tls, pEntry)
		}
	}
	libc.Xmemset(tls, pHash, 0, uint32(unsafe.Sizeof(IdxHash{})))
}

func idxHashString(tls *libc.TLS, z uintptr, n int32) int32 {
	var ret uint32 = uint32(0)
	var i int32
	for i = 0; i < n; i++ {
		ret = ret + (ret<<3 + uint32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(i))))))
	}
	return int32(ret % uint32(IDX_HASH_SIZE))
}

func idxHashAdd(tls *libc.TLS, pRc uintptr, pHash uintptr, zKey uintptr, zVal uintptr) int32 {
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var iHash int32 = idxHashString(tls, zKey, nKey)
	var nVal int32 = func() int32 {
		if zVal != 0 {
			return int32(libc.Xstrlen(tls, zVal))
		}
		return 0
	}()
	var pEntry uintptr

	for pEntry = *(*uintptr)(unsafe.Pointer(pHash + 4 + uintptr(iHash)*4)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if int32(libc.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey && 0 == libc.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint32(nKey)) {
			return 1
		}
	}
	pEntry = idxMalloc(tls, pRc, int32(uint32(unsafe.Sizeof(IdxHashEntry{}))+uint32(nKey)+uint32(1)+uint32(nVal)+uint32(1)))
	if pEntry != 0 {
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey = pEntry + 1*20
		libc.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint32(nKey))
		if zVal != 0 {
			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey + uintptr(nKey+1)
			libc.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal, zVal, uint32(nVal))
		}
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext = *(*uintptr)(unsafe.Pointer(pHash + 4 + uintptr(iHash)*4))
		*(*uintptr)(unsafe.Pointer(pHash + 4 + uintptr(iHash)*4)) = pEntry

		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext = (*IdxHash)(unsafe.Pointer(pHash)).FpFirst
		(*IdxHash)(unsafe.Pointer(pHash)).FpFirst = pEntry
	}
	return 0
}

func idxHashFind(tls *libc.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr {
	var iHash int32
	var pEntry uintptr
	if nKey < 0 {
		nKey = int32(libc.Xstrlen(tls, zKey))
	}
	iHash = idxHashString(tls, zKey, nKey)

	for pEntry = *(*uintptr)(unsafe.Pointer(pHash + 4 + uintptr(iHash)*4)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if int32(libc.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey && 0 == libc.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint32(nKey)) {
			return pEntry
		}
	}
	return uintptr(0)
}

func idxHashSearch(tls *libc.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr {
	var pEntry uintptr = idxHashFind(tls, pHash, zKey, nKey)
	if pEntry != 0 {
		return (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal
	}
	return uintptr(0)
}

func idxNewConstraint(tls *libc.TLS, pRc uintptr, zColl uintptr) uintptr {
	var pNew uintptr
	var nColl int32 = int32(libc.Xstrlen(tls, zColl))

	pNew = idxMalloc(tls, pRc, int32(uint32(unsafe.Sizeof(IdxConstraint{}))*uint32(nColl)+uint32(1)))
	if pNew != 0 {
		(*IdxConstraint)(unsafe.Pointer(pNew)).FzColl = pNew + 1*28
		libc.Xmemcpy(tls, (*IdxConstraint)(unsafe.Pointer(pNew)).FzColl, zColl, uint32(nColl+1))
	}
	return pNew
}

func idxDatabaseError(tls *libc.TLS, db uintptr, pzErrmsg uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
}

func idxPrepareStmt(tls *libc.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zSql uintptr) int32 {
	var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, ppStmt, uintptr(0))
	if rc != SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
		idxDatabaseError(tls, db, pzErrmsg)
	}
	return rc
}

func idxPrintfPrepareStmt(tls *libc.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zFmt uintptr, va uintptr) int32 {
	var ap va_list
	_ = ap
	var rc int32
	var zSql uintptr
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		rc = idxPrepareStmt(tls, db, ppStmt, pzErrmsg, zSql)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	_ = ap
	return rc
}

type ExpertVtab1 = struct {
	Fbase    sqlite3_vtab
	FpTab    uintptr
	FpExpert uintptr
}

type ExpertVtab = ExpertVtab1

type ExpertCsr1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpData uintptr
}

type ExpertCsr = ExpertCsr1

func expertDequote(tls *libc.TLS, zIn uintptr) uintptr {
	var n int32 = int32(libc.Xstrlen(tls, zIn))
	var zRet uintptr = sqlite3.Xsqlite3_malloc(tls, n)

	if zRet != 0 {
		var iOut int32 = 0
		var iIn int32 = 0
		for iIn = 1; iIn < n-1; iIn++ {
			if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == '\'' {
				iIn++
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
		}
		*(*int8)(unsafe.Pointer(zRet + uintptr(iOut))) = int8(0)
	}

	return zRet
}

func expertConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pExpert uintptr = pAux
	var p uintptr = uintptr(0)

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3, 0)
		*(*int32)(unsafe.Pointer(bp)) = SQLITE_ERROR
	} else {
		var zCreateTable uintptr = expertDequote(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
		if zCreateTable != 0 {
			*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				p = idxMalloc(tls, bp, int32(unsafe.Sizeof(ExpertVtab{})))
			}
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				(*ExpertVtab)(unsafe.Pointer(p)).FpExpert = pExpert
				(*ExpertVtab)(unsafe.Pointer(p)).FpTab = (*sqlite3expert)(unsafe.Pointer(pExpert)).FpTable

			}
			sqlite3.Xsqlite3_free(tls, zCreateTable)
		} else {
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_NOMEM
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = p
	return *(*int32)(unsafe.Pointer(bp))
}

func expertDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func expertBestIndex(tls *libc.TLS, pVtab uintptr, pIdxInfo uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pVtab
	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var n int32 = 0
	var pScan uintptr
	var opmask int32 = SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT | SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_GE | SQLITE_INDEX_CONSTRAINT_LE

	pScan = idxMalloc(tls, bp, int32(unsafe.Sizeof(IdxScan{})))
	if pScan != 0 {
		var i int32

		(*IdxScan)(unsafe.Pointer(pScan)).FpTab = (*ExpertVtab)(unsafe.Pointer(p)).FpTab
		(*IdxScan)(unsafe.Pointer(pScan)).FpNextScan = (*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan
		(*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan = pScan

		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12
			if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 &&
				(*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn >= 0 &&
				(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn)*12)).FiPk == 0 &&
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop)&opmask != 0 {
				var pNew uintptr
				var zColl uintptr = sqlite3.Xsqlite3_vtab_collation(tls, pIdxInfo, i)
				pNew = idxNewConstraint(tls, bp, zColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn
					if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpEq
						(*IdxScan)(unsafe.Pointer(pScan)).FpEq = pNew
					} else {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FbRange = 1
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpRange
						(*IdxScan)(unsafe.Pointer(pScan)).FpRange = pNew
					}
				}
				n++
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = n
			}
		}

		for i = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy - 1; i >= 0; i-- {
			var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).FiColumn
			if iCol >= 0 {
				var pNew uintptr = idxNewConstraint(tls, bp, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr(iCol)*12)).FzColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = iCol
					(*IdxConstraint)(unsafe.Pointer(pNew)).FbDesc = int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).Fdesc)
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpLink = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxScan)(unsafe.Pointer(pScan)).FpOrder = pNew
					n++
				}
			}
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000.0 / float64(n+1)
	return *(*int32)(unsafe.Pointer(bp))
}

func expertUpdate(tls *libc.TLS, pVtab uintptr, nData int32, azData uintptr, pRowid uintptr) int32 {
	_ = pVtab
	_ = nData
	_ = azData
	_ = pRowid
	return SQLITE_OK
}

func expertOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pCsr uintptr
	_ = pVTab
	pCsr = idxMalloc(tls, bp, int32(unsafe.Sizeof(ExpertCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return *(*int32)(unsafe.Pointer(bp))
}

func expertClose(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

func expertEof(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	return libc.Bool32((*ExpertCsr)(unsafe.Pointer(pCsr)).FpData == uintptr(0))
}

func expertNext(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	var rc int32 = SQLITE_OK

	rc = sqlite3.Xsqlite3_step(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	if rc != SQLITE_ROW {
		rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
		(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	} else {
		rc = SQLITE_OK
	}

	return rc
}

func expertRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	_ = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

func expertColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCsr uintptr = cur
	var pVal uintptr
	pVal = sqlite3.Xsqlite3_column_value(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData, i)
	if pVal != 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, pVal)
	}
	return SQLITE_OK
}

func expertFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var pExpert uintptr = (*ExpertVtab)(unsafe.Pointer(pVtab)).FpExpert
	var rc int32

	_ = idxNum
	_ = idxStr
	_ = argc
	_ = argv
	rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	if rc == SQLITE_OK {
		rc = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pExpert)).Fdb, pCsr+4, pVtab+8,
			ts+19, libc.VaList(bp, (*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(pVtab)).FpTab)).FzName))
	}

	if rc == SQLITE_OK {
		rc = expertNext(tls, cur)
	}
	return rc
}

func idxRegisterVtab(tls *libc.TLS, p uintptr) int32 {
	return sqlite3.Xsqlite3_create_module(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+56, uintptr(unsafe.Pointer(&expertModule)), p)
}

var expertModule = sqlite3_module{
	FiVersion:    2,
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
	FxUpdate:     0,
}

func idxFinalize(tls *libc.TLS, pRc uintptr, pStmt uintptr) {
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = rc
	}
}

func idxGetTableInfo(tls *libc.TLS, db uintptr, zTab uintptr, ppOut uintptr, pzErrmsg uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(0)
	var nCol int32 = 0
	var nTab int32
	var nByte int32
	var pNew uintptr = uintptr(0)

	var rc2 int32
	var pCsr uintptr = uintptr(0)
	var nPk int32 = 0

	*(*uintptr)(unsafe.Pointer(ppOut)) = uintptr(0)
	if zTab == uintptr(0) {
		return SQLITE_ERROR
	}
	nTab = int32(libc.Xstrlen(tls, zTab))
	nByte = int32(uint32(unsafe.Sizeof(IdxTable{})) + uint32(nTab) + uint32(1))
	*(*int32)(unsafe.Pointer(bp + 16)) = idxPrintfPrepareStmt(tls, db, bp+8, pzErrmsg, ts+63, libc.VaList(bp, zTab))
	for *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8))) {
		var zCol uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 1)
		*(*uintptr)(unsafe.Pointer(bp + 12)) = uintptr(0)
		if zCol == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 16)) = SQLITE_ERROR
			break
		}
		nByte = nByte + (1 + int32(libc.Xstrlen(tls, zCol)))
		*(*int32)(unsafe.Pointer(bp + 16)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+85, zTab, zCol, uintptr(0), bp+12, uintptr(0), uintptr(0), uintptr(0))
		if *(*uintptr)(unsafe.Pointer(bp + 12)) == uintptr(0) {
			*(*uintptr)(unsafe.Pointer(bp + 12)) = ts + 90
		}
		nByte = nByte + (1 + int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 12)))))
		nCol++
		nPk = nPk + libc.Bool32(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 5) > 0)
	}
	rc2 = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16)) = rc2
	}

	nByte = int32(uint32(nByte) + uint32(unsafe.Sizeof(IdxColumn{}))*uint32(nCol))
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		pNew = idxMalloc(tls, bp+16, nByte)
	}
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		(*IdxTable)(unsafe.Pointer(pNew)).FaCol = pNew + 1*16
		(*IdxTable)(unsafe.Pointer(pNew)).FnCol = nCol
		pCsr = (*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12
	}

	nCol = 0
	for *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8))) {
		var zCol uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 1)
		*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
		var nCopy int32
		if zCol == uintptr(0) {
			continue
		}
		nCopy = int32(libc.Xstrlen(tls, zCol)) + 1
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12)).FzName = pCsr
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12)).FiPk = libc.Bool32(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 5) == 1 && nPk == 1)
		libc.Xmemcpy(tls, pCsr, zCol, uint32(nCopy))
		pCsr += uintptr(nCopy)

		*(*int32)(unsafe.Pointer(bp + 16)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+85, zTab, zCol, uintptr(0), bp+20, uintptr(0), uintptr(0), uintptr(0))
		if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
			if *(*uintptr)(unsafe.Pointer(bp + 20)) == uintptr(0) {
				*(*uintptr)(unsafe.Pointer(bp + 20)) = ts + 90
			}
			nCopy = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))) + 1
			(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*12)).FzColl = pCsr
			libc.Xmemcpy(tls, pCsr, *(*uintptr)(unsafe.Pointer(bp + 20)), uint32(nCopy))
			pCsr += uintptr(nCopy)
		}

		nCol++
	}
	idxFinalize(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 8)))

	if *(*int32)(unsafe.Pointer(bp + 16)) != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, pNew)
		pNew = uintptr(0)
	} else if pNew != uintptr(0) {
		(*IdxTable)(unsafe.Pointer(pNew)).FzName = pCsr
		if (*IdxTable)(unsafe.Pointer(pNew)).FzName != uintptr(0) {
			libc.Xmemcpy(tls, (*IdxTable)(unsafe.Pointer(pNew)).FzName, zTab, uint32(nTab+1))
		}
	}

	*(*uintptr)(unsafe.Pointer(ppOut)) = pNew
	return *(*int32)(unsafe.Pointer(bp + 16))
}

func idxAppendText(tls *libc.TLS, pRc uintptr, zIn uintptr, zFmt uintptr, va uintptr) uintptr {
	var ap va_list
	_ = ap
	var zAppend uintptr = uintptr(0)
	var zRet uintptr = uintptr(0)
	var nIn int32
	if zIn != 0 {
		nIn = int32(libc.Xstrlen(tls, zIn))
	} else {
		nIn = 0
	}
	var nAppend int32 = 0
	ap = va
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		zAppend = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
		if zAppend != 0 {
			nAppend = int32(libc.Xstrlen(tls, zAppend))
			zRet = sqlite3.Xsqlite3_malloc(tls, nIn+nAppend+1)
		}
		if zAppend != 0 && zRet != 0 {
			if nIn != 0 {
				libc.Xmemcpy(tls, zRet, zIn, uint32(nIn))
			}
			libc.Xmemcpy(tls, zRet+uintptr(nIn), zAppend, uint32(nAppend+1))
		} else {
			sqlite3.Xsqlite3_free(tls, zRet)
			zRet = uintptr(0)
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
		sqlite3.Xsqlite3_free(tls, zAppend)
		sqlite3.Xsqlite3_free(tls, zIn)
	}
	_ = ap
	return zRet
}

func idxIdentifierRequiresQuotes(tls *libc.TLS, zId uintptr) int32 {
	var i int32
	var nId int32 = int32(libc.Xstrlen(tls, zId))

	if sqlite3.Xsqlite3_keyword_check(tls, zId, nId) != 0 {
		return 1
	}

	for i = 0; *(*int8)(unsafe.Pointer(zId + uintptr(i))) != 0; i++ {
		if !(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) == '_') &&
			!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= '0' && int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= '9') &&
			!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'a' && int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'z') &&
			!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'A' && int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'Z') {
			return 1
		}
	}
	return 0
}

func idxAppendColDefn(tls *libc.TLS, pRc uintptr, zIn uintptr, pTab uintptr, pCons uintptr) uintptr {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zRet uintptr = zIn
	var p uintptr = (*IdxTable)(unsafe.Pointer(pTab)).FaCol + uintptr((*IdxConstraint)(unsafe.Pointer(pCons)).FiCol)*12
	if zRet != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+97, 0)
	}

	if idxIdentifierRequiresQuotes(tls, (*IdxColumn)(unsafe.Pointer(p)).FzName) != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+100, libc.VaList(bp, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	} else {
		zRet = idxAppendText(tls, pRc, zRet, ts, libc.VaList(bp+8, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	}

	if sqlite3.Xsqlite3_stricmp(tls, (*IdxColumn)(unsafe.Pointer(p)).FzColl, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
		if idxIdentifierRequiresQuotes(tls, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
			zRet = idxAppendText(tls, pRc, zRet, ts+103, libc.VaList(bp+16, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		} else {
			zRet = idxAppendText(tls, pRc, zRet, ts+115, libc.VaList(bp+24, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		}
	}

	if (*IdxConstraint)(unsafe.Pointer(pCons)).FbDesc != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+127, 0)
	}
	return zRet
}

func idxFindCompatible(tls *libc.TLS, pRc uintptr, dbm uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var zTbl uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	var pIter uintptr
	var nEq int32 = 0

	for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
		nEq++
	}

	*(*int32)(unsafe.Pointer(bp + 24)) = idxPrintfPrepareStmt(tls, dbm, bp+16, uintptr(0), ts+133, libc.VaList(bp, zTbl))
	for *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16))) == SQLITE_ROW {
		var bMatch int32 = 1
		var pT uintptr = pTail
		*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), 1)
		if zIdx == uintptr(0) {
			continue
		}

		for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
			(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 0
		}

		*(*int32)(unsafe.Pointer(bp + 24)) = idxPrintfPrepareStmt(tls, dbm, bp+20, uintptr(0), ts+154, libc.VaList(bp+8, zIdx))
		for *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 20))) == SQLITE_ROW {
			var iIdx int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), 0)
			var iCol int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), 1)
			var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), 4)

			if iIdx < nEq {
				for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag != 0 {
						continue
					}
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FiCol != iCol {
						continue
					}
					if sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pIter)).FzColl, zColl) != 0 {
						continue
					}
					(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 1
					break
				}
				if pIter == uintptr(0) {
					bMatch = 0
					break
				}
			} else {
				if pT != 0 {
					if (*IdxConstraint)(unsafe.Pointer(pT)).FiCol != iCol || sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pT)).FzColl, zColl) != 0 {
						bMatch = 0
						break
					}
					pT = (*IdxConstraint)(unsafe.Pointer(pT)).FpLink
				}
			}
		}
		idxFinalize(tls, bp+24, *(*uintptr)(unsafe.Pointer(bp + 20)))

		if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK && bMatch != 0 {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
			return 1
		}
	}
	idxFinalize(tls, bp+24, *(*uintptr)(unsafe.Pointer(bp + 16)))

	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 24))
	return 0
}

func countNonzeros(tls *libc.TLS, pCount uintptr, nc int32, azResults uintptr, azColumns uintptr) int32 {
	_ = azColumns
	if nc > 0 && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(azResults))))) != '0' || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(azResults)) + 1))) != 0) {
		*(*int32)(unsafe.Pointer(pCount)) += 1
	}
	return 0
}

func idxCreateFromCons(tls *libc.TLS, p uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var dbm uintptr = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 48)) = SQLITE_OK
	if (pEq != 0 || pTail != 0) && 0 == idxFindCompatible(tls, bp+48, dbm, pScan, pEq, pTail) {
		var pTab uintptr = (*IdxScan)(unsafe.Pointer(pScan)).FpTab
		var zCols uintptr = uintptr(0)
		var zIdx uintptr = uintptr(0)
		var pCons uintptr
		var h uint32 = uint32(0)
		var zFmt uintptr

		for pCons = pEq; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+48, zCols, pTab, pCons)
		}
		for pCons = pTail; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+48, zCols, pTab, pCons)
		}

		if *(*int32)(unsafe.Pointer(bp + 48)) == SQLITE_OK {
			var zTable uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
			var quoteTable int32 = idxIdentifierRequiresQuotes(tls, zTable)
			var zName uintptr = uintptr(0)
			var collisions int32 = 0
			for __ccgo := true; __ccgo; __ccgo = collisions < 50 && zName != uintptr(0) {
				var zFind uintptr
				for *(*int32)(unsafe.Pointer(bp + 52)) = 0; *(*int8)(unsafe.Pointer(zCols + uintptr(*(*int32)(unsafe.Pointer(bp + 52))))) != 0; *(*int32)(unsafe.Pointer(bp + 52))++ {
					h = h + (h<<3 + uint32(*(*int8)(unsafe.Pointer(zCols + uintptr(*(*int32)(unsafe.Pointer(bp + 52)))))))
				}
				sqlite3.Xsqlite3_free(tls, zName)
				zName = sqlite3.Xsqlite3_mprintf(tls, ts+176, libc.VaList(bp, zTable, h))
				if zName == uintptr(0) {
					break
				}

				zFmt = ts + 188
				zFind = sqlite3.Xsqlite3_mprintf(tls, zFmt, libc.VaList(bp+16, zName))
				*(*int32)(unsafe.Pointer(bp + 52)) = 0
				*(*int32)(unsafe.Pointer(bp + 48)) = sqlite3.Xsqlite3_exec(tls, dbm, zFind, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
				}{countNonzeros})), bp+52, uintptr(0))

				sqlite3.Xsqlite3_free(tls, zFind)
				if *(*int32)(unsafe.Pointer(bp + 52)) == 0 {
					collisions = 0
					break
				}
				collisions++
			}
			if collisions != 0 {
				*(*int32)(unsafe.Pointer(bp + 48)) = SQLITE_BUSY | int32(3)<<8
			} else if zName == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 48)) = SQLITE_NOMEM
			} else {
				if quoteTable != 0 {
					zFmt = ts + 274
				} else {
					zFmt = ts + 304
				}
				zIdx = sqlite3.Xsqlite3_mprintf(tls, zFmt, libc.VaList(bp+24, zName, zTable, zCols))
				if !(zIdx != 0) {
					*(*int32)(unsafe.Pointer(bp + 48)) = SQLITE_NOMEM
				} else {
					*(*int32)(unsafe.Pointer(bp + 48)) = sqlite3.Xsqlite3_exec(tls, dbm, zIdx, uintptr(0), uintptr(0), (*sqlite3expert)(unsafe.Pointer(p)).FpzErrmsg)
					if *(*int32)(unsafe.Pointer(bp + 48)) != SQLITE_OK {
						*(*int32)(unsafe.Pointer(bp + 48)) = SQLITE_BUSY | int32(3)<<8
					} else {
						idxHashAdd(tls, bp+48, p+44, zName, zIdx)
					}
				}
				sqlite3.Xsqlite3_free(tls, zName)
				sqlite3.Xsqlite3_free(tls, zIdx)
			}
		}

		sqlite3.Xsqlite3_free(tls, zCols)
	}
	return *(*int32)(unsafe.Pointer(bp + 48))
}

func idxFindConstraint(tls *libc.TLS, pList uintptr, p uintptr) int32 {
	var pCmp uintptr
	for pCmp = pList; pCmp != 0; pCmp = (*IdxConstraint)(unsafe.Pointer(pCmp)).FpLink {
		if (*IdxConstraint)(unsafe.Pointer(p)).FiCol == (*IdxConstraint)(unsafe.Pointer(pCmp)).FiCol {
			return 1
		}
	}
	return 0
}

func idxCreateFromWhere(tls *libc.TLS, p uintptr, pScan uintptr, pTail uintptr) int32 {
	var p1 uintptr = uintptr(0)
	var pCon uintptr
	var rc int32

	for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpEq; pCon != 0; pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {
		if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
			(*IdxConstraint)(unsafe.Pointer(pCon)).FpLink = p1
			p1 = pCon
		}
	}

	rc = idxCreateFromCons(tls, p, pScan, p1, pTail)

	if pTail == uintptr(0) {
		for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpRange; rc == SQLITE_OK && pCon != 0; pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {
			if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
				rc = idxCreateFromCons(tls, p, pScan, p1, pCon)
			}
		}
	}

	return rc
}

func idxCreateCandidates(tls *libc.TLS, p uintptr) int32 {
	var rc int32 = SQLITE_OK
	var pIter uintptr

	for pIter = (*sqlite3expert)(unsafe.Pointer(p)).FpScan; pIter != 0 && rc == SQLITE_OK; pIter = (*IdxScan)(unsafe.Pointer(pIter)).FpNextScan {
		rc = idxCreateFromWhere(tls, p, pIter, uintptr(0))
		if rc == SQLITE_OK && (*IdxScan)(unsafe.Pointer(pIter)).FpOrder != 0 {
			rc = idxCreateFromWhere(tls, p, pIter, (*IdxScan)(unsafe.Pointer(pIter)).FpOrder)
		}
	}

	return rc
}

func idxConstraintFree(tls *libc.TLS, pConstraint uintptr) {
	var pNext uintptr
	var p uintptr

	for p = pConstraint; p != 0; p = pNext {
		pNext = (*IdxConstraint)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func idxScanFree(tls *libc.TLS, pScan uintptr, pLast uintptr) {
	var p uintptr
	var pNext uintptr
	for p = pScan; p != pLast; p = pNext {
		pNext = (*IdxScan)(unsafe.Pointer(p)).FpNextScan
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpOrder)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpEq)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpRange)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func idxStatementFree(tls *libc.TLS, pStatement uintptr, pLast uintptr) {
	var p uintptr
	var pNext uintptr
	for p = pStatement; p != pLast; p = pNext {
		pNext = (*IdxStatement)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzEQP)
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzIdx)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func idxTableFree(tls *libc.TLS, pTab uintptr) {
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxTable)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

func idxWriteFree(tls *libc.TLS, pTab uintptr) {
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

func idxFindIndexes(tls *libc.TLS, p uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(4128)
	defer tls.Free(4128)

	var pStmt uintptr
	var dbm uintptr

	var zSql uintptr
	var nIdx int32
	var zIdx uintptr

	var zDetail uintptr
	var nDetail int32
	var i int32
	var pEntry uintptr

	dbm = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 4124)) = SQLITE_OK
	idxHashInit(tls, bp+24)

	pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
__1:
	if !(*(*int32)(unsafe.Pointer(bp + 4124)) == SQLITE_OK && pStmt != 0) {
		goto __3
	}
	*(*uintptr)(unsafe.Pointer(bp + 4120)) = uintptr(0)
	idxHashClear(tls, bp+24)
	*(*int32)(unsafe.Pointer(bp + 4124)) = idxPrintfPrepareStmt(tls, dbm, bp+4120, pzErr,
		ts+330, libc.VaList(bp, (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql))
__4:
	if !(*(*int32)(unsafe.Pointer(bp + 4124)) == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 4120))) == SQLITE_ROW) {
		goto __5
	}

	zDetail = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 4120)), 3)

	if !!(zDetail != 0) {
		goto __6
	}
	goto __4
__6:
	;
	nDetail = int32(libc.Xstrlen(tls, zDetail))

	i = 0
__7:
	if !(i < nDetail) {
		goto __9
	}
	zIdx = uintptr(0)
	if !(i+13 < nDetail && libc.Xmemcmp(tls, zDetail+uintptr(i), ts+352, uint32(13)) == 0) {
		goto __10
	}
	zIdx = zDetail + uintptr(i+13)
	goto __11
__10:
	if !(i+22 < nDetail &&
		libc.Xmemcmp(tls, zDetail+uintptr(i), ts+366, uint32(22)) == 0) {
		goto __12
	}
	zIdx = zDetail + uintptr(i+22)
__12:
	;
__11:
	;
	if !(zIdx != 0) {
		goto __13
	}
	nIdx = 0
__14:
	if !(int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != 0 && (int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != ' ' || int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx+1)))) != '(')) {
		goto __15
	}
	nIdx++
	goto __14
__15:
	;
	zSql = idxHashSearch(tls, p+44, zIdx, nIdx)
	if !(zSql != 0) {
		goto __16
	}
	idxHashAdd(tls, bp+4124, bp+24, zSql, uintptr(0))
	if !(*(*int32)(unsafe.Pointer(bp + 4124)) != 0) {
		goto __17
	}
	goto find_indexes_out
__17:
	;
__16:
	;
	goto __9
__13:
	;
	goto __8
__8:
	i++
	goto __7
	goto __9
__9:
	;
	if !(int32(*(*int8)(unsafe.Pointer(zDetail))) != '-') {
		goto __18
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP = idxAppendText(tls, bp+4124, (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP, ts+389, libc.VaList(bp+8, zDetail))
__18:
	;
	goto __4
__5:
	;
	pEntry = (*IdxHash)(unsafe.Pointer(bp + 24)).FpFirst
__19:
	if !(pEntry != 0) {
		goto __21
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx = idxAppendText(tls, bp+4124, (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx, ts+393, libc.VaList(bp+16, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey))
	goto __20
__20:
	pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext
	goto __19
	goto __21
__21:
	;
	idxFinalize(tls, bp+4124, *(*uintptr)(unsafe.Pointer(bp + 4120)))
	goto __2
__2:
	pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext
	goto __1
	goto __3
__3:
	;
find_indexes_out:
	idxHashClear(tls, bp+24)
	return *(*int32)(unsafe.Pointer(bp + 4124))
}

func idxAuthCallback(tls *libc.TLS, pCtx uintptr, eOp int32, z3 uintptr, z4 uintptr, zDb uintptr, zTrigger uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	_ = z4
	_ = zTrigger
	if eOp == SQLITE_INSERT || eOp == SQLITE_UPDATE || eOp == SQLITE_DELETE {
		if sqlite3.Xsqlite3_stricmp(tls, zDb, ts+85) == 0 {
			var p uintptr = pCtx
			var pTab uintptr
			for pTab = (*sqlite3expert)(unsafe.Pointer(p)).FpTable; pTab != 0; pTab = (*IdxTable)(unsafe.Pointer(pTab)).FpNext {
				if 0 == sqlite3.Xsqlite3_stricmp(tls, z3, (*IdxTable)(unsafe.Pointer(pTab)).FzName) {
					break
				}
			}
			if pTab != 0 {
				var pWrite uintptr
				for pWrite = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite; pWrite != 0; pWrite = (*IdxWrite)(unsafe.Pointer(pWrite)).FpNext {
					if (*IdxWrite)(unsafe.Pointer(pWrite)).FpTab == pTab && (*IdxWrite)(unsafe.Pointer(pWrite)).FeOp == eOp {
						break
					}
				}
				if pWrite == uintptr(0) {
					pWrite = idxMalloc(tls, bp, int32(unsafe.Sizeof(IdxWrite{})))
					if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpTab = pTab
						(*IdxWrite)(unsafe.Pointer(pWrite)).FeOp = eOp
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
						(*sqlite3expert)(unsafe.Pointer(p)).FpWrite = pWrite
					}
				}
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func idxProcessOneTrigger(tls *libc.TLS, p uintptr, pWrite uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var pTab uintptr = (*IdxWrite)(unsafe.Pointer(pWrite)).FpTab
	var zTab uintptr = (*IdxTable)(unsafe.Pointer(pTab)).FzName
	var zSql uintptr = ts + 398
	*(*uintptr)(unsafe.Pointer(bp + 80)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 84)) = SQLITE_OK
	var zWrite uintptr = uintptr(0)

	*(*int32)(unsafe.Pointer(bp + 84)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+80, pzErr, zSql, libc.VaList(bp, zTab, zTab))
	for *(*int32)(unsafe.Pointer(bp + 84)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80))) {
		var zCreate uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), 0)
		if zCreate == uintptr(0) {
			continue
		}
		*(*int32)(unsafe.Pointer(bp + 84)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zCreate, uintptr(0), uintptr(0), pzErr)
	}
	idxFinalize(tls, bp+84, *(*uintptr)(unsafe.Pointer(bp + 80)))

	if *(*int32)(unsafe.Pointer(bp + 84)) == SQLITE_OK {
		var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+524, libc.VaList(bp+16, zTab, zInt))
		if z == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 84)) = SQLITE_NOMEM
		} else {
			*(*int32)(unsafe.Pointer(bp + 84)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, z, uintptr(0), uintptr(0), pzErr)
			sqlite3.Xsqlite3_free(tls, z)
		}
	}

	switch (*IdxWrite)(unsafe.Pointer(pWrite)).FeOp {
	case SQLITE_INSERT:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+84, zWrite, ts+557, libc.VaList(bp+32, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+84, zWrite, ts+580, libc.VaList(bp+40, func() uintptr {
					if i == 0 {
						return ts + 584
					}
					return ts + 97
				}()))
			}
			zWrite = idxAppendText(tls, bp+84, zWrite, ts+585, 0)
			break

		}
	case SQLITE_UPDATE:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+84, zWrite, ts+587, libc.VaList(bp+48, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+84, zWrite, ts+602, libc.VaList(bp+56, func() uintptr {
					if i == 0 {
						return ts + 584
					}
					return ts + 97
				}(),
					(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pTab)).FaCol+uintptr(i)*12)).FzName))
			}
			break

		}
	default:
		{
			if *(*int32)(unsafe.Pointer(bp + 84)) == SQLITE_OK {
				zWrite = sqlite3.Xsqlite3_mprintf(tls, ts+609, libc.VaList(bp+72, zInt))
				if zWrite == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 84)) = SQLITE_NOMEM
				}
			}

		}
	}

	if *(*int32)(unsafe.Pointer(bp + 84)) == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 88)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 84)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zWrite, -1, bp+88, uintptr(0))
		idxFinalize(tls, bp+84, *(*uintptr)(unsafe.Pointer(bp + 88)))
		if *(*int32)(unsafe.Pointer(bp + 84)) != SQLITE_OK {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zWrite)

	if *(*int32)(unsafe.Pointer(bp + 84)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 84)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zDrop, uintptr(0), uintptr(0), pzErr)
	}

	return *(*int32)(unsafe.Pointer(bp + 84))
}

var zInt uintptr = ts + 624
var zDrop uintptr = ts + 662

func idxProcessTriggers(tls *libc.TLS, p uintptr, pzErr uintptr) int32 {
	var rc int32 = SQLITE_OK
	var pEnd uintptr = uintptr(0)
	var pFirst uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite

	for rc == SQLITE_OK && pFirst != pEnd {
		var pIter uintptr
		for pIter = pFirst; rc == SQLITE_OK && pIter != pEnd; pIter = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext {
			rc = idxProcessOneTrigger(tls, p, pIter, pzErr)
		}
		pEnd = pFirst
		pFirst = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
	}

	return rc
}

func idxCreateVtabSchema(tls *libc.TLS, p uintptr, pzErrmsg uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	*(*int32)(unsafe.Pointer(bp + 48)) = idxRegisterVtab(tls, p)
	*(*uintptr)(unsafe.Pointer(bp + 40)) = uintptr(0)

	*(*int32)(unsafe.Pointer(bp + 48)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+40, pzErrmsg,
		ts+711)
	for *(*int32)(unsafe.Pointer(bp + 48)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40))) {
		var zType uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), 0)
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), 1)
		var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), 2)

		if zType == uintptr(0) || zName == uintptr(0) {
			continue
		}
		if int32(*(*int8)(unsafe.Pointer(zType))) == 'v' || int32(*(*int8)(unsafe.Pointer(zType + 1))) == 'r' {
			if zSql != 0 {
				*(*int32)(unsafe.Pointer(bp + 48)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), pzErrmsg)
			}
		} else {
			*(*int32)(unsafe.Pointer(bp + 48)) = idxGetTableInfo(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, zName, bp+44, pzErrmsg)
			if *(*int32)(unsafe.Pointer(bp + 48)) == SQLITE_OK {
				var i int32
				var zInner uintptr = uintptr(0)
				var zOuter uintptr = uintptr(0)
				(*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44)))).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpTable
				(*sqlite3expert)(unsafe.Pointer(p)).FpTable = *(*uintptr)(unsafe.Pointer(bp + 44))

				zInner = idxAppendText(tls, bp+48, uintptr(0), ts+979, 0)
				for i = 0; i < (*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44)))).FnCol; i++ {
					zInner = idxAppendText(tls, bp+48, zInner, ts+995,
						libc.VaList(bp, func() uintptr {
							if i == 0 {
								return ts + 584
							}
							return ts + 97
						}(), (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44)))).FaCol+uintptr(i)*12)).FzName, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44)))).FaCol+uintptr(i)*12)).FzColl))
				}
				zInner = idxAppendText(tls, bp+48, zInner, ts+585, 0)

				zOuter = idxAppendText(tls, bp+48, uintptr(0),
					ts+1011, libc.VaList(bp+24, zName, zInner))
				if *(*int32)(unsafe.Pointer(bp + 48)) == SQLITE_OK {
					*(*int32)(unsafe.Pointer(bp + 48)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zOuter, uintptr(0), uintptr(0), pzErrmsg)
				}
				sqlite3.Xsqlite3_free(tls, zInner)
				sqlite3.Xsqlite3_free(tls, zOuter)
			}
		}
	}
	idxFinalize(tls, bp+48, *(*uintptr)(unsafe.Pointer(bp + 40)))
	return *(*int32)(unsafe.Pointer(bp + 48))
}

type IdxSampleCtx = struct {
	FiTarget int32
	Ftarget  float64
	FnRow    float64
	FnRet    float64
}

func idxSampleFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var bRet int32

	_ = argv

	if (*IdxSampleCtx)(unsafe.Pointer(p)).FnRow == 0.0 {
		bRet = 1
	} else {
		bRet = libc.Bool32((*IdxSampleCtx)(unsafe.Pointer(p)).FnRet/(*IdxSampleCtx)(unsafe.Pointer(p)).FnRow <= (*IdxSampleCtx)(unsafe.Pointer(p)).Ftarget)
		if bRet == 0 {
			sqlite3.Xsqlite3_randomness(tls, 2, bp)
			bRet = libc.Bool32(int32(*(*uint16)(unsafe.Pointer(bp)))%100 <= (*IdxSampleCtx)(unsafe.Pointer(p)).FiTarget)
		}
	}

	sqlite3.Xsqlite3_result_int(tls, pCtx, bRet)
	*(*float64)(unsafe.Pointer(p + 12)) += 1.0
	*(*float64)(unsafe.Pointer(p + 20)) += float64(bRet)
}

type IdxRemCtx = struct {
	FnSlot int32
	FaSlot [1]struct {
		FeType int32
		FiVal  i64
		FrVal  float64
		FnByte int32
		Fn     int32
		Fz     uintptr
	}
}

type IdxRemSlot = struct {
	FeType int32
	FiVal  i64
	FrVal  float64
	FnByte int32
	Fn     int32
	Fz     uintptr
}

func idxRemFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) {
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pSlot uintptr
	var iSlot int32

	iSlot = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))

	pSlot = p + 4 + uintptr(iSlot)*32

	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case SQLITE_NULL:
		break

	case SQLITE_INTEGER:
		sqlite3.Xsqlite3_result_int64(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal)
		break

	case SQLITE_FLOAT:
		sqlite3.Xsqlite3_result_double(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal)
		break

	case SQLITE_BLOB:
		sqlite3.Xsqlite3_result_blob(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, libc.UintptrFromInt32(-1))
		break

	case SQLITE_TEXT:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, libc.UintptrFromInt32(-1))
		break
	}

	(*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case SQLITE_NULL:
		break

	case SQLITE_INTEGER:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		break

	case SQLITE_FLOAT:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		break

	case SQLITE_BLOB:
		fallthrough
	case SQLITE_TEXT:
		{
			var nByte int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
			var pData uintptr = uintptr(0)
			if nByte > (*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte {
				var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, nByte*2)
				if zNew == uintptr(0) {
					sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
					return
				}
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte = nByte * 2
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz = zNew
			}
			(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn = nByte
			if (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType == SQLITE_BLOB {
				pData = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
				if pData != 0 {
					libc.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, pData, uint32(nByte))
				}
			} else {
				pData = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
				libc.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, pData, uint32(nByte))
			}
			break

		}
	}
}

func idxLargestIndex(tls *libc.TLS, db uintptr, pnMax uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp + 4)) = SQLITE_OK
	var zMax uintptr = ts + 1052
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)

	*(*int32)(unsafe.Pointer(pnMax)) = 0
	*(*int32)(unsafe.Pointer(bp + 4)) = idxPrepareStmt(tls, db, bp, pzErr, zMax)
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp))) {
		*(*int32)(unsafe.Pointer(pnMax)) = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp)), 0) + 1
	}
	idxFinalize(tls, bp+4, *(*uintptr)(unsafe.Pointer(bp)))

	return *(*int32)(unsafe.Pointer(bp + 4))
}

func idxPopulateOneStat1(tls *libc.TLS, p uintptr, pIndexXInfo uintptr, pWriteStat uintptr, zTab uintptr, zIdx uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var zCols uintptr = uintptr(0)
	var zOrder uintptr = uintptr(0)
	var zQuery uintptr = uintptr(0)
	var nCol int32 = 0
	var i int32
	*(*uintptr)(unsafe.Pointer(bp + 116)) = uintptr(0)
	var aStat uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 112)) = SQLITE_OK

	sqlite3.Xsqlite3_bind_text(tls, pIndexXInfo, 1, zIdx, -1, uintptr(0))
	for SQLITE_OK == *(*int32)(unsafe.Pointer(bp + 112)) && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pIndexXInfo) {
		var zComma uintptr
		if zCols == uintptr(0) {
			zComma = ts + 584
		} else {
			zComma = ts + 97
		}
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 0)
		var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 1)
		zCols = idxAppendText(tls, bp+112, zCols,
			ts+1189, libc.VaList(bp, zComma, zName, nCol, zName, zColl))
		zOrder = idxAppendText(tls, bp+112, zOrder, ts+1224, libc.VaList(bp+40, zComma, libc.PreIncInt32(&nCol, 1)))
	}
	sqlite3.Xsqlite3_reset(tls, pIndexXInfo)
	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
		if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1229, libc.VaList(bp+56, zCols, zTab, zOrder))
		} else {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1261, libc.VaList(bp+80, zCols, zOrder))
		}
	}
	sqlite3.Xsqlite3_free(tls, zCols)
	sqlite3.Xsqlite3_free(tls, zOrder)

	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 112)) = idxPrepareStmt(tls, dbrem, bp+116, pzErr, zQuery)
	}
	sqlite3.Xsqlite3_free(tls, zQuery)

	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
		aStat = idxMalloc(tls, bp+112, int32(uint32(unsafe.Sizeof(int32(0)))*uint32(nCol+1)))
	}
	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 116))) {
		var pEntry uintptr
		var zStat uintptr = uintptr(0)
		for i = 0; i <= nCol; i++ {
			*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4)) = 1
		}
		for *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 116))) {
			*(*int32)(unsafe.Pointer(aStat))++
			for i = 0; i < nCol; i++ {
				if sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 116)), i) == 0 {
					break
				}
			}
			for ; i < nCol; i++ {
				*(*int32)(unsafe.Pointer(aStat + uintptr(i+1)*4))++
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
			var s0 int32 = *(*int32)(unsafe.Pointer(aStat))
			zStat = sqlite3.Xsqlite3_mprintf(tls, ts+1333, libc.VaList(bp+96, s0))
			if zStat == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 112)) = SQLITE_NOMEM
			}
			for i = 1; *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK && i <= nCol; i++ {
				zStat = idxAppendText(tls, bp+112, zStat, ts+1336, libc.VaList(bp+104, (s0+*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4))/2) / *(*int32)(unsafe.Pointer(aStat + uintptr(i)*4))))
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 1, zTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 2, zIdx, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 3, zStat, -1, uintptr(0))
			sqlite3.Xsqlite3_step(tls, pWriteStat)
			*(*int32)(unsafe.Pointer(bp + 112)) = sqlite3.Xsqlite3_reset(tls, pWriteStat)
		}

		pEntry = idxHashFind(tls, p+44, zIdx, int32(libc.Xstrlen(tls, zIdx)))
		if pEntry != 0 {
			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 = zStat
		} else {
			sqlite3.Xsqlite3_free(tls, zStat)
		}
	}
	sqlite3.Xsqlite3_free(tls, aStat)
	idxFinalize(tls, bp+112, *(*uintptr)(unsafe.Pointer(bp + 116)))

	return *(*int32)(unsafe.Pointer(bp + 112))
}

func idxBuildSampleTable(tls *libc.TLS, p uintptr, zTab uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	var zSql uintptr

	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+1340, uintptr(0), uintptr(0), uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+1404, libc.VaList(bp, zTab))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	return rc
}

func idxPopulateStat1(tls *libc.TLS, p uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*int32)(unsafe.Pointer(bp + 4)) = SQLITE_OK
	*(*int32)(unsafe.Pointer(bp)) = 0
	var pCtx uintptr = uintptr(0)

	var i int32
	var iPrev i64 = int64(-100000)
	*(*uintptr)(unsafe.Pointer(bp + 36)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 40)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 44)) = uintptr(0)

	var zAllIndex uintptr = ts + 1480
	var zIndexXInfo uintptr = ts + 1594
	var zWrite uintptr = ts + 1649

	if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 0 {
		return SQLITE_OK
	}

	*(*int32)(unsafe.Pointer(bp + 4)) = idxLargestIndex(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp, pzErr)
	if *(*int32)(unsafe.Pointer(bp)) <= 0 || *(*int32)(unsafe.Pointer(bp + 4)) != SQLITE_OK {
		return *(*int32)(unsafe.Pointer(bp + 4))
	}

	*(*int32)(unsafe.Pointer(bp + 4)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+1690, uintptr(0), uintptr(0), uintptr(0))

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		var nByte int32 = int32(uint32(unsafe.Sizeof(IdxRemCtx{})) + uint32(unsafe.Sizeof(IdxRemSlot{}))*uint32(*(*int32)(unsafe.Pointer(bp))))
		pCtx = idxMalloc(tls, bp+4, nByte)
	}

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 4)) = sqlite3.Xsqlite3_create_function(tls,
			dbrem, ts+1724, 2, SQLITE_UTF8, pCtx, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{idxRemFunc})), uintptr(0), uintptr(0))
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4)) = sqlite3.Xsqlite3_create_function(tls,
			(*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+1728, 0, SQLITE_UTF8, bp+8, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{idxSampleFunc})), uintptr(0), uintptr(0))
	}

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		(*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot = *(*int32)(unsafe.Pointer(bp)) + 1
		*(*int32)(unsafe.Pointer(bp + 4)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+36, pzErr, zAllIndex)
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+40, pzErr, zIndexXInfo)
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+44, pzErr, zWrite)
	}

	for *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 36))) {
		var iRowid i64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 36)), 0)
		var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 36)), 1)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 36)), 2)
		if zTab == uintptr(0) || zIdx == uintptr(0) {
			continue
		}
		if (*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100 && iPrev != iRowid {
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8)).Ftarget = float64((*sqlite3expert)(unsafe.Pointer(p)).FiSample) / 100.0
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8)).FiTarget = (*sqlite3expert)(unsafe.Pointer(p)).FiSample
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8)).FnRow = 0.0
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8)).FnRet = 0.0
			*(*int32)(unsafe.Pointer(bp + 4)) = idxBuildSampleTable(tls, p, zTab)
			if *(*int32)(unsafe.Pointer(bp + 4)) != SQLITE_OK {
				break
			}
		}
		*(*int32)(unsafe.Pointer(bp + 4)) = idxPopulateOneStat1(tls, p, *(*uintptr)(unsafe.Pointer(bp + 40)), *(*uintptr)(unsafe.Pointer(bp + 44)), zTab, zIdx, pzErr)
		iPrev = iRowid
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK && (*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100 {
		*(*int32)(unsafe.Pointer(bp + 4)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv,
			ts+1340, uintptr(0), uintptr(0), uintptr(0))
	}

	idxFinalize(tls, bp+4, *(*uintptr)(unsafe.Pointer(bp + 36)))
	idxFinalize(tls, bp+4, *(*uintptr)(unsafe.Pointer(bp + 40)))
	idxFinalize(tls, bp+4, *(*uintptr)(unsafe.Pointer(bp + 44)))

	if pCtx != 0 {
		for i = 0; i < (*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot; i++ {
			sqlite3.Xsqlite3_free(tls, (*IdxRemSlot)(unsafe.Pointer(pCtx+4+uintptr(i)*32)).Fz)
		}
		sqlite3.Xsqlite3_free(tls, pCtx)
	}

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+1735, uintptr(0), uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+1340, uintptr(0), uintptr(0), uintptr(0))
	return *(*int32)(unsafe.Pointer(bp + 4))
}

func sqlite3_expert_new(tls *libc.TLS, db uintptr, pzErrmsg uintptr) uintptr {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*int32)(unsafe.Pointer(bp + 16)) = SQLITE_OK
	var pNew uintptr

	pNew = idxMalloc(tls, bp+16, int32(unsafe.Sizeof(sqlite3expert{})))

	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		(*sqlite3expert)(unsafe.Pointer(pNew)).Fdb = db
		(*sqlite3expert)(unsafe.Pointer(pNew)).FiSample = 100
		*(*int32)(unsafe.Pointer(bp + 16)) = sqlite3.Xsqlite3_open(tls, ts+1757, pNew+12)
	}
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16)) = sqlite3.Xsqlite3_open(tls, ts+1757, pNew+8)
		if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
			sqlite3.Xsqlite3_db_config(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, SQLITE_DBCONFIG_TRIGGER_EQP, libc.VaList(bp, 1, uintptr(0)))
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 16)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdb, bp+20, pzErrmsg,
			ts+1766, 0)
		for *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 20))) {
			var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), 0)
			if zSql != 0 {
				*(*int32)(unsafe.Pointer(bp + 16)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, zSql, uintptr(0), uintptr(0), pzErrmsg)
			}
		}
		idxFinalize(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 20)))
	}

	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16)) = idxCreateVtabSchema(tls, pNew, pzErrmsg)
	}

	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		sqlite3.Xsqlite3_set_authorizer(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbv, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
		}{idxAuthCallback})), pNew)
	}

	if *(*int32)(unsafe.Pointer(bp + 16)) != SQLITE_OK {
		sqlite3_expert_destroy(tls, pNew)
		pNew = uintptr(0)
	}
	return pNew
}

func sqlite3_expert_config(tls *libc.TLS, p uintptr, op int32, va uintptr) int32 {
	var rc int32 = SQLITE_OK
	var ap va_list
	_ = ap
	ap = va
	switch op {
	case EXPERT_CONFIG_SAMPLE:
		{
			var iVal int32 = libc.VaInt32(&ap)
			if iVal < 0 {
				iVal = 0
			}
			if iVal > 100 {
				iVal = 100
			}
			(*sqlite3expert)(unsafe.Pointer(p)).FiSample = iVal
			break

		}
	default:
		rc = SQLITE_NOTFOUND
		break
	}

	_ = ap
	return rc
}

func sqlite3_expert_sql(tls *libc.TLS, p uintptr, zSql uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pScanOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpScan
	var pStmtOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
	*(*int32)(unsafe.Pointer(bp + 8)) = SQLITE_OK
	*(*uintptr)(unsafe.Pointer(bp + 4)) = zSql

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun != 0 {
		return SQLITE_MISUSE
	}

	for *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_OK && *(*uintptr)(unsafe.Pointer(bp + 4)) != 0 && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4)))) != 0 {
		*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 8)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, *(*uintptr)(unsafe.Pointer(bp + 4)), -1, bp, bp+4)
		if *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_OK {
			if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
				var pNew uintptr
				var z uintptr = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp)))
				var n int32 = int32(libc.Xstrlen(tls, z))
				pNew = idxMalloc(tls, bp+8, int32(uint32(unsafe.Sizeof(IdxStatement{}))+uint32(n)+uint32(1)))
				if *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_OK {
					(*IdxStatement)(unsafe.Pointer(pNew)).FzSql = pNew + 1*20
					libc.Xmemcpy(tls, (*IdxStatement)(unsafe.Pointer(pNew)).FzSql, z, uint32(n+1))
					(*IdxStatement)(unsafe.Pointer(pNew)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
					if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
						(*IdxStatement)(unsafe.Pointer(pNew)).FiId = (*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1
					}
					(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pNew
				}
				sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp)))
			}
		} else {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 8)) != SQLITE_OK {
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, pScanOrig)
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, pStmtOrig)
		(*sqlite3expert)(unsafe.Pointer(p)).FpScan = pScanOrig
		(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pStmtOrig
	}

	return *(*int32)(unsafe.Pointer(bp + 8))
}

func sqlite3_expert_analyze(tls *libc.TLS, p uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var pEntry uintptr

	*(*int32)(unsafe.Pointer(bp + 24)) = idxProcessTriggers(tls, p, pzErr)

	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24)) = idxCreateCandidates(tls, p)
	} else if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_BUSY|int32(3)<<8 {
		if pzErr != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+1865, 0)
		}
		return *(*int32)(unsafe.Pointer(bp + 24))
	}

	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24)) = idxPopulateStat1(tls, p, pzErr)
	}

	for pEntry = (*sqlite3expert)(unsafe.Pointer(p)).FhIdx.FpFirst; pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext {
		(*sqlite3expert)(unsafe.Pointer(p)).FzCandidates = idxAppendText(tls, bp+24, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates,
			ts+1909, libc.VaList(bp, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal,
				func() uintptr {
					if (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 != 0 {
						return ts + 1918
					}
					return ts + 584
				}(), (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2))
	}

	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24)) = idxFindIndexes(tls, p, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		(*sqlite3expert)(unsafe.Pointer(p)).FbRun = 1
	}
	return *(*int32)(unsafe.Pointer(bp + 24))
}

func sqlite3_expert_count(tls *libc.TLS, p uintptr) int32 {
	var nRet int32 = 0
	if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
		nRet = (*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1
	}
	return nRet
}

func sqlite3_expert_report(tls *libc.TLS, p uintptr, iStmt int32, eReport int32) uintptr {
	var zRet uintptr = uintptr(0)
	var pStmt uintptr

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun == 0 {
		return uintptr(0)
	}
	for pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement; pStmt != 0 && (*IdxStatement)(unsafe.Pointer(pStmt)).FiId != iStmt; pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext {
	}
	switch eReport {
	case EXPERT_REPORT_SQL:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql
		}
		break
	case EXPERT_REPORT_INDEXES:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx
		}
		break
	case EXPERT_REPORT_PLAN:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP
		}
		break
	case EXPERT_REPORT_CANDIDATES:
		zRet = (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates
		break
	}
	return zRet
}

func sqlite3_expert_destroy(tls *libc.TLS, p uintptr) {
	if p != 0 {
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm)
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv)
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, uintptr(0))
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, uintptr(0))
		idxTableFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpTable)
		idxWriteFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpWrite)
		idxHashClear(tls, p+44)
		sqlite3.Xsqlite3_free(tls, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

type ClientData = uintptr

type Tcl_WideInt = int64
type Tcl_WideUInt = uint64

type stat = struct {
	Fst_dev      dev_t
	Fst_ino      ino_t
	Fst_nlink    nlink_t
	Fst_mode     mode_t
	Fst_padding0 int16
	Fst_uid      uid_t
	Fst_gid      gid_t
	Fst_padding1 int32
	Fst_rdev     dev_t
	Fst_atim_ext int32
	Fst_atim     struct {
		Ftv_sec  time_t
		Ftv_nsec int32
	}
	Fst_mtim_ext int32
	Fst_mtim     struct {
		Ftv_sec  time_t
		Ftv_nsec int32
	}
	Fst_ctim_ext int32
	Fst_ctim     struct {
		Ftv_sec  time_t
		Ftv_nsec int32
	}
	Fst_btim_ext int32
	Fst_birthtim struct {
		Ftv_sec  time_t
		Ftv_nsec int32
	}
	Fst_size    off_t
	Fst_blocks  blkcnt_t
	Fst_blksize blksize_t
	Fst_flags   fflags_t
	Fst_gen     uint64
	Fst_spare   [10]uint64
}

type Tcl_Interp1 = struct {
	FresultDontUse    uintptr
	FfreeProcDontUse  uintptr
	FerrorLineDontUse int32
}

type Tcl_Interp = Tcl_Interp1

type Tcl_AsyncHandler = uintptr
type Tcl_Channel = uintptr
type Tcl_ChannelTypeVersion = uintptr
type Tcl_Command = uintptr
type Tcl_Condition = uintptr
type Tcl_Dict = uintptr
type Tcl_EncodingState = uintptr
type Tcl_Encoding = uintptr
type Tcl_Event1 = struct {
	Fproc    uintptr
	FnextPtr uintptr
}

type Tcl_Event = Tcl_Event1
type Tcl_InterpState = uintptr
type Tcl_LoadHandle = uintptr
type Tcl_Mutex = uintptr
type Tcl_Pid = uintptr
type Tcl_RegExp = uintptr
type Tcl_ThreadDataKey = uintptr
type Tcl_ThreadId = uintptr
type Tcl_TimerToken = uintptr
type Tcl_Trace = uintptr
type Tcl_Var = uintptr
type Tcl_ZlibStream = uintptr

type Tcl_RegExpIndices1 = struct {
	Fstart int32
	Fend   int32
}

type Tcl_RegExpIndices = Tcl_RegExpIndices1

type Tcl_RegExpInfo1 = struct {
	Fnsubs       int32
	Fmatches     uintptr
	FextendStart int32
	Freserved    int32
}

type Tcl_RegExpInfo = Tcl_RegExpInfo1

type Tcl_Stat_ = uintptr
type Tcl_OldStat_ = uintptr

type Tcl_ValueType = uint32

type Tcl_Value1 = struct {
	Ftype        Tcl_ValueType
	FintValue    int32
	FdoubleValue float64
	FwideValue   Tcl_WideInt
}

type Tcl_Value = Tcl_Value1

type Tcl_Obj1 = struct {
	FrefCount    int32
	Fbytes       uintptr
	Flength      int32
	FtypePtr     uintptr
	FinternalRep struct {
		FlongValue   int32
		F__ccgo_pad1 [4]byte
	}
}

type Tcl_ObjType1 = struct {
	Fname             uintptr
	FfreeIntRepProc   uintptr
	FdupIntRepProc    uintptr
	FupdateStringProc uintptr
	FsetFromAnyProc   uintptr
}

type Tcl_ObjType = Tcl_ObjType1

type Tcl_Obj = Tcl_Obj1

type Tcl_SavedResult1 = struct {
	Fresult       uintptr
	FfreeProc     uintptr
	FobjResultPtr uintptr
	FappendResult uintptr
	FappendAvl    int32
	FappendUsed   int32
	FresultSpace  [201]int8
	F__ccgo_pad1  [3]byte
}

type Tcl_SavedResult = Tcl_SavedResult1

type Tcl_Namespace1 = struct {
	Fname       uintptr
	FfullName   uintptr
	FclientData ClientData
	FdeleteProc uintptr
	FparentPtr  uintptr
}

type Tcl_Namespace = Tcl_Namespace1

type Tcl_CallFrame1 = struct {
	FnsPtr   uintptr
	Fdummy1  int32
	Fdummy2  int32
	Fdummy3  uintptr
	Fdummy4  uintptr
	Fdummy5  uintptr
	Fdummy6  int32
	Fdummy7  uintptr
	Fdummy8  uintptr
	Fdummy9  int32
	Fdummy10 uintptr
	Fdummy11 uintptr
	Fdummy12 uintptr
	Fdummy13 uintptr
}

type Tcl_CallFrame = Tcl_CallFrame1

type Tcl_CmdInfo1 = struct {
	FisNativeObjectProc int32
	FobjProc            uintptr
	FobjClientData      ClientData
	Fproc               uintptr
	FclientData         ClientData
	FdeleteProc         uintptr
	FdeleteData         ClientData
	FnamespacePtr       uintptr
}

type Tcl_CmdInfo = Tcl_CmdInfo1

type Tcl_DString1 = struct {
	Fstring      uintptr
	Flength      int32
	FspaceAvl    int32
	FstaticSpace [200]int8
}

type Tcl_DString = Tcl_DString1

type Tcl_HashKeyType1 = struct {
	Fversion         int32
	Fflags           int32
	FhashKeyProc     uintptr
	FcompareKeysProc uintptr
	FallocEntryProc  uintptr
	FfreeEntryProc   uintptr
}

type Tcl_HashKeyType = Tcl_HashKeyType1
type Tcl_HashTable1 = struct {
	Fbuckets       uintptr
	FstaticBuckets [4]uintptr
	FnumBuckets    int32
	FnumEntries    int32
	FrebuildSize   int32
	FdownShift     int32
	Fmask          int32
	FkeyType       int32
	FfindProc      uintptr
	FcreateProc    uintptr
	FtypePtr       uintptr
}

type Tcl_HashTable = Tcl_HashTable1
type Tcl_HashEntry1 = struct {
	FnextPtr    uintptr
	FtablePtr   uintptr
	Fhash       uintptr
	FclientData ClientData
	Fkey        struct{ FoneWordValue uintptr }
}

type Tcl_HashEntry = Tcl_HashEntry1

type Tcl_HashSearch1 = struct {
	FtablePtr     uintptr
	FnextIndex    int32
	FnextEntryPtr uintptr
}

type Tcl_HashSearch = Tcl_HashSearch1

type Tcl_DictSearch = struct {
	Fnext          uintptr
	Fepoch         int32
	FdictionaryPtr Tcl_Dict
}

type Tcl_QueuePosition = uint32

type Tcl_Time1 = struct {
	Fsec  int32
	Fusec int32
}

type Tcl_Time = Tcl_Time1

type Tcl_ChannelType1 = struct {
	FtypeName         uintptr
	Fversion          Tcl_ChannelTypeVersion
	FcloseProc        uintptr
	FinputProc        uintptr
	FoutputProc       uintptr
	FseekProc         uintptr
	FsetOptionProc    uintptr
	FgetOptionProc    uintptr
	FwatchProc        uintptr
	FgetHandleProc    uintptr
	Fclose2Proc       uintptr
	FblockModeProc    uintptr
	FflushProc        uintptr
	FhandlerProc      uintptr
	FwideSeekProc     uintptr
	FthreadActionProc uintptr
	FtruncateProc     uintptr
}

type Tcl_ChannelType = Tcl_ChannelType1

type Tcl_PathType = uint32

type Tcl_GlobTypeData1 = struct {
	Ftype       int32
	Fperm       int32
	FmacType    uintptr
	FmacCreator uintptr
}

type Tcl_GlobTypeData = Tcl_GlobTypeData1

type utimbuf = struct {
	Factime  time_t
	Fmodtime time_t
}

type Tcl_FSVersion = uintptr

type Tcl_Filesystem1 = struct {
	FtypeName                 uintptr
	FstructureLength          int32
	Fversion                  Tcl_FSVersion
	FpathInFilesystemProc     uintptr
	FdupInternalRepProc       uintptr
	FfreeInternalRepProc      uintptr
	FinternalToNormalizedProc uintptr
	FcreateInternalRepProc    uintptr
	FnormalizePathProc        uintptr
	FfilesystemPathTypeProc   uintptr
	FfilesystemSeparatorProc  uintptr
	FstatProc                 uintptr
	FaccessProc               uintptr
	FopenFileChannelProc      uintptr
	FmatchInDirectoryProc     uintptr
	FutimeProc                uintptr
	FlinkProc                 uintptr
	FlistVolumesProc          uintptr
	FfileAttrStringsProc      uintptr
	FfileAttrsGetProc         uintptr
	FfileAttrsSetProc         uintptr
	FcreateDirectoryProc      uintptr
	FremoveDirectoryProc      uintptr
	FdeleteFileProc           uintptr
	FcopyFileProc             uintptr
	FrenameFileProc           uintptr
	FcopyDirectoryProc        uintptr
	FlstatProc                uintptr
	FloadFileProc             uintptr
	FgetCwdProc               uintptr
	FchdirProc                uintptr
}

type Tcl_Filesystem = Tcl_Filesystem1

type Tcl_NotifierProcs1 = struct {
	FsetTimerProc          uintptr
	FwaitForEventProc      uintptr
	FcreateFileHandlerProc uintptr
	FdeleteFileHandlerProc uintptr
	FinitNotifierProc      uintptr
	FfinalizeNotifierProc  uintptr
	FalertNotifierProc     uintptr
	FserviceModeHookProc   uintptr
}

type Tcl_NotifierProcs = Tcl_NotifierProcs1

type Tcl_Token1 = struct {
	Ftype          int32
	Fstart         uintptr
	Fsize          int32
	FnumComponents int32
}

type Tcl_Token = Tcl_Token1

type Tcl_Parse1 = struct {
	FcommentStart    uintptr
	FcommentSize     int32
	FcommandStart    uintptr
	FcommandSize     int32
	FnumWords        int32
	FtokenPtr        uintptr
	FnumTokens       int32
	FtokensAvailable int32
	FerrorType       int32
	Fstring          uintptr
	Fend             uintptr
	Finterp          uintptr
	Fterm            uintptr
	Fincomplete      int32
	FstaticTokens    [20]Tcl_Token
}

type Tcl_Parse = Tcl_Parse1

type Tcl_EncodingType1 = struct {
	FencodingName uintptr
	FtoUtfProc    uintptr
	FfromUtfProc  uintptr
	FfreeProc     uintptr
	FclientData   ClientData
	FnullSize     int32
}

type Tcl_EncodingType = Tcl_EncodingType1

type Tcl_UniChar = uint16

type Tcl_Config1 = struct {
	Fkey   uintptr
	Fvalue uintptr
}

type Tcl_Config = Tcl_Config1
type mp_digit = uint32

type Tcl_ArgvInfo = struct {
	Ftype       int32
	FkeyStr     uintptr
	FsrcPtr     uintptr
	FdstPtr     uintptr
	FhelpStr    uintptr
	FclientData ClientData
}

type TclPlatStubs1 = struct {
	Fmagic int32
	Fhooks uintptr
}

type TclStubHooks = struct {
	FtclPlatStubs    uintptr
	FtclIntStubs     uintptr
	FtclIntPlatStubs uintptr
}

type TclStubs1 = struct {
	Fmagic                                  int32
	Fhooks                                  uintptr
	Ftcl_PkgProvideEx                       uintptr
	Ftcl_PkgRequireEx                       uintptr
	Ftcl_Panic                              uintptr
	Ftcl_Alloc                              uintptr
	Ftcl_Free                               uintptr
	Ftcl_Realloc                            uintptr
	Ftcl_DbCkalloc                          uintptr
	Ftcl_DbCkfree                           uintptr
	Ftcl_DbCkrealloc                        uintptr
	Ftcl_CreateFileHandler                  uintptr
	Ftcl_DeleteFileHandler                  uintptr
	Ftcl_SetTimer                           uintptr
	Ftcl_Sleep                              uintptr
	Ftcl_WaitForEvent                       uintptr
	Ftcl_AppendAllObjTypes                  uintptr
	Ftcl_AppendStringsToObj                 uintptr
	Ftcl_AppendToObj                        uintptr
	Ftcl_ConcatObj                          uintptr
	Ftcl_ConvertToType                      uintptr
	Ftcl_DbDecrRefCount                     uintptr
	Ftcl_DbIncrRefCount                     uintptr
	Ftcl_DbIsShared                         uintptr
	Ftcl_DbNewBooleanObj                    uintptr
	Ftcl_DbNewByteArrayObj                  uintptr
	Ftcl_DbNewDoubleObj                     uintptr
	Ftcl_DbNewListObj                       uintptr
	Ftcl_DbNewLongObj                       uintptr
	Ftcl_DbNewObj                           uintptr
	Ftcl_DbNewStringObj                     uintptr
	Ftcl_DuplicateObj                       uintptr
	FtclFreeObj                             uintptr
	Ftcl_GetBoolean                         uintptr
	Ftcl_GetBooleanFromObj                  uintptr
	Ftcl_GetByteArrayFromObj                uintptr
	Ftcl_GetDouble                          uintptr
	Ftcl_GetDoubleFromObj                   uintptr
	Ftcl_GetIndexFromObj                    uintptr
	Ftcl_GetInt                             uintptr
	Ftcl_GetIntFromObj                      uintptr
	Ftcl_GetLongFromObj                     uintptr
	Ftcl_GetObjType                         uintptr
	Ftcl_GetStringFromObj                   uintptr
	Ftcl_InvalidateStringRep                uintptr
	Ftcl_ListObjAppendList                  uintptr
	Ftcl_ListObjAppendElement               uintptr
	Ftcl_ListObjGetElements                 uintptr
	Ftcl_ListObjIndex                       uintptr
	Ftcl_ListObjLength                      uintptr
	Ftcl_ListObjReplace                     uintptr
	Ftcl_NewBooleanObj                      uintptr
	Ftcl_NewByteArrayObj                    uintptr
	Ftcl_NewDoubleObj                       uintptr
	Ftcl_NewIntObj                          uintptr
	Ftcl_NewListObj                         uintptr
	Ftcl_NewLongObj                         uintptr
	Ftcl_NewObj                             uintptr
	Ftcl_NewStringObj                       uintptr
	Ftcl_SetBooleanObj                      uintptr
	Ftcl_SetByteArrayLength                 uintptr
	Ftcl_SetByteArrayObj                    uintptr
	Ftcl_SetDoubleObj                       uintptr
	Ftcl_SetIntObj                          uintptr
	Ftcl_SetListObj                         uintptr
	Ftcl_SetLongObj                         uintptr
	Ftcl_SetObjLength                       uintptr
	Ftcl_SetStringObj                       uintptr
	Ftcl_AddErrorInfo                       uintptr
	Ftcl_AddObjErrorInfo                    uintptr
	Ftcl_AllowExceptions                    uintptr
	Ftcl_AppendElement                      uintptr
	Ftcl_AppendResult                       uintptr
	Ftcl_AsyncCreate                        uintptr
	Ftcl_AsyncDelete                        uintptr
	Ftcl_AsyncInvoke                        uintptr
	Ftcl_AsyncMark                          uintptr
	Ftcl_AsyncReady                         uintptr
	Ftcl_BackgroundError                    uintptr
	Ftcl_Backslash                          uintptr
	Ftcl_BadChannelOption                   uintptr
	Ftcl_CallWhenDeleted                    uintptr
	Ftcl_CancelIdleCall                     uintptr
	Ftcl_Close                              uintptr
	Ftcl_CommandComplete                    uintptr
	Ftcl_Concat                             uintptr
	Ftcl_ConvertElement                     uintptr
	Ftcl_ConvertCountedElement              uintptr
	Ftcl_CreateAlias                        uintptr
	Ftcl_CreateAliasObj                     uintptr
	Ftcl_CreateChannel                      uintptr
	Ftcl_CreateChannelHandler               uintptr
	Ftcl_CreateCloseHandler                 uintptr
	Ftcl_CreateCommand                      uintptr
	Ftcl_CreateEventSource                  uintptr
	Ftcl_CreateExitHandler                  uintptr
	Ftcl_CreateInterp                       uintptr
	Ftcl_CreateMathFunc                     uintptr
	Ftcl_CreateObjCommand                   uintptr
	Ftcl_CreateSlave                        uintptr
	Ftcl_CreateTimerHandler                 uintptr
	Ftcl_CreateTrace                        uintptr
	Ftcl_DeleteAssocData                    uintptr
	Ftcl_DeleteChannelHandler               uintptr
	Ftcl_DeleteCloseHandler                 uintptr
	Ftcl_DeleteCommand                      uintptr
	Ftcl_DeleteCommandFromToken             uintptr
	Ftcl_DeleteEvents                       uintptr
	Ftcl_DeleteEventSource                  uintptr
	Ftcl_DeleteExitHandler                  uintptr
	Ftcl_DeleteHashEntry                    uintptr
	Ftcl_DeleteHashTable                    uintptr
	Ftcl_DeleteInterp                       uintptr
	Ftcl_DetachPids                         uintptr
	Ftcl_DeleteTimerHandler                 uintptr
	Ftcl_DeleteTrace                        uintptr
	Ftcl_DontCallWhenDeleted                uintptr
	Ftcl_DoOneEvent                         uintptr
	Ftcl_DoWhenIdle                         uintptr
	Ftcl_DStringAppend                      uintptr
	Ftcl_DStringAppendElement               uintptr
	Ftcl_DStringEndSublist                  uintptr
	Ftcl_DStringFree                        uintptr
	Ftcl_DStringGetResult                   uintptr
	Ftcl_DStringInit                        uintptr
	Ftcl_DStringResult                      uintptr
	Ftcl_DStringSetLength                   uintptr
	Ftcl_DStringStartSublist                uintptr
	Ftcl_Eof                                uintptr
	Ftcl_ErrnoId                            uintptr
	Ftcl_ErrnoMsg                           uintptr
	Ftcl_Eval                               uintptr
	Ftcl_EvalFile                           uintptr
	Ftcl_EvalObj                            uintptr
	Ftcl_EventuallyFree                     uintptr
	Ftcl_Exit                               uintptr
	Ftcl_ExposeCommand                      uintptr
	Ftcl_ExprBoolean                        uintptr
	Ftcl_ExprBooleanObj                     uintptr
	Ftcl_ExprDouble                         uintptr
	Ftcl_ExprDoubleObj                      uintptr
	Ftcl_ExprLong                           uintptr
	Ftcl_ExprLongObj                        uintptr
	Ftcl_ExprObj                            uintptr
	Ftcl_ExprString                         uintptr
	Ftcl_Finalize                           uintptr
	Ftcl_FindExecutable                     uintptr
	Ftcl_FirstHashEntry                     uintptr
	Ftcl_Flush                              uintptr
	Ftcl_FreeResult                         uintptr
	Ftcl_GetAlias                           uintptr
	Ftcl_GetAliasObj                        uintptr
	Ftcl_GetAssocData                       uintptr
	Ftcl_GetChannel                         uintptr
	Ftcl_GetChannelBufferSize               uintptr
	Ftcl_GetChannelHandle                   uintptr
	Ftcl_GetChannelInstanceData             uintptr
	Ftcl_GetChannelMode                     uintptr
	Ftcl_GetChannelName                     uintptr
	Ftcl_GetChannelOption                   uintptr
	Ftcl_GetChannelType                     uintptr
	Ftcl_GetCommandInfo                     uintptr
	Ftcl_GetCommandName                     uintptr
	Ftcl_GetErrno                           uintptr
	Ftcl_GetHostName                        uintptr
	Ftcl_GetInterpPath                      uintptr
	Ftcl_GetMaster                          uintptr
	Ftcl_GetNameOfExecutable                uintptr
	Ftcl_GetObjResult                       uintptr
	Ftcl_GetOpenFile                        uintptr
	Ftcl_GetPathType                        uintptr
	Ftcl_Gets                               uintptr
	Ftcl_GetsObj                            uintptr
	Ftcl_GetServiceMode                     uintptr
	Ftcl_GetSlave                           uintptr
	Ftcl_GetStdChannel                      uintptr
	Ftcl_GetStringResult                    uintptr
	Ftcl_GetVar                             uintptr
	Ftcl_GetVar2                            uintptr
	Ftcl_GlobalEval                         uintptr
	Ftcl_GlobalEvalObj                      uintptr
	Ftcl_HideCommand                        uintptr
	Ftcl_Init                               uintptr
	Ftcl_InitHashTable                      uintptr
	Ftcl_InputBlocked                       uintptr
	Ftcl_InputBuffered                      uintptr
	Ftcl_InterpDeleted                      uintptr
	Ftcl_IsSafe                             uintptr
	Ftcl_JoinPath                           uintptr
	Ftcl_LinkVar                            uintptr
	Freserved188                            uintptr
	Ftcl_MakeFileChannel                    uintptr
	Ftcl_MakeSafe                           uintptr
	Ftcl_MakeTcpClientChannel               uintptr
	Ftcl_Merge                              uintptr
	Ftcl_NextHashEntry                      uintptr
	Ftcl_NotifyChannel                      uintptr
	Ftcl_ObjGetVar2                         uintptr
	Ftcl_ObjSetVar2                         uintptr
	Ftcl_OpenCommandChannel                 uintptr
	Ftcl_OpenFileChannel                    uintptr
	Ftcl_OpenTcpClient                      uintptr
	Ftcl_OpenTcpServer                      uintptr
	Ftcl_Preserve                           uintptr
	Ftcl_PrintDouble                        uintptr
	Ftcl_PutEnv                             uintptr
	Ftcl_PosixError                         uintptr
	Ftcl_QueueEvent                         uintptr
	Ftcl_Read                               uintptr
	Ftcl_ReapDetachedProcs                  uintptr
	Ftcl_RecordAndEval                      uintptr
	Ftcl_RecordAndEvalObj                   uintptr
	Ftcl_RegisterChannel                    uintptr
	Ftcl_RegisterObjType                    uintptr
	Ftcl_RegExpCompile                      uintptr
	Ftcl_RegExpExec                         uintptr
	Ftcl_RegExpMatch                        uintptr
	Ftcl_RegExpRange                        uintptr
	Ftcl_Release                            uintptr
	Ftcl_ResetResult                        uintptr
	Ftcl_ScanElement                        uintptr
	Ftcl_ScanCountedElement                 uintptr
	Ftcl_SeekOld                            uintptr
	Ftcl_ServiceAll                         uintptr
	Ftcl_ServiceEvent                       uintptr
	Ftcl_SetAssocData                       uintptr
	Ftcl_SetChannelBufferSize               uintptr
	Ftcl_SetChannelOption                   uintptr
	Ftcl_SetCommandInfo                     uintptr
	Ftcl_SetErrno                           uintptr
	Ftcl_SetErrorCode                       uintptr
	Ftcl_SetMaxBlockTime                    uintptr
	Ftcl_SetPanicProc                       uintptr
	Ftcl_SetRecursionLimit                  uintptr
	Ftcl_SetResult                          uintptr
	Ftcl_SetServiceMode                     uintptr
	Ftcl_SetObjErrorCode                    uintptr
	Ftcl_SetObjResult                       uintptr
	Ftcl_SetStdChannel                      uintptr
	Ftcl_SetVar                             uintptr
	Ftcl_SetVar2                            uintptr
	Ftcl_SignalId                           uintptr
	Ftcl_SignalMsg                          uintptr
	Ftcl_SourceRCFile                       uintptr
	Ftcl_SplitList                          uintptr
	Ftcl_SplitPath                          uintptr
	Ftcl_StaticPackage                      uintptr
	Ftcl_StringMatch                        uintptr
	Ftcl_TellOld                            uintptr
	Ftcl_TraceVar                           uintptr
	Ftcl_TraceVar2                          uintptr
	Ftcl_TranslateFileName                  uintptr
	Ftcl_Ungets                             uintptr
	Ftcl_UnlinkVar                          uintptr
	Ftcl_UnregisterChannel                  uintptr
	Ftcl_UnsetVar                           uintptr
	Ftcl_UnsetVar2                          uintptr
	Ftcl_UntraceVar                         uintptr
	Ftcl_UntraceVar2                        uintptr
	Ftcl_UpdateLinkedVar                    uintptr
	Ftcl_UpVar                              uintptr
	Ftcl_UpVar2                             uintptr
	Ftcl_VarEval                            uintptr
	Ftcl_VarTraceInfo                       uintptr
	Ftcl_VarTraceInfo2                      uintptr
	Ftcl_Write                              uintptr
	Ftcl_WrongNumArgs                       uintptr
	Ftcl_DumpActiveMemory                   uintptr
	Ftcl_ValidateAllMemory                  uintptr
	Ftcl_AppendResultVA                     uintptr
	Ftcl_AppendStringsToObjVA               uintptr
	Ftcl_HashStats                          uintptr
	Ftcl_ParseVar                           uintptr
	Ftcl_PkgPresent                         uintptr
	Ftcl_PkgPresentEx                       uintptr
	Ftcl_PkgProvide                         uintptr
	Ftcl_PkgRequire                         uintptr
	Ftcl_SetErrorCodeVA                     uintptr
	Ftcl_VarEvalVA                          uintptr
	Ftcl_WaitPid                            uintptr
	Ftcl_PanicVA                            uintptr
	Ftcl_GetVersion                         uintptr
	Ftcl_InitMemory                         uintptr
	Ftcl_StackChannel                       uintptr
	Ftcl_UnstackChannel                     uintptr
	Ftcl_GetStackedChannel                  uintptr
	Ftcl_SetMainLoop                        uintptr
	Freserved285                            uintptr
	Ftcl_AppendObjToObj                     uintptr
	Ftcl_CreateEncoding                     uintptr
	Ftcl_CreateThreadExitHandler            uintptr
	Ftcl_DeleteThreadExitHandler            uintptr
	Ftcl_DiscardResult                      uintptr
	Ftcl_EvalEx                             uintptr
	Ftcl_EvalObjv                           uintptr
	Ftcl_EvalObjEx                          uintptr
	Ftcl_ExitThread                         uintptr
	Ftcl_ExternalToUtf                      uintptr
	Ftcl_ExternalToUtfDString               uintptr
	Ftcl_FinalizeThread                     uintptr
	Ftcl_FinalizeNotifier                   uintptr
	Ftcl_FreeEncoding                       uintptr
	Ftcl_GetCurrentThread                   uintptr
	Ftcl_GetEncoding                        uintptr
	Ftcl_GetEncodingName                    uintptr
	Ftcl_GetEncodingNames                   uintptr
	Ftcl_GetIndexFromObjStruct              uintptr
	Ftcl_GetThreadData                      uintptr
	Ftcl_GetVar2Ex                          uintptr
	Ftcl_InitNotifier                       uintptr
	Ftcl_MutexLock                          uintptr
	Ftcl_MutexUnlock                        uintptr
	Ftcl_ConditionNotify                    uintptr
	Ftcl_ConditionWait                      uintptr
	Ftcl_NumUtfChars                        uintptr
	Ftcl_ReadChars                          uintptr
	Ftcl_RestoreResult                      uintptr
	Ftcl_SaveResult                         uintptr
	Ftcl_SetSystemEncoding                  uintptr
	Ftcl_SetVar2Ex                          uintptr
	Ftcl_ThreadAlert                        uintptr
	Ftcl_ThreadQueueEvent                   uintptr
	Ftcl_UniCharAtIndex                     uintptr
	Ftcl_UniCharToLower                     uintptr
	Ftcl_UniCharToTitle                     uintptr
	Ftcl_UniCharToUpper                     uintptr
	Ftcl_UniCharToUtf                       uintptr
	Ftcl_UtfAtIndex                         uintptr
	Ftcl_UtfCharComplete                    uintptr
	Ftcl_UtfBackslash                       uintptr
	Ftcl_UtfFindFirst                       uintptr
	Ftcl_UtfFindLast                        uintptr
	Ftcl_UtfNext                            uintptr
	Ftcl_UtfPrev                            uintptr
	Ftcl_UtfToExternal                      uintptr
	Ftcl_UtfToExternalDString               uintptr
	Ftcl_UtfToLower                         uintptr
	Ftcl_UtfToTitle                         uintptr
	Ftcl_UtfToUniChar                       uintptr
	Ftcl_UtfToUpper                         uintptr
	Ftcl_WriteChars                         uintptr
	Ftcl_WriteObj                           uintptr
	Ftcl_GetString                          uintptr
	Ftcl_GetDefaultEncodingDir              uintptr
	Ftcl_SetDefaultEncodingDir              uintptr
	Ftcl_AlertNotifier                      uintptr
	Ftcl_ServiceModeHook                    uintptr
	Ftcl_UniCharIsAlnum                     uintptr
	Ftcl_UniCharIsAlpha                     uintptr
	Ftcl_UniCharIsDigit                     uintptr
	Ftcl_UniCharIsLower                     uintptr
	Ftcl_UniCharIsSpace                     uintptr
	Ftcl_UniCharIsUpper                     uintptr
	Ftcl_UniCharIsWordChar                  uintptr
	Ftcl_UniCharLen                         uintptr
	Ftcl_UniCharNcmp                        uintptr
	Ftcl_UniCharToUtfDString                uintptr
	Ftcl_UtfToUniCharDString                uintptr
	Ftcl_GetRegExpFromObj                   uintptr
	Ftcl_EvalTokens                         uintptr
	Ftcl_FreeParse                          uintptr
	Ftcl_LogCommandInfo                     uintptr
	Ftcl_ParseBraces                        uintptr
	Ftcl_ParseCommand                       uintptr
	Ftcl_ParseExpr                          uintptr
	Ftcl_ParseQuotedString                  uintptr
	Ftcl_ParseVarName                       uintptr
	Ftcl_GetCwd                             uintptr
	Ftcl_Chdir                              uintptr
	Ftcl_Access                             uintptr
	Ftcl_Stat                               uintptr
	Ftcl_UtfNcmp                            uintptr
	Ftcl_UtfNcasecmp                        uintptr
	Ftcl_StringCaseMatch                    uintptr
	Ftcl_UniCharIsControl                   uintptr
	Ftcl_UniCharIsGraph                     uintptr
	Ftcl_UniCharIsPrint                     uintptr
	Ftcl_UniCharIsPunct                     uintptr
	Ftcl_RegExpExecObj                      uintptr
	Ftcl_RegExpGetInfo                      uintptr
	Ftcl_NewUnicodeObj                      uintptr
	Ftcl_SetUnicodeObj                      uintptr
	Ftcl_GetCharLength                      uintptr
	Ftcl_GetUniChar                         uintptr
	Ftcl_GetUnicode                         uintptr
	Ftcl_GetRange                           uintptr
	Ftcl_AppendUnicodeToObj                 uintptr
	Ftcl_RegExpMatchObj                     uintptr
	Ftcl_SetNotifier                        uintptr
	Ftcl_GetAllocMutex                      uintptr
	Ftcl_GetChannelNames                    uintptr
	Ftcl_GetChannelNamesEx                  uintptr
	Ftcl_ProcObjCmd                         uintptr
	Ftcl_ConditionFinalize                  uintptr
	Ftcl_MutexFinalize                      uintptr
	Ftcl_CreateThread                       uintptr
	Ftcl_ReadRaw                            uintptr
	Ftcl_WriteRaw                           uintptr
	Ftcl_GetTopChannel                      uintptr
	Ftcl_ChannelBuffered                    uintptr
	Ftcl_ChannelName                        uintptr
	Ftcl_ChannelVersion                     uintptr
	Ftcl_ChannelBlockModeProc               uintptr
	Ftcl_ChannelCloseProc                   uintptr
	Ftcl_ChannelClose2Proc                  uintptr
	Ftcl_ChannelInputProc                   uintptr
	Ftcl_ChannelOutputProc                  uintptr
	Ftcl_ChannelSeekProc                    uintptr
	Ftcl_ChannelSetOptionProc               uintptr
	Ftcl_ChannelGetOptionProc               uintptr
	Ftcl_ChannelWatchProc                   uintptr
	Ftcl_ChannelGetHandleProc               uintptr
	Ftcl_ChannelFlushProc                   uintptr
	Ftcl_ChannelHandlerProc                 uintptr
	Ftcl_JoinThread                         uintptr
	Ftcl_IsChannelShared                    uintptr
	Ftcl_IsChannelRegistered                uintptr
	Ftcl_CutChannel                         uintptr
	Ftcl_SpliceChannel                      uintptr
	Ftcl_ClearChannelHandlers               uintptr
	Ftcl_IsChannelExisting                  uintptr
	Ftcl_UniCharNcasecmp                    uintptr
	Ftcl_UniCharCaseMatch                   uintptr
	Ftcl_FindHashEntry                      uintptr
	Ftcl_CreateHashEntry                    uintptr
	Ftcl_InitCustomHashTable                uintptr
	Ftcl_InitObjHashTable                   uintptr
	Ftcl_CommandTraceInfo                   uintptr
	Ftcl_TraceCommand                       uintptr
	Ftcl_UntraceCommand                     uintptr
	Ftcl_AttemptAlloc                       uintptr
	Ftcl_AttemptDbCkalloc                   uintptr
	Ftcl_AttemptRealloc                     uintptr
	Ftcl_AttemptDbCkrealloc                 uintptr
	Ftcl_AttemptSetObjLength                uintptr
	Ftcl_GetChannelThread                   uintptr
	Ftcl_GetUnicodeFromObj                  uintptr
	Ftcl_GetMathFuncInfo                    uintptr
	Ftcl_ListMathFuncs                      uintptr
	Ftcl_SubstObj                           uintptr
	Ftcl_DetachChannel                      uintptr
	Ftcl_IsStandardChannel                  uintptr
	Ftcl_FSCopyFile                         uintptr
	Ftcl_FSCopyDirectory                    uintptr
	Ftcl_FSCreateDirectory                  uintptr
	Ftcl_FSDeleteFile                       uintptr
	Ftcl_FSLoadFile                         uintptr
	Ftcl_FSMatchInDirectory                 uintptr
	Ftcl_FSLink                             uintptr
	Ftcl_FSRemoveDirectory                  uintptr
	Ftcl_FSRenameFile                       uintptr
	Ftcl_FSLstat                            uintptr
	Ftcl_FSUtime                            uintptr
	Ftcl_FSFileAttrsGet                     uintptr
	Ftcl_FSFileAttrsSet                     uintptr
	Ftcl_FSFileAttrStrings                  uintptr
	Ftcl_FSStat                             uintptr
	Ftcl_FSAccess                           uintptr
	Ftcl_FSOpenFileChannel                  uintptr
	Ftcl_FSGetCwd                           uintptr
	Ftcl_FSChdir                            uintptr
	Ftcl_FSConvertToPathType                uintptr
	Ftcl_FSJoinPath                         uintptr
	Ftcl_FSSplitPath                        uintptr
	Ftcl_FSEqualPaths                       uintptr
	Ftcl_FSGetNormalizedPath                uintptr
	Ftcl_FSJoinToPath                       uintptr
	Ftcl_FSGetInternalRep                   uintptr
	Ftcl_FSGetTranslatedPath                uintptr
	Ftcl_FSEvalFile                         uintptr
	Ftcl_FSNewNativePath                    uintptr
	Ftcl_FSGetNativePath                    uintptr
	Ftcl_FSFileSystemInfo                   uintptr
	Ftcl_FSPathSeparator                    uintptr
	Ftcl_FSListVolumes                      uintptr
	Ftcl_FSRegister                         uintptr
	Ftcl_FSUnregister                       uintptr
	Ftcl_FSData                             uintptr
	Ftcl_FSGetTranslatedStringPath          uintptr
	Ftcl_FSGetFileSystemForPath             uintptr
	Ftcl_FSGetPathType                      uintptr
	Ftcl_OutputBuffered                     uintptr
	Ftcl_FSMountsChanged                    uintptr
	Ftcl_EvalTokensStandard                 uintptr
	Ftcl_GetTime                            uintptr
	Ftcl_CreateObjTrace                     uintptr
	Ftcl_GetCommandInfoFromToken            uintptr
	Ftcl_SetCommandInfoFromToken            uintptr
	Ftcl_DbNewWideIntObj                    uintptr
	Ftcl_GetWideIntFromObj                  uintptr
	Ftcl_NewWideIntObj                      uintptr
	Ftcl_SetWideIntObj                      uintptr
	Ftcl_AllocStatBuf                       uintptr
	Ftcl_Seek                               uintptr
	Ftcl_Tell                               uintptr
	Ftcl_ChannelWideSeekProc                uintptr
	Ftcl_DictObjPut                         uintptr
	Ftcl_DictObjGet                         uintptr
	Ftcl_DictObjRemove                      uintptr
	Ftcl_DictObjSize                        uintptr
	Ftcl_DictObjFirst                       uintptr
	Ftcl_DictObjNext                        uintptr
	Ftcl_DictObjDone                        uintptr
	Ftcl_DictObjPutKeyList                  uintptr
	Ftcl_DictObjRemoveKeyList               uintptr
	Ftcl_NewDictObj                         uintptr
	Ftcl_DbNewDictObj                       uintptr
	Ftcl_RegisterConfig                     uintptr
	Ftcl_CreateNamespace                    uintptr
	Ftcl_DeleteNamespace                    uintptr
	Ftcl_AppendExportList                   uintptr
	Ftcl_Export                             uintptr
	Ftcl_Import                             uintptr
	Ftcl_ForgetImport                       uintptr
	Ftcl_GetCurrentNamespace                uintptr
	Ftcl_GetGlobalNamespace                 uintptr
	Ftcl_FindNamespace                      uintptr
	Ftcl_FindCommand                        uintptr
	Ftcl_GetCommandFromObj                  uintptr
	Ftcl_GetCommandFullName                 uintptr
	Ftcl_FSEvalFileEx                       uintptr
	Ftcl_SetExitProc                        uintptr
	Ftcl_LimitAddHandler                    uintptr
	Ftcl_LimitRemoveHandler                 uintptr
	Ftcl_LimitReady                         uintptr
	Ftcl_LimitCheck                         uintptr
	Ftcl_LimitExceeded                      uintptr
	Ftcl_LimitSetCommands                   uintptr
	Ftcl_LimitSetTime                       uintptr
	Ftcl_LimitSetGranularity                uintptr
	Ftcl_LimitTypeEnabled                   uintptr
	Ftcl_LimitTypeExceeded                  uintptr
	Ftcl_LimitTypeSet                       uintptr
	Ftcl_LimitTypeReset                     uintptr
	Ftcl_LimitGetCommands                   uintptr
	Ftcl_LimitGetTime                       uintptr
	Ftcl_LimitGetGranularity                uintptr
	Ftcl_SaveInterpState                    uintptr
	Ftcl_RestoreInterpState                 uintptr
	Ftcl_DiscardInterpState                 uintptr
	Ftcl_SetReturnOptions                   uintptr
	Ftcl_GetReturnOptions                   uintptr
	Ftcl_IsEnsemble                         uintptr
	Ftcl_CreateEnsemble                     uintptr
	Ftcl_FindEnsemble                       uintptr
	Ftcl_SetEnsembleSubcommandList          uintptr
	Ftcl_SetEnsembleMappingDict             uintptr
	Ftcl_SetEnsembleUnknownHandler          uintptr
	Ftcl_SetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleSubcommandList          uintptr
	Ftcl_GetEnsembleMappingDict             uintptr
	Ftcl_GetEnsembleUnknownHandler          uintptr
	Ftcl_GetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleNamespace               uintptr
	Ftcl_SetTimeProc                        uintptr
	Ftcl_QueryTimeProc                      uintptr
	Ftcl_ChannelThreadActionProc            uintptr
	Ftcl_NewBignumObj                       uintptr
	Ftcl_DbNewBignumObj                     uintptr
	Ftcl_SetBignumObj                       uintptr
	Ftcl_GetBignumFromObj                   uintptr
	Ftcl_TakeBignumFromObj                  uintptr
	Ftcl_TruncateChannel                    uintptr
	Ftcl_ChannelTruncateProc                uintptr
	Ftcl_SetChannelErrorInterp              uintptr
	Ftcl_GetChannelErrorInterp              uintptr
	Ftcl_SetChannelError                    uintptr
	Ftcl_GetChannelError                    uintptr
	Ftcl_InitBignumFromDouble               uintptr
	Ftcl_GetNamespaceUnknownHandler         uintptr
	Ftcl_SetNamespaceUnknownHandler         uintptr
	Ftcl_GetEncodingFromObj                 uintptr
	Ftcl_GetEncodingSearchPath              uintptr
	Ftcl_SetEncodingSearchPath              uintptr
	Ftcl_GetEncodingNameFromEnvironment     uintptr
	Ftcl_PkgRequireProc                     uintptr
	Ftcl_AppendObjToErrorInfo               uintptr
	Ftcl_AppendLimitedToObj                 uintptr
	Ftcl_Format                             uintptr
	Ftcl_AppendFormatToObj                  uintptr
	Ftcl_ObjPrintf                          uintptr
	Ftcl_AppendPrintfToObj                  uintptr
	Ftcl_CancelEval                         uintptr
	Ftcl_Canceled                           uintptr
	Ftcl_CreatePipe                         uintptr
	Ftcl_NRCreateCommand                    uintptr
	Ftcl_NREvalObj                          uintptr
	Ftcl_NREvalObjv                         uintptr
	Ftcl_NRCmdSwap                          uintptr
	Ftcl_NRAddCallback                      uintptr
	Ftcl_NRCallObjProc                      uintptr
	Ftcl_GetFSDeviceFromStat                uintptr
	Ftcl_GetFSInodeFromStat                 uintptr
	Ftcl_GetModeFromStat                    uintptr
	Ftcl_GetLinkCountFromStat               uintptr
	Ftcl_GetUserIdFromStat                  uintptr
	Ftcl_GetGroupIdFromStat                 uintptr
	Ftcl_GetDeviceTypeFromStat              uintptr
	Ftcl_GetAccessTimeFromStat              uintptr
	Ftcl_GetModificationTimeFromStat        uintptr
	Ftcl_GetChangeTimeFromStat              uintptr
	Ftcl_GetSizeFromStat                    uintptr
	Ftcl_GetBlocksFromStat                  uintptr
	Ftcl_GetBlockSizeFromStat               uintptr
	Ftcl_SetEnsembleParameterList           uintptr
	Ftcl_GetEnsembleParameterList           uintptr
	Ftcl_ParseArgsObjv                      uintptr
	Ftcl_GetErrorLine                       uintptr
	Ftcl_SetErrorLine                       uintptr
	Ftcl_TransferResult                     uintptr
	Ftcl_InterpActive                       uintptr
	Ftcl_BackgroundException                uintptr
	Ftcl_ZlibDeflate                        uintptr
	Ftcl_ZlibInflate                        uintptr
	Ftcl_ZlibCRC32                          uintptr
	Ftcl_ZlibAdler32                        uintptr
	Ftcl_ZlibStreamInit                     uintptr
	Ftcl_ZlibStreamGetCommandName           uintptr
	Ftcl_ZlibStreamEof                      uintptr
	Ftcl_ZlibStreamChecksum                 uintptr
	Ftcl_ZlibStreamPut                      uintptr
	Ftcl_ZlibStreamGet                      uintptr
	Ftcl_ZlibStreamClose                    uintptr
	Ftcl_ZlibStreamReset                    uintptr
	Ftcl_SetStartupScript                   uintptr
	Ftcl_GetStartupScript                   uintptr
	Ftcl_CloseEx                            uintptr
	Ftcl_NRExprObj                          uintptr
	Ftcl_NRSubstObj                         uintptr
	Ftcl_LoadFile                           uintptr
	Ftcl_FindSymbol                         uintptr
	Ftcl_FSUnloadFile                       uintptr
	Ftcl_ZlibStreamSetCompressionDictionary uintptr
	Freserved631                            uintptr
	Freserved632                            uintptr
	Freserved633                            uintptr
	Freserved634                            uintptr
	Freserved635                            uintptr
	Freserved636                            uintptr
	Freserved637                            uintptr
	Freserved638                            uintptr
	Freserved639                            uintptr
	Freserved640                            uintptr
	Freserved641                            uintptr
	Freserved642                            uintptr
	Freserved643                            uintptr
	Freserved644                            uintptr
	Freserved645                            uintptr
	Freserved646                            uintptr
	Freserved647                            uintptr
	Freserved648                            uintptr
	Freserved649                            uintptr
	Freserved650                            uintptr
	Freserved651                            uintptr
	Freserved652                            uintptr
	Freserved653                            uintptr
	Freserved654                            uintptr
	Freserved655                            uintptr
	Freserved656                            uintptr
	Freserved657                            uintptr
	Freserved658                            uintptr
	Freserved659                            uintptr
	Freserved660                            uintptr
	Freserved661                            uintptr
	Freserved662                            uintptr
	Freserved663                            uintptr
	Freserved664                            uintptr
	Freserved665                            uintptr
	Freserved666                            uintptr
	Freserved667                            uintptr
	Freserved668                            uintptr
	Freserved669                            uintptr
	Freserved670                            uintptr
	Freserved671                            uintptr
	Freserved672                            uintptr
	Freserved673                            uintptr
	Freserved674                            uintptr
	Freserved675                            uintptr
	Freserved676                            uintptr
	Freserved677                            uintptr
	Freserved678                            uintptr
	Freserved679                            uintptr
	Freserved680                            uintptr
	Freserved681                            uintptr
	Freserved682                            uintptr
	FtclUnusedStubEntry                     uintptr
}

type TclStubs = TclStubs1

type TclPlatStubs = TclPlatStubs1

func dbHandleFromObj(tls *libc.TLS, interp uintptr, pObj uintptr, pDb uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, pObj), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930, tcl.XTcl_GetString(tls, pObj), 0))
		return TCL_ERROR
	}

	*(*uintptr)(unsafe.Pointer(pDb)) = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24)).FobjClientData))
	return TCL_OK
}

func testExpertCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var pExpert uintptr = clientData
	*(*[6]Subcmd)(unsafe.Pointer(bp)) = [6]Subcmd{
		{FzSub: ts + 1947, FnArg: 1, FzMsg: ts + 1951},
		{FzSub: ts + 1957, FzMsg: ts + 584},
		{FzSub: ts + 1965, FzMsg: ts + 584},
		{FzSub: ts + 1971, FnArg: 2, FzMsg: ts + 1978},
		{FzSub: ts + 1991, FzMsg: ts + 584},
		{},
	}

	var rc int32 = TCL_OK
	*(*uintptr)(unsafe.Pointer(bp + 76)) = uintptr(0)

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*4)), bp, int32(unsafe.Sizeof(Subcmd{})), ts+2014, 0, bp+72)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+(*Subcmd)(unsafe.Pointer(bp+uintptr(*(*int32)(unsafe.Pointer(bp + 72)))*12)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*Subcmd)(unsafe.Pointer(bp+uintptr(*(*int32)(unsafe.Pointer(bp + 72)))*12)).FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 72)) {
	case 0:
		{
			var zArg uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			rc = sqlite3_expert_sql(tls, pExpert, zArg, bp+76)
			break

		}

	case 1:
		{
			rc = sqlite3_expert_analyze(tls, pExpert, bp+76)
			break

		}

	case 2:
		{
			var n int32 = sqlite3_expert_count(tls, pExpert)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, n))
			break

		}

	case 3:
		{
			*(*[5]uintptr)(unsafe.Pointer(bp + 84)) = [5]uintptr{
				ts + 1947, ts + 2026, ts + 2034, ts + 2039, uintptr(0),
			}

			var zReport uintptr

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+80) != 0 ||
				tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84, int32(unsafe.Sizeof(uintptr(0))), ts+1971, 0, bp+104) != 0 {
				return TCL_ERROR
			}

			zReport = sqlite3_expert_report(tls, pExpert, *(*int32)(unsafe.Pointer(bp + 80)), 1+*(*int32)(unsafe.Pointer(bp + 104)))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zReport, -1))
			break

		}

	default:
		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
		break
	}

	if rc != TCL_OK {
		if *(*uintptr)(unsafe.Pointer(bp + 76)) != 0 {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 76)), -1))
		} else {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		}
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 76)))
	return rc
}

type Subcmd = struct {
	FzSub uintptr
	FnArg int32
	FzMsg uintptr
}

func testExpertDel(tls *libc.TLS, clientData uintptr) {
	var pExpert uintptr = clientData
	sqlite3_expert_destroy(tls, pExpert)
}

func test_sqlite3_expert_new(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zCmd uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 44)) = uintptr(0)
	var pExpert uintptr
	var rc int32 = TCL_OK

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if dbHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+40) != 0 {
		return TCL_ERROR
	}

	zCmd = sqlite3.Xsqlite3_mprintf(tls, ts+2053, libc.VaList(bp, libc.PreIncInt32(&iCmd, 1)))
	if zCmd == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, ts+2069, uintptr(0)))
		return TCL_ERROR
	}

	pExpert = sqlite3_expert_new(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), bp+44)
	if pExpert == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(bp + 44)), uintptr(0)))
		rc = TCL_ERROR
	} else {
		var p uintptr = pExpert
		tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{testExpertCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testExpertDel})))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zCmd, -1))
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 44)))
	return rc
}

var iCmd int32 = 0

func TestExpert_Init(tls *libc.TLS, interp uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[1]struct {
		FzCmd  uintptr
		FxProc uintptr
	})(unsafe.Pointer(bp)) = [1]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{
		{FzCmd: ts + 2083, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3_expert_new}))},
	}
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof([1]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{}))/uint32(unsafe.Sizeof(struct {
		FzCmd  uintptr
		FxProc uintptr
	}{})); i++ {
		var p uintptr = bp + uintptr(i)*8
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FzCmd, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

func f5tDbPointer(tls *libc.TLS, interp uintptr, pObj uintptr, ppDb uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr

	var z uintptr = tcl.XTcl_GetString(tls, pObj)
	if tcl.XTcl_GetCommandInfo(tls, interp, z, bp) != 0 {
		p = (*Tcl_CmdInfo)(unsafe.Pointer(bp)).FobjClientData
		*(*uintptr)(unsafe.Pointer(ppDb)) = (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb
		return TCL_OK
	}
	return TCL_ERROR
}

func f5tResultToErrorCode(tls *libc.TLS, zRes uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*[4]ErrorCode)(unsafe.Pointer(bp)) = [4]ErrorCode{
		{Frc: SQLITE_DONE, FzError: ts + 2102},
		{Frc: SQLITE_ERROR, FzError: ts + 2114},
		{FzError: ts + 2127},
		{FzError: ts + 584},
	}
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof([4]ErrorCode{}))/uint32(unsafe.Sizeof(ErrorCode{})); i++ {
		if 0 == sqlite3.Xsqlite3_stricmp(tls, zRes, (*ErrorCode)(unsafe.Pointer(bp+uintptr(i)*8)).FzError) {
			return (*ErrorCode)(unsafe.Pointer(bp + uintptr(i)*8)).Frc
		}
	}

	return SQLITE_ERROR
}

type ErrorCode = struct {
	Frc     int32
	FzError uintptr
}

func f5tDbAndApi(tls *libc.TLS, interp uintptr, pObj uintptr, ppDb uintptr, ppApi uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	*(*uintptr)(unsafe.Pointer(bp + 48)) = uintptr(0)
	var rc int32 = f5tDbPointer(tls, interp, pObj, bp+48)
	if rc != TCL_OK {
		return TCL_ERROR
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 52)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 56)) = uintptr(0)

		rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), ts+2137, -1, bp+52, uintptr(0))
		if rc != SQLITE_OK {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2153, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 48))), 0))
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_bind_pointer(tls, *(*uintptr)(unsafe.Pointer(bp + 52)), 1, bp+56, ts+2161, uintptr(0))
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 52)))

		if sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 52))) != SQLITE_OK {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+2153, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 48))), 0))
			return TCL_ERROR
		}

		*(*uintptr)(unsafe.Pointer(ppDb)) = *(*uintptr)(unsafe.Pointer(bp + 48))
		*(*uintptr)(unsafe.Pointer(ppApi)) = *(*uintptr)(unsafe.Pointer(bp + 56))
	}

	return TCL_OK
}

type F5tFunction1 = struct {
	Finterp  uintptr
	FpScript uintptr
}

type F5tFunction = F5tFunction1

type F5tApi1 = struct {
	FpApi uintptr
	FpFts uintptr
}

type F5tApi = F5tApi1

type F5tAuxData1 = struct{ FpObj uintptr }

type F5tAuxData = F5tAuxData1

func xTokenizeCb(tls *libc.TLS, pCtx uintptr, tflags int32, zToken uintptr, nToken int32, iStart int32, iEnd int32) int32 {
	var p uintptr = pCtx
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	var rc int32

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zToken, nToken))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, iStart))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, iEnd))

	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc == TCL_OK {
		rc = f5tResultToErrorCode(tls, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp))
	}

	return rc
}

func xQueryPhraseCb(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var p uintptr = pCtx
	var pEval uintptr
	var rc int32

	(*F5tApi)(unsafe.Pointer(bp + 72)).FpApi = pApi
	(*F5tApi)(unsafe.Pointer(bp + 72)).FpFts = pFts
	libc.Xsprintf(tls, bp+8, ts+2174, libc.VaList(bp, libc.PostIncInt64(&iCmd1, 1)))
	tcl.XTcl_CreateObjCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{xF5tApi})), bp+72, uintptr(0))

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, bp+8, -1))
	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8)

	if rc == TCL_OK {
		rc = f5tResultToErrorCode(tls, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp))
	}

	return rc
}

var iCmd1 sqlite3_int64 = int64(0)

func xSetAuxdataDestructor(tls *libc.TLS, p uintptr) {
	var pData uintptr = p
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*F5tAuxData)(unsafe.Pointer(pData)).FpObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, pData)
}

func xF5tApi(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(400)
	defer tls.Free(400)

	*(*[19]Sub)(unsafe.Pointer(bp + 32)) = [19]Sub{
		{FzName: ts + 2185, FzMsg: ts + 584},
		{FzName: ts + 2198, FzMsg: ts + 584},
		{FzName: ts + 2208, FnArg: 1, FzMsg: ts + 2225},
		{FzName: ts + 2229, FnArg: 2, FzMsg: ts + 2239},
		{FzName: ts + 2251, FzMsg: ts + 584},
		{FzName: ts + 2264, FnArg: 1, FzMsg: ts + 2276},
		{FzName: ts + 2283, FzMsg: ts + 584},
		{FzName: ts + 2294, FnArg: 1, FzMsg: ts + 2300},
		{FzName: ts + 2304, FzMsg: ts + 584},
		{FzName: ts + 2311, FnArg: 1, FzMsg: ts + 2225},
		{FzName: ts + 2323, FnArg: 1, FzMsg: ts + 2225},
		{FzName: ts + 2335, FnArg: 2, FzMsg: ts + 2348},
		{FzName: ts + 2362, FnArg: 1, FzMsg: ts + 2374},
		{FzName: ts + 2380, FnArg: 1, FzMsg: ts + 2392},
		{FzName: ts + 2398, FnArg: 1, FzMsg: ts + 2413},
		{FzName: ts + 2421, FnArg: 1, FzMsg: ts + 2392},
		{FzName: ts + 2436, FnArg: 4, FzMsg: ts + 2451},
		{FzName: ts + 2480, FnArg: 3, FzMsg: ts + 2501},
		{},
	}
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 260)) = 0
	var p uintptr = clientData

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2523)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+32, int32(unsafe.Sizeof(Sub{})), ts+2523, 0, bp+260)
	if rc != TCL_OK {
		return rc
	}
	if (*Sub)(unsafe.Pointer(bp+32+uintptr(*(*int32)(unsafe.Pointer(bp + 260)))*12)).FnArg != objc-2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, (*Sub)(unsafe.Pointer(bp+32+uintptr(*(*int32)(unsafe.Pointer(bp + 260)))*12)).FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 260)) {
	case 0:
		{
			var nCol int32
			nCol = (*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nCol))
			}
			break

		}
	case 1:
		{
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxRowCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+264)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 264))))
			}
			break

		}
	case 2:
		{
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+272) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnTotalSize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 272)), bp+276)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 276))))
			}
			break

		}
	case 3:
		{
			var zText uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+284)

			(*F5tFunction)(unsafe.Pointer(bp + 288)).Finterp = interp
			(*F5tFunction)(unsafe.Pointer(bp + 288)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxTokenize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, zText, *(*int32)(unsafe.Pointer(bp + 284)), bp+288, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
			}{xTokenizeCb})))
			if rc == SQLITE_OK {
				tcl.XTcl_ResetResult(tls, interp)
			}
			return rc

		}
	case 4:
		{
			var nPhrase int32
			nPhrase = (*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nPhrase))
			}
			break

		}
	case 5:
		{
			var sz int32
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+296) != 0 {
				return TCL_ERROR
			}
			sz = (*struct {
				f func(*libc.TLS, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseSize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 296)))
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sz))
			}
			break

		}
	case 6:
		{
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxInstCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+300)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 300))))
			}
			break

		}
	case 7:
		{
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+304) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxInst})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 304)), bp+308, bp+312, bp+316)
			if rc == SQLITE_OK {
				var pList uintptr = tcl.XTcl_NewObj(tls)
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 308))))
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 312))))
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 316))))
				tcl.XTcl_SetObjResult(tls, interp, pList)
			}
			break

		}
	case 8:
		{
			var iRowid sqlite3_int64 = (*struct {
				f func(*libc.TLS, uintptr) sqlite3_int64
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxRowid})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, iRowid))
			break

		}
	case 9:
		{
			*(*uintptr)(unsafe.Pointer(bp + 324)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 328)) = 0

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+320) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnText})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 320)), bp+324, bp+328)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 324)), *(*int32)(unsafe.Pointer(bp + 328))))
			}
			break

		}
	case 10:
		{
			*(*int32)(unsafe.Pointer(bp + 336)) = 0

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+332) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnSize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 332)), bp+336)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 336))))
			}
			break

		}
	case 11:
		{
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+340) != 0 {
				return TCL_ERROR
			}
			(*F5tFunction)(unsafe.Pointer(bp + 344)).Finterp = interp
			(*F5tFunction)(unsafe.Pointer(bp + 344)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxQueryPhrase})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 340)), bp+344, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{xQueryPhraseCb})))
			if rc == SQLITE_OK {
				tcl.XTcl_ResetResult(tls, interp)
			}
			break

		}
	case 12:
		{
			var pData uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(F5tAuxData{})))
			if pData == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2069, 0))
				return TCL_ERROR
			}
			(*F5tAuxData)(unsafe.Pointer(pData)).FpObj = *(*uintptr)(unsafe.Pointer(objv + 2*4))
			(*Tcl_Obj)(unsafe.Pointer((*F5tAuxData)(unsafe.Pointer(pData)).FpObj)).FrefCount++
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxSetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, pData, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{xSetAuxdataDestructor})))
			break

		}
	case 13:
		{
			var pData uintptr

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+352) != 0 {
				return TCL_ERROR
			}
			pData = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxGetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 352)))
			if pData == uintptr(0) {
				tcl.XTcl_ResetResult(tls, interp)
			} else {
				tcl.XTcl_SetObjResult(tls, interp, (*F5tAuxData)(unsafe.Pointer(pData)).FpObj)
				if *(*int32)(unsafe.Pointer(bp + 352)) != 0 {
					xSetAuxdataDestructor(tls, pData)
				}
			}
			break

		}

	case 14:
		{
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+356) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxSetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, uintptr(0)+uintptr(*(*int32)(unsafe.Pointer(bp + 356))), uintptr(0))
			break

		}
	case 15:
		{
			var iVal int32

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+360) != 0 {
				return TCL_ERROR
			}
			iVal = (int32((*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxGetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 360)))) - int32(uintptr(0))) / 1
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iVal))
			break

		}

	case 16:
		{
			var zColvar uintptr
			var zOffvar uintptr
			var pScript uintptr = *(*uintptr)(unsafe.Pointer(objv + 5*4))

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+364) != 0 {
				return TCL_ERROR
			}
			zColvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			zOffvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))

			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseFirst})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 364)), bp+368, bp+376, bp+380)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3ErrName(tls, rc), 0))
				return TCL_ERROR
			}
			for ; *(*int32)(unsafe.Pointer(bp + 376)) >= 0; (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseNext})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+368, bp+376, bp+380) {
				tcl.XTcl_SetVar2Ex(tls, interp, zColvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 376))), 0)
				tcl.XTcl_SetVar2Ex(tls, interp, zOffvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 380))), 0)
				rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
				if rc == TCL_CONTINUE {
					rc = TCL_OK
				}
				if rc != TCL_OK {
					if rc == TCL_BREAK {
						rc = TCL_OK
					}
					break
				}
			}

			break

		}

	case 17:
		{
			var zColvar uintptr
			var pScript uintptr = *(*uintptr)(unsafe.Pointer(objv + 4*4))

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+384) != 0 {
				return TCL_ERROR
			}
			zColvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))

			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseFirstColumn})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 384)), bp+388, bp+396)
			if rc != SQLITE_OK {
				tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
				return TCL_ERROR
			}
			for ; *(*int32)(unsafe.Pointer(bp + 396)) >= 0; (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseNextColumn})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+388, bp+396) {
				tcl.XTcl_SetVar2Ex(tls, interp, zColvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 396))), 0)
				rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
				if rc == TCL_CONTINUE {
					rc = TCL_OK
				}
				if rc != TCL_OK {
					if rc == TCL_BREAK {
						rc = TCL_OK
					}
					break
				}
			}

			break

		}

	default:
		break
	}

	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}

	return TCL_OK
}

type Sub = struct {
	FzName uintptr
	FnArg  int32
	FzMsg  uintptr
}

func xF5tFunction(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, nVal int32, apVal uintptr) {
	bp := tls.Alloc(100)
	defer tls.Free(100)

	var p uintptr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxUserData})).f(tls, pFts)
	var pEval uintptr
	var i int32
	var rc int32

	(*F5tApi)(unsafe.Pointer(bp + 72)).FpApi = pApi
	(*F5tApi)(unsafe.Pointer(bp + 72)).FpFts = pFts

	libc.Xsprintf(tls, bp+8, ts+2535, libc.VaList(bp, libc.PostIncInt64(&iCmd2, 1)))
	tcl.XTcl_CreateObjCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{xF5tApi})), bp+72, uintptr(0))
	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, bp+8, -1))

	for i = 0; i < nVal; i++ {
		var pObj uintptr = uintptr(0)
		switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))) {
		case SQLITE_TEXT:
			pObj = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))), -1)
			break
		case SQLITE_BLOB:
			pObj = tcl.XTcl_NewByteArrayObj(tls,
				sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))), sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))))
			break
		case SQLITE_INTEGER:
			pObj = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))))
			break
		case SQLITE_FLOAT:
			pObj = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))))
			break
		default:
			pObj = tcl.XTcl_NewObj(tls)
			break
		}
		tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, pObj)
	}

	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, TCL_GLOBAL_ONLY)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8)

	if rc != TCL_OK {
		sqlite3.Xsqlite3_result_error(tls, pCtx, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp), -1)
	} else {
		var pVar uintptr = tcl.XTcl_GetObjResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp)

		var zType uintptr = func() uintptr {
			if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
				return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
			}
			return ts + 584
		}()
		var c int8 = *(*int8)(unsafe.Pointer(zType))
		if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2544) == 0 && (*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0) {
			var data uintptr = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+80)
			sqlite3.Xsqlite3_result_blob(tls, pCtx, data, *(*int32)(unsafe.Pointer(bp + 80)), libc.UintptrFromInt32(-1))
		} else if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2554) == 0 {
			tcl.XTcl_GetIntFromObj(tls, uintptr(0), pVar, bp+80)
			sqlite3.Xsqlite3_result_int(tls, pCtx, *(*int32)(unsafe.Pointer(bp + 80)))
		} else if int32(c) == 'd' && libc.Xstrcmp(tls, zType, ts+2562) == 0 {
			tcl.XTcl_GetDoubleFromObj(tls, uintptr(0), pVar, bp+84)
			sqlite3.Xsqlite3_result_double(tls, pCtx, *(*float64)(unsafe.Pointer(bp + 84)))
		} else if int32(c) == 'w' && libc.Xstrcmp(tls, zType, ts+2569) == 0 || int32(c) == 'i' && libc.Xstrcmp(tls, zType, ts+2577) == 0 {
			tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), pVar, bp+92)
			sqlite3.Xsqlite3_result_int64(tls, pCtx, *(*Tcl_WideInt)(unsafe.Pointer(bp + 92)))
		} else {
			var data uintptr = tcl.XTcl_GetStringFromObj(tls, pVar, bp+80)
			sqlite3.Xsqlite3_result_text(tls, pCtx, data, *(*int32)(unsafe.Pointer(bp + 80)), libc.UintptrFromInt32(-1))
		}
	}
}

var iCmd2 sqlite3_int64 = int64(0)

func xF5tDestroy(tls *libc.TLS, pCtx uintptr) {
	var p uintptr = pCtx
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*F5tFunction)(unsafe.Pointer(p)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, p)
}

func f5tCreateFunction(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zName uintptr
	var pScript uintptr
	*(*uintptr)(unsafe.Pointer(bp + 24)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 28)) = uintptr(0)
	var pCtx uintptr = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2581)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+24, bp+28) != 0 {
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
	pCtx = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tFunction{})))
	(*F5tFunction)(unsafe.Pointer(pCtx)).Finterp = interp
	(*F5tFunction)(unsafe.Pointer(pCtx)).FpScript = pScript
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, fts5_extension_function, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 28)))).FxCreateFunction})).f(tls,
		*(*uintptr)(unsafe.Pointer(bp + 28)), zName, pCtx, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr)
		}{xF5tFunction})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{xF5tDestroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2153, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 24))), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

type F5tTokenizeCtx1 = struct {
	FpRet   uintptr
	FbSubst int32
	FzInput uintptr
}

type F5tTokenizeCtx = F5tTokenizeCtx1

func xTokenizeCb2(tls *libc.TLS, pCtx uintptr, tflags int32, zToken uintptr, nToken int32, iStart int32, iEnd int32) int32 {
	var p uintptr = pCtx
	if (*F5tTokenizeCtx)(unsafe.Pointer(p)).FbSubst != 0 {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, zToken, nToken))
		tcl.XTcl_ListObjAppendElement(tls,
			uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, (*F5tTokenizeCtx)(unsafe.Pointer(p)).FzInput+uintptr(iStart), iEnd-iStart))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, zToken, nToken))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewIntObj(tls, iStart))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewIntObj(tls, iEnd))
	}
	return SQLITE_OK
}

func f5tTokenize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(148)
	defer tls.Free(148)

	var zText uintptr

	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 100)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 132)) = uintptr(0)

	var pRet uintptr = uintptr(0)

	var rc int32

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2596)
		return TCL_ERROR
	}
	if objc == 5 {
		var zOpt uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
		if libc.Xstrcmp(tls, ts+2618, zOpt) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2625, zOpt, 0))
			return TCL_ERROR
		}
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*4)), bp+96, bp+100) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_SplitList(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*4))), bp+104, bp+108) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 104)) == 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+2647, 0))
		tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(bp + 108)))
		return TCL_ERROR
	}
	zText = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4)), bp+112)

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 100)))).FxFindTokenizer})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 100)), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 108)))), bp+116, bp+120)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+2647, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 108)))), 0))
		return TCL_ERROR
	}

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_tokenizer)(unsafe.Pointer(bp + 120)).FxCreate})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 116)), *(*uintptr)(unsafe.Pointer(bp + 108))+1*4, *(*int32)(unsafe.Pointer(bp + 104))-1, bp+132)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, ts+2667, 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 136)).FbSubst = libc.Bool32(objc == 5)
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 136)).FpRet = pRet
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 136)).FzInput = zText
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_tokenizer)(unsafe.Pointer(bp + 120)).FxTokenize})).f(tls,
		*(*uintptr)(unsafe.Pointer(bp + 132)), bp+136, FTS5_TOKENIZE_DOCUMENT, zText, *(*int32)(unsafe.Pointer(bp + 112)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
		}{xTokenizeCb2})))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*fts5_tokenizer)(unsafe.Pointer(bp + 120)).FxDelete})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 132)))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+80, ts+2696, 0))
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pRet
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		return TCL_ERROR
	}

	tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(bp + 108)))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return TCL_OK
}

type F5tTokenizerContext1 = struct {
	FpCtx   uintptr
	FxToken uintptr
}

type F5tTokenizerContext = F5tTokenizerContext1
type F5tTokenizerModule1 = struct {
	Finterp   uintptr
	FpScript  uintptr
	FpContext uintptr
}

type F5tTokenizerModule = F5tTokenizerModule1
type F5tTokenizerInstance1 = struct {
	Finterp   uintptr
	FpScript  uintptr
	FpContext uintptr
}

type F5tTokenizerInstance = F5tTokenizerInstance1

func f5tTokenizerCreate(tls *libc.TLS, pCtx uintptr, azArg uintptr, nArg int32, ppOut uintptr) int32 {
	var pMod uintptr = pCtx
	var pEval uintptr
	var rc int32 = TCL_OK
	var i int32

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	for i = 0; rc == TCL_OK && i < nArg; i++ {
		var pObj uintptr = tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4)), -1)
		rc = tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp, pEval, pObj)
	}

	if rc == TCL_OK {
		rc = tcl.XTcl_EvalObjEx(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp, pEval, TCL_GLOBAL_ONLY)
	}
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	if rc == TCL_OK {
		var pInst uintptr
		pInst = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerInstance{})))
		libc.Xmemset(tls, pInst, 0, uint32(unsafe.Sizeof(F5tTokenizerInstance{})))
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript = tcl.XTcl_GetObjResult(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp)
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpContext
		(*Tcl_Obj)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript)).FrefCount++
		*(*uintptr)(unsafe.Pointer(ppOut)) = pInst
	}

	return rc
}

func f5tTokenizerDelete(tls *libc.TLS, p uintptr) {
	var pInst uintptr = p
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pInst)
}

func f5tTokenizerTokenize(tls *libc.TLS, p uintptr, pCtx uintptr, flags int32, pText uintptr, nText int32, xToken uintptr) int32 {
	var pInst uintptr = p
	var pOldCtx uintptr
	var xOldToken uintptr
	var pEval uintptr
	var rc int32
	var zFlags uintptr

	pOldCtx = (*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx
	xOldToken = (*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken

	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx = pCtx
	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken = xToken

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	switch flags {
	case FTS5_TOKENIZE_DOCUMENT:
		zFlags = ts + 2727
		break
	case FTS5_TOKENIZE_AUX:
		zFlags = ts + 2736
		break
	case FTS5_TOKENIZE_QUERY:
		zFlags = ts + 2740
		break
	case FTS5_TOKENIZE_PREFIX | FTS5_TOKENIZE_QUERY:
		zFlags = ts + 2746
		break
	default:
		zFlags = ts + 2758
		break
	}

	tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zFlags, -1))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, pText, nText))
	rc = tcl.XTcl_EvalObjEx(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, TCL_GLOBAL_ONLY)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx = pOldCtx
	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken = xOldToken
	return rc
}

func f5tTokenizerReturn(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr

	var tflags int32
	var zToken uintptr
	var rc int32

	var zArg uintptr
	p = clientData
	tflags = 0

	if !(objc == 5) {
		goto __1
	}
	zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16)
	if !(*(*int32)(unsafe.Pointer(bp + 16)) <= 10 && *(*int32)(unsafe.Pointer(bp + 16)) >= 2 && libc.Xmemcmp(tls, ts+2766, zArg, uint32(*(*int32)(unsafe.Pointer(bp + 16)))) == 0) {
		goto __3
	}
	tflags = tflags | FTS5_TOKEN_COLOCATED
	goto __4
__3:
	goto usage
__4:
	;
	goto __2
__1:
	if !(objc != 4) {
		goto __5
	}
	goto usage
__5:
	;
__2:
	;
	zToken = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*4)), bp+20)
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*4)), bp+24) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4)), bp+28) != 0) {
		goto __6
	}
	return TCL_ERROR
__6:
	;
	if !((*F5tTokenizerContext)(unsafe.Pointer(p)).FxToken == uintptr(0)) {
		goto __7
	}
	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp, ts+2777, 0))
	return TCL_ERROR
__7:
	;
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*F5tTokenizerContext)(unsafe.Pointer(p)).FxToken})).f(tls, (*F5tTokenizerContext)(unsafe.Pointer(p)).FpCtx, tflags, zToken, *(*int32)(unsafe.Pointer(bp + 20)), *(*int32)(unsafe.Pointer(bp + 24)), *(*int32)(unsafe.Pointer(bp + 28)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	if rc == SQLITE_OK {
		return TCL_OK
	}
	return TCL_ERROR

usage:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2835)
	return TCL_ERROR
}

func f5tDelTokenizer(tls *libc.TLS, pCtx uintptr) {
	var pMod uintptr = pCtx
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pMod)
}

func f5tCreateTokenizer(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pContext uintptr = clientData

	var zName uintptr
	var pScript uintptr

	var pMod uintptr
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2581)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16, bp+20) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))

	(*fts5_tokenizer)(unsafe.Pointer(bp + 24)).FxCreate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{f5tTokenizerCreate}))
	(*fts5_tokenizer)(unsafe.Pointer(bp + 24)).FxTokenize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	}{f5tTokenizerTokenize}))
	(*fts5_tokenizer)(unsafe.Pointer(bp + 24)).FxDelete = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{f5tTokenizerDelete}))

	pMod = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerModule{})))
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp = interp
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript = pScript
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpContext = pContext
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20)))).FxCreateTokenizer})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), zName, pMod, bp+24, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{f5tDelTokenizer})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2863, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func xF5tFree(tls *libc.TLS, clientData ClientData) {
	tcl.XTcl_Free(tls, clientData)
}

func f5tMayBeCorrupt(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	return TCL_OK
}

func f5t_fts5HashKey(tls *libc.TLS, nSlot int32, p uintptr, n int32) uint32 {
	var i int32
	var h uint32 = uint32(13)
	for i = n - 1; i >= 0; i-- {
		h = h<<3 ^ h ^ uint32(*(*int8)(unsafe.Pointer(p + uintptr(i))))
	}
	return h % uint32(nSlot)
}

func f5tTokenHash(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr

	var iVal uint32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2900)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	z = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4)

	iVal = f5t_fts5HashKey(tls, *(*int32)(unsafe.Pointer(bp)), z, *(*int32)(unsafe.Pointer(bp + 4)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(iVal)))
	return TCL_OK
}

func f5tRegisterMatchinfo(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if f5tDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3Fts5TestRegisterMatchinfo(tls, *(*uintptr)(unsafe.Pointer(bp)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

func f5tRegisterTok(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 4)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp, bp+4) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3Fts5TestRegisterTok(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*uintptr)(unsafe.Pointer(bp + 4)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

func Fts5tcl_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	var pContext uintptr

	pContext = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerContext{})))
	libc.Xmemset(tls, pContext, 0, uint32(unsafe.Sizeof(F5tTokenizerContext{})))

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd))/uint32(unsafe.Sizeof(struct {
		FzName        uintptr
		FxProc        uintptr
		FbTokenizeCtx int32
	}{})); i++ {
		var p uintptr = uintptr(unsafe.Pointer(&aCmd)) + uintptr(i)*12
		var pCtx uintptr = uintptr(0)
		if (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
		})(unsafe.Pointer(p)).FbTokenizeCtx != 0 {
			pCtx = pContext
		}
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
		})(unsafe.Pointer(p)).FzName, (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
		})(unsafe.Pointer(p)).FxProc, pCtx, func() uintptr {
			if i != 0 {
				return uintptr(0)
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{xF5tFree}))
		}())
	}

	return TCL_OK
}

var aCmd = [8]struct {
	FzName        uintptr
	FxProc        uintptr
	FbTokenizeCtx int32
}{
	{FzName: ts + 2912, FxProc: 0, FbTokenizeCtx: 1},
	{FzName: ts + 2942, FxProc: 0, FbTokenizeCtx: 1},
	{FzName: ts + 2961, FxProc: 0},
	{FzName: ts + 2983, FxProc: 0},
	{FzName: ts + 3012, FxProc: 0},
	{FzName: ts + 3040, FxProc: 0},
	{FzName: ts + 3064, FxProc: 0},
	{FzName: ts + 3096, FxProc: 0},
}

type Fts5MatchinfoCtx1 = struct {
	FnCol    int32
	FnPhrase int32
	FzArg    uintptr
	FnRet    int32
	FaRet    uintptr
}

type Fts5MatchinfoCtx = Fts5MatchinfoCtx1

type u32 = uint32

func fts5_api_from_db(tls *libc.TLS, db uintptr, ppApi uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	var rc int32

	*(*uintptr)(unsafe.Pointer(ppApi)) = uintptr(0)
	rc = sqlite3.Xsqlite3_prepare(tls, db, ts+2137, -1, bp, uintptr(0))
	if rc == SQLITE_OK {
		sqlite3.Xsqlite3_bind_pointer(tls, *(*uintptr)(unsafe.Pointer(bp)), 1, ppApi, ts+2161, uintptr(0))
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp)))
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp)))
	}

	return rc
}

func fts5MatchinfoFlagsize(tls *libc.TLS, nCol int32, nPhrase int32, f int8) int32 {
	var ret int32 = -1
	switch int32(f) {
	case 'p':
		ret = 1
		break
	case 'c':
		ret = 1
		break
	case 'x':
		ret = 3 * nCol * nPhrase
		break
	case 'y':
		ret = nCol * nPhrase
		break
	case 'b':
		ret = (nCol + 31) / 32 * nPhrase
		break
	case 'n':
		ret = 1
		break
	case 'a':
		ret = nCol
		break
	case 'l':
		ret = nCol
		break
	case 's':
		ret = nCol
		break
	}
	return ret
}

func fts5MatchinfoIter(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, x uintptr) int32 {
	var i int32
	var n int32 = 0
	var rc int32 = SQLITE_OK
	var f int8
	for i = 0; libc.AssignInt8(&f, *(*int8)(unsafe.Pointer((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg + uintptr(i)))) != 0; i++ {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{x})).f(tls, pApi, pFts, p, f, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet+uintptr(n)*4)
		if rc != SQLITE_OK {
			break
		}
		n = n + fts5MatchinfoFlagsize(tls, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase, f)
	}
	return rc
}

func fts5MatchinfoXCb(tls *libc.TLS, pApi uintptr, pFts uintptr, pUserData uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var aOut uintptr = pUserData
	var iPrev int32 = -1

	for (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseFirst})).f(tls, pFts, 0, bp, bp+8, bp+12); *(*int32)(unsafe.Pointer(bp + 8)) >= 0; (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseNext})).f(tls, pFts, bp, bp+8, bp+12) {
		*(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 8))*3+1)*4))++
		if *(*int32)(unsafe.Pointer(bp + 8)) != iPrev {
			*(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 8))*3+2)*4))++
		}
		iPrev = *(*int32)(unsafe.Pointer(bp + 8))
	}

	return SQLITE_OK
}

func fts5MatchinfoGlobalCb(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, f int8, aOut uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	switch int32(f) {
	case 'p':
		*(*u32)(unsafe.Pointer(aOut)) = u32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase)
		break

	case 'c':
		*(*u32)(unsafe.Pointer(aOut)) = u32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol)
		break

	case 'x':
		{
			var i int32
			for i = 0; i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase && rc == SQLITE_OK; i++ {
				var pPtr uintptr = aOut + uintptr(i*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol*3)*4
				rc = (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxQueryPhrase})).f(tls, pFts, i, pPtr, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				}{fts5MatchinfoXCb})))
			}
			break

		}

	case 'n':
		{
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxRowCount})).f(tls, pFts, bp)
			*(*u32)(unsafe.Pointer(aOut)) = u32(*(*sqlite3_int64)(unsafe.Pointer(bp)))
			break

		}

	case 'a':
		{
			*(*sqlite3_int64)(unsafe.Pointer(bp + 8)) = int64(0)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxRowCount})).f(tls, pFts, bp+8)
			if *(*sqlite3_int64)(unsafe.Pointer(bp + 8)) == int64(0) {
				libc.Xmemset(tls, aOut, 0, uint32(unsafe.Sizeof(u32(0)))*uint32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol))
			} else {
				var i int32
				for i = 0; rc == SQLITE_OK && i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol; i++ {
					rc = (*struct {
						f func(*libc.TLS, uintptr, int32, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxColumnTotalSize})).f(tls, pFts, i, bp+16)
					if rc == SQLITE_OK {
						*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32((int64(2)**(*sqlite3_int64)(unsafe.Pointer(bp + 16)) + *(*sqlite3_int64)(unsafe.Pointer(bp + 8))) / (int64(2) * *(*sqlite3_int64)(unsafe.Pointer(bp + 8))))
					}
				}
			}
			break

		}

	}
	return rc
}

func fts5MatchinfoLocalCb(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, f int8, aOut uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var i int32
	var rc int32 = SQLITE_OK

	switch int32(f) {
	case 'b':
		{
			var iPhrase int32
			var nInt int32 = ((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol + 31) / 32 * (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase
			for i = 0; i < nInt; i++ {
				*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32(0)
			}

			for iPhrase = 0; iPhrase < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; iPhrase++ {
				for (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseFirstColumn})).f(tls, pFts, iPhrase, bp, bp+8); *(*int32)(unsafe.Pointer(bp + 8)) >= 0; (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseNextColumn})).f(tls, pFts, bp, bp+8) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(iPhrase*(((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol+31)/32)+*(*int32)(unsafe.Pointer(bp + 8))/32)*4)) |= u32(1) << (*(*int32)(unsafe.Pointer(bp + 8)) % 32)
				}
			}

			break

		}

	case 'x':
		fallthrough
	case 'y':
		{
			var nMul int32 = func() int32 {
				if int32(f) == 'x' {
					return 3
				}
				return 1
			}()
			var iPhrase int32

			for i = 0; i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; i++ {
				*(*u32)(unsafe.Pointer(aOut + uintptr(i*nMul)*4)) = u32(0)
			}

			for iPhrase = 0; iPhrase < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; iPhrase++ {
				for (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseFirst})).f(tls, pFts, iPhrase, bp+12, bp+20, bp+24); *(*int32)(unsafe.Pointer(bp + 24)) >= 0; (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseNext})).f(tls, pFts, bp+12, bp+20, bp+24) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(nMul*(*(*int32)(unsafe.Pointer(bp + 20))+iPhrase*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol))*4))++
				}
			}

			break

		}

	case 'l':
		{
			for i = 0; rc == SQLITE_OK && i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol; i++ {
				rc = (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxColumnSize})).f(tls, pFts, i, bp+28)
				*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32(*(*int32)(unsafe.Pointer(bp + 28)))
			}
			break

		}

	case 's':
		{
			libc.Xmemset(tls, aOut, 0, uint32(unsafe.Sizeof(u32(0)))*uint32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol))

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxInstCount})).f(tls, pFts, bp+32)
			for i = 0; rc == SQLITE_OK && i < *(*int32)(unsafe.Pointer(bp + 32)); i++ {
				*(*int32)(unsafe.Pointer(bp + 40)) = 0
				var iNextPhrase int32
				var iNextOff int32
				var nSeq u32 = u32(1)
				var j int32

				rc = (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxInst})).f(tls, pFts, i, bp+36, bp+40, bp+44)
				iNextPhrase = *(*int32)(unsafe.Pointer(bp + 36)) + 1
				iNextOff = *(*int32)(unsafe.Pointer(bp + 44)) + (*struct {
					f func(*libc.TLS, uintptr, int32) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseSize})).f(tls, pFts, 0)
				for j = i + 1; rc == SQLITE_OK && j < *(*int32)(unsafe.Pointer(bp + 32)); j++ {
					rc = (*struct {
						f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxInst})).f(tls, pFts, j, bp+48, bp+52, bp+56)
					if *(*int32)(unsafe.Pointer(bp + 52)) != *(*int32)(unsafe.Pointer(bp + 40)) || *(*int32)(unsafe.Pointer(bp + 56)) > iNextOff {
						break
					}
					if *(*int32)(unsafe.Pointer(bp + 48)) == iNextPhrase && *(*int32)(unsafe.Pointer(bp + 56)) == iNextOff {
						nSeq++
						iNextPhrase = *(*int32)(unsafe.Pointer(bp + 48)) + 1
						iNextOff = *(*int32)(unsafe.Pointer(bp + 56)) + (*struct {
							f func(*libc.TLS, uintptr, int32) int32
						})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseSize})).f(tls, pFts, *(*int32)(unsafe.Pointer(bp + 48)))
					}
				}

				if nSeq > *(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 40)))*4)) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 40)))*4)) = nSeq
				}
			}

			break

		}
	}
	return rc
}

func fts5MatchinfoNew(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, zArg uintptr) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var nCol int32
	var nPhrase int32
	var i int32
	var nInt int32
	var nByte sqlite3_int64
	var rc int32

	nCol = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxColumnCount})).f(tls, pFts)
	nPhrase = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseCount})).f(tls, pFts)

	nInt = 0
	for i = 0; *(*int8)(unsafe.Pointer(zArg + uintptr(i))) != 0; i++ {
		var n int32 = fts5MatchinfoFlagsize(tls, nCol, nPhrase, *(*int8)(unsafe.Pointer(zArg + uintptr(i))))
		if n < 0 {
			var zErr uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+3131, libc.VaList(bp, int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i))))))
			sqlite3.Xsqlite3_result_error(tls, pCtx, zErr, -1)
			sqlite3.Xsqlite3_free(tls, zErr)
			return uintptr(0)
		}
		nInt = nInt + n
	}

	nByte = sqlite3_int64(uint32(unsafe.Sizeof(Fts5MatchinfoCtx{})) +
		uint32(unsafe.Sizeof(u32(0)))*uint32(nInt) +
		uint32(i+1))
	p = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if p == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return uintptr(0)
	}
	libc.Xmemset(tls, p, 0, uint32(nByte))

	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol = nCol
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase = nPhrase
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet = p + 1*20
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnRet = nInt
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg = (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet + uintptr(nInt)*4
	libc.Xmemcpy(tls, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg, zArg, uint32(i))

	rc = fts5MatchinfoIter(tls, pApi, pFts, p, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
	}{fts5MatchinfoGlobalCb})))
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
		sqlite3.Xsqlite3_free(tls, p)
		p = uintptr(0)
	}

	return p
}

func fts5MatchinfoFunc(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, nVal int32, apVal uintptr) {
	var zArg uintptr
	var p uintptr
	var rc int32 = SQLITE_OK

	if nVal > 0 {
		zArg = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	} else {
		zArg = ts + 3163
	}

	p = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxGetAuxdata})).f(tls, pFts, 0)
	if p == uintptr(0) || sqlite3.Xsqlite3_stricmp(tls, zArg, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg) != 0 {
		p = fts5MatchinfoNew(tls, pApi, pFts, pCtx, zArg)
		if p == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxSetAuxdata})).f(tls, pFts, p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}

	if rc == SQLITE_OK {
		rc = fts5MatchinfoIter(tls, pApi, pFts, p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
		}{fts5MatchinfoLocalCb})))
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	} else {
		var nByte int32 = int32(uint32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnRet) * uint32(unsafe.Sizeof(u32(0))))
		sqlite3.Xsqlite3_result_blob(tls, pCtx, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet, nByte, libc.UintptrFromInt32(-1))
	}
}

func sqlite3Fts5TestRegisterMatchinfo(tls *libc.TLS, db uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	rc = fts5_api_from_db(tls, db, bp)
	if rc != SQLITE_OK {
		return rc
	}

	if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) || (*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FiVersion < 2 {
		return SQLITE_ERROR
	}

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, fts5_extension_function, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FxCreateFunction})).f(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+3167, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr)
	}{fts5MatchinfoFunc})), uintptr(0))

	return rc
}

type Fts5tokTable1 = struct {
	Fbase sqlite3_vtab
	Ftok  fts5_tokenizer
	FpTok uintptr
}

type Fts5tokTable = Fts5tokTable1
type Fts5tokCursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FiRowid int32
	FzInput uintptr
	FnRow   int32
	FaRow   uintptr
}

type Fts5tokCursor = Fts5tokCursor1
type Fts5tokRow1 = struct {
	FzToken uintptr
	FiStart int32
	FiEnd   int32
	FiPos   int32
}

type Fts5tokRow = Fts5tokRow1

func fts5tokDequote(tls *libc.TLS, z uintptr) {
	var q int8 = *(*int8)(unsafe.Pointer(z))

	if int32(q) == '[' || int32(q) == '\'' || int32(q) == '"' || int32(q) == '`' {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}

		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(q) {
					iIn++
					break
				} else {
					iIn = iIn + 2
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
				}
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}

		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

func fts5tokDequoteArray(tls *libc.TLS, argc int32, argv uintptr, pazDequote uintptr) int32 {
	var rc int32 = SQLITE_OK
	if argc == 0 {
		*(*uintptr)(unsafe.Pointer(pazDequote)) = uintptr(0)
	} else {
		var i int32
		var nByte int32 = 0
		var azDequote uintptr

		for i = 0; i < argc; i++ {
			nByte = nByte + int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))+size_t(1))
		}

		*(*uintptr)(unsafe.Pointer(pazDequote)) = libc.AssignUintptr(&azDequote, sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(uintptr(0)))*uint32(argc)+uint32(nByte))))
		if azDequote == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			var pSpace uintptr = azDequote + uintptr(argc)*4
			for i = 0; i < argc; i++ {
				var n int32 = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
				*(*uintptr)(unsafe.Pointer(azDequote + uintptr(i)*4)) = pSpace
				libc.Xmemcpy(tls, pSpace, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), uint32(n+1))
				fts5tokDequote(tls, pSpace)
				pSpace += uintptr(n + 1)
			}
		}
	}

	return rc
}

func fts5tokConnectMethod(tls *libc.TLS, db uintptr, pCtx uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pApi uintptr = pCtx
	var pTab uintptr = uintptr(0)
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	var nDequote int32 = 0

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+3177)

	if rc == SQLITE_OK {
		nDequote = argc - 3
		rc = fts5tokDequoteArray(tls, nDequote, argv+3*4, bp)
	}

	if rc == SQLITE_OK {
		pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Fts5tokTable{})))
		if pTab == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(Fts5tokTable{})))
		}
	}

	if rc == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 4)) = uintptr(0)
		var zModule uintptr = uintptr(0)
		if nDequote > 0 {
			zModule = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))
		}

		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(pApi)).FxFindTokenizer})).f(tls, pApi, zModule, bp+4, pTab+12)
		if rc == SQLITE_OK {
			var azArg uintptr = func() uintptr {
				if nDequote > 1 {
					return *(*uintptr)(unsafe.Pointer(bp)) + 1*4
				}
				return uintptr(0)
			}()
			var nArg int32
			if nDequote > 0 {
				nArg = nDequote - 1
			} else {
				nArg = 0
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5tokTable)(unsafe.Pointer(pTab)).Ftok.FxCreate})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 4)), azArg, nArg, pTab+24)
		}
	}

	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, pTab)
		pTab = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	return rc
}

func fts5tokDisconnectMethod(tls *libc.TLS, pVtab uintptr) int32 {
	var pTab uintptr = pVtab
	if (*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Fts5tokTable)(unsafe.Pointer(pTab)).Ftok.FxDelete})).f(tls, (*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok)
	}
	sqlite3.Xsqlite3_free(tls, pTab)
	return SQLITE_OK
}

func fts5tokBestIndexMethod(tls *libc.TLS, pVTab uintptr, pInfo uintptr) int32 {
	var i int32

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pInfo)).FnConstraint; i++ {
		if (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).Fusable != 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FidxNum = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FestimatedCost = float64(1)
			return SQLITE_OK
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FidxNum = 0

	return SQLITE_OK
}

func fts5tokOpenMethod(tls *libc.TLS, pVTab uintptr, ppCsr uintptr) int32 {
	var pCsr uintptr

	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Fts5tokCursor{})))
	if pCsr == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint32(unsafe.Sizeof(Fts5tokCursor{})))

	*(*uintptr)(unsafe.Pointer(ppCsr)) = pCsr
	return SQLITE_OK
}

func fts5tokResetCursor(tls *libc.TLS, pCsr uintptr) {
	var i int32
	for i = 0; i < (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow; i++ {
		sqlite3.Xsqlite3_free(tls, (*Fts5tokRow)(unsafe.Pointer((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow+uintptr(i)*16)).FzToken)
	}
	sqlite3.Xsqlite3_free(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput)
	sqlite3.Xsqlite3_free(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput = uintptr(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow = uintptr(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow = 0
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid = 0
}

func fts5tokCloseMethod(tls *libc.TLS, pCursor uintptr) int32 {
	var pCsr uintptr = pCursor
	fts5tokResetCursor(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

func fts5tokNextMethod(tls *libc.TLS, pCursor uintptr) int32 {
	var pCsr uintptr = pCursor
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid++
	return SQLITE_OK
}

func fts5tokCb(tls *libc.TLS, pCtx uintptr, tflags int32, pToken uintptr, nToken int32, iStart int32, iEnd int32) int32 {
	var pCsr uintptr = pCtx
	var pRow uintptr

	if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow&((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow-1) == 0 {
		var nNew int32
		if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow != 0 {
			nNew = (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow * 2
		} else {
			nNew = 32
		}
		var aNew uintptr
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow, uint64(uint32(nNew)*uint32(unsafe.Sizeof(Fts5tokRow{}))))
		if aNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, aNew+uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)*16, 0, uint32(unsafe.Sizeof(Fts5tokRow{}))*uint32(nNew-(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow))
		(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow = aNew
	}

	pRow = (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow + uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)*16
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FiStart = iStart
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FiEnd = iEnd
	if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow != 0 {
		(*Fts5tokRow)(unsafe.Pointer(pRow)).FiPos = (*Fts5tokRow)(unsafe.Pointer(pRow+libc.UintptrFromInt32(-1)*16)).FiPos + func() int32 {
			if tflags&FTS5_TOKEN_COLOCATED != 0 {
				return 0
			}
			return 1
		}()
	}
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken = sqlite3.Xsqlite3_malloc(tls, nToken+1)
	if (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemcpy(tls, (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken, pToken, uint32(nToken))
	*(*int8)(unsafe.Pointer((*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken + uintptr(nToken))) = int8(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow++

	return SQLITE_OK
}

func fts5tokFilterMethod(tls *libc.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, nVal int32, apVal uintptr) int32 {
	var rc int32 = SQLITE_ERROR
	var pCsr uintptr = pCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab

	fts5tokResetCursor(tls, pCsr)
	if idxNum == 1 {
		var zByte uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
		var nByte int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))
		(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput = sqlite3.Xsqlite3_malloc(tls, nByte+1)
		if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			if nByte > 0 {
				libc.Xmemcpy(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput, zByte, uint32(nByte))
			}
			*(*int8)(unsafe.Pointer((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput + uintptr(nByte))) = int8(0)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5tokTable)(unsafe.Pointer(pTab)).Ftok.FxTokenize})).f(tls,
				(*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok, pCsr, 0, zByte, nByte, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
				}{fts5tokCb})))
		}
	}

	if rc != SQLITE_OK {
		return rc
	}
	return fts5tokNextMethod(tls, pCursor)
}

func fts5tokEofMethod(tls *libc.TLS, pCursor uintptr) int32 {
	var pCsr uintptr = pCursor
	return libc.Bool32((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid > (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)
}

func fts5tokColumnMethod(tls *libc.TLS, pCursor uintptr, pCtx uintptr, iCol int32) int32 {
	var pCsr uintptr = pCursor
	var pRow uintptr = (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow + uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid-1)*16

	switch iCol {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput, -1, libc.UintptrFromInt32(-1))
		break
	case 1:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken, -1, libc.UintptrFromInt32(-1))
		break
	case 2:
		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiStart)
		break
	case 3:
		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiEnd)
		break
	default:
		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiPos)
		break
	}
	return SQLITE_OK
}

func fts5tokRowidMethod(tls *libc.TLS, pCursor uintptr, pRowid uintptr) int32 {
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3_int64((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid)
	return SQLITE_OK
}

func sqlite3Fts5TestRegisterTok(tls *libc.TLS, db uintptr, pApi uintptr) int32 {
	var rc int32

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3235, uintptr(unsafe.Pointer(&fts5tok_module)), pApi)
	return rc
}

var fts5tok_module = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

type sqlite3_api_routines = sqlite3_api_routines1

type sqlite3_loadext_entry = uintptr

type rune_t = int32

type div_t = struct {
	Fquot int32
	Frem  int32
}

type ldiv_t = struct {
	Fquot int32
	Frem  int32
}

type lldiv_t = struct {
	Fquot int64
	Frem  int64
}

type constraint_handler_t = uintptr

type _RuneEntry = struct {
	F__min   int32
	F__max   int32
	F__map   int32
	F__types uintptr
}

type _RuneRange = struct {
	F__nranges int32
	F__ranges  uintptr
}

type _RuneLocale = struct {
	F__magic        [8]int8
	F__encoding     [32]int8
	F__sgetrune     uintptr
	F__sputrune     uintptr
	F__invalid_rune int32
	F__runetype     [256]uint32
	F__maplower     [256]int32
	F__mapupper     [256]int32
	F__runetype_ext _RuneRange
	F__maplower_ext _RuneRange
	F__mapupper_ext _RuneRange
	F__variable     uintptr
	F__variable_len int32
}

func __getCurrentRuneLocale(tls *libc.TLS) uintptr {
	if libc.X_ThreadRuneLocale != 0 {
		return libc.X_ThreadRuneLocale
	}
	return libc.X_CurrentRuneLocale
}

func __maskrune(tls *libc.TLS, _c int32, _f uint32) int32 {
	return int32(func() uint32 {
		if _c < 0 || _c >= int32(1)<<8 {
			return libc.X___runetype(tls, _c)
		}
		return *(*uint32)(unsafe.Pointer(__getCurrentRuneLocale(tls) + 52 + uintptr(_c)*4))
	}() & _f)
}

func __sbmaskrune(tls *libc.TLS, _c int32, _f uint32) int32 {
	if _c < 0 || _c >= libc.X__mb_sb_limit {
		return 0
	}
	return int32(*(*uint32)(unsafe.Pointer(__getCurrentRuneLocale(tls) + 52 + uintptr(_c)*4)) & _f)
}

func __sbistype(tls *libc.TLS, _c int32, _f uint32) int32 {
	return libc.BoolInt32(!!(__sbmaskrune(tls, _c, _f) != 0))
}

func __sbmaskrune_l(tls *libc.TLS, __c int32, __f uint32, __loc locale_t) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var runes uintptr = libc.X__runes_for_locale(tls, __loc, bp)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return 0
	}
	return int32(*(*uint32)(unsafe.Pointer(runes + 52 + uintptr(__c)*4)) & __f)
}

func __sbistype_l(tls *libc.TLS, __c int32, __f uint32, __loc locale_t) int32 {
	return libc.BoolInt32(!!(tcl.X__sbmaskrune_l(tls, __c, __f, __loc) != 0))
}

func isalnum_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_A|X_CTYPE_D|X_CTYPE_N), __l)
}

func isalpha_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_A), __l)
}

func isblank_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_B), __l)
}

func iscntrl_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_C), __l)
}

func isdigit_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_D), __l)
}

func isgraph_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_G), __l)
}

func ishexnumber_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_X), __l)
}

func isideogram_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_I), __l)
}

func islower_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_L), __l)
}

func isnumber_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_D|X_CTYPE_N), __l)
}

func isphonogram_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_Q), __l)
}

func isprint_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_R), __l)
}

func ispunct_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_P), __l)
}

func isrune_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, 0xFFFFFF00, __l)
}

func isspace_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_S), __l)
}

func isspecial_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_T), __l)
}

func isupper_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_U), __l)
}

func isxdigit_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbistype_l(tls, __c, uint32(X_CTYPE_X), __l)
}

func digittoint_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	return tcl.X__sbmaskrune_l(tls, __c, uint32(0xFF), __l)
}

func tolower_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var __runes uintptr = libc.X__runes_for_locale(tls, __l, bp)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return __c
	}
	return *(*int32)(unsafe.Pointer(__runes + 1076 + uintptr(__c)*4))
}

func toupper_l(tls *libc.TLS, __c int32, __l locale_t) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var __runes uintptr = libc.X__runes_for_locale(tls, __l, bp)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return __c
	}
	return *(*int32)(unsafe.Pointer(__runes + 2100 + uintptr(__c)*4))
}

type amatch_vtab1 = struct {
	Fbase       sqlite3_vtab
	FzClassName uintptr
	FzDb        uintptr
	FzSelf      uintptr
	FzCostTab   uintptr
	FzVocabTab  uintptr
	FzVocabWord uintptr
	FzVocabLang uintptr
	FpRule      uintptr
	FrIns       amatch_cost
	FrDel       amatch_cost
	FrSub       amatch_cost
	Fdb         uintptr
	FpVCheck    uintptr
	FnCursor    int32
}

type amatch_vtab = amatch_vtab1
type amatch_cursor1 = struct {
	Fbase      sqlite3_vtab_cursor
	FiRowid    sqlite3_int64
	FiLang     amatch_langid
	FrLimit    amatch_cost
	FnBuf      int32
	FoomErr    int32
	FnWord     int32
	FzBuf      uintptr
	FzInput    uintptr
	FpVtab     uintptr
	FpAllWords uintptr
	FpCurrent  uintptr
	FpCost     uintptr
	FpWord     uintptr
}

type amatch_cursor = amatch_cursor1
type amatch_rule1 = struct {
	FpNext       uintptr
	FzFrom       uintptr
	FrCost       amatch_cost
	FiLang       amatch_langid
	FnFrom       amatch_len
	FnTo         amatch_len
	FzTo         [4]int8
	F__ccgo_pad1 [2]byte
}

type amatch_rule = amatch_rule1
type amatch_word1 = struct {
	FpNext  uintptr
	FsCost  amatch_avl
	FsWord  amatch_avl
	FrCost  amatch_cost
	FiSeq   int32
	FzCost  [10]int8
	FnMatch int16
	FzWord  [4]int8
}

type amatch_word = amatch_word1
type amatch_avl1 = struct {
	FpWord     uintptr
	FzKey      uintptr
	FpBefore   uintptr
	FpAfter    uintptr
	FpUp       uintptr
	Fheight    int16
	Fimbalance int16
}

type amatch_avl = amatch_avl1

func amatchAvlRecomputeHeight(tls *libc.TLS, p uintptr) {
	var hBefore int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*amatch_avl)(unsafe.Pointer(p)).Fimbalance = int16(int32(hBefore) - int32(hAfter))
	(*amatch_avl)(unsafe.Pointer(p)).Fheight = int16(func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}() + 1)
}

func amatchAvlRotateBefore(tls *libc.TLS, pP uintptr) uintptr {
	var pB uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pB)).FpAfter
	(*amatch_avl)(unsafe.Pointer(pB)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*amatch_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pB)
	return pB
}

func amatchAvlRotateAfter(tls *libc.TLS, pP uintptr) uintptr {
	var pA uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pA)).FpBefore
	(*amatch_avl)(unsafe.Pointer(pA)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*amatch_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pA)
	return pA
}

func amatchAvlFromPtr(tls *libc.TLS, p uintptr, pp uintptr) uintptr {
	var pUp uintptr = (*amatch_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*amatch_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return pUp + 12
	}
	return pUp + 8
}

func amatchAvlBalance(tls *libc.TLS, p uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		amatchAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp)))
		if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) >= 2 {
			var pB uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpBefore
			if int32((*amatch_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpBefore = amatchAvlRotateAfter(tls, pB)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp)), bp)
			*(*uintptr)(unsafe.Pointer(bp)) = libc.AssignPtrUintptr(pp, amatchAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp))))
		} else if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) <= -2 {
			var pA uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpAfter
			if int32((*amatch_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpAfter = amatchAvlRotateBefore(tls, pA)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp)), bp)
			*(*uintptr)(unsafe.Pointer(bp)) = libc.AssignPtrUintptr(pp, amatchAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp)) = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpUp
	}
	return pTop
}

func amatchAvlSearch(tls *libc.TLS, p uintptr, zKey uintptr) uintptr {
	var c int32
	for p != 0 && libc.AssignInt32(&c, libc.Xstrcmp(tls, zKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey)) != 0 {
		if c < 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

func amatchAvlFirst(tls *libc.TLS, p uintptr) uintptr {
	if p != 0 {
		for (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

func amatchAvlInsert(tls *libc.TLS, ppHead uintptr, pNew uintptr) uintptr {
	var c int32
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			c = libc.Xstrcmp(tls, (*amatch_avl)(unsafe.Pointer(pNew)).FzKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey)
			if c < 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if c > 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*amatch_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, p)

	return uintptr(0)
}

func amatchAvlRemove(tls *libc.TLS, ppHead uintptr, pOld uintptr) {
	var ppParent uintptr
	var pBalance uintptr = uintptr(0)

	ppParent = amatchAvlFromPtr(tls, pOld, ppHead)
	if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0) && (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = uintptr(0)
		pBalance = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore != 0 && (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter != 0 {
		var pX uintptr
		var pY uintptr
		pX = amatchAvlFirst(tls, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		*(*uintptr)(unsafe.Pointer(amatchAvlFromPtr(tls, pX, uintptr(0)))) = (*amatch_avl)(unsafe.Pointer(pX)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		}
		pBalance = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		(*amatch_avl)(unsafe.Pointer(pX)).FpAfter = (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = pX
		} else {
			pBalance = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpBefore = libc.AssignUintptr(&pY, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		if pY != 0 {
			(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
		*(*uintptr)(unsafe.Pointer(ppParent)) = pX
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = libc.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = libc.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	}
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, pBalance)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpUp = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpAfter = uintptr(0)

}

type amatch_cost = int32
type amatch_len = int8
type amatch_langid = int32

func amatchMergeRules(tls *libc.TLS, pA uintptr, pB uintptr) uintptr {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pTail uintptr

	pTail = bp
	for pA != 0 && pB != 0 {
		if (*amatch_rule)(unsafe.Pointer(pA)).FrCost <= (*amatch_rule)(unsafe.Pointer(pB)).FrCost {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*amatch_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*amatch_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*amatch_rule)(unsafe.Pointer(bp)).FpNext
}

func amatchLoadOneRule(tls *libc.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iLang sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var rCost amatch_cost = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = SQLITE_OK
	var nFrom int32
	var nTo int32
	var pRule uintptr = uintptr(0)

	if zFrom == uintptr(0) {
		zFrom = ts + 584
	}
	if zTo == uintptr(0) {
		zTo = ts + 584
	}
	nFrom = int32(libc.Xstrlen(tls, zFrom))
	nTo = int32(libc.Xstrlen(tls, zTo))

	if libc.Xstrcmp(tls, zFrom, zTo) == 0 {
		if int32(*(*int8)(unsafe.Pointer(zFrom))) == '?' && int32(*(*int8)(unsafe.Pointer(zFrom + 1))) == 0 {
			if (*amatch_vtab)(unsafe.Pointer(p)).FrSub == 0 || (*amatch_vtab)(unsafe.Pointer(p)).FrSub > rCost {
				(*amatch_vtab)(unsafe.Pointer(p)).FrSub = rCost
			}
		}
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return SQLITE_OK
	}

	if rCost <= 0 || rCost > AMATCH_MX_COST {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3248,
			libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_COST))
		rc = SQLITE_ERROR
	} else if nFrom > AMATCH_MX_LENGTH || nTo > AMATCH_MX_LENGTH {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3282,
			libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_LENGTH))
		rc = SQLITE_ERROR
	} else if iLang < int64(0) || iLang > int64(AMATCH_MX_LANGID) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3314,
			libc.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_LANGID))
		rc = SQLITE_ERROR
	} else if libc.Xstrcmp(tls, zFrom, ts+584) == 0 && libc.Xstrcmp(tls, zTo, ts+3349) == 0 {
		if (*amatch_vtab)(unsafe.Pointer(p)).FrIns == 0 || (*amatch_vtab)(unsafe.Pointer(p)).FrIns > rCost {
			(*amatch_vtab)(unsafe.Pointer(p)).FrIns = rCost
		}
	} else if libc.Xstrcmp(tls, zFrom, ts+3349) == 0 && libc.Xstrcmp(tls, zTo, ts+584) == 0 {
		if (*amatch_vtab)(unsafe.Pointer(p)).FrDel == 0 || (*amatch_vtab)(unsafe.Pointer(p)).FrDel > rCost {
			(*amatch_vtab)(unsafe.Pointer(p)).FrDel = rCost
		}
	} else {
		pRule = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(amatch_rule{}))+uint32(nFrom)+uint32(nTo)))
		if pRule == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pRule, 0, uint32(unsafe.Sizeof(amatch_rule{})))
			(*amatch_rule)(unsafe.Pointer(pRule)).FzFrom = pRule + 18 + uintptr(nTo+1)
			(*amatch_rule)(unsafe.Pointer(pRule)).FnFrom = amatch_len(nFrom)
			libc.Xmemcpy(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, uint32(nFrom+1))
			libc.Xmemcpy(tls, pRule+18, zTo, uint32(nTo+1))
			(*amatch_rule)(unsafe.Pointer(pRule)).FnTo = amatch_len(nTo)
			(*amatch_rule)(unsafe.Pointer(pRule)).FrCost = rCost
			(*amatch_rule)(unsafe.Pointer(pRule)).FiLang = int32(iLang)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

func amatchFreeRules(tls *libc.TLS, p uintptr) {
	for (*amatch_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*amatch_vtab)(unsafe.Pointer(p)).FpRule
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	(*amatch_vtab)(unsafe.Pointer(p)).FpRule = uintptr(0)
}

func amatchLoadRules(tls *libc.TLS, db uintptr, p uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var rc int32 = SQLITE_OK
	var zSql uintptr
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+3351, libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzDb, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab))
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var rc2 int32
		*(*uintptr)(unsafe.Pointer(bp + 56)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3371, libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3378,
				libc.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))))
			rc = SQLITE_ERROR
		} else {
			for rc == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) {
				*(*uintptr)(unsafe.Pointer(bp + 60)) = uintptr(0)
				rc = amatchLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56)), bp+60, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 60)) != 0 {
					(*amatch_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 60)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 60))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	if rc == SQLITE_OK {
		var i uint32
		var pX uintptr

		for i = uint32(0); i < uint32(unsafe.Sizeof([15]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) = uintptr(0)
		}
		for libc.AssignUintptr(&pX, pHead) != uintptr(0) {
			pHead = (*amatch_rule)(unsafe.Pointer(pX)).FpNext
			(*amatch_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) != 0 && i < uint32(unsafe.Sizeof([15]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0)))-uint32(1); i++ {
				pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 64))
		i = uint32(1)
		for ; i < uint32(unsafe.Sizeof([15]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0))); i++ {
			pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)), pX)
		}
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = amatchMergeRules(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

func amatchDequote(tls *libc.TLS, zIn uintptr) uintptr {
	var nIn sqlite3_int64
	var zOut uintptr

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+int64(1)))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn))

		if int32(q) != '[' && int32(q) != '\'' && int32(q) != '"' && int32(q) != '`' {
			libc.Xmemcpy(tls, zOut, zIn, size_t(nIn+int64(1)))
		} else {
			var iOut int32 = 0
			var iIn int32

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

func amatchVCheckClear(tls *libc.TLS, p uintptr) {
	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
		(*amatch_vtab)(unsafe.Pointer(p)).FpVCheck = uintptr(0)
	}
}

func amatchFree(tls *libc.TLS, p uintptr) {
	if p != 0 {
		amatchFreeRules(tls, p)
		amatchVCheckClear(tls, p)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf)
		libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(amatch_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func amatchDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab

	amatchFree(tls, p)
	return SQLITE_OK
}

func amatchValueOfKey(tls *libc.TLS, zKey uintptr, zStr uintptr) uintptr {
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var nStr int32 = int32(libc.Xstrlen(tls, zStr))
	var i int32
	if nStr < nKey+1 {
		return uintptr(0)
	}
	if libc.Xmemcmp(tls, zStr, zKey, uint32(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint32(X_CTYPE_S)) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint32(X_CTYPE_S)) != 0 {
		i++
	}
	return zStr + uintptr(i)
}

func amatchConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var pNew uintptr
	var zModule uintptr
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = SQLITE_OK
	pNew = uintptr(0)
	zModule = *(*uintptr)(unsafe.Pointer(argv))
	zDb = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return SQLITE_NOMEM
__1:
	;
	rc = SQLITE_NOMEM
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(amatch_vtab{})))
	(*amatch_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zModule))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName == uintptr(0)) {
		goto __2
	}
	goto amatchConnectError
__2:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, zDb))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __3
	}
	goto amatchConnectError
__3:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __4
	}
	goto amatchConnectError
__4:
	;
	i = 3
__5:
	if !(i < argc) {
		goto __7
	}
	zVal = amatchValueOfKey(tls, ts+3412, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __8
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab == uintptr(0)) {
		goto __9
	}
	goto amatchConnectError
__9:
	;
	goto __6
__8:
	;
	zVal = amatchValueOfKey(tls, ts+3429, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __10
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord == uintptr(0)) {
		goto __11
	}
	goto amatchConnectError
__11:
	;
	goto __6
__10:
	;
	zVal = amatchValueOfKey(tls, ts+3445, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang == uintptr(0)) {
		goto __13
	}
	goto amatchConnectError
__13:
	;
	goto __6
__12:
	;
	zVal = amatchValueOfKey(tls, ts+3465, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __14
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __15
	}
	goto amatchConnectError
__15:
	;
	goto __6
__14:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3480, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	amatchFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return SQLITE_ERROR
	goto __6
__6:
	i++
	goto __5
	goto __7
__7:
	;
	rc = SQLITE_OK
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __16
	}
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3509, 0)
	rc = SQLITE_ERROR
	goto __17
__16:
	rc = amatchLoadRules(tls, db, pNew, pzErr)
__17:
	;
	if !(rc == SQLITE_OK) {
		goto __18
	}
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+3543)
__18:
	;
	if !(rc != SQLITE_OK) {
		goto __19
	}
	amatchFree(tls, pNew)
__19:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc

amatchConnectError:
	amatchFree(tls, pNew)
	return rc
}

func amatchOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(amatch_cursor{})))
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	(*amatch_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

func amatchClearCursor(tls *libc.TLS, pCur uintptr) {
	var pWord uintptr
	var pNextWord uintptr
	for pWord = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords; pWord != 0; pWord = pNextWord {
		pNextWord = (*amatch_word)(unsafe.Pointer(pWord)).FpNext
		sqlite3.Xsqlite3_free(tls, pWord)
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCost = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpWord = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = 1000000
	(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord = 0
}

func amatchClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	amatchClearCursor(tls, pCur)
	(*amatch_vtab)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func amatchEncodeInt(tls *libc.TLS, x int32, z uintptr) {
	*(*int8)(unsafe.Pointer(z)) = a[x>>18&0x3f]
	*(*int8)(unsafe.Pointer(z + 1)) = a[x>>12&0x3f]
	*(*int8)(unsafe.Pointer(z + 2)) = a[x>>6&0x3f]
	*(*int8)(unsafe.Pointer(z + 3)) = a[x&0x3f]
}

var a = *(*[65]int8)(unsafe.Pointer(ts + 3610))

func amatchWriteCost(tls *libc.TLS, pWord uintptr) {
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, pWord+60)
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FiSeq, pWord+60+uintptr(4))
	*(*int8)(unsafe.Pointer(pWord + 60 + 8)) = int8(0)
}

func amatchStrcpy(tls *libc.TLS, dest uintptr, src uintptr) {
	for int32(libc.AssignPtrInt8(libc.PostIncUintptr(&dest, 1), *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&src, 1))))) != 0 {
	}
}

func amatchStrcat(tls *libc.TLS, dest uintptr, src uintptr) {
	for *(*int8)(unsafe.Pointer(dest)) != 0 {
		dest++
	}
	amatchStrcpy(tls, dest, src)
}

func amatchAddWord(tls *libc.TLS, pCur uintptr, rCost amatch_cost, nMatch int32, zWordBase uintptr, zWordTail uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pWord uintptr
	var pNode uintptr
	var pOther uintptr
	_ = pOther
	var nBase int32
	var nTail int32

	if rCost > (*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit {
		return
	}
	nBase = int32(libc.Xstrlen(tls, zWordBase))
	nTail = int32(libc.Xstrlen(tls, zWordTail))
	if nBase+nTail+3 > (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = nBase + nTail + 100
		(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = sqlite3.Xsqlite3_realloc(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf)
		if (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf == uintptr(0) {
			(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
			return
		}
	}
	amatchEncodeInt(tls, nMatch, bp)
	libc.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, bp+uintptr(2), uint32(2))
	libc.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf+uintptr(2), zWordBase, uint32(nBase))
	libc.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf+uintptr(2)+uintptr(nBase), zWordTail, uint32(nTail+1))
	pNode = amatchAvlSearch(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpWord, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	if pNode != 0 {
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		if (*amatch_word)(unsafe.Pointer(pWord)).FrCost > rCost {
			amatchAvlRemove(tls, pCur+52, pWord+4)
			(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
			amatchWriteCost(tls, pWord)
			pOther = amatchAvlInsert(tls, pCur+52, pWord+4)
			_ = pOther
		}
		return
	}
	pWord = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(amatch_word{}))+uint32(nBase)+uint32(nTail)-uint32(1)))
	if pWord == uintptr(0) {
		return
	}
	libc.Xmemset(tls, pWord, 0, uint32(unsafe.Sizeof(amatch_word{})))
	(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
	(*amatch_word)(unsafe.Pointer(pWord)).FiSeq = libc.PostIncInt32(&(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord, 1)
	amatchWriteCost(tls, pWord)
	(*amatch_word)(unsafe.Pointer(pWord)).FnMatch = int16(nMatch)
	(*amatch_word)(unsafe.Pointer(pWord)).FpNext = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = pWord
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FzKey = pWord + 60
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FpWord = pWord
	pOther = amatchAvlInsert(tls, pCur+52, pWord+4)
	_ = pOther
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FzKey = pWord + 72
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FpWord = pWord
	amatchStrcpy(tls, pWord+72, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pOther = amatchAvlInsert(tls, pCur+56, pWord+28)
	_ = pOther
}

func amatchNext(tls *libc.TLS, cur uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var pCur uintptr = cur
	var pWord uintptr = uintptr(0)
	var pNode uintptr
	var isMatch int32 = 0
	var p uintptr = (*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab
	var nWord int32
	var rc int32
	var i int32
	var zW uintptr
	var pRule uintptr
	var zBuf uintptr = uintptr(0)
	var nBuf int8 = int8(0)

	var nNextIn int32

	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck == uintptr(0) {
		var zSql uintptr
		if (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang != 0 && *(*int8)(unsafe.Pointer((*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang)) != 0 {
			zSql = sqlite3.Xsqlite3_mprintf(tls,
				ts+3675,
				libc.VaList(bp, ts+3697,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang))
		} else {
			zSql = sqlite3.Xsqlite3_mprintf(tls,
				ts+3736,
				libc.VaList(bp+40, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord))
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*amatch_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, p+60, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			return rc
		}
	}
	sqlite3.Xsqlite3_bind_int(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 2, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)

	for __ccgo := true; __ccgo; __ccgo = !(isMatch != 0) {
		pNode = amatchAvlFirst(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpCost)
		if pNode == uintptr(0) {
			pWord = uintptr(0)
			break
		}
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		amatchAvlRemove(tls, pCur+52, pWord+4)

		nWord = int32(libc.Xstrlen(tls, pWord+72+uintptr(2)))
		if nWord+20 > int32(nBuf) {
			nBuf = int8(nWord + 100)
			zBuf = sqlite3.Xsqlite3_realloc(tls, zBuf, int32(nBuf))
			if zBuf == uintptr(0) {
				return SQLITE_NOMEM
			}
		}
		amatchStrcpy(tls, zBuf, pWord+72+uintptr(2))
		*(*int8)(unsafe.Pointer(bp + 64)) = int8(0)
		*(*int8)(unsafe.Pointer(bp + 72)) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)))
		if *(*int8)(unsafe.Pointer(bp + 72)) != 0 {
			for i = 1; i <= 4 && int32(*(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr(int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+i))))&0xc0 == 0x80; i++ {
				*(*int8)(unsafe.Pointer(bp + 72 + uintptr(i))) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr(int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+i)))
			}
			*(*int8)(unsafe.Pointer(bp + 72 + uintptr(i))) = int8(0)
			nNextIn = i
		} else {
			nNextIn = 0
		}

		if *(*int8)(unsafe.Pointer(bp + 72)) != 0 && int32(*(*int8)(unsafe.Pointer(bp + 72))) != '*' {
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			amatchStrcat(tls, zBuf, bp+72)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, nWord+nNextIn, uintptr(0))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc == SQLITE_ROW {
				zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
				if libc.Xstrncmp(tls, zBuf, zW, uint32(nWord+nNextIn)) == 0 {
					amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+nNextIn, zBuf, ts+584)
				}
			}
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
		}

		for 1 != 0 {
			amatchStrcpy(tls, zBuf+uintptr(nWord), bp+64)
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, -1, libc.UintptrFromInt32(-1))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc != SQLITE_ROW {
				break
			}
			zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
			amatchStrcpy(tls, zBuf+uintptr(nWord), bp+64)
			if libc.Xstrncmp(tls, zW, zBuf, uint32(nWord)) != 0 {
				break
			}
			if int32(*(*int8)(unsafe.Pointer(bp + 72))) == '*' && int32(*(*int8)(unsafe.Pointer(bp + 72 + 1))) == 0 ||
				int32(*(*int8)(unsafe.Pointer(bp + 72))) == 0 && int32(*(*int8)(unsafe.Pointer(zW + uintptr(nWord)))) == 0 {
				isMatch = 1
				*(*int8)(unsafe.Pointer(bp + 72)) = int8(0)
				nNextIn = 0
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64)) = *(*int8)(unsafe.Pointer(zW + uintptr(nWord)))
			for i = 1; i <= 4 && int32(*(*int8)(unsafe.Pointer(zW + uintptr(nWord+i))))&0xc0 == 0x80; i++ {
				*(*int8)(unsafe.Pointer(bp + 64 + uintptr(i))) = *(*int8)(unsafe.Pointer(zW + uintptr(nWord+i)))
			}
			*(*int8)(unsafe.Pointer(bp + 64 + uintptr(i))) = int8(0)
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			if (*amatch_vtab)(unsafe.Pointer(p)).FrIns > 0 {
				amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_vtab)(unsafe.Pointer(p)).FrIns, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch),
					zBuf, bp+64)
			}
			if (*amatch_vtab)(unsafe.Pointer(p)).FrSub > 0 {
				amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_vtab)(unsafe.Pointer(p)).FrSub, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+nNextIn,
					zBuf, bp+64)
			}
			if (*amatch_vtab)(unsafe.Pointer(p)).FrIns < 0 && (*amatch_vtab)(unsafe.Pointer(p)).FrSub < 0 {
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64 + uintptr(i-1)))++
		}
		sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)

		if (*amatch_vtab)(unsafe.Pointer(p)).FrDel > 0 {
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_vtab)(unsafe.Pointer(p)).FrDel, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+nNextIn,
				zBuf, ts+584)
		}

		for pRule = (*amatch_vtab)(unsafe.Pointer(p)).FpRule; pRule != 0; pRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext {
			if (*amatch_rule)(unsafe.Pointer(pRule)).FiLang != (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang {
				continue
			}
			if libc.Xstrncmp(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput+uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch), uint32((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0 {
				amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_rule)(unsafe.Pointer(pRule)).FrCost,
					int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+int32((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom), pWord+72+uintptr(2), pRule+18)
			}
		}
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = pWord
	sqlite3.Xsqlite3_free(tls, zBuf)
	return SQLITE_OK
}

func amatchFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 3784
	var idx int32

	amatchClearCursor(tls, pCur)
	idx = 0
	if idxNum&1 != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		idx++
	}
	if idxNum&2 != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	if idxNum&4 != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zWord))
	if (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput == uintptr(0) {
		return SQLITE_NOMEM
	}
	amatchAddWord(tls, pCur, 0, 0, ts+584, ts+584)
	amatchNext(tls, pVtabCursor)

	return SQLITE_OK
}

func amatchColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	switch i {
	case AMATCH_COL_WORD:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent+72+uintptr(2), -1, uintptr(0))
			break

		}
	case AMATCH_COL_DISTANCE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_word)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FrCost)
			break

		}
	case AMATCH_COL_LANGUAGE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)
			break

		}
	case AMATCH_COL_NWORD:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FnWord)
			break

		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	}
	return SQLITE_OK
}

func amatchRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*amatch_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func amatchEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0))
}

func amatchBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iLangTerm int32 = -1
	var i int32
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if iPlan&1 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			iPlan = iPlan | 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if iPlan&2 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1 &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE) {
			iPlan = iPlan | 2
			iDistTerm = i
		}
		if iPlan&4 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | 4
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iLangTerm = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if iPlan&2 != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = 1 + libc.Bool32(iPlan&1 != 0)
	}
	if iPlan&4 != 0 {
		var idx int32 = 1
		if iPlan&1 != 0 {
			idx++
		}
		if iPlan&2 != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == 1 &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10000)

	return SQLITE_OK
}

func amatchUpdate(tls *libc.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr = pVTab
	var zCmd uintptr
	_ = pRowid
	if argc == 1 {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3786,
			libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_NULL {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3816,
			libc.VaList(bp+8, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4))) != SQLITE_NULL ||
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4))) != SQLITE_NULL ||
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4))) != SQLITE_NULL {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+3844, libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4)))
	if zCmd == uintptr(0) {
		return SQLITE_OK
	}

	return SQLITE_OK
}

var amatchModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
	FxUpdate:     0,
}

func sqlite3_amatch_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3893, uintptr(unsafe.Pointer(&amatchModule)), uintptr(0))
	return rc
}

type ApndVfs = sqlite3_vfs1
type ApndFile1 = struct {
	Fbase   sqlite3_file
	FiPgOne sqlite3_int64
	FiMark  sqlite3_int64
}

type ApndFile = ApndFile1

var apnd_vfs = sqlite3_vfs{
	FiVersion:          3,
	FmxPathname:        1024,
	FzName:             ts + 3911,
	FxOpen:             0,
	FxDelete:           0,
	FxAccess:           0,
	FxFullPathname:     0,
	FxDlOpen:           0,
	FxDlError:          0,
	FxDlSym:            0,
	FxDlClose:          0,
	FxRandomness:       0,
	FxSleep:            0,
	FxCurrentTime:      0,
	FxGetLastError:     0,
	FxCurrentTimeInt64: 0,
	FxSetSystemCall:    0,
	FxGetSystemCall:    0,
	FxNextSystemCall:   0,
}

var apnd_io_methods = sqlite3_io_methods{
	FiVersion:               3,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
	FxFetch:                 0,
	FxUnfetch:               0,
}

func apndClose(tls *libc.TLS, pFile uintptr) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxClose})).f(tls, pFile)
}

func apndRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var paf uintptr = pFile
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, zBuf, iAmt, (*ApndFile)(unsafe.Pointer(paf)).FiPgOne+iOfst)
}

func apndWriteMark(tls *libc.TLS, paf uintptr, pFile uintptr, iWriteEnd sqlite_int64) int32 {
	bp := tls.Alloc(25)
	defer tls.Free(25)

	var iPgOne sqlite_int64 = (*ApndFile)(unsafe.Pointer(paf)).FiPgOne

	var i int32 = APND_MARK_FOS_SZ
	var rc int32

	libc.Xmemcpy(tls, bp, ts+3919, uint32(APND_MARK_PREFIX_SZ))
	for libc.PreDecInt32(&i, 1) >= 0 {
		*(*uint8)(unsafe.Pointer(bp + uintptr(APND_MARK_PREFIX_SZ+i))) = uint8(iPgOne & int64(0xff))
		iPgOne >>= 8
	}
	iWriteEnd = iWriteEnd + (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
	if SQLITE_OK == libc.AssignInt32(&rc, (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxWrite})).f(tls, pFile, bp, APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ, iWriteEnd)) {
		(*ApndFile)(unsafe.Pointer(paf)).FiMark = iWriteEnd
	}
	return rc
}

func apndWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var paf uintptr = pFile
	var iWriteEnd sqlite_int64 = iOfst + sqlite_int64(iAmt)
	if iWriteEnd >= int64(0x40000000) {
		return SQLITE_FULL
	}
	pFile = pFile + uintptr(1)*20

	if (*ApndFile)(unsafe.Pointer(paf)).FiMark < int64(0) || (*ApndFile)(unsafe.Pointer(paf)).FiPgOne+iWriteEnd > (*ApndFile)(unsafe.Pointer(paf)).FiMark {
		var rc int32 = apndWriteMark(tls, paf, pFile, iWriteEnd)
		if SQLITE_OK != rc {
			return rc
		}
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxWrite})).f(tls, pFile, zBuf, iAmt, (*ApndFile)(unsafe.Pointer(paf)).FiPgOne+iOfst)
}

func apndTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	var paf uintptr = pFile
	pFile = pFile + uintptr(1)*20

	if SQLITE_OK != apndWriteMark(tls, paf, pFile, size) {
		return SQLITE_IOERR
	}

	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxTruncate})).f(tls, pFile, (*ApndFile)(unsafe.Pointer(paf)).FiMark+int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ))
}

func apndSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSync})).f(tls, pFile, flags)
}

func apndFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var paf uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = func() int64 {
		if (*ApndFile)(unsafe.Pointer(paf)).FiMark >= int64(0) {
			return (*ApndFile)(unsafe.Pointer(paf)).FiMark - (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
		}
		return int64(0)
	}()
	return SQLITE_OK
}

func apndLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxLock})).f(tls, pFile, eLock)
}

func apndUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnlock})).f(tls, pFile, eLock)
}

func apndCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxCheckReservedLock})).f(tls, pFile, pResOut)
}

func apndFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var paf uintptr = pFile
	var rc int32
	pFile = pFile + uintptr(1)*20
	if op == SQLITE_FCNTL_SIZE_HINT {
		*(*sqlite3_int64)(unsafe.Pointer(pArg)) += (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFileControl})).f(tls, pFile, op, pArg)
	if rc == SQLITE_OK && op == SQLITE_FCNTL_VFSNAME {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+3937, libc.VaList(bp, (*ApndFile)(unsafe.Pointer(paf)).FiPgOne, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

func apndSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSectorSize})).f(tls, pFile)
}

func apndDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxDeviceCharacteristics})).f(tls, pFile)
}

func apndShmMap(tls *libc.TLS, pFile uintptr, iPg int32, pgsz int32, bExtend int32, pp uintptr) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmMap})).f(tls, pFile, iPg, pgsz, bExtend, pp)
}

func apndShmLock(tls *libc.TLS, pFile uintptr, offset int32, n int32, flags int32) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmLock})).f(tls, pFile, offset, n, flags)
}

func apndShmBarrier(tls *libc.TLS, pFile uintptr) {
	pFile = pFile + uintptr(1)*20
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmBarrier})).f(tls, pFile)
}

func apndShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 {
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmUnmap})).f(tls, pFile, deleteFlag)
}

func apndFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 {
	var p uintptr = pFile
	if (*ApndFile)(unsafe.Pointer(p)).FiMark < int64(0) || iOfst+sqlite3_int64(iAmt) > (*ApndFile)(unsafe.Pointer(p)).FiMark {
		return SQLITE_IOERR
	}
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFetch})).f(tls, pFile, iOfst+(*ApndFile)(unsafe.Pointer(p)).FiPgOne, iAmt, pp)
}

func apndUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, pPage uintptr) int32 {
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*20
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnfetch})).f(tls, pFile, iOfst+(*ApndFile)(unsafe.Pointer(p)).FiPgOne, pPage)
}

func apndReadMark(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) sqlite3_int64 {
	bp := tls.Alloc(25)
	defer tls.Free(25)

	var rc int32
	var i int32
	var iMark sqlite3_int64
	var msbs int32 = 8 * (APND_MARK_FOS_SZ - 1)

	if int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ) != sz&int64(0x1ff) {
		return int64(-1)
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, bp, APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ, sz-int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ))
	if rc != 0 {
		return int64(-1)
	}
	if libc.Xmemcmp(tls, bp, ts+3919, uint32(APND_MARK_PREFIX_SZ)) != 0 {
		return int64(-1)
	}
	iMark = sqlite3_int64(int32(*(*uint8)(unsafe.Pointer(bp + 17)))&0x7f) << msbs
	for i = 1; i < 8; i++ {
		msbs = msbs - 8
		iMark = iMark | sqlite3_int64(*(*uint8)(unsafe.Pointer(bp + uintptr(APND_MARK_PREFIX_SZ+i))))<<msbs
	}
	if iMark > sz-int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ)-int64(512) {
		return int64(-1)
	}
	if iMark&int64(0x1ff) != 0 {
		return int64(-1)
	}
	return iMark
}

var apvfsSqliteHdr = *(*[16]int8)(unsafe.Pointer(ts + 3951))

func apndIsAppendvfsDatabase(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32

	var iMark sqlite3_int64 = apndReadMark(tls, sz, pFile)
	if iMark >= int64(0) {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, bp, int32(unsafe.Sizeof([16]int8{})), iMark)
		if SQLITE_OK == rc &&
			libc.Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&apvfsSqliteHdr)), uint32(unsafe.Sizeof([16]int8{}))) == 0 &&
			sz&int64(0x1ff) == int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ) &&
			sz >= int64(512+(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ)) {
			return 1
		}
	}
	return 0
}

func apndIsOrdinaryDatabaseFile(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if apndIsAppendvfsDatabase(tls, sz, pFile) != 0 ||
		sz&int64(0x1ff) != int64(0) ||
		SQLITE_OK != (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, bp, int32(unsafe.Sizeof([16]int8{})), int64(0)) ||
		libc.Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&apvfsSqliteHdr)), uint32(unsafe.Sizeof([16]int8{}))) != 0 {
		return 0
	} else {
		return 1
	}
	return int32(0)
}

func apndOpen(tls *libc.TLS, pApndVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pApndFile uintptr = pFile
	var pBaseFile uintptr = pFile + uintptr(1)*20
	var pBaseVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pApndVfs)).FpAppData
	var rc int32
	*(*sqlite3_int64)(unsafe.Pointer(bp)) = int64(0)
	if flags&SQLITE_OPEN_MAIN_DB == 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pBaseVfs)).FxOpen})).f(tls, pBaseVfs, zName, pFile, flags, pOutFlags)
	}
	libc.Xmemset(tls, pApndFile, 0, uint32(unsafe.Sizeof(ApndFile{})))
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&apnd_io_methods))
	(*ApndFile)(unsafe.Pointer(pApndFile)).FiMark = int64(-1)

	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pBaseVfs)).FxOpen})).f(tls, pBaseVfs, zName, pBaseFile, flags, pOutFlags)
	if rc == SQLITE_OK {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods)).FxFileSize})).f(tls, pBaseFile, bp)
		if rc != 0 {
			(*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods)).FxClose})).f(tls, pBaseFile)
		}
	}
	if rc != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
		return rc
	}
	if apndIsOrdinaryDatabaseFile(tls, *(*sqlite3_int64)(unsafe.Pointer(bp)), pBaseFile) != 0 {
		libc.Xmemmove(tls, pApndFile, pBaseFile, uint32((*sqlite3_vfs)(unsafe.Pointer(pBaseVfs)).FszOsFile))
		return SQLITE_OK
	}
	(*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne = apndReadMark(tls, *(*sqlite3_int64)(unsafe.Pointer(bp)), pFile)
	if (*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne >= int64(0) {
		(*ApndFile)(unsafe.Pointer(pApndFile)).FiMark = *(*sqlite3_int64)(unsafe.Pointer(bp)) - int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ)
		return SQLITE_OK
	}
	if flags&SQLITE_OPEN_CREATE == 0 {
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods)).FxClose})).f(tls, pBaseFile)
		rc = SQLITE_CANTOPEN
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
	} else {
		(*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne = (*(*sqlite3_int64)(unsafe.Pointer(bp)) + int64(APND_ROUNDUP-1)) & libc.CplInt64(int64(APND_ROUNDUP-1))
	}
	return rc
}

func apndDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDelete})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, dirSync)
}

func apndAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxAccess})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, flags, pResOut)
}

func apndFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxFullPathname})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, nOut, zOut)
}

func apndDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlOpen})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath)
}

func apndDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zErrMsg)
}

func apndDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlSym})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p, zSym)
}

func apndDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlClose})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pHandle)
}

func apndRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxRandomness})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zBufOut)
}

func apndSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSleep})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nMicro)
}

func apndCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxCurrentTime})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pTimeOut)
}

func apndGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetLastError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, a, b)
}

func apndCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxCurrentTimeInt64})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p)
}

func apndSetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr, pCall sqlite3_syscall_ptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName, pCall)
}

func apndGetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) sqlite3_syscall_ptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func apndNextSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxNextSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func sqlite3_appendvfs_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	var pOrig uintptr
	_ = pApi

	_ = pzErrMsg
	_ = db
	pOrig = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if pOrig == uintptr(0) {
		return SQLITE_ERROR
	}
	apnd_vfs.FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FiVersion
	apnd_vfs.FpAppData = pOrig
	apnd_vfs.FszOsFile = int32(uint32((*sqlite3_vfs)(unsafe.Pointer(pOrig)).FszOsFile) + uint32(unsafe.Sizeof(ApndFile{})))
	rc = sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&apnd_vfs)), 0)
	if rc == SQLITE_OK {
		rc = SQLITE_OK | int32(1)<<8
	}
	return rc
}

func init_api_ptr(tls *libc.TLS, pApi uintptr) {
	_ = pApi

}

type u8 = uint8

var b64DigitValues = [128]u8{
	u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(WS), u8(WS), u8(WS), u8(WS), u8(WS), u8(ND), u8(ND),
	u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND),
	u8(WS), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND), u8(62), u8(ND), u8(ND), u8(ND), u8(63),
	u8(52), u8(53), u8(54), u8(55), u8(56), u8(57), u8(58), u8(59), u8(60), u8(61), u8(ND), u8(ND), u8(ND), u8(PC), u8(ND), u8(ND),
	u8(ND), u8(0), u8(1), u8(2), u8(3), u8(4), u8(5), u8(6), u8(7), u8(8), u8(9), u8(10), u8(11), u8(12), u8(13), u8(14),
	u8(15), u8(16), u8(17), u8(18), u8(19), u8(20), u8(21), u8(22), u8(23), u8(24), u8(25), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND),
	u8(ND), u8(26), u8(27), u8(28), u8(29), u8(30), u8(31), u8(32), u8(33), u8(34), u8(35), u8(36), u8(37), u8(38), u8(39), u8(40),
	u8(41), u8(42), u8(43), u8(44), u8(45), u8(46), u8(47), u8(48), u8(49), u8(50), u8(51), u8(ND), u8(ND), u8(ND), u8(ND), u8(ND),
}

var b64Numerals = *(*[65]int8)(unsafe.Pointer(ts + 3967))

func toBase64(tls *libc.TLS, pIn uintptr, nbIn int32, pOut uintptr) uintptr {
	var nCol int32 = 0
	for nbIn >= 3 {
		*(*int8)(unsafe.Pointer(pOut)) = b64Numerals[u8(int32(*(*u8)(unsafe.Pointer(pIn)))>>2)]
		*(*int8)(unsafe.Pointer(pOut + 1)) = b64Numerals[u8((int32(*(*u8)(unsafe.Pointer(pIn)))<<4|int32(*(*u8)(unsafe.Pointer(pIn + 1)))>>4)&0x3f)]
		*(*int8)(unsafe.Pointer(pOut + 2)) = b64Numerals[u8(int32(*(*u8)(unsafe.Pointer(pIn + 1)))&0xf<<2|int32(*(*u8)(unsafe.Pointer(pIn + 2)))>>6)]
		*(*int8)(unsafe.Pointer(pOut + 3)) = b64Numerals[u8(int32(*(*u8)(unsafe.Pointer(pIn + 2)))&0x3f)]
		pOut += uintptr(4)
		nbIn = nbIn - 3
		pIn += uintptr(3)
		if libc.AssignAddInt32(&nCol, 4) >= B64_DARK_MAX || nbIn <= 0 {
			*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&pOut, 1))) = int8('\n')
			nCol = 0
		}
	}
	if nbIn > 0 {
		var nco int8 = int8(nbIn + 1)
		var nbe int32
		var qv uint32 = uint32(*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pIn, 1))))
		for nbe = 1; nbe < 3; nbe++ {
			qv <<= 8
			if nbe < nbIn {
				qv = qv | uint32(*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pIn, 1))))
			}
		}
		for nbe = 3; nbe >= 0; nbe-- {
			var ce int8
			if nbe < int32(nco) {
				ce = b64Numerals[u8(qv&uint32(0x3f))]
			} else {
				ce = int8('=')
			}
			qv >>= 6
			*(*int8)(unsafe.Pointer(pOut + uintptr(nbe))) = ce
		}
		pOut += uintptr(4)
		*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&pOut, 1))) = int8('\n')
	}
	*(*int8)(unsafe.Pointer(pOut)) = int8(0)
	return pOut
}

func skipNonB64(tls *libc.TLS, s uintptr) uintptr {
	var c int8
	for libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(s))) != 0 && !(int32(func() uint8 {
		if int32(u8(c)) < 0x80 {
			return b64DigitValues[u8(c)]
		}
		return uint8(0x80)
	}()) < 0x80) {
		s++
	}
	return s
}

func fromBase64(tls *libc.TLS, pIn uintptr, ncIn int32, pOut uintptr) uintptr {
	if ncIn > 0 && int32(*(*int8)(unsafe.Pointer(pIn + uintptr(ncIn-1)))) == '\n' {
		ncIn--
	}
	for ncIn > 0 && int32(*(*int8)(unsafe.Pointer(pIn))) != '=' {
		var pUse uintptr = skipNonB64(tls, pIn)
		var qv uint32 = uint32(0)
		var nti int32
		var nbo int32
		var nac int32
		ncIn = ncIn - (int32(pUse)-int32(pIn))/1
		pIn = pUse
		if ncIn > 4 {
			nti = 4
		} else {
			nti = ncIn
		}
		ncIn = ncIn - nti
		nbo = int32(nboi[nti])
		if nbo == 0 {
			break
		}
		for nac = 0; nac < 4; nac++ {
			var c int8
			if nac < nti {
				c = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&pIn, 1)))
			} else {
				c = b64Numerals[0]
			}
			var bdp u8 = func() uint8 {
				if int32(u8(c)) < 0x80 {
					return b64DigitValues[u8(c)]
				}
				return uint8(0x80)
			}()
			switch int32(bdp) {
			case ND:
				ncIn = 0

				fallthrough
			case WS:
				nti = nac

				fallthrough
			case PC:
				bdp = u8(0)
				nbo--

				fallthrough
			default:
				qv = qv<<6 | uint32(bdp)
				break
			}
		}
		switch nbo {
		case 3:
			*(*u8)(unsafe.Pointer(pOut + 2)) = u8(qv & uint32(0xff))
			fallthrough
		case 2:
			*(*u8)(unsafe.Pointer(pOut + 1)) = u8(qv >> 8 & uint32(0xff))
			fallthrough
		case 1:
			*(*u8)(unsafe.Pointer(pOut)) = u8(qv >> 16 & uint32(0xff))
		}
		pOut += uintptr(nbo)
	}
	return pOut
}

var nboi = [5]int8{int8(0), int8(0), int8(1), int8(2), int8(3)}

func base64(tls *libc.TLS, context uintptr, na int32, av uintptr) {
	var nb int32
	var nc int32
	var nv int32
	var nvMax int32
	var cBuf uintptr
	var bBuf uintptr
	nv = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(av)))
	nvMax = sqlite3.Xsqlite3_limit(tls, sqlite3.Xsqlite3_context_db_handle(tls, context),
		SQLITE_LIMIT_LENGTH, -1)

	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(av))) {
	case SQLITE_BLOB:
		goto __2
	case SQLITE_TEXT:
		goto __3
	default:
		goto __4
	}
	goto __1
__2:
	nb = nv
	nc = 4 * (nv + 2/3)
	nc = nc + ((nc+(B64_DARK_MAX-1))/B64_DARK_MAX + 1)
	if !(nvMax < nc) {
		goto __5
	}
	sqlite3.Xsqlite3_result_error(tls, context, ts+4032, -1)
	return
__5:
	;
	cBuf = sqlite3.Xsqlite3_malloc(tls, nc)
	if !!(cBuf != 0) {
		goto __6
	}
	goto memFail
__6:
	;
	bBuf = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(av)))
	nc = (int32(toBase64(tls, bBuf, nb, cBuf)) - int32(cBuf)) / 1
	sqlite3.Xsqlite3_result_text(tls, context, cBuf, nc, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	goto __1
__3:
	nc = nv
	nb = 3 * ((nv + 3) / 4)
	if !(nvMax < nb) {
		goto __7
	}
	sqlite3.Xsqlite3_result_error(tls, context, ts+4064, -1)
	return
	goto __8
__7:
	if !(nb < 1) {
		goto __9
	}
	nb = 1
__9:
	;
__8:
	;
	bBuf = sqlite3.Xsqlite3_malloc(tls, nb)
	if !!(bBuf != 0) {
		goto __10
	}
	goto memFail
__10:
	;
	cBuf = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(av)))
	nb = (int32(fromBase64(tls, cBuf, nc, bBuf)) - int32(bBuf)) / 1
	sqlite3.Xsqlite3_result_blob(tls, context, bBuf, nb, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	goto __1
__4:
	sqlite3.Xsqlite3_result_error(tls, context, ts+4096, -1)
	return
__1:
	;
	return
memFail:
	sqlite3.Xsqlite3_result_error(tls, context, ts+4129, -1)
}

func sqlite3_base64_init(tls *libc.TLS, db uintptr, pzErr uintptr, pApi uintptr) int32 {
	_ = pApi
	_ = pzErr
	return sqlite3.Xsqlite3_create_function(tls, db, ts+4140, 1,
		SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS|SQLITE_DIRECTONLY|SQLITE_UTF8,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{base64})), uintptr(0), uintptr(0))
}

var b85_cOffset = [5]u8{u8(0), u8('#'), u8(0), u8('*' - 4), u8(0)}

func skipNonB85(tls *libc.TLS, s uintptr) uintptr {
	var c int8
	for libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(s))) != 0 && !((libc.Bool32(int32(c) >= '#')+libc.Bool32(int32(c) > '&')+libc.Bool32(int32(c) >= '*')+libc.Bool32(int32(c) > 'z'))&1 != 0) {
		s++
	}
	return s
}

func putcs(tls *libc.TLS, pc uintptr, s uintptr) uintptr {
	var c int8
	for int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&s, 1))))) != 0 {
		*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&pc, 1))) = c
	}
	return pc
}

func toBase85(tls *libc.TLS, pIn uintptr, nbIn int32, pOut uintptr, pSep uintptr) uintptr {
	var nCol int32 = 0
	for nbIn >= 4 {
		var nco int32 = 5
		var qbv uint32 = uint32(*(*u8)(unsafe.Pointer(pIn)))<<24 | uint32(int32(*(*u8)(unsafe.Pointer(pIn + 1)))<<16) | uint32(int32(*(*u8)(unsafe.Pointer(pIn + 2)))<<8) | uint32(*(*u8)(unsafe.Pointer(pIn + 3)))
		for nco > 0 {
			var nqv uint32 = qbv / 85
			var dv uint8 = uint8(qbv - 85*nqv)
			qbv = nqv
			*(*int8)(unsafe.Pointer(pOut + uintptr(libc.PreDecInt32(&nco, 1)))) = func() int8 {
				if int32(dv) < 4 {
					return int8(int32(dv) + '#')
				}
				return int8(int32(dv) - 4 + '*')
			}()
		}
		nbIn = nbIn - 4
		pIn += uintptr(4)
		pOut += uintptr(5)
		if pSep != 0 && libc.AssignAddInt32(&nCol, 5) >= B85_DARK_MAX {
			pOut = putcs(tls, pOut, pSep)
			nCol = 0
		}
	}
	if nbIn > 0 {
		var nco int32 = nbIn + 1
		var qv uint32 = uint32(*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pIn, 1))))
		var nbe int32 = 1
		for libc.PostIncInt32(&nbe, 1) < nbIn {
			qv = qv<<8 | uint32(*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pIn, 1))))
		}
		nCol = nCol + nco
		for nco > 0 {
			var dv u8 = u8(qv % uint32(85))
			qv = qv / uint32(85)
			*(*int8)(unsafe.Pointer(pOut + uintptr(libc.PreDecInt32(&nco, 1)))) = func() int8 {
				if int32(dv) < 4 {
					return int8(int32(dv) + '#')
				}
				return int8(int32(dv) - 4 + '*')
			}()
		}
		pOut += uintptr(nbIn + 1)
	}
	if pSep != 0 && nCol > 0 {
		pOut = putcs(tls, pOut, pSep)
	}
	*(*int8)(unsafe.Pointer(pOut)) = int8(0)
	return pOut
}

func fromBase85(tls *libc.TLS, pIn uintptr, ncIn int32, pOut uintptr) uintptr {
	if ncIn > 0 && int32(*(*int8)(unsafe.Pointer(pIn + uintptr(ncIn-1)))) == '\n' {
		ncIn--
	}
	for ncIn > 0 {
		var pUse uintptr = skipNonB85(tls, pIn)
		var qv uint32 = uint32(0)
		var nti int32
		var nbo int32
		ncIn = ncIn - (int32(pUse)-int32(pIn))/1
		pIn = pUse
		if ncIn > 5 {
			nti = 5
		} else {
			nti = ncIn
		}
		nbo = int32(nboi1[nti])
		if nbo == 0 {
			break
		}
		for nti > 0 {
			var c int8 = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&pIn, 1)))
			var cdo u8 = b85_cOffset[libc.Bool32(int32(c) >= '#')+libc.Bool32(int32(c) > '&')+libc.Bool32(int32(c) >= '*')+libc.Bool32(int32(c) > 'z')]
			ncIn--
			if int32(cdo) == 0 {
				break
			}
			qv = uint32(85)*qv + uint32(int32(c)-int32(cdo))
			nti--
		}
		nbo = nbo - nti
		switch nbo {
		case 4:
			*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pOut, 1))) = u8(qv >> 24 & uint32(0xff))
			fallthrough
		case 3:
			*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pOut, 1))) = u8(qv >> 16 & uint32(0xff))
			fallthrough
		case 2:
			*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pOut, 1))) = u8(qv >> 8 & uint32(0xff))
			fallthrough
		case 1:
			*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&pOut, 1))) = u8(qv & uint32(0xff))
			fallthrough
		case 0:
			break
		}
	}
	return pOut
}

var nboi1 = [6]int8{int8(0), int8(0), int8(1), int8(2), int8(3), int8(4)}

func allBase85(tls *libc.TLS, p uintptr, len int32) int32 {
	var c int8
	for libc.PostDecInt32(&len, 1) > 0 && int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))) != 0 {
		if !((libc.Bool32(int32(c) >= '#')+libc.Bool32(int32(c) > '&')+libc.Bool32(int32(c) >= '*')+libc.Bool32(int32(c) > 'z'))&1 != 0) && !(__sbistype(tls, int32(c), uint32(X_CTYPE_S)) != 0) {
			return 0
		}
	}
	return 1
}

func is_base85(tls *libc.TLS, context uintptr, na int32, av uintptr) {
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(av))) {
	case SQLITE_TEXT:
		{
			var rv int32 = allBase85(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(av))),
				sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(av))))
			sqlite3.Xsqlite3_result_int(tls, context, rv)

		}
		break
	case SQLITE_NULL:
		sqlite3.Xsqlite3_result_null(tls, context)
		break
	default:
		sqlite3.Xsqlite3_result_error(tls, context, ts+4147, -1)
		return
	}
}

func base85(tls *libc.TLS, context uintptr, na int32, av uintptr) {
	var nb int32
	var nc int32
	var nv int32
	var nvMax int32
	var cBuf uintptr
	var bBuf uintptr
	nv = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(av)))
	nvMax = sqlite3.Xsqlite3_limit(tls, sqlite3.Xsqlite3_context_db_handle(tls, context),
		SQLITE_LIMIT_LENGTH, -1)

	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(av))) {
	case SQLITE_BLOB:
		goto __2
	case SQLITE_TEXT:
		goto __3
	default:
		goto __4
	}
	goto __1
__2:
	nb = nv

	nc = 5*(nv/4) + nv%4 + nv/64 + 1 + 2
	if !(nvMax < nc) {
		goto __5
	}
	sqlite3.Xsqlite3_result_error(tls, context, ts+4183, -1)
	return
__5:
	;
	cBuf = sqlite3.Xsqlite3_malloc(tls, nc)
	if !!(cBuf != 0) {
		goto __6
	}
	goto memFail
__6:
	;
	bBuf = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(av)))
	nc = (int32(toBase85(tls, bBuf, nb, cBuf, ts+4215)) - int32(cBuf)) / 1
	sqlite3.Xsqlite3_result_text(tls, context, cBuf, nc, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	goto __1
__3:
	nc = nv
	nb = 4*(nv/5) + nv%5
	if !(nvMax < nb) {
		goto __7
	}
	sqlite3.Xsqlite3_result_error(tls, context, ts+4217, -1)
	return
	goto __8
__7:
	if !(nb < 1) {
		goto __9
	}
	nb = 1
__9:
	;
__8:
	;
	bBuf = sqlite3.Xsqlite3_malloc(tls, nb)
	if !!(bBuf != 0) {
		goto __10
	}
	goto memFail
__10:
	;
	cBuf = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(av)))
	nb = (int32(fromBase85(tls, cBuf, nc, bBuf)) - int32(bBuf)) / 1
	sqlite3.Xsqlite3_result_blob(tls, context, bBuf, nb, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	goto __1
__4:
	sqlite3.Xsqlite3_result_error(tls, context, ts+4249, -1)
	return
__1:
	;
	return
memFail:
	sqlite3.Xsqlite3_result_error(tls, context, ts+4283, -1)
}

func sqlite3_base85_init(tls *libc.TLS, db uintptr, pzErr uintptr, pApi uintptr) int32 {
	_ = pApi
	_ = pzErr
	{
		var rc int32 = sqlite3.Xsqlite3_create_function(tls, db, ts+4294, 1,
			SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS|SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{is_base85})), uintptr(0), uintptr(0))
		if rc != SQLITE_OK {
			return rc
		}

	}
	return sqlite3.Xsqlite3_create_function(tls, db, ts+4304, 1,
		SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS|SQLITE_DIRECTONLY|SQLITE_UTF8,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{base85})), uintptr(0), uintptr(0))
}

func sqlite3_basexx_init(tls *libc.TLS, db uintptr, pzErr uintptr, pApi uintptr) int32 {
	init_api_ptr(tls, pApi)
	var rc1 int32 = sqlite3_base64_init(tls, db, uintptr(0), uintptr(0))
	var rc2 int32 = sqlite3_base85_init(tls, db, uintptr(0), uintptr(0))

	if rc1 == SQLITE_OK && rc2 == SQLITE_OK {
		return SQLITE_OK
	} else {
		return SQLITE_ERROR
	}
	return int32(0)
}

type iovec = struct {
	Fiov_base uintptr
	Fiov_len  size_t
}

var azType = [5]uintptr{ts + 4311, ts + 4317, ts + 2562, ts + 4323,
	ts + 4329}

type carray_bind1 = struct {
	FaData  uintptr
	FnData  int32
	FmFlags int32
	FxDel   uintptr
}

type carray_bind = carray_bind1

type carray_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiRowid      sqlite3_int64
	FpPtr        uintptr
	FiCnt        sqlite3_int64
	FeType       uint8
	F__ccgo_pad1 [3]byte
}

type carray_cursor = carray_cursor1

func carrayConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pNew uintptr
	var rc int32

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+4342)
	if rc == SQLITE_OK {
		pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(sqlite3_vtab{})))
	}
	return rc
}

func carrayDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func carrayOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(carray_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(carray_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func carrayClose(tls *libc.TLS, cur uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

func carrayNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

func carrayColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case CARRAY_COLUMN_POINTER:
		return SQLITE_OK
	case CARRAY_COLUMN_COUNT:
		x = (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt
		break
	case CARRAY_COLUMN_CTYPE:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, azType[(*carray_cursor)(unsafe.Pointer(pCur)).FeType], -1, uintptr(0))
			return SQLITE_OK

		}
	default:
		{
			switch int32((*carray_cursor)(unsafe.Pointer(pCur)).FeType) {
			case CARRAY_INT32:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*4)))
					return SQLITE_OK

				}
			case CARRAY_INT64:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*8)))
					return SQLITE_OK

				}
			case CARRAY_DOUBLE:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_double(tls, ctx, *(*float64)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*8)))
					return SQLITE_OK

				}
			case CARRAY_TEXT:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*4)), -1, libc.UintptrFromInt32(-1))
					return SQLITE_OK

				}
			case CARRAY_BLOB:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_blob(tls, ctx, (*iovec)(unsafe.Pointer(p+uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*8)).Fiov_base,
						int32((*iovec)(unsafe.Pointer(p+uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*8)).Fiov_len), libc.UintptrFromInt32(-1))
					return SQLITE_OK

				}
			}

		}
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return SQLITE_OK
}

func carrayRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*carray_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func carrayEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid > (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt)
}

func carrayFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = uintptr(0)
	(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = int64(0)
	switch idxNum {
	case 1:
		{
			var pBind uintptr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv)), ts+4405)
			if pBind == uintptr(0) {
				break
			}
			(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = (*carray_bind)(unsafe.Pointer(pBind)).FaData
			(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = sqlite3_int64((*carray_bind)(unsafe.Pointer(pBind)).FnData)
			(*carray_cursor)(unsafe.Pointer(pCur)).FeType = uint8((*carray_bind)(unsafe.Pointer(pBind)).FmFlags & 0x07)
			break

		}
	case 2:
		fallthrough
	case 3:
		{
			(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv)), ts+4417)
			(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = func() int64 {
				if (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr != 0 {
					return sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
				}
				return int64(0)
			}()
			if idxNum < 3 {
				(*carray_cursor)(unsafe.Pointer(pCur)).FeType = uint8(CARRAY_INT32)
			} else {
				var i uint8
				var zType uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
				for i = uint8(0); uint32(i) < uint32(unsafe.Sizeof(azType))/uint32(unsafe.Sizeof(uintptr(0))); i++ {
					if sqlite3.Xsqlite3_stricmp(tls, zType, azType[i]) == 0 {
						break
					}
				}
				if uint32(i) >= uint32(unsafe.Sizeof(azType))/uint32(unsafe.Sizeof(uintptr(0))) {
					(*sqlite3_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
						ts+4424, libc.VaList(bp, zType))
					return SQLITE_ERROR
				} else {
					(*carray_cursor)(unsafe.Pointer(pCur)).FeType = i
				}
			}
			break

		}
	}
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return SQLITE_OK
}

func carrayBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var i int32
	var ptrIdx int32 = -1
	var cntIdx int32 = -1
	var ctypeIdx int32 = -1

	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case CARRAY_COLUMN_POINTER:
			ptrIdx = i
			break
		case CARRAY_COLUMN_COUNT:
			cntIdx = i
			break
		case CARRAY_COLUMN_CTYPE:
			ctypeIdx = i
			break
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if ptrIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(100)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
		if cntIdx >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).FargvIndex = 2
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).Fomit = uint8(1)
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
			if ctypeIdx >= 0 {
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).FargvIndex = 3
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).Fomit = uint8(1)
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 3
			}
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
	}
	return SQLITE_OK
}

var carrayModule = sqlite3_module{
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func carrayBindDel(tls *libc.TLS, pPtr uintptr) {
	var p uintptr = pPtr
	if (*carray_bind)(unsafe.Pointer(p)).FxDel != uintptr(0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*carray_bind)(unsafe.Pointer(p)).FxDel})).f(tls, (*carray_bind)(unsafe.Pointer(p)).FaData)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func sqlite3_carray_bind(tls *libc.TLS, pStmt uintptr, idx int32, aData uintptr, nData int32, mFlags int32, xDestroy uintptr) int32 {
	var pNew uintptr
	var i int32
	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(carray_bind{})))
	if pNew == uintptr(0) {
		if xDestroy != uintptr(0) && xDestroy != libc.UintptrFromInt32(-1) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{xDestroy})).f(tls, aData)
		}
		return SQLITE_NOMEM
	}
	(*carray_bind)(unsafe.Pointer(pNew)).FnData = nData
	(*carray_bind)(unsafe.Pointer(pNew)).FmFlags = mFlags
	if xDestroy == libc.UintptrFromInt32(-1) {
		var sz sqlite3_int64 = sqlite3_int64(nData)
		switch mFlags & 0x07 {
		case CARRAY_INT32:
			sz = sz * int64(4)
			break
			fallthrough
		case CARRAY_INT64:
			sz = sz * int64(8)
			break
			fallthrough
		case CARRAY_DOUBLE:
			sz = sz * int64(8)
			break
			fallthrough
		case CARRAY_TEXT:
			sz = sz * sqlite3_int64(unsafe.Sizeof(uintptr(0)))
			break
			fallthrough
		case CARRAY_BLOB:
			sz = sz * sqlite3_int64(unsafe.Sizeof(iovec{}))
			break
		}
		if mFlags&0x07 == CARRAY_TEXT {
			for i = 0; i < nData; i++ {
				var z uintptr = *(*uintptr)(unsafe.Pointer(aData + uintptr(i)*4))
				if z != 0 {
					sz = sz + sqlite3_int64(libc.Xstrlen(tls, z)+size_t(1))
				}
			}
		} else if mFlags&0x07 == CARRAY_BLOB {
			for i = 0; i < nData; i++ {
				sz = sz + sqlite3_int64((*iovec)(unsafe.Pointer(aData+uintptr(i)*8)).Fiov_len)
			}
		}
		(*carray_bind)(unsafe.Pointer(pNew)).FaData = sqlite3.Xsqlite3_malloc64(tls, uint64(sz))
		if (*carray_bind)(unsafe.Pointer(pNew)).FaData == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, pNew)
			return SQLITE_NOMEM
		}
		if mFlags&0x07 == CARRAY_TEXT {
			var az uintptr = (*carray_bind)(unsafe.Pointer(pNew)).FaData
			var z uintptr = az + uintptr(nData)*4
			for i = 0; i < nData; i++ {
				var zData uintptr = *(*uintptr)(unsafe.Pointer(aData + uintptr(i)*4))
				var n sqlite3_int64
				if zData == uintptr(0) {
					*(*uintptr)(unsafe.Pointer(az + uintptr(i)*4)) = uintptr(0)
					continue
				}
				*(*uintptr)(unsafe.Pointer(az + uintptr(i)*4)) = z
				n = sqlite3_int64(libc.Xstrlen(tls, zData))
				libc.Xmemcpy(tls, z, zData, uint32(n+int64(1)))
				z += uintptr(n + int64(1))
			}
		} else if mFlags&0x07 == CARRAY_BLOB {
			var p uintptr = (*carray_bind)(unsafe.Pointer(pNew)).FaData
			var z uintptr = p + uintptr(nData)*8
			for i = 0; i < nData; i++ {
				var n size_t = (*iovec)(unsafe.Pointer(aData + uintptr(i)*8)).Fiov_len
				(*iovec)(unsafe.Pointer(p + uintptr(i)*8)).Fiov_len = n
				(*iovec)(unsafe.Pointer(p + uintptr(i)*8)).Fiov_base = z
				z += uintptr(n)
				libc.Xmemcpy(tls, (*iovec)(unsafe.Pointer(p+uintptr(i)*8)).Fiov_base, (*iovec)(unsafe.Pointer(aData+uintptr(i)*8)).Fiov_base, n)
			}
		} else {
			libc.Xmemcpy(tls, (*carray_bind)(unsafe.Pointer(pNew)).FaData, aData, uint32(sz))
		}
		(*carray_bind)(unsafe.Pointer(pNew)).FxDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))
	} else {
		(*carray_bind)(unsafe.Pointer(pNew)).FaData = aData
		(*carray_bind)(unsafe.Pointer(pNew)).FxDel = xDestroy
	}
	return sqlite3.Xsqlite3_bind_pointer(tls, pStmt, idx, pNew, ts+4405, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{carrayBindDel})))
}

func inttoptrFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*sqlite3_int64)(unsafe.Pointer(bp + 4)) = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if uint32(unsafe.Sizeof(sqlite3_int64(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp, bp+4, uint32(unsafe.Sizeof(uintptr(0))))
	} else {
		*(*int32)(unsafe.Pointer(bp + 12)) = int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 4)) & int64(0xffffffff))
		libc.Xmemcpy(tls, bp, bp+12, uint32(unsafe.Sizeof(uintptr(0))))
	}
	sqlite3.Xsqlite3_result_pointer(tls, context, *(*uintptr)(unsafe.Pointer(bp)), ts+4417, uintptr(0))
}

func sqlite3_carray_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4417, uintptr(unsafe.Pointer(&carrayModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4445, 1, SQLITE_UTF8, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{inttoptrFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

type CksmVfs = sqlite3_vfs1
type CksmFile1 = struct {
	Fbase        sqlite3_file
	FzFName      uintptr
	FcomputeCksm int8
	FverifyCksm  int8
	FisWal       int8
	FinCkpt      int8
	FpPartner    uintptr
}

type CksmFile = CksmFile1

var cksm_vfs = sqlite3_vfs{
	FiVersion:          3,
	FmxPathname:        1024,
	FzName:             ts + 4454,
	FxOpen:             0,
	FxDelete:           0,
	FxAccess:           0,
	FxFullPathname:     0,
	FxDlOpen:           0,
	FxDlError:          0,
	FxDlSym:            0,
	FxDlClose:          0,
	FxRandomness:       0,
	FxSleep:            0,
	FxCurrentTime:      0,
	FxGetLastError:     0,
	FxCurrentTimeInt64: 0,
	FxSetSystemCall:    0,
	FxGetSystemCall:    0,
	FxNextSystemCall:   0,
}

var cksm_io_methods = sqlite3_io_methods{
	FiVersion:               3,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
	FxFetch:                 0,
	FxUnfetch:               0,
}

func cksmCompute(tls *libc.TLS, a uintptr, nByte int32, aOut uintptr) {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*u32)(unsafe.Pointer(bp + 4)) = u32(0)
	*(*u32)(unsafe.Pointer(bp + 8)) = u32(0)
	var aData uintptr = a
	var aEnd uintptr = a + uintptr(nByte)
	*(*u32)(unsafe.Pointer(bp)) = u32(1)

	if 1 == int32(*(*u8)(unsafe.Pointer(bp))) {
		for __ccgo := true; __ccgo; __ccgo = aData < aEnd {
			*(*u32)(unsafe.Pointer(bp + 4)) += *(*u32)(unsafe.Pointer(libc.PostIncUintptr(&aData, 4))) + *(*u32)(unsafe.Pointer(bp + 8))
			*(*u32)(unsafe.Pointer(bp + 8)) += *(*u32)(unsafe.Pointer(libc.PostIncUintptr(&aData, 4))) + *(*u32)(unsafe.Pointer(bp + 4))
		}
	} else {
		for __ccgo1 := true; __ccgo1; __ccgo1 = aData < aEnd {
			*(*u32)(unsafe.Pointer(bp + 4)) += *(*u32)(unsafe.Pointer(aData))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(aData))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(aData))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(aData))&0xFF000000>>24 + *(*u32)(unsafe.Pointer(bp + 8))
			*(*u32)(unsafe.Pointer(bp + 8)) += *(*u32)(unsafe.Pointer(aData + 1*4))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(aData + 1*4))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(aData + 1*4))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(aData + 1*4))&0xFF000000>>24 + *(*u32)(unsafe.Pointer(bp + 4))
			aData += 4 * uintptr(2)
		}
		*(*u32)(unsafe.Pointer(bp + 4)) = *(*u32)(unsafe.Pointer(bp + 4))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(bp + 4))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(bp + 4))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(bp + 4))&0xFF000000>>24
		*(*u32)(unsafe.Pointer(bp + 8)) = *(*u32)(unsafe.Pointer(bp + 8))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(bp + 8))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(bp + 8))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(bp + 8))&0xFF000000>>24
	}
	libc.Xmemcpy(tls, aOut, bp+4, uint32(4))
	libc.Xmemcpy(tls, aOut+uintptr(4), bp+8, uint32(4))
}

func cksmVerifyFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var nByte int32
	var data uintptr

	data = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if data == uintptr(0) {
		return
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_BLOB {
		return
	}
	nByte = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if nByte < 512 || nByte > 65536 || nByte&(nByte-1) != 0 {
		return
	}
	cksmCompute(tls, data, nByte-8, bp)
	sqlite3.Xsqlite3_result_int(tls, context, libc.Bool32(libc.Xmemcmp(tls, data+uintptr(nByte)-uintptr(8), bp, uint32(8)) == 0))
}

func cksmClose(tls *libc.TLS, pFile uintptr) int32 {
	var p uintptr = pFile
	if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
		(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FpPartner = uintptr(0)
		(*CksmFile)(unsafe.Pointer(p)).FpPartner = uintptr(0)
	}
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxClose})).f(tls, pFile)
}

func cksmSetFlags(tls *libc.TLS, p uintptr, hasCorrectReserveSize int32) {
	if hasCorrectReserveSize != int32((*CksmFile)(unsafe.Pointer(p)).FcomputeCksm) {
		(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = libc.AssignPtrInt8(p+9, int8(hasCorrectReserveSize))
		if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FverifyCksm = int8(hasCorrectReserveSize)
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FcomputeCksm = int8(hasCorrectReserveSize)
		}
	}
}

func cksmRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*16
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, zBuf, iAmt, iOfst)
	if rc == SQLITE_OK {
		if iOfst == int64(0) && iAmt >= 100 && (libc.Xmemcmp(tls, zBuf, ts+3951, uint32(16)) == 0 || libc.Xmemcmp(tls, zBuf, ts+4462, uint32(3)) == 0) {
			var d uintptr = zBuf
			var hasCorrectReserveSize int8 = int8(libc.Bool32(int32(*(*u8)(unsafe.Pointer(d + 20))) == 8))
			cksmSetFlags(tls, p, int32(hasCorrectReserveSize))
		}

		if iAmt >= 512 &&
			(*CksmFile)(unsafe.Pointer(p)).FverifyCksm != 0 &&
			!(int32((*CksmFile)(unsafe.Pointer(p)).FinCkpt) != 0) {
			cksmCompute(tls, zBuf, iAmt-8, bp+16)
			if libc.Xmemcmp(tls, zBuf+uintptr(iAmt)-uintptr(8), bp+16, uint32(8)) != 0 {
				sqlite3.Xsqlite3_log(tls, SQLITE_IOERR|int32(32)<<8,
					ts+4466,
					libc.VaList(bp, iOfst, (*CksmFile)(unsafe.Pointer(p)).FzFName))
				rc = SQLITE_IOERR | int32(32)<<8
			}
		}
	}
	return rc
}

func cksmWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*16
	if iOfst == int64(0) && iAmt >= 100 && (libc.Xmemcmp(tls, zBuf, ts+3951, uint32(16)) == 0 || libc.Xmemcmp(tls, zBuf, ts+4462, uint32(3)) == 0) {
		var d uintptr = zBuf
		var hasCorrectReserveSize int8 = int8(libc.Bool32(int32(*(*u8)(unsafe.Pointer(d + 20))) == 8))
		cksmSetFlags(tls, p, int32(hasCorrectReserveSize))
	}

	if iAmt >= 512 &&
		(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0 &&
		!(int32((*CksmFile)(unsafe.Pointer(p)).FinCkpt) != 0) {
		cksmCompute(tls, zBuf, iAmt-8, zBuf+uintptr(iAmt)-uintptr(8))
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxWrite})).f(tls, pFile, zBuf, iAmt, iOfst)
}

func cksmTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxTruncate})).f(tls, pFile, size)
}

func cksmSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSync})).f(tls, pFile, flags)
}

func cksmFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var p uintptr = pFile
	pFile = p + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFileSize})).f(tls, pFile, pSize)
}

func cksmLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxLock})).f(tls, pFile, eLock)
}

func cksmUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnlock})).f(tls, pFile, eLock)
}

func cksmCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxCheckReservedLock})).f(tls, pFile, pResOut)
}

func cksmFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*16
	if op == SQLITE_FCNTL_PRAGMA {
		var azArg uintptr = pArg

		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(azArg + 1*4)), ts+4501) == 0 {
			var zArg uintptr = *(*uintptr)(unsafe.Pointer(azArg + 2*4))
			if zArg != uintptr(0) {
				if int32(*(*int8)(unsafe.Pointer(zArg))) >= '1' && int32(*(*int8)(unsafe.Pointer(zArg))) <= '9' ||
					sqlite3.Xsqlite3_strlike(tls, ts+4523, zArg, uint32(0)) == 0 ||
					sqlite3.Xsqlite3_stricmp(tls, ts+4531, zArg) == 0 ||
					sqlite3.Xsqlite3_stricmp(tls, ts+4535, zArg) == 0 {
					(*CksmFile)(unsafe.Pointer(p)).FverifyCksm = (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm
				} else {
					(*CksmFile)(unsafe.Pointer(p)).FverifyCksm = int8(0)
				}
				if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
					(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FverifyCksm = (*CksmFile)(unsafe.Pointer(p)).FverifyCksm
				}
			}
			*(*uintptr)(unsafe.Pointer(azArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+1333, libc.VaList(bp, int32((*CksmFile)(unsafe.Pointer(p)).FverifyCksm)))
			return SQLITE_OK
		} else if (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0 && *(*uintptr)(unsafe.Pointer(azArg + 2*4)) != uintptr(0) &&
			sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(azArg + 1*4)), ts+4538) == 0 {
			return SQLITE_OK
		}
	} else if op == SQLITE_FCNTL_CKPT_START || op == SQLITE_FCNTL_CKPT_DONE {
		(*CksmFile)(unsafe.Pointer(p)).FinCkpt = int8(libc.Bool32(op == SQLITE_FCNTL_CKPT_START))
		if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FinCkpt = (*CksmFile)(unsafe.Pointer(p)).FinCkpt
		}
	} else if op == SQLITE_FCNTL_CKSM_FILE {
		var ppFile uintptr = pArg
		*(*uintptr)(unsafe.Pointer(ppFile)) = p
		return SQLITE_OK
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFileControl})).f(tls, pFile, op, pArg)
	if rc == SQLITE_OK && op == SQLITE_FCNTL_VFSNAME {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+4548, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

func cksmSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSectorSize})).f(tls, pFile)
}

func cksmDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxDeviceCharacteristics})).f(tls, pFile)
}

func cksmShmMap(tls *libc.TLS, pFile uintptr, iPg int32, pgsz int32, bExtend int32, pp uintptr) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmMap})).f(tls, pFile, iPg, pgsz, bExtend, pp)
}

func cksmShmLock(tls *libc.TLS, pFile uintptr, offset int32, n int32, flags int32) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmLock})).f(tls, pFile, offset, n, flags)
}

func cksmShmBarrier(tls *libc.TLS, pFile uintptr) {
	pFile = pFile + uintptr(1)*16
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmBarrier})).f(tls, pFile)
}

func cksmShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 {
	pFile = pFile + uintptr(1)*16
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmUnmap})).f(tls, pFile, deleteFlag)
}

func cksmFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 {
	var p uintptr = pFile
	if (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0 {
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		return SQLITE_OK
	}
	pFile = pFile + uintptr(1)*16
	if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FiVersion > 2 && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFetch != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFetch})).f(tls, pFile, iOfst, iAmt, pp)
	}
	*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
	return SQLITE_OK
}

func cksmUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, pPage uintptr) int32 {
	pFile = pFile + uintptr(1)*16
	if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FiVersion > 2 && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnfetch != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnfetch})).f(tls, pFile, iOfst, pPage)
	}
	return SQLITE_OK
}

func cksmOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var pSubFile uintptr
	var pSubVfs uintptr
	var rc int32

	pSubVfs = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if !(flags&(SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_WAL) == 0) {
		goto __1
	}
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pSubVfs)).FxOpen})).f(tls, pSubVfs, zName, pFile, flags, pOutFlags)
__1:
	;
	p = pFile
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(CksmFile{})))
	pSubFile = pFile + uintptr(1)*16
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&cksm_io_methods))
	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pSubVfs)).FxOpen})).f(tls, pSubVfs, zName, pSubFile, flags, pOutFlags)
	if !(rc != 0) {
		goto __2
	}
	goto cksm_open_done
__2:
	;
	if !(flags&SQLITE_OPEN_WAL != 0) {
		goto __3
	}
	*(*uintptr)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3_database_file_object(tls, zName)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods)).FxFileControl})).f(tls, *(*uintptr)(unsafe.Pointer(bp)), SQLITE_FCNTL_CKSM_FILE, bp)

	(*CksmFile)(unsafe.Pointer(p)).FpPartner = *(*uintptr)(unsafe.Pointer(bp))

	(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FpPartner = p
	(*CksmFile)(unsafe.Pointer(p)).FisWal = int8(1)
	(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = (*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FcomputeCksm
	goto __4
__3:
	(*CksmFile)(unsafe.Pointer(p)).FisWal = int8(0)
	(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = int8(0)
__4:
	;
	(*CksmFile)(unsafe.Pointer(p)).FzFName = zName
cksm_open_done:
	if !(rc != 0) {
		goto __5
	}
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
__5:
	;
	return rc
}

func cksmDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDelete})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, dirSync)
}

func cksmAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxAccess})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, flags, pResOut)
}

func cksmFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxFullPathname})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, nOut, zOut)
}

func cksmDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlOpen})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath)
}

func cksmDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zErrMsg)
}

func cksmDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlSym})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p, zSym)
}

func cksmDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlClose})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pHandle)
}

func cksmRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxRandomness})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zBufOut)
}

func cksmSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSleep})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nMicro)
}

func cksmCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxCurrentTime})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pTimeOut)
}

func cksmGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetLastError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, a, b)
}

func cksmCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pOrig uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	var rc int32

	if (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FxCurrentTimeInt64 != 0 {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrig)).FxCurrentTimeInt64})).f(tls, pOrig, p)
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrig)).FxCurrentTime})).f(tls, pOrig, bp)
		*(*sqlite3_int64)(unsafe.Pointer(p)) = libc.Int64FromFloat64(*(*float64)(unsafe.Pointer(bp)) * 86400000.0)
	}
	return rc
}

func cksmSetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr, pCall sqlite3_syscall_ptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName, pCall)
}

func cksmGetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) sqlite3_syscall_ptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func cksmNextSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxNextSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func cksmRegisterFunc(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32
	if db == uintptr(0) {
		return SQLITE_OK
	}
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4556, 1,
		SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{cksmVerifyFunc})), uintptr(0), uintptr(0))
	return rc
}

func cksmRegisterVfs(tls *libc.TLS) int32 {
	var rc int32 = SQLITE_OK
	var pOrig uintptr
	if sqlite3.Xsqlite3_vfs_find(tls, ts+4454) != uintptr(0) {
		return SQLITE_OK
	}
	pOrig = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if pOrig == uintptr(0) {
		return SQLITE_ERROR
	}
	cksm_vfs.FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FiVersion
	cksm_vfs.FpAppData = pOrig
	cksm_vfs.FszOsFile = int32(uint32((*sqlite3_vfs)(unsafe.Pointer(pOrig)).FszOsFile) + uint32(unsafe.Sizeof(CksmFile{})))
	rc = sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&cksm_vfs)), 1)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{cksmRegisterFunc})))
	}
	return rc
}

func sqlite3_register_cksumvfs(tls *libc.TLS, NotUsed uintptr) int32 {
	_ = NotUsed
	return cksmRegisterVfs(tls)
}

func sqlite3_unregister_cksumvfs(tls *libc.TLS) int32 {
	if sqlite3.Xsqlite3_vfs_find(tls, ts+4454) != 0 {
		sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&cksm_vfs)))
		sqlite3.Xsqlite3_cancel_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{cksmRegisterFunc})))
	}
	return SQLITE_OK
}

type closure_vtab1 = struct {
	Fbase          sqlite3_vtab
	FzDb           uintptr
	FzSelf         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	Fdb            uintptr
	FnCursor       int32
}

type closure_vtab = closure_vtab1
type closure_cursor1 = struct {
	Fbase          sqlite3_vtab_cursor
	FpVtab         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	FpCurrent      uintptr
	FpClosure      uintptr
}

type closure_cursor = closure_cursor1
type closure_queue1 = struct {
	FpFirst uintptr
	FpLast  uintptr
}

type closure_queue = closure_queue1
type closure_avl1 = struct {
	Fid          sqlite3_int64
	FiGeneration int32
	FpList       uintptr
	FpBefore     uintptr
	FpAfter      uintptr
	FpUp         uintptr
	Fheight      int16
	Fimbalance   int16
}

type closure_avl = closure_avl1

func closureAvlRecomputeHeight(tls *libc.TLS, p uintptr) {
	var hBefore int16
	if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*closure_avl)(unsafe.Pointer(p)).Fimbalance = int16(int32(hBefore) - int32(hAfter))
	(*closure_avl)(unsafe.Pointer(p)).Fheight = int16(func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}() + 1)
}

func closureAvlRotateBefore(tls *libc.TLS, pP uintptr) uintptr {
	var pB uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pB)).FpAfter
	(*closure_avl)(unsafe.Pointer(pB)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*closure_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pB)
	return pB
}

func closureAvlRotateAfter(tls *libc.TLS, pP uintptr) uintptr {
	var pA uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pA)).FpBefore
	(*closure_avl)(unsafe.Pointer(pA)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*closure_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pA)
	return pA
}

func closureAvlFromPtr(tls *libc.TLS, p uintptr, pp uintptr) uintptr {
	var pUp uintptr = (*closure_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*closure_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return pUp + 20
	}
	return pUp + 16
}

func closureAvlBalance(tls *libc.TLS, p uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		closureAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp)))
		if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) >= 2 {
			var pB uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpBefore
			if int32((*closure_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpBefore = closureAvlRotateAfter(tls, pB)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp)), bp)
			*(*uintptr)(unsafe.Pointer(bp)) = libc.AssignPtrUintptr(pp, closureAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp))))
		} else if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) <= -2 {
			var pA uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpAfter
			if int32((*closure_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpAfter = closureAvlRotateBefore(tls, pA)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp)), bp)
			*(*uintptr)(unsafe.Pointer(bp)) = libc.AssignPtrUintptr(pp, closureAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp)) = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpUp
	}
	return pTop
}

func closureAvlSearch(tls *libc.TLS, p uintptr, id sqlite3_int64) uintptr {
	for p != 0 && id != (*closure_avl)(unsafe.Pointer(p)).Fid {
		if id < (*closure_avl)(unsafe.Pointer(p)).Fid {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

func closureAvlFirst(tls *libc.TLS, p uintptr) uintptr {
	if p != 0 {
		for (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

func closureAvlNext(tls *libc.TLS, p uintptr) uintptr {
	var pPrev uintptr = uintptr(0)
	for p != 0 && (*closure_avl)(unsafe.Pointer(p)).FpAfter == pPrev {
		pPrev = p
		p = (*closure_avl)(unsafe.Pointer(p)).FpUp
	}
	if p != 0 && pPrev == uintptr(0) {
		p = closureAvlFirst(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter)
	}
	return p
}

func closureAvlInsert(tls *libc.TLS, ppHead uintptr, pNew uintptr) uintptr {
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*closure_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			if (*closure_avl)(unsafe.Pointer(pNew)).Fid < (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if (*closure_avl)(unsafe.Pointer(pNew)).Fid > (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*closure_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*closure_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = closureAvlBalance(tls, p)
	return uintptr(0)
}

func closureAvlDestroy(tls *libc.TLS, p uintptr, xDestroy uintptr) {
	if p != 0 {
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpBefore, xDestroy)
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter, xDestroy)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{xDestroy})).f(tls, p)
	}
}

func queuePush(tls *libc.TLS, pQueue uintptr, pNode uintptr) {
	(*closure_avl)(unsafe.Pointer(pNode)).FpList = uintptr(0)
	if (*closure_queue)(unsafe.Pointer(pQueue)).FpLast != 0 {
		(*closure_avl)(unsafe.Pointer((*closure_queue)(unsafe.Pointer(pQueue)).FpLast)).FpList = pNode
	} else {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = pNode
	}
	(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = pNode
}

func queuePull(tls *libc.TLS, pQueue uintptr) uintptr {
	var p uintptr = (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst
	if p != 0 {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = (*closure_avl)(unsafe.Pointer(p)).FpList
		if (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst == uintptr(0) {
			(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = uintptr(0)
		}
	}
	return p
}

func closureDequote(tls *libc.TLS, zIn uintptr) uintptr {
	var nIn sqlite3_int64
	var zOut uintptr

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+int64(1)))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn))

		if int32(q) != '[' && int32(q) != '\'' && int32(q) != '"' && int32(q) != '`' {
			libc.Xmemcpy(tls, zOut, zIn, size_t(nIn+int64(1)))
		} else {
			var iOut int32 = 0
			var iIn int32

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

func closureFree(tls *libc.TLS, p uintptr) {
	if p != 0 {
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzSelf)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzTableName)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzIdColumn)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzParentColumn)
		libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(closure_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func closureDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab

	closureFree(tls, p)
	return SQLITE_OK
}

func closureValueOfKey(tls *libc.TLS, zKey uintptr, zStr uintptr) uintptr {
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var nStr int32 = int32(libc.Xstrlen(tls, zStr))
	var i int32
	if nStr < nKey+1 {
		return uintptr(0)
	}
	if libc.Xmemcmp(tls, zStr, zKey, uint32(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint32(X_CTYPE_S)) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint32(X_CTYPE_S)) != 0 {
		i++
	}
	return zStr + uintptr(i)
}

func closureConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var pNew uintptr
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = SQLITE_OK
	pNew = uintptr(0)
	zDb = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return SQLITE_NOMEM
__1:
	;
	rc = SQLITE_NOMEM
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(closure_vtab{})))
	(*closure_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*closure_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zDb))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __2
	}
	goto closureConnectError
__2:
	;
	(*closure_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __3
	}
	goto closureConnectError
__3:
	;
	i = 3
__4:
	if !(i < argc) {
		goto __6
	}
	zVal = closureValueOfKey(tls, ts+4572, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __7
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzTableName)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzTableName = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0)) {
		goto __8
	}
	goto closureConnectError
__8:
	;
	goto __5
__7:
	;
	zVal = closureValueOfKey(tls, ts+4582, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __9
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn == uintptr(0)) {
		goto __10
	}
	goto closureConnectError
__10:
	;
	goto __5
__9:
	;
	zVal = closureValueOfKey(tls, ts+4591, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	if !(zVal != 0) {
		goto __11
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn == uintptr(0)) {
		goto __12
	}
	goto closureConnectError
__12:
	;
	goto __5
__11:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3480, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	closureFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return SQLITE_ERROR
	goto __5
__5:
	i++
	goto __4
	goto __6
__6:
	;
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+4604)
	if !(rc != SQLITE_OK) {
		goto __13
	}
	closureFree(tls, pNew)
__13:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc

closureConnectError:
	closureFree(tls, pNew)
	return rc
}

func closureOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(closure_cursor{})))
	(*closure_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	(*closure_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

func closureClearCursor(tls *libc.TLS, pCur uintptr) {
	closureAvlDestroy(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpClosure = uintptr(0)
}

func closureClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	closureClearCursor(tls, pCur)
	(*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func closureNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlNext(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)
	return SQLITE_OK
}

func closureInsertNode(tls *libc.TLS, pQueue uintptr, pCur uintptr, id sqlite3_int64, iGeneration int32) int32 {
	var pNew uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_avl{})))
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(closure_avl{})))
	(*closure_avl)(unsafe.Pointer(pNew)).Fid = id
	(*closure_avl)(unsafe.Pointer(pNew)).FiGeneration = iGeneration
	closureAvlInsert(tls, pCur+24, pNew)
	queuePush(tls, pQueue, pNew)
	return SQLITE_OK
}

func closureFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*closure_cursor)(unsafe.Pointer(pCur)).FpVtab
	var iRoot sqlite3_int64
	var mxGen int32 = 999999999
	var zSql uintptr

	var pAvl uintptr
	var rc int32 = SQLITE_OK
	var zTableName uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName
	var zIdColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn
	var zParentColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn

	_ = idxStr
	_ = argc
	closureClearCursor(tls, pCur)
	libc.Xmemset(tls, bp+72, 0, uint32(unsafe.Sizeof(closure_queue{})))
	if idxNum&1 == 0 {
		return SQLITE_OK
	}
	iRoot = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if idxNum&0x000f0 != 0 {
		mxGen = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>4&0x0f)*4)))
		if idxNum&0x00002 != 0 {
			mxGen--
		}
	}
	if idxNum&0x00f00 != 0 {
		zTableName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>8&0x0f)*4)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zTableName))
	}
	if idxNum&0x0f000 != 0 {
		zIdColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>12&0x0f)*4)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, zIdColumn))
	}
	if idxNum&0x0f0000 != 0 {
		zParentColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>16&0x0f)*4)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+16, zParentColumn))
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+4694,
		libc.VaList(bp+24, zTableName, zIdColumn, zTableName, zTableName, zParentColumn))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, bp+80, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg)
			(*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+64, sqlite3.Xsqlite3_errmsg(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb)))
			return rc
		}
	}
	if rc == SQLITE_OK {
		rc = closureInsertNode(tls, bp+72, pCur, iRoot, 0)
	}
	for libc.AssignUintptr(&pAvl, queuePull(tls, bp+72)) != uintptr(0) {
		if (*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration >= mxGen {
			continue
		}
		sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), 1, (*closure_avl)(unsafe.Pointer(pAvl)).Fid)
		for rc == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80))) == SQLITE_ROW {
			if sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), 0) == SQLITE_INTEGER {
				var iNew sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), 0)
				if closureAvlSearch(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, iNew) == uintptr(0) {
					rc = closureInsertNode(tls, bp+72, pCur, iNew, (*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration+1)
				}
			}
		}
		sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 80)))
	}
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 80)))
	if rc == SQLITE_OK {
		(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlFirst(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure)
	}

	return rc
}

func closureColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	switch i {
	case CLOSURE_COL_ID:
		{
			sqlite3.Xsqlite3_result_int64(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid)
			break

		}
	case CLOSURE_COL_DEPTH:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FiGeneration)
			break

		}
	case CLOSURE_COL_ROOT:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	case CLOSURE_COL_TABLENAME:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzTableName
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	case CLOSURE_COL_IDCOLUMN:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzIdColumn
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	case CLOSURE_COL_PARENTCOLUMN:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzParentColumn
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	}
	return SQLITE_OK
}

func closureRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid
	return SQLITE_OK
}

func closureEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0))
}

func closureBestIndex(tls *libc.TLS, pTab uintptr, pIdxInfo uintptr) int32 {
	var iPlan int32 = 0
	var i int32
	var idx int32 = 1
	var pConstraint uintptr
	var pVtab uintptr = pTab
	var rCost float64 = 10000000.0

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if iPlan&1 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_ROOT &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / 100.0
		}
		if iPlan&0x0000f0 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_DEPTH &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | idx<<4
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
				iPlan = iPlan | 0x000002
			}
			rCost = rCost / 5.0
		}
		if iPlan&0x000f00 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_TABLENAME &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | idx<<8
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / 5.0
		}
		if iPlan&0x00f000 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_IDCOLUMN &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | idx<<12
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if iPlan&0x0f0000 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_PARENTCOLUMN &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | idx<<16
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName == uintptr(0) && iPlan&0x000f00 == 0 ||
		(*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn == uintptr(0) && iPlan&0x00f000 == 0 ||
		(*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn == uintptr(0) && iPlan&0x0f0000 == 0 {
		iPlan = 0
	}
	if iPlan&1 == 0 {
		rCost = rCost * 1e30
		i = 0
	__4:
		if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
			goto __6
		}
		{
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 0

		}
		goto __5
	__5:
		i++
		pConstraint += 12
		goto __4
		goto __6
	__6:
		;
		iPlan = 0
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == CLOSURE_COL_ID &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return SQLITE_OK
}

var closureModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_closure_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4740, uintptr(unsafe.Pointer(&closureModule)), uintptr(0))
	return rc
}

type CsvReader1 = struct {
	Fin        uintptr
	Fz         uintptr
	Fn         int32
	FnAlloc    int32
	FnLine     int32
	FbNotFirst int32
	FcTerm     int32
	FiIn       size_t
	FnIn       size_t
	FzIn       uintptr
	FzErr      [200]int8
}

type CsvReader = CsvReader1

func csv_reader_init(tls *libc.TLS, p uintptr) {
	(*CsvReader)(unsafe.Pointer(p)).Fin = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fz = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	(*CsvReader)(unsafe.Pointer(p)).FnAlloc = 0
	(*CsvReader)(unsafe.Pointer(p)).FnLine = 0
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 0
	(*CsvReader)(unsafe.Pointer(p)).FnIn = size_t(0)
	(*CsvReader)(unsafe.Pointer(p)).FzIn = uintptr(0)
	*(*int8)(unsafe.Pointer(p + 40)) = int8(0)
}

func csv_reader_reset(tls *libc.TLS, p uintptr) {
	if (*CsvReader)(unsafe.Pointer(p)).Fin != 0 {
		libc.Xfclose(tls, (*CsvReader)(unsafe.Pointer(p)).Fin)
		sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
	}
	sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).Fz)
	csv_reader_init(tls, p)
}

func csv_errmsg(tls *libc.TLS, p uintptr, zFormat uintptr, va uintptr) {
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_vsnprintf(tls, CSV_MXERR, p+40, zFormat, ap)
	_ = ap
}

func csv_reader_open(tls *libc.TLS, p uintptr, zFilename uintptr, zData uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if zFilename != 0 {
		(*CsvReader)(unsafe.Pointer(p)).FzIn = sqlite3.Xsqlite3_malloc(tls, CSV_INBUFSZ)
		if (*CsvReader)(unsafe.Pointer(p)).FzIn == uintptr(0) {
			csv_errmsg(tls, p, ts+2069, 0)
			return 1
		}
		(*CsvReader)(unsafe.Pointer(p)).Fin = libc.Xfopen(tls, zFilename, ts+4759)
		if (*CsvReader)(unsafe.Pointer(p)).Fin == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
			csv_reader_reset(tls, p)
			csv_errmsg(tls, p, ts+4762, libc.VaList(bp, zFilename))
			return 1
		}
	} else {
		(*CsvReader)(unsafe.Pointer(p)).FzIn = zData
		(*CsvReader)(unsafe.Pointer(p)).FnIn = libc.Xstrlen(tls, zData)
	}
	return 0
}

func csv_getc_refill(tls *libc.TLS, p uintptr) int32 {
	var got size_t

	got = libc.Xfread(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn, uint32(1), uint32(CSV_INBUFSZ), (*CsvReader)(unsafe.Pointer(p)).Fin)
	if got == size_t(0) {
		return -1
	}
	(*CsvReader)(unsafe.Pointer(p)).FnIn = got
	(*CsvReader)(unsafe.Pointer(p)).FiIn = size_t(1)
	return int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).FzIn)))
}

func csv_getc(tls *libc.TLS, p uintptr) int32 {
	if (*CsvReader)(unsafe.Pointer(p)).FiIn >= (*CsvReader)(unsafe.Pointer(p)).FnIn {
		if (*CsvReader)(unsafe.Pointer(p)).Fin != uintptr(0) {
			return csv_getc_refill(tls, p)
		}
		return -1
	}
	return int32(*(*uint8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).FzIn + uintptr(libc.PostIncUint32(&(*CsvReader)(unsafe.Pointer(p)).FiIn, 1)))))
}

func csv_resize_and_append(tls *libc.TLS, p uintptr, c int8) int32 {
	var zNew uintptr
	var nNew int32 = (*CsvReader)(unsafe.Pointer(p)).FnAlloc*2 + 100
	zNew = sqlite3.Xsqlite3_realloc64(tls, (*CsvReader)(unsafe.Pointer(p)).Fz, uint64(nNew))
	if zNew != 0 {
		(*CsvReader)(unsafe.Pointer(p)).Fz = zNew
		(*CsvReader)(unsafe.Pointer(p)).FnAlloc = nNew
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
		return 0
	} else {
		csv_errmsg(tls, p, ts+2069, 0)
		return 1
	}
	return int32(0)
}

func csv_append(tls *libc.TLS, p uintptr, c int8) int32 {
	if (*CsvReader)(unsafe.Pointer(p)).Fn >= (*CsvReader)(unsafe.Pointer(p)).FnAlloc-1 {
		return csv_resize_and_append(tls, p, c)
	}
	*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
	return 0
}

func csv_read_one_field(tls *libc.TLS, p uintptr) uintptr {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var c int32
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	c = csv_getc(tls, p)
	if c == -1 {
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = -1
		return uintptr(0)
	}
	if c == '"' {
		var pc int32
		var ppc int32
		var startLine int32 = (*CsvReader)(unsafe.Pointer(p)).FnLine
		pc = libc.AssignInt32(&ppc, 0)
		for 1 != 0 {
			c = csv_getc(tls, p)
			if c <= '"' || pc == '"' {
				if c == '\n' {
					(*CsvReader)(unsafe.Pointer(p)).FnLine++
				}
				if c == '"' {
					if pc == '"' {
						pc = 0
						continue
					}
				}
				if c == ',' && pc == '"' ||
					c == '\n' && pc == '"' ||
					c == '\n' && pc == '\r' && ppc == '"' ||
					c == -1 && pc == '"' {
					for __ccgo := true; __ccgo; __ccgo = int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn)))) != '"' {
						(*CsvReader)(unsafe.Pointer(p)).Fn--
					}
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
				if pc == '"' && c != '\r' {
					csv_errmsg(tls, p, ts+4791, libc.VaList(bp, (*CsvReader)(unsafe.Pointer(p)).FnLine, '"'))
					break
				}
				if c == -1 {
					csv_errmsg(tls, p, ts+4823,
						libc.VaList(bp+16, startLine, '"'))
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
			}
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			ppc = pc
			pc = c
		}
	} else {
		if c&0xff == 0xef && (*CsvReader)(unsafe.Pointer(p)).FbNotFirst == 0 {
			csv_append(tls, p, int8(c))
			c = csv_getc(tls, p)
			if c&0xff == 0xbb {
				csv_append(tls, p, int8(c))
				c = csv_getc(tls, p)
				if c&0xff == 0xbf {
					(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
					(*CsvReader)(unsafe.Pointer(p)).Fn = 0
					return csv_read_one_field(tls, p)
				}
			}
		}
		for c > ',' || c != -1 && c != ',' && c != '\n' {
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			c = csv_getc(tls, p)
		}
		if c == '\n' {
			(*CsvReader)(unsafe.Pointer(p)).FnLine++
			if (*CsvReader)(unsafe.Pointer(p)).Fn > 0 && int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn-1)))) == '\r' {
				(*CsvReader)(unsafe.Pointer(p)).Fn--
			}
		}
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
	}

	if (*CsvReader)(unsafe.Pointer(p)).Fz != 0 {
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn))) = int8(0)
	}
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
	return (*CsvReader)(unsafe.Pointer(p)).Fz
}

type CsvTable1 = struct {
	Fbase      sqlite3_vtab
	FzFilename uintptr
	FzData     uintptr
	FiStart    int32
	FnCol      int32
	FtstFlags  uint32
}

type CsvTable = CsvTable1

type CsvCursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	Frdr    CsvReader
	FazVal  uintptr
	FaLen   uintptr
	FiRowid sqlite3_int64
}

type CsvCursor = CsvCursor1

func csv_xfer_error(tls *libc.TLS, pTab uintptr, pRdr uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg)
	(*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, pRdr+40))
}

func csvtabDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzFilename)
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzData)
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func csv_skip_whitespace(tls *libc.TLS, z uintptr) uintptr {
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(z)))), uint32(X_CTYPE_S)) != 0 {
		z++
	}
	return z
}

func csv_trim_whitespace(tls *libc.TLS, z uintptr) {
	var n size_t = libc.Xstrlen(tls, z)
	for n > size_t(0) && __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n))))), uint32(X_CTYPE_S)) != 0 {
		n--
	}
	*(*int8)(unsafe.Pointer(z + uintptr(n))) = int8(0)
}

func csv_dequote(tls *libc.TLS, z uintptr) {
	var j int32
	var cQuote int8 = *(*int8)(unsafe.Pointer(z))
	var i size_t
	var n size_t

	if int32(cQuote) != '\'' && int32(cQuote) != '"' {
		return
	}
	n = libc.Xstrlen(tls, z)
	if n < size_t(2) || int32(*(*int8)(unsafe.Pointer(z + uintptr(n-size_t(1))))) != int32(*(*int8)(unsafe.Pointer(z))) {
		return
	}
	i = size_t(1)
	j = 0
	for ; i < n-size_t(1); i++ {
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == int32(cQuote) && int32(*(*int8)(unsafe.Pointer(z + uintptr(i+size_t(1))))) == int32(cQuote) {
			i++
		}
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
}

func csv_parameter(tls *libc.TLS, zTag uintptr, nTag int32, z uintptr) uintptr {
	z = csv_skip_whitespace(tls, z)
	if libc.Xstrncmp(tls, zTag, z, uint32(nTag)) != 0 {
		return uintptr(0)
	}
	z = csv_skip_whitespace(tls, z+uintptr(nTag))
	if int32(*(*int8)(unsafe.Pointer(z))) != '=' {
		return uintptr(0)
	}
	return csv_skip_whitespace(tls, z+uintptr(1))
}

func csv_string_parameter(tls *libc.TLS, p uintptr, zParam uintptr, zArg uintptr, pzVal uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zValue uintptr
	zValue = csv_parameter(tls, zParam, int32(libc.Xstrlen(tls, zParam)), zArg)
	if zValue == uintptr(0) {
		return 0
	}
	*(*int8)(unsafe.Pointer(p + 40)) = int8(0)
	if *(*uintptr)(unsafe.Pointer(pzVal)) != 0 {
		csv_errmsg(tls, p, ts+4862, libc.VaList(bp, zParam))
		return 1
	}
	*(*uintptr)(unsafe.Pointer(pzVal)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, zValue))
	if *(*uintptr)(unsafe.Pointer(pzVal)) == uintptr(0) {
		csv_errmsg(tls, p, ts+2069, 0)
		return 1
	}
	csv_trim_whitespace(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	csv_dequote(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	return 1
}

func csv_boolean(tls *libc.TLS, z uintptr) int32 {
	if sqlite3.Xsqlite3_stricmp(tls, ts+4531, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4535, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4891, z) == 0 ||
		int32(*(*int8)(unsafe.Pointer(z))) == '1' && int32(*(*int8)(unsafe.Pointer(z + 1))) == 0 {
		return 1
	}
	if sqlite3.Xsqlite3_stricmp(tls, ts+4896, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4899, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4903, z) == 0 ||
		int32(*(*int8)(unsafe.Pointer(z))) == '0' && int32(*(*int8)(unsafe.Pointer(z + 1))) == 0 {
		return 0
	}
	return -1
}

func csv_boolean_parameter(tls *libc.TLS, zTag uintptr, nTag int32, z uintptr, pValue uintptr) int32 {
	var b int32
	z = csv_skip_whitespace(tls, z)
	if libc.Xstrncmp(tls, zTag, z, uint32(nTag)) != 0 {
		return 0
	}
	z = csv_skip_whitespace(tls, z+uintptr(nTag))
	if int32(*(*int8)(unsafe.Pointer(z))) == 0 {
		*(*int32)(unsafe.Pointer(pValue)) = 1
		return 1
	}
	if int32(*(*int8)(unsafe.Pointer(z))) != '=' {
		return 0
	}
	z = csv_skip_whitespace(tls, z+uintptr(1))
	b = csv_boolean(tls, z)
	if b >= 0 {
		*(*int32)(unsafe.Pointer(pValue)) = b
		return 1
	}
	return 0
}

func csvtabConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(336)
	defer tls.Free(336)

	var pNew uintptr
	var bHeader int32
	var rc int32
	var i int32
	var j int32
	var tstFlags int32

	var nCol int32

	var z uintptr
	var zValue uintptr
	var z1 uintptr
	var pStr uintptr
	var zSep uintptr
	var iCol int32
	pNew = uintptr(0)
	bHeader = -1
	rc = SQLITE_OK
	tstFlags = 0
	nCol = -99

	libc.Xmemset(tls, bp+80, 0, uint32(unsafe.Sizeof(CsvReader{})))
	libc.Xmemset(tls, bp+320, 0, uint32(unsafe.Sizeof([3]uintptr{})))
	i = 3
__1:
	if !(i < argc) {
		goto __3
	}
	z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
	j = 0
__4:
	if !(uint32(j) < uint32(unsafe.Sizeof(azParam))/uint32(unsafe.Sizeof(uintptr(0)))) {
		goto __6
	}
	if !(csv_string_parameter(tls, bp+80, azParam[j], z, bp+320+uintptr(j)*4) != 0) {
		goto __7
	}
	goto __6
__7:
	;
	goto __5
__5:
	j++
	goto __4
	goto __6
__6:
	;
	if !(uint32(j) < uint32(unsafe.Sizeof(azParam))/uint32(unsafe.Sizeof(uintptr(0)))) {
		goto __8
	}
	if !(*(*int8)(unsafe.Pointer(bp + 80 + 40)) != 0) {
		goto __10
	}
	goto csvtab_connect_error
__10:
	;
	goto __9
__8:
	if !(csv_boolean_parameter(tls, ts+4909, 6, z, bp+332) != 0) {
		goto __11
	}
	if !(bHeader >= 0) {
		goto __13
	}
	csv_errmsg(tls, bp+80, ts+4916, 0)
	goto csvtab_connect_error
__13:
	;
	bHeader = *(*int32)(unsafe.Pointer(bp + 332))
	goto __12
__11:
	if !(libc.AssignUintptr(&zValue, csv_parameter(tls, ts+4949, 9, z)) != uintptr(0)) {
		goto __14
	}
	tstFlags = int32(uint32(libc.Xatoi(tls, zValue)))
	goto __15
__14:
	if !(libc.AssignUintptr(&zValue, csv_parameter(tls, ts+4959, 7, z)) != uintptr(0)) {
		goto __16
	}
	if !(nCol > 0) {
		goto __18
	}
	csv_errmsg(tls, bp+80, ts+4967, 0)
	goto csvtab_connect_error
__18:
	;
	nCol = libc.Xatoi(tls, zValue)
	if !(nCol <= 0) {
		goto __19
	}
	csv_errmsg(tls, bp+80, ts+5001, 0)
	goto csvtab_connect_error
__19:
	;
	goto __17
__16:
	csv_errmsg(tls, bp+80, ts+5032, libc.VaList(bp, z))
	goto csvtab_connect_error
__17:
	;
__15:
	;
__12:
	;
__9:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	if !(libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 320)) == uintptr(0)) == libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 320 + 1*4)) == uintptr(0))) {
		goto __20
	}
	csv_errmsg(tls, bp+80, ts+5052, 0)
	goto csvtab_connect_error
__20:
	;
	if !((nCol <= 0 || bHeader == 1) &&
		csv_reader_open(tls, bp+80, *(*uintptr)(unsafe.Pointer(bp + 320)), *(*uintptr)(unsafe.Pointer(bp + 320 + 1*4))) != 0) {
		goto __21
	}
	goto csvtab_connect_error
__21:
	;
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CsvTable{})))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	if !(pNew == uintptr(0)) {
		goto __22
	}
	goto csvtab_connect_oom
__22:
	;
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(CsvTable{})))
	if !(*(*uintptr)(unsafe.Pointer(bp + 320 + 2*4)) == uintptr(0)) {
		goto __23
	}
	pStr = sqlite3.Xsqlite3_str_new(tls, uintptr(0))
	zSep = ts + 584
	iCol = 0
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+979, 0)
	if !(nCol < 0 && bHeader < 1) {
		goto __25
	}
	nCol = 0
__26:
	csv_read_one_field(tls, bp+80)
	nCol++
	goto __27
__27:
	if (*CsvReader)(unsafe.Pointer(bp+80)).FcTerm == ',' {
		goto __26
	}
	goto __28
__28:
	;
__25:
	;
	if !(nCol > 0 && bHeader < 1) {
		goto __29
	}
	iCol = 0
__31:
	if !(iCol < nCol) {
		goto __33
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+5104, libc.VaList(bp+8, zSep, iCol))
	zSep = ts + 5115
	goto __32
__32:
	iCol++
	goto __31
	goto __33
__33:
	;
	goto __30
__29:
__34:
	z1 = csv_read_one_field(tls, bp+80)
	if !(nCol > 0 && iCol < nCol || nCol < 0 && bHeader != 0) {
		goto __37
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+5117, libc.VaList(bp+24, zSep, z1))
	zSep = ts + 5115
	iCol++
__37:
	;
	goto __35
__35:
	if (*CsvReader)(unsafe.Pointer(bp+80)).FcTerm == ',' {
		goto __34
	}
	goto __36
__36:
	;
	if !(nCol < 0) {
		goto __38
	}
	nCol = iCol
	goto __39
__38:
__40:
	if !(iCol < nCol) {
		goto __41
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+5104, libc.VaList(bp+40, zSep, libc.PreIncInt32(&iCol, 1)))
	zSep = ts + 5115
	goto __40
__41:
	;
__39:
	;
__30:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+585, 0)
	*(*uintptr)(unsafe.Pointer(bp + 320 + 2*4)) = sqlite3.Xsqlite3_str_finish(tls, pStr)
	if !(*(*uintptr)(unsafe.Pointer(bp + 320 + 2*4)) == uintptr(0)) {
		goto __42
	}
	goto csvtab_connect_oom
__42:
	;
	goto __24
__23:
	if !(nCol < 0) {
		goto __43
	}
__45:
	csv_read_one_field(tls, bp+80)
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol++
	goto __46
__46:
	if (*CsvReader)(unsafe.Pointer(bp+80)).FcTerm == ',' {
		goto __45
	}
	goto __47
__47:
	;
	goto __44
__43:
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
__44:
	;
__24:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FzFilename = *(*uintptr)(unsafe.Pointer(bp + 320))
	*(*uintptr)(unsafe.Pointer(bp + 320)) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FzData = *(*uintptr)(unsafe.Pointer(bp + 320 + 1*4))
	*(*uintptr)(unsafe.Pointer(bp + 320 + 1*4)) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FtstFlags = uint32(tstFlags)
	if !(bHeader != 1) {
		goto __48
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = 0
	goto __49
__48:
	if !((*CsvTable)(unsafe.Pointer(pNew)).FzData != 0) {
		goto __50
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int32((*CsvReader)(unsafe.Pointer(bp + 80)).FiIn)
	goto __51
__50:
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int32(uint32(libc.Xftell(tls, (*CsvReader)(unsafe.Pointer(bp+80)).Fin)) - (*CsvReader)(unsafe.Pointer(bp+80)).FnIn + (*CsvReader)(unsafe.Pointer(bp+80)).FiIn)
__51:
	;
__49:
	;
	csv_reader_reset(tls, bp+80)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, *(*uintptr)(unsafe.Pointer(bp + 320 + 2*4)))
	if !(rc != 0) {
		goto __52
	}
	csv_errmsg(tls, bp+80, ts+5129, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(bp + 320 + 2*4)), sqlite3.Xsqlite3_errmsg(tls, db)))
	goto csvtab_connect_error
__52:
	;
	i = 0
__53:
	if !(uint32(i) < uint32(unsafe.Sizeof([3]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0)))) {
		goto __55
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 320 + uintptr(i)*4)))
	goto __54
__54:
	i++
	goto __53
	goto __55
__55:
	;
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	return SQLITE_OK

csvtab_connect_oom:
	rc = SQLITE_NOMEM
	csv_errmsg(tls, bp+80, ts+2069, 0)

csvtab_connect_error:
	if !(pNew != 0) {
		goto __56
	}
	csvtabDisconnect(tls, pNew)
__56:
	;
	i = 0
__57:
	if !(uint32(i) < uint32(unsafe.Sizeof([3]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0)))) {
		goto __59
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 320 + uintptr(i)*4)))
	goto __58
__58:
	i++
	goto __57
	goto __59
__59:
	;
	if !(*(*int8)(unsafe.Pointer(bp + 80 + 40)) != 0) {
		goto __60
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(pzErr)))
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+72, bp+80+40))
__60:
	;
	csv_reader_reset(tls, bp+80)
	if !(rc == SQLITE_OK) {
		goto __61
	}
	rc = SQLITE_ERROR
__61:
	;
	return rc
}

var azParam = [3]uintptr{
	ts + 5151, ts + 5160, ts + 5165,
}

func csvtabCursorRowReset(tls *libc.TLS, pCur uintptr) {
	var pTab uintptr = (*CsvCursor)(unsafe.Pointer(pCur)).Fbase.FpVtab
	var i int32
	for i = 0; i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)))
		*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) = uintptr(0)
		*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
	}
}

func csvtabCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	return csvtabConnect(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

func csvtabClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	csvtabCursorRowReset(tls, pCur)
	csv_reader_reset(tls, pCur+4)
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

func csvtabOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	var pTab uintptr = p
	var pCur uintptr
	var nByte size_t
	nByte = uint32(unsafe.Sizeof(CsvCursor{})) + (uint32(unsafe.Sizeof(uintptr(0)))+uint32(unsafe.Sizeof(int32(0))))*uint32((*CsvTable)(unsafe.Pointer(pTab)).FnCol)
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, nByte)
	(*CsvCursor)(unsafe.Pointer(pCur)).FazVal = pCur + 1*260
	(*CsvCursor)(unsafe.Pointer(pCur)).FaLen = (*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr((*CsvTable)(unsafe.Pointer(pTab)).FnCol)*4
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	if csv_reader_open(tls, pCur+4, (*CsvTable)(unsafe.Pointer(pTab)).FzFilename, (*CsvTable)(unsafe.Pointer(pTab)).FzData) != 0 {
		csv_xfer_error(tls, pTab, pCur+4)
		return SQLITE_ERROR
	}
	return SQLITE_OK
}

func csvtabNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var i int32 = 0
	var z uintptr
	for __ccgo := true; __ccgo; __ccgo = (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FcTerm == ',' {
		z = csv_read_one_field(tls, pCur+4)
		if z == uintptr(0) {
			break
		}
		if i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			if *(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) < (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn+1 {
				var zNew uintptr = sqlite3.Xsqlite3_realloc64(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)), uint64((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn+1))
				if zNew == uintptr(0) {
					csv_errmsg(tls, pCur+4, ts+2069, 0)
					csv_xfer_error(tls, pTab, pCur+4)
					break
				}
				*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) = zNew
				*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1
			}
			libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)), z, uint32((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn+1))
			i++
		}
	}
	if z == uintptr(0) && i == 0 {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(-1)
	} else {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid++
		for i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)))
			*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) = uintptr(0)
			*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
			i++
		}
	}
	return SQLITE_OK
}

func csvtabColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if i >= 0 && i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol && *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)) != uintptr(0) {
		sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*4)), -1, libc.UintptrFromInt32(-1))
	}
	return SQLITE_OK
}

func csvtabRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*CsvCursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func csvtabEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*CsvCursor)(unsafe.Pointer(pCur)).FiRowid < int64(0))
}

func csvtabFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)

	if csv_append(tls, pCur+4, int8(0)) != 0 {
		return SQLITE_NOMEM
	}

	if (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin == uintptr(0) {
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = size_t((*CsvTable)(unsafe.Pointer(pTab)).FiStart)
	} else {
		libc.Xfseek(tls, (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin, (*CsvTable)(unsafe.Pointer(pTab)).FiStart, SEEK_SET)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = size_t(0)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FnIn = size_t(0)
	}
	return csvtabNext(tls, pVtabCursor)
}

func csvtabBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000)
	if (*CsvTable)(unsafe.Pointer(tab)).FtstFlags&uint32(CSVTEST_FIDX) != uint32(0) {
		var i int32
		var nConst int32 = 0
		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var op uint8
			if int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(i)*12)).Fusable) == 0 {
				continue
			}
			op = (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).Fop
			if int32(op) == SQLITE_INDEX_CONSTRAINT_EQ ||
				int32(op) == SQLITE_INDEX_CONSTRAINT_LIKE ||
				int32(op) == SQLITE_INDEX_CONSTRAINT_GLOB {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(nConst)*8)).FargvIndex = nConst + 1
				nConst++
			}
		}
	}
	return SQLITE_OK
}

var CsvModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func csvtabUpdate(tls *libc.TLS, p uintptr, n int32, v uintptr, x uintptr) int32 {
	return SQLITE_READONLY
}

var CsvModuleFauxWrite = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
	FxUpdate:     0,
}

func sqlite3_csv_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5172, uintptr(unsafe.Pointer(&CsvModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5176, uintptr(unsafe.Pointer(&CsvModuleFauxWrite)), uintptr(0))
	}
	return rc
}

type Decimal1 = struct {
	Fsign   int8
	Foom    int8
	FisNull int8
	FisInit int8
	FnDigit int32
	FnFrac  int32
	Fa      uintptr
}

type Decimal = Decimal1

func decimal_clear(tls *libc.TLS, p uintptr) {
	sqlite3.Xsqlite3_free(tls, (*Decimal)(unsafe.Pointer(p)).Fa)
}

func decimal_free(tls *libc.TLS, p uintptr) {
	if p != 0 {
		decimal_clear(tls, p)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func decimal_new(tls *libc.TLS, pCtx uintptr, pIn uintptr, nAlt int32, zAlt uintptr) uintptr {
	var p uintptr
	var n int32
	var i int32
	var zIn uintptr
	var iExp int32
	var j int32
	var neg int32
	var c int8
	var nExtra int32
	iExp = 0
	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Decimal{})))
	if !(p == uintptr(0)) {
		goto __1
	}
	goto new_no_mem
__1:
	;
	(*Decimal)(unsafe.Pointer(p)).Fsign = int8(0)
	(*Decimal)(unsafe.Pointer(p)).Foom = int8(0)
	(*Decimal)(unsafe.Pointer(p)).FisInit = int8(1)
	(*Decimal)(unsafe.Pointer(p)).FisNull = int8(0)
	(*Decimal)(unsafe.Pointer(p)).FnDigit = 0
	(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
	if !(zAlt != 0) {
		goto __2
	}
	n = nAlt
	zIn = zAlt
	goto __3
__2:
	if !(sqlite3.Xsqlite3_value_type(tls, pIn) == SQLITE_NULL) {
		goto __4
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = uintptr(0)
	(*Decimal)(unsafe.Pointer(p)).FisNull = int8(1)
	return p
__4:
	;
	n = sqlite3.Xsqlite3_value_bytes(tls, pIn)
	zIn = sqlite3.Xsqlite3_value_text(tls, pIn)
__3:
	;
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_malloc64(tls, uint64(n+1))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __5
	}
	goto new_no_mem
__5:
	;
	i = 0
__6:
	if !(__sbistype(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))), uint32(X_CTYPE_S)) != 0) {
		goto __8
	}
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '-') {
		goto __9
	}
	(*Decimal)(unsafe.Pointer(p)).Fsign = int8(1)
	i++
	goto __10
__9:
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '+') {
		goto __11
	}
	i++
__11:
	;
__10:
	;
__12:
	if !(i < n && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '0') {
		goto __13
	}
	i++
	goto __12
__13:
	;
__14:
	if !(i < n) {
		goto __15
	}
	c = int8(*(*uint8)(unsafe.Pointer(zIn + uintptr(i))))
	if !(int32(c) >= '0' && int32(c) <= '9') {
		goto __16
	}
	*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(libc.PostIncInt32(&(*Decimal)(unsafe.Pointer(p)).FnDigit, 1)))) = int8(int32(c) - '0')
	goto __17
__16:
	if !(int32(c) == '.') {
		goto __18
	}
	(*Decimal)(unsafe.Pointer(p)).FnFrac = (*Decimal)(unsafe.Pointer(p)).FnDigit + 1
	goto __19
__18:
	if !(int32(c) == 'e' || int32(c) == 'E') {
		goto __20
	}
	j = i + 1
	neg = 0
	if !(j >= n) {
		goto __21
	}
	goto __15
__21:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) == '-') {
		goto __22
	}
	neg = 1
	j++
	goto __23
__22:
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) == '+') {
		goto __24
	}
	j++
__24:
	;
__23:
	;
__25:
	if !(j < n && iExp < 1000000) {
		goto __26
	}
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) >= '0' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) <= '9') {
		goto __27
	}
	iExp = iExp*10 + int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) - '0'
__27:
	;
	j++
	goto __25
__26:
	;
	if !(neg != 0) {
		goto __28
	}
	iExp = -iExp
__28:
	;
	goto __15
__20:
	;
__19:
	;
__17:
	;
	i++
	goto __14
__15:
	;
	if !((*Decimal)(unsafe.Pointer(p)).FnFrac != 0) {
		goto __29
	}
	(*Decimal)(unsafe.Pointer(p)).FnFrac = (*Decimal)(unsafe.Pointer(p)).FnDigit - ((*Decimal)(unsafe.Pointer(p)).FnFrac - 1)
__29:
	;
	if !(iExp > 0) {
		goto __30
	}
	if !((*Decimal)(unsafe.Pointer(p)).FnFrac > 0) {
		goto __32
	}
	if !(iExp <= (*Decimal)(unsafe.Pointer(p)).FnFrac) {
		goto __33
	}
	*(*int32)(unsafe.Pointer(p + 8)) -= iExp
	iExp = 0
	goto __34
__33:
	iExp = iExp - (*Decimal)(unsafe.Pointer(p)).FnFrac
	(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
__34:
	;
__32:
	;
	if !(iExp > 0) {
		goto __35
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, uint64((*Decimal)(unsafe.Pointer(p)).FnDigit+iExp+1))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __36
	}
	goto new_no_mem
__36:
	;
	libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr((*Decimal)(unsafe.Pointer(p)).FnDigit), 0, uint32(iExp))
	*(*int32)(unsafe.Pointer(p + 4)) += iExp
__35:
	;
	goto __31
__30:
	if !(iExp < 0) {
		goto __37
	}
	iExp = -iExp
	nExtra = (*Decimal)(unsafe.Pointer(p)).FnDigit - (*Decimal)(unsafe.Pointer(p)).FnFrac - 1
	if !(nExtra != 0) {
		goto __38
	}
	if !(nExtra >= iExp) {
		goto __39
	}
	*(*int32)(unsafe.Pointer(p + 8)) += iExp
	iExp = 0
	goto __40
__39:
	iExp = iExp - nExtra
	(*Decimal)(unsafe.Pointer(p)).FnFrac = (*Decimal)(unsafe.Pointer(p)).FnDigit - 1
__40:
	;
__38:
	;
	if !(iExp > 0) {
		goto __41
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, uint64((*Decimal)(unsafe.Pointer(p)).FnDigit+iExp+1))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __42
	}
	goto new_no_mem
__42:
	;
	libc.Xmemmove(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr(iExp), (*Decimal)(unsafe.Pointer(p)).Fa, uint32((*Decimal)(unsafe.Pointer(p)).FnDigit))
	libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa, 0, uint32(iExp))
	*(*int32)(unsafe.Pointer(p + 4)) += iExp
	*(*int32)(unsafe.Pointer(p + 8)) += iExp
__41:
	;
__37:
	;
__31:
	;
	return p

new_no_mem:
	if !(pCtx != 0) {
		goto __43
	}
	sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
__43:
	;
	sqlite3.Xsqlite3_free(tls, p)
	return uintptr(0)
}

func decimal_result(tls *libc.TLS, pCtx uintptr, p uintptr) {
	var z uintptr
	var i int32
	var j int32
	var n int32
	if p == uintptr(0) || (*Decimal)(unsafe.Pointer(p)).Foom != 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return
	}
	if (*Decimal)(unsafe.Pointer(p)).FisNull != 0 {
		sqlite3.Xsqlite3_result_null(tls, pCtx)
		return
	}
	z = sqlite3.Xsqlite3_malloc(tls, (*Decimal)(unsafe.Pointer(p)).FnDigit+4)
	if z == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return
	}
	i = 0
	if (*Decimal)(unsafe.Pointer(p)).FnDigit == 0 || (*Decimal)(unsafe.Pointer(p)).FnDigit == 1 && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa))) == 0 {
		(*Decimal)(unsafe.Pointer(p)).Fsign = int8(0)
	}
	if (*Decimal)(unsafe.Pointer(p)).Fsign != 0 {
		*(*int8)(unsafe.Pointer(z)) = int8('-')
		i = 1
	}
	n = (*Decimal)(unsafe.Pointer(p)).FnDigit - (*Decimal)(unsafe.Pointer(p)).FnFrac
	if n <= 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8('0')
	}
	j = 0
	for n > 1 && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) == 0 {
		j++
		n--
	}
	for n > 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8(int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) + '0')
		j++
		n--
	}
	if (*Decimal)(unsafe.Pointer(p)).FnFrac != 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8('.')
		for __ccgo := true; __ccgo; __ccgo = j < (*Decimal)(unsafe.Pointer(p)).FnDigit {
			*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8(int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) + '0')
			j++
		}
	}
	*(*int8)(unsafe.Pointer(z + uintptr(i))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, pCtx, z, i, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
}

func decimalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var p uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	_ = argc
	decimal_result(tls, context, p)
	decimal_free(tls, p)
}

func decimal_cmp(tls *libc.TLS, pA uintptr, pB uintptr) int32 {
	var nASig int32
	var nBSig int32
	var rc int32
	var n int32
	if int32((*Decimal)(unsafe.Pointer(pA)).Fsign) != int32((*Decimal)(unsafe.Pointer(pB)).Fsign) {
		if (*Decimal)(unsafe.Pointer(pA)).Fsign != 0 {
			return -1
		}
		return +1
	}
	if (*Decimal)(unsafe.Pointer(pA)).Fsign != 0 {
		var pTemp uintptr = pA
		pA = pB
		pB = pTemp
	}
	nASig = (*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pA)).FnFrac
	nBSig = (*Decimal)(unsafe.Pointer(pB)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnFrac
	if nASig != nBSig {
		return nASig - nBSig
	}
	n = (*Decimal)(unsafe.Pointer(pA)).FnDigit
	if n > (*Decimal)(unsafe.Pointer(pB)).FnDigit {
		n = (*Decimal)(unsafe.Pointer(pB)).FnDigit
	}
	rc = libc.Xmemcmp(tls, (*Decimal)(unsafe.Pointer(pA)).Fa, (*Decimal)(unsafe.Pointer(pB)).Fa, uint32(n))
	if rc == 0 {
		rc = (*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnDigit
	}
	return rc
}

func decimalCmpFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var pA uintptr
	var pB uintptr
	var rc int32
	pA = uintptr(0)
	pB = uintptr(0)

	_ = argc
	pA = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	if !(pA == uintptr(0) || (*Decimal)(unsafe.Pointer(pA)).FisNull != 0) {
		goto __1
	}
	goto cmp_done
__1:
	;
	pB = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	if !(pB == uintptr(0) || (*Decimal)(unsafe.Pointer(pB)).FisNull != 0) {
		goto __2
	}
	goto cmp_done
__2:
	;
	rc = decimal_cmp(tls, pA, pB)
	if !(rc < 0) {
		goto __3
	}
	rc = -1
	goto __4
__3:
	if !(rc > 0) {
		goto __5
	}
	rc = +1
__5:
	;
__4:
	;
	sqlite3.Xsqlite3_result_int(tls, context, rc)
cmp_done:
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func decimal_expand(tls *libc.TLS, p uintptr, nDigit int32, nFrac int32) {
	var nAddSig int32
	var nAddFrac int32
	if p == uintptr(0) {
		return
	}
	nAddFrac = nFrac - (*Decimal)(unsafe.Pointer(p)).FnFrac
	nAddSig = nDigit - (*Decimal)(unsafe.Pointer(p)).FnDigit - nAddFrac
	if nAddFrac == 0 && nAddSig == 0 {
		return
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, uint64(nDigit+1))
	if (*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0) {
		(*Decimal)(unsafe.Pointer(p)).Foom = int8(1)
		return
	}
	if nAddSig != 0 {
		libc.Xmemmove(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr(nAddSig), (*Decimal)(unsafe.Pointer(p)).Fa, uint32((*Decimal)(unsafe.Pointer(p)).FnDigit))
		libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa, 0, uint32(nAddSig))
		*(*int32)(unsafe.Pointer(p + 4)) += nAddSig
	}
	if nAddFrac != 0 {
		libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr((*Decimal)(unsafe.Pointer(p)).FnDigit), 0, uint32(nAddFrac))
		*(*int32)(unsafe.Pointer(p + 4)) += nAddFrac
		*(*int32)(unsafe.Pointer(p + 8)) += nAddFrac
	}
}

func decimal_add(tls *libc.TLS, pA uintptr, pB uintptr) {
	var nSig int32
	var nFrac int32
	var nDigit int32
	var i int32
	var rc int32
	if pA == uintptr(0) {
		return
	}
	if (*Decimal)(unsafe.Pointer(pA)).Foom != 0 || pB == uintptr(0) || (*Decimal)(unsafe.Pointer(pB)).Foom != 0 {
		(*Decimal)(unsafe.Pointer(pA)).Foom = int8(1)
		return
	}
	if (*Decimal)(unsafe.Pointer(pA)).FisNull != 0 || (*Decimal)(unsafe.Pointer(pB)).FisNull != 0 {
		(*Decimal)(unsafe.Pointer(pA)).FisNull = int8(1)
		return
	}
	nSig = (*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if nSig != 0 && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa))) == 0 {
		nSig--
	}
	if nSig < (*Decimal)(unsafe.Pointer(pB)).FnDigit-(*Decimal)(unsafe.Pointer(pB)).FnFrac {
		nSig = (*Decimal)(unsafe.Pointer(pB)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnFrac
	}
	nFrac = (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if nFrac < (*Decimal)(unsafe.Pointer(pB)).FnFrac {
		nFrac = (*Decimal)(unsafe.Pointer(pB)).FnFrac
	}
	nDigit = nSig + nFrac + 1
	decimal_expand(tls, pA, nDigit, nFrac)
	decimal_expand(tls, pB, nDigit, nFrac)
	if (*Decimal)(unsafe.Pointer(pA)).Foom != 0 || (*Decimal)(unsafe.Pointer(pB)).Foom != 0 {
		(*Decimal)(unsafe.Pointer(pA)).Foom = int8(1)
	} else {
		if int32((*Decimal)(unsafe.Pointer(pA)).Fsign) == int32((*Decimal)(unsafe.Pointer(pB)).Fsign) {
			var carry int32 = 0
			for i = nDigit - 1; i >= 0; i-- {
				var x int32 = int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i)))) + int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pB)).Fa + uintptr(i)))) + carry
				if x >= 10 {
					carry = 1
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x - 10)
				} else {
					carry = 0
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x)
				}
			}
		} else {
			var aA uintptr
			var aB uintptr
			var borrow int32 = 0
			rc = libc.Xmemcmp(tls, (*Decimal)(unsafe.Pointer(pA)).Fa, (*Decimal)(unsafe.Pointer(pB)).Fa, uint32(nDigit))
			if rc < 0 {
				aA = (*Decimal)(unsafe.Pointer(pB)).Fa
				aB = (*Decimal)(unsafe.Pointer(pA)).Fa
				(*Decimal)(unsafe.Pointer(pA)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pA)).Fsign != 0))
			} else {
				aA = (*Decimal)(unsafe.Pointer(pA)).Fa
				aB = (*Decimal)(unsafe.Pointer(pB)).Fa
			}
			for i = nDigit - 1; i >= 0; i-- {
				var x int32 = int32(*(*int8)(unsafe.Pointer(aA + uintptr(i)))) - int32(*(*int8)(unsafe.Pointer(aB + uintptr(i)))) - borrow
				if x < 0 {
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x + 10)
					borrow = 1
				} else {
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x)
					borrow = 0
				}
			}
		}
	}
}

func decimalCollFunc(tls *libc.TLS, notUsed uintptr, nKey1 int32, pKey1 uintptr, nKey2 int32, pKey2 uintptr) int32 {
	var zA uintptr = pKey1
	var zB uintptr = pKey2
	var pA uintptr = decimal_new(tls, uintptr(0), uintptr(0), nKey1, zA)
	var pB uintptr = decimal_new(tls, uintptr(0), uintptr(0), nKey2, zB)
	var rc int32
	_ = notUsed
	if pA == uintptr(0) || pB == uintptr(0) {
		rc = 0
	} else {
		rc = decimal_cmp(tls, pA, pB)
	}
	decimal_free(tls, pA)
	decimal_free(tls, pB)
	return rc
}

func decimalAddFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var pA uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	var pB uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	_ = argc
	decimal_add(tls, pA, pB)
	decimal_result(tls, context, pA)
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func decimalSubFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var pA uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	var pB uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	_ = argc
	if pB != 0 {
		(*Decimal)(unsafe.Pointer(pB)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pB)).Fsign != 0))
		decimal_add(tls, pA, pB)
		decimal_result(tls, context, pA)
	}
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func decimalSumStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var p uintptr
	var pArg uintptr
	_ = argc
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(Decimal{})))
	if p == uintptr(0) {
		return
	}
	if !(int32((*Decimal)(unsafe.Pointer(p)).FisInit) != 0) {
		(*Decimal)(unsafe.Pointer(p)).FisInit = int8(1)
		(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_malloc(tls, 2)
		if (*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0) {
			(*Decimal)(unsafe.Pointer(p)).Foom = int8(1)
		} else {
			*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa)) = int8(0)
		}
		(*Decimal)(unsafe.Pointer(p)).FnDigit = 1
		(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	pArg = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	decimal_add(tls, p, pArg)
	decimal_free(tls, pArg)
}

func decimalSumInverse(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var p uintptr
	var pArg uintptr
	_ = argc
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(Decimal{})))
	if p == uintptr(0) {
		return
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	pArg = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	if pArg != 0 {
		(*Decimal)(unsafe.Pointer(pArg)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pArg)).Fsign != 0))
	}
	decimal_add(tls, p, pArg)
	decimal_free(tls, pArg)
}

func decimalSumValue(tls *libc.TLS, context uintptr) {
	var p uintptr = sqlite3.Xsqlite3_aggregate_context(tls, context, 0)
	if p == uintptr(0) {
		return
	}
	decimal_result(tls, context, p)
}

func decimalSumFinalize(tls *libc.TLS, context uintptr) {
	var p uintptr = sqlite3.Xsqlite3_aggregate_context(tls, context, 0)
	if p == uintptr(0) {
		return
	}
	decimal_result(tls, context, p)
	decimal_clear(tls, p)
}

func decimalMulFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var pA uintptr
	var pB uintptr
	var acc uintptr
	var i int32
	var j int32
	var k int32
	var minFrac int32
	var f int8
	var carry int32
	var x int32
	pA = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	pB = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, uintptr(0))
	acc = uintptr(0)
	_ = argc
	if !(pA == uintptr(0) || (*Decimal)(unsafe.Pointer(pA)).Foom != 0 || (*Decimal)(unsafe.Pointer(pA)).FisNull != 0 ||
		pB == uintptr(0) || (*Decimal)(unsafe.Pointer(pB)).Foom != 0 || (*Decimal)(unsafe.Pointer(pB)).FisNull != 0) {
		goto __1
	}
	goto mul_end
__1:
	;
	acc = sqlite3.Xsqlite3_malloc64(tls, uint64((*Decimal)(unsafe.Pointer(pA)).FnDigit+(*Decimal)(unsafe.Pointer(pB)).FnDigit+2))
	if !(acc == uintptr(0)) {
		goto __2
	}
	sqlite3.Xsqlite3_result_error_nomem(tls, context)
	goto mul_end
__2:
	;
	libc.Xmemset(tls, acc, 0, uint32((*Decimal)(unsafe.Pointer(pA)).FnDigit+(*Decimal)(unsafe.Pointer(pB)).FnDigit+2))
	minFrac = (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if !((*Decimal)(unsafe.Pointer(pB)).FnFrac < minFrac) {
		goto __3
	}
	minFrac = (*Decimal)(unsafe.Pointer(pB)).FnFrac
__3:
	;
	i = (*Decimal)(unsafe.Pointer(pA)).FnDigit - 1
__4:
	if !(i >= 0) {
		goto __6
	}
	f = *(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i)))
	carry = 0
	j = (*Decimal)(unsafe.Pointer(pB)).FnDigit - 1
	k = i + j + 3
__7:
	if !(j >= 0) {
		goto __9
	}
	x = int32(*(*int8)(unsafe.Pointer(acc + uintptr(k)))) + int32(f)*int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pB)).Fa + uintptr(j)))) + carry
	*(*int8)(unsafe.Pointer(acc + uintptr(k))) = int8(x % 10)
	carry = x / 10
	goto __8
__8:
	j--
	k--
	goto __7
	goto __9
__9:
	;
	x = int32(*(*int8)(unsafe.Pointer(acc + uintptr(k)))) + carry
	*(*int8)(unsafe.Pointer(acc + uintptr(k))) = int8(x % 10)
	*(*int8)(unsafe.Pointer(acc + uintptr(k-1))) += int8(x / 10)
	goto __5
__5:
	i--
	goto __4
	goto __6
__6:
	;
	sqlite3.Xsqlite3_free(tls, (*Decimal)(unsafe.Pointer(pA)).Fa)
	(*Decimal)(unsafe.Pointer(pA)).Fa = acc
	acc = uintptr(0)
	*(*int32)(unsafe.Pointer(pA + 4)) += (*Decimal)(unsafe.Pointer(pB)).FnDigit + 2
	*(*int32)(unsafe.Pointer(pA + 8)) += (*Decimal)(unsafe.Pointer(pB)).FnFrac
	*(*int8)(unsafe.Pointer(pA)) ^= int8(int32((*Decimal)(unsafe.Pointer(pB)).Fsign))
__10:
	if !((*Decimal)(unsafe.Pointer(pA)).FnFrac > minFrac && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr((*Decimal)(unsafe.Pointer(pA)).FnDigit-1)))) == 0) {
		goto __11
	}
	(*Decimal)(unsafe.Pointer(pA)).FnFrac--
	(*Decimal)(unsafe.Pointer(pA)).FnDigit--
	goto __10
__11:
	;
	decimal_result(tls, context, pA)

mul_end:
	sqlite3.Xsqlite3_free(tls, acc)
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func sqlite3_decimal_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	var i uint32
	_ = pzErrMsg

	_ = pApi

	for i = uint32(0); i < uint32(int32(uint32(unsafe.Sizeof(aFunc))/uint32(unsafe.Sizeof(struct {
		FzFuncName uintptr
		FnArg      int32
		FxFunc     uintptr
	}{})))) && rc == SQLITE_OK; i++ {
		rc = sqlite3.Xsqlite3_create_function(tls, db, aFunc[i].FzFuncName, aFunc[i].FnArg,
			SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,
			uintptr(0), aFunc[i].FxFunc, uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_window_function(tls, db, ts+5183, 1,
			SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{decimalSumStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{decimalSumFinalize})),
			*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{decimalSumValue})), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{decimalSumInverse})), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_collation(tls, db, ts+5195, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{decimalCollFunc})))
	}
	return rc
}

var aFunc = [5]struct {
	FzFuncName uintptr
	FnArg      int32
	FxFunc     uintptr
}{
	{FzFuncName: ts + 5195, FnArg: 1, FxFunc: 0},
	{FzFuncName: ts + 5203, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 5215, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 5227, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 5239, FnArg: 2, FxFunc: 0},
}

type EvalResult = struct {
	Fz      uintptr
	FzSep   uintptr
	FszSep  int32
	FnAlloc sqlite3_int64
	FnUsed  sqlite3_int64
}

func callback(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr, colnames uintptr) int32 {
	var p uintptr = pCtx
	var i int32
	if argv == uintptr(0) {
		return 0
	}
	for i = 0; i < argc; i++ {
		var z uintptr
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)) != 0 {
			z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
		} else {
			z = ts + 584
		}
		var sz size_t = libc.Xstrlen(tls, z)
		if sqlite3_int64(sz)+(*EvalResult)(unsafe.Pointer(p)).FnUsed+sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep)+int64(1) > (*EvalResult)(unsafe.Pointer(p)).FnAlloc {
			var zNew uintptr
			(*EvalResult)(unsafe.Pointer(p)).FnAlloc = (*EvalResult)(unsafe.Pointer(p)).FnAlloc*int64(2) + sqlite3_int64(sz) + sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep) + int64(1)

			if (*EvalResult)(unsafe.Pointer(p)).FnAlloc <= int64(0x7fffffff) {
				zNew = sqlite3.Xsqlite3_realloc64(tls, (*EvalResult)(unsafe.Pointer(p)).Fz, uint64((*EvalResult)(unsafe.Pointer(p)).FnAlloc))
			} else {
				zNew = uintptr(0)
			}
			if zNew == uintptr(0) {
				sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(p)).Fz)
				libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(EvalResult{})))
				return 1
			}
			(*EvalResult)(unsafe.Pointer(p)).Fz = zNew
		}
		if (*EvalResult)(unsafe.Pointer(p)).FnUsed > int64(0) {
			libc.Xmemcpy(tls, (*EvalResult)(unsafe.Pointer(p)).Fz+uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed), (*EvalResult)(unsafe.Pointer(p)).FzSep, uint32((*EvalResult)(unsafe.Pointer(p)).FszSep))
			*(*sqlite3_int64)(unsafe.Pointer(p + 20)) += sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep)
		}
		libc.Xmemcpy(tls, (*EvalResult)(unsafe.Pointer(p)).Fz+uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed), z, sz)
		*(*sqlite3_int64)(unsafe.Pointer(p + 20)) += sqlite3_int64(sz)
	}
	return 0
}

func sqlEvalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zSql uintptr
	var db uintptr
	*(*uintptr)(unsafe.Pointer(bp + 28)) = uintptr(0)
	var rc int32

	libc.Xmemset(tls, bp, 0, uint32(unsafe.Sizeof(EvalResult{})))
	(*EvalResult)(unsafe.Pointer(bp)).FzSep = ts + 5251
	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zSql == uintptr(0) {
		return
	}
	if argc > 1 {
		(*EvalResult)(unsafe.Pointer(bp)).FzSep = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		if (*EvalResult)(unsafe.Pointer(bp)).FzSep == uintptr(0) {
			return
		}
	}
	(*EvalResult)(unsafe.Pointer(bp)).FszSep = int32(libc.Xstrlen(tls, (*EvalResult)(unsafe.Pointer(bp)).FzSep))
	db = sqlite3.Xsqlite3_context_db_handle(tls, context)
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{callback})), bp, bp+28)
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error(tls, context, *(*uintptr)(unsafe.Pointer(bp + 28)), -1)
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 28)))
	} else if (*EvalResult)(unsafe.Pointer(bp)).FzSep == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(bp)).Fz)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, (*EvalResult)(unsafe.Pointer(bp)).Fz, int32((*EvalResult)(unsafe.Pointer(bp)).FnUsed), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func sqlite3_eval_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5253, 1,
		SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sqlEvalFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5253, 2,
			SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{sqlEvalFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

type explain_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
}

type explain_vtab = explain_vtab1

type explain_cursor1 = struct {
	Fbase     sqlite3_vtab_cursor
	Fdb       uintptr
	FzSql     uintptr
	FpExplain uintptr
	Frc       int32
}

type explain_cursor = explain_cursor1

func explainConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pNew uintptr
	var rc int32

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+5258)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(explain_vtab{})))
		(*explain_vtab)(unsafe.Pointer(pNew)).Fdb = db
	}
	return rc
}

func explainDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func explainOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(explain_cursor{})))
	(*explain_cursor)(unsafe.Pointer(pCur)).Fdb = (*explain_vtab)(unsafe.Pointer(p)).Fdb
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func explainClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func explainNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	if (*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_DONE && (*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_ROW {
		return (*explain_cursor)(unsafe.Pointer(pCur)).Frc
	}
	return SQLITE_OK
}

func explainColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	if i == EXPLN_COLUMN_SQL {
		sqlite3.Xsqlite3_result_text(tls, ctx, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql, -1, libc.UintptrFromInt32(-1))
	} else {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, i))
	}
	return SQLITE_OK
}

func explainRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, 0)
	return SQLITE_OK
}

func explainEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_ROW)
}

func explainFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pCur uintptr = pVtabCursor
	var zSql uintptr = uintptr(0)
	var rc int32
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_TEXT {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = SQLITE_DONE
		return SQLITE_OK
	}
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))))
	if (*explain_cursor)(unsafe.Pointer(pCur)).FzSql != 0 {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5320, libc.VaList(bp+8, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql))
	}
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*explain_cursor)(unsafe.Pointer(pCur)).Fdb, zSql, -1, pCur+12, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if rc != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
		sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
		(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = uintptr(0)
	} else {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		if (*explain_cursor)(unsafe.Pointer(pCur)).Frc == SQLITE_DONE || (*explain_cursor)(unsafe.Pointer(pCur)).Frc == SQLITE_ROW {
			rc = SQLITE_OK
		} else {
			rc = (*explain_cursor)(unsafe.Pointer(pCur)).Frc
		}
	}
	return rc
}

func explainBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var i int32
	var idx int32 = -1
	var unusable int32 = 0

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(500)
	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != EXPLN_COLUMN_SQL {
			continue
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			unusable = 1
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idx = i
		}
	}
	if idx >= 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).Fomit = uint8(1)
	} else if unusable != 0 {
		return SQLITE_CONSTRAINT
	}
	return SQLITE_OK
}

var explainModule = sqlite3_module{
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3ExplainVtabInit(tls *libc.TLS, db uintptr) int32 {
	var rc int32 = SQLITE_OK
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5331, uintptr(unsafe.Pointer(&explainModule)), uintptr(0))
	return rc
}

func sqlite3_explain_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3ExplainVtabInit(tls, db)
	return rc
}

type pthread_once = struct {
	Fstate int32
	Fmutex pthread_mutex_t
}

type pthread_t = uintptr
type pthread_attr_t = uintptr
type pthread_mutex_t = uintptr
type pthread_mutexattr_t = uintptr
type pthread_cond_t = uintptr
type pthread_condattr_t = uintptr
type pthread_key_t = int32
type pthread_once_t = pthread_once
type pthread_rwlock_t = uintptr
type pthread_rwlockattr_t = uintptr
type pthread_barrier_t = uintptr
type pthread_barrierattr_t = uintptr
type pthread_spinlock_t = uintptr

type pthread_addr_t = uintptr
type pthread_startroutine_t = uintptr

type u_char = uint8
type u_short = uint16
type u_int = uint32
type u_long = uint32
type ushort = uint16
type uint = uint32

type int8_t = int8

type int16_t = int16

type int32_t = int32

type int64_t = int64

type uint8_t = uint8

type uint16_t = uint16

type uint32_t = uint32

type uint64_t = uint64

type intptr_t = int32
type uintptr_t = uint32
type intmax_t = int64
type uintmax_t = uint64

type u_int8_t = uint8
type u_int16_t = uint16
type u_int32_t = uint32
type u_int64_t = uint64

type u_quad_t = uint64
type quad_t = int64
type qaddr_t = uintptr

type caddr_t = uintptr
type c_caddr_t = uintptr

type blksize_t = int32

type cpuwhich_t = int32
type cpulevel_t = int32
type cpusetid_t = int32

type blkcnt_t = int64

type clock_t = uint32

type clockid_t = int32

type critical_t = int32
type daddr_t = int64

type dev_t = uint64

type fflags_t = uint32

type fixpt_t = uint32

type fsblkcnt_t = uint64
type fsfilcnt_t = uint64

type gid_t = uint32

type in_addr_t = uint32

type in_port_t = uint16

type id_t = int64

type ino_t = uint64

type key_t = int32

type lwpid_t = int32

type mode_t = uint16

type accmode_t = int32

type nlink_t = uint64

type pid_t = int32

type register_t = int32

type rlim_t = int64

type sbintime_t = int64

type segsz_t = int32

type suseconds_t = int32

type time_t = int32

type timer_t = uintptr

type mqd_t = uintptr

type u_register_t = uint32

type uid_t = uint32

type useconds_t = uint32

type cap_ioctl_t = uint32

type kpaddr_t = uint64
type kvaddr_t = uint64
type ksize_t = uint64
type kssize_t = int64

type vm_offset_t = uint32
type vm_ooffset_t = uint64
type vm_paddr_t = uint64
type vm_pindex_t = uint64
type vm_size_t = uint32

type rman_res_t = uint64

func __bitcount32(tls *libc.TLS, _x uint32) uint32 {
	_x = _x&uint32(0x55555555) + _x&0xaaaaaaaa>>1
	_x = _x&uint32(0x33333333) + _x&0xcccccccc>>2
	_x = (_x + _x>>4) & uint32(0x0f0f0f0f)
	_x = _x + _x>>8
	_x = (_x + _x>>16) & uint32(0x000000ff)
	return _x
}

type __sigset = struct{ F__bits [4]uint32 }

type timeval = struct {
	Ftv_sec  time_t
	Ftv_usec suseconds_t
}

type timespec = struct {
	Ftv_sec  time_t
	Ftv_nsec int32
}

type itimerspec = struct {
	Fit_interval struct {
		Ftv_sec  time_t
		Ftv_nsec int32
	}
	Fit_value struct {
		Ftv_sec  time_t
		Ftv_nsec int32
	}
}

type fd_mask = uint32

type sigset_t = __sigset

type fd_set1 = struct{ F__fds_bits [32]uint32 }

type fd_set = fd_set1

type timezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
}

type bintime = struct {
	Fsec  time_t
	Ffrac uint64_t
}

func sbttons(tls *libc.TLS, _sbt sbintime_t) int64_t {
	var ns uint64_t

	ns = uint64_t(_sbt)
	if ns >= uint64(int64(1)<<32) {
		ns = ns >> 32 * uint64(1000000000)
	} else {
		ns = uint64(0)
	}

	return int64_t(ns + uint64_t(int64(1000000000)*(_sbt&int64(0xffffffff))>>32))
}

func nstosbt(tls *libc.TLS, _ns int64_t) sbintime_t {
	var sb sbintime_t = int64(0)

	if _ns >= int64(1000000000) {
		sb = _ns / int64(1000000000) * (int64(1) << 32)
		_ns = _ns % int64(1000000000)
	}

	sb = sbintime_t(uint64(sb) + (uint64(_ns)*9223372037+uint64(0x7fffffff))>>31)
	return sb
}

func sbttous(tls *libc.TLS, _sbt sbintime_t) int64_t {
	return int64(1000000) * _sbt >> 32
}

func ustosbt(tls *libc.TLS, _us int64_t) sbintime_t {
	var sb sbintime_t = int64(0)

	if _us >= int64(1000000) {
		sb = _us / int64(1000000) * (int64(1) << 32)
		_us = _us % int64(1000000)
	}

	sb = sbintime_t(uint64(sb) + (uint64(_us)*9223372036855+uint64(0x7fffffff))>>31)
	return sb
}

type itimerval = struct {
	Fit_interval struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
	Fit_value struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
}

type clockinfo = struct {
	Fhz     int32
	Ftick   int32
	Fspare  int32
	Fstathz int32
	Fprofhz int32
}

type tm = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int32
	Ftm_zone   uintptr
}

type sigevent = struct {
	Fsigev_notify int32
	Fsigev_signo  int32
	Fsigev_value  struct{ Fsival_int int32 }
	F_sigev_un    struct {
		F_threadid   int32
		F__ccgo_pad1 [28]byte
	}
}

type flock = struct {
	Fl_start  off_t
	Fl_len    off_t
	Fl_pid    pid_t
	Fl_type   int16
	Fl_whence int16
	Fl_sysid  int32
}

type __oflock = struct {
	Fl_start  off_t
	Fl_len    off_t
	Fl_pid    pid_t
	Fl_type   int16
	Fl_whence int16
}

type crypt_data = struct {
	Finitialized int32
	F__buf       [256]int8
}

type dirent = struct {
	Fd_fileno ino_t
	Fd_off    off_t
	Fd_reclen uint16
	Fd_type   uint8
	Fd_pad0   uint8
	Fd_namlen uint16
	Fd_pad1   uint16
	Fd_name   [256]int8
}

func readFileContents(tls *libc.TLS, ctx uintptr, zName uintptr) {
	var in uintptr
	var nIn sqlite3_int64
	var pBuf uintptr
	var db uintptr
	var mxBlob int32

	in = libc.Xfopen(tls, zName, ts+4759)
	if in == uintptr(0) {
		return
	}
	libc.Xfseek(tls, in, 0, SEEK_END)
	nIn = sqlite3_int64(libc.Xftell(tls, in))
	libc.Xrewind(tls, in)
	db = sqlite3.Xsqlite3_context_db_handle(tls, ctx)
	mxBlob = sqlite3.Xsqlite3_limit(tls, db, SQLITE_LIMIT_LENGTH, -1)
	if nIn > sqlite3_int64(mxBlob) {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, SQLITE_TOOBIG)
		libc.Xfclose(tls, in)
		return
	}
	pBuf = sqlite3.Xsqlite3_malloc64(tls, func() uint64 {
		if nIn != 0 {
			return uint64(nIn)
		}
		return uint64(1)
	}())
	if pBuf == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
		libc.Xfclose(tls, in)
		return
	}
	if nIn == sqlite3_int64(libc.Xfread(tls, pBuf, uint32(1), size_t(nIn), in)) {
		sqlite3.Xsqlite3_result_blob64(tls, ctx, pBuf, uint64(nIn), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, SQLITE_IOERR)
		sqlite3.Xsqlite3_free(tls, pBuf)
	}
	libc.Xfclose(tls, in)
}

func readfileFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var zName uintptr
	_ = argc
	zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zName == uintptr(0) {
		return
	}
	readFileContents(tls, context, zName)
}

func ctxErrorMsg(tls *libc.TLS, ctx uintptr, zFmt uintptr, va uintptr) {
	var zMsg uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	sqlite3.Xsqlite3_result_error(tls, ctx, zMsg, -1)
	sqlite3.Xsqlite3_free(tls, zMsg)
	_ = ap
}

func fileStat(tls *libc.TLS, zPath uintptr, pStatBuf uintptr) int32 {
	return libc.Xstat(tls, zPath, pStatBuf)
}

func fileLinkStat(tls *libc.TLS, zPath uintptr, pStatBuf uintptr) int32 {
	return libc.Xlstat(tls, zPath, pStatBuf)
}

func makeDirectory(tls *libc.TLS, zFile uintptr) int32 {
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var zCopy uintptr = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zFile))
	var rc int32 = SQLITE_OK

	if zCopy == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var nCopy int32 = int32(libc.Xstrlen(tls, zCopy))
		var i int32 = 1

		for rc == SQLITE_OK {
			var rc2 int32

			for ; int32(*(*int8)(unsafe.Pointer(zCopy + uintptr(i)))) != '/' && i < nCopy; i++ {
			}
			if i == nCopy {
				break
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8(0)

			rc2 = fileStat(tls, zCopy, bp+8)
			if rc2 != 0 {
				if libc.Xmkdir(tls, zCopy, uint16(0777)) != 0 {
					rc = SQLITE_ERROR
				}
			} else {
				if !(int32((*stat)(unsafe.Pointer(bp+8)).Fst_mode)&0170000 == 0040000) {
					rc = SQLITE_ERROR
				}
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8('/')
			i++
		}

		sqlite3.Xsqlite3_free(tls, zCopy)
	}

	return rc
}

func writeFile(tls *libc.TLS, pCtx uintptr, zFile uintptr, pData uintptr, mode mode_t, mtime sqlite3_int64) int32 {
	bp := tls.Alloc(224)
	defer tls.Free(224)

	if zFile == uintptr(0) {
		return 1
	}
	if int32(mode)&0170000 == 0120000 {
		var zTo uintptr = sqlite3.Xsqlite3_value_text(tls, pData)
		if zTo == uintptr(0) || libc.Xsymlink(tls, zTo, zFile) < 0 {
			return 1
		}
	} else {
		if int32(mode)&0170000 == 0040000 {
			if libc.Xmkdir(tls, zFile, mode) != 0 {
				if *(*int32)(unsafe.Pointer(libc.X__error(tls))) != EEXIST ||
					0 != fileStat(tls, zFile, bp) ||
					!(int32((*stat)(unsafe.Pointer(bp)).Fst_mode)&0170000 == 0040000) ||
					int32((*stat)(unsafe.Pointer(bp)).Fst_mode)&0777 != int32(mode)&0777 && 0 != libc.Xchmod(tls, zFile, uint16(int32(mode)&0777)) {
					return 1
				}
			}
		} else {
			var nWrite sqlite3_int64 = int64(0)
			var z uintptr
			var rc int32 = 0
			var out uintptr = libc.Xfopen(tls, zFile, ts+5339)
			if out == uintptr(0) {
				return 1
			}
			z = sqlite3.Xsqlite3_value_blob(tls, pData)
			if z != 0 {
				var n sqlite3_int64 = sqlite3_int64(libc.Xfwrite(tls, z, uint32(1), uint32(sqlite3.Xsqlite3_value_bytes(tls, pData)), out))
				nWrite = sqlite3_int64(sqlite3.Xsqlite3_value_bytes(tls, pData))
				if nWrite != n {
					rc = 1
				}
			}
			libc.Xfclose(tls, out)
			if rc == 0 && mode != 0 && libc.Xchmod(tls, zFile, uint16(int32(mode)&0777)) != 0 {
				rc = 1
			}
			if rc != 0 {
				return 2
			}
			sqlite3.Xsqlite3_result_int64(tls, pCtx, nWrite)
		}
	}

	if mtime >= int64(0) {
		(*timeval)(unsafe.Pointer(bp + 208)).Ftv_usec = libc.AssignPtrInt32(bp+208+1*8+4, 0)
		(*timeval)(unsafe.Pointer(bp + 208)).Ftv_sec = libc.Xtime(tls, uintptr(0))
		(*timeval)(unsafe.Pointer(bp + 208 + 1*8)).Ftv_sec = time_t(mtime)
		if libc.Xutimes(tls, zFile, bp+208) != 0 {
			return 1
		}
	}

	return 0
}

func writefileFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zFile uintptr
	var mode mode_t = mode_t(0)
	var res int32
	var mtime sqlite3_int64 = int64(-1)

	if argc < 2 || argc > 4 {
		sqlite3.Xsqlite3_result_error(tls, context,
			ts+5342, -1)
		return
	}

	zFile = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zFile == uintptr(0) {
		return
	}
	if argc >= 3 {
		mode = mode_t(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	}
	if argc == 4 {
		mtime = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	}

	res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + 1*4)), mode, mtime)
	if res == 1 && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == ENOENT {
		if makeDirectory(tls, zFile) == SQLITE_OK {
			res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + 1*4)), mode, mtime)
		}
	}

	if argc > 2 && res != 0 {
		if int32(mode)&0170000 == 0120000 {
			ctxErrorMsg(tls, context, ts+5392, libc.VaList(bp, zFile))
		} else if int32(mode)&0170000 == 0040000 {
			ctxErrorMsg(tls, context, ts+5421, libc.VaList(bp+8, zFile))
		} else {
			ctxErrorMsg(tls, context, ts+5452, libc.VaList(bp+16, zFile))
		}
	}
}

func lsModeFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	var iMode int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))

	_ = argc
	if iMode&0170000 == 0120000 {
		*(*int8)(unsafe.Pointer(bp)) = int8('l')
	} else if iMode&0170000 == 0100000 {
		*(*int8)(unsafe.Pointer(bp)) = int8('-')
	} else if iMode&0170000 == 0040000 {
		*(*int8)(unsafe.Pointer(bp)) = int8('d')
	} else {
		*(*int8)(unsafe.Pointer(bp)) = int8('?')
	}
	for i = 0; i < 3; i++ {
		var m int32 = iMode >> ((2 - i) * 3)
		var a uintptr = bp + uintptr(1+i*3)
		*(*int8)(unsafe.Pointer(a)) = func() int8 {
			if m&0x4 != 0 {
				return int8('r')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + 1)) = func() int8 {
			if m&0x2 != 0 {
				return int8('w')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + 2)) = func() int8 {
			if m&0x1 != 0 {
				return int8('x')
			}
			return int8('-')
		}()
	}
	*(*int8)(unsafe.Pointer(bp + 10)) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp, -1, libc.UintptrFromInt32(-1))
}

type fsdir_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FnLvl  int32
	FiLvl  int32
	FaLvl  uintptr
	FzBase uintptr
	FnBase int32
	FsStat struct {
		Fst_dev      dev_t
		Fst_ino      ino_t
		Fst_nlink    nlink_t
		Fst_mode     mode_t
		Fst_padding0 int16
		Fst_uid      uid_t
		Fst_gid      gid_t
		Fst_padding1 int32
		Fst_rdev     dev_t
		Fst_atim_ext int32
		Fst_atim     struct {
			Ftv_sec  time_t
			Ftv_nsec int32
		}
		Fst_mtim_ext int32
		Fst_mtim     struct {
			Ftv_sec  time_t
			Ftv_nsec int32
		}
		Fst_ctim_ext int32
		Fst_ctim     struct {
			Ftv_sec  time_t
			Ftv_nsec int32
		}
		Fst_btim_ext int32
		Fst_birthtim struct {
			Ftv_sec  time_t
			Ftv_nsec int32
		}
		Fst_size    off_t
		Fst_blocks  blkcnt_t
		Fst_blksize blksize_t
		Fst_flags   fflags_t
		Fst_gen     uint64
		Fst_spare   [10]uint64
	}
	FzPath  uintptr
	FiRowid sqlite3_int64
}

type fsdir_cursor = fsdir_cursor1
type FsdirLevel1 = struct {
	FpDir uintptr
	FzDir uintptr
}

type FsdirLevel = FsdirLevel1

type fsdir_tab1 = struct{ Fbase sqlite3_vtab }

type fsdir_tab = fsdir_tab1

func fsdirConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pNew uintptr = uintptr(0)
	var rc int32
	_ = pAux
	_ = argc
	_ = argv
	_ = pzErr
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+5477)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_tab{})))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(fsdir_tab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

func fsdirDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func fsdirOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	_ = p
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(fsdir_cursor{})))
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func fsdirResetCursor(tls *libc.TLS, pCur uintptr) {
	var i int32
	for i = 0; i <= (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl; i++ {
		var pLvl uintptr = (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(i)*8
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir != 0 {
			libc.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		}
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
	}
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
}

func fsdirClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur

	fsdirResetCursor(tls, pCur)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func fsdirSetErrmsg(tls *libc.TLS, pCur uintptr, zFmt uintptr, va uintptr) {
	var ap va_list
	_ = ap
	ap = va
	(*sqlite3_vtab)(unsafe.Pointer((*fsdir_cursor)(unsafe.Pointer(pCur)).Fbase.FpVtab)).FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

func fsdirNext(tls *libc.TLS, cur uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pCur uintptr = cur
	var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode

	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid++
	if int32(m)&0170000 == 0040000 {
		var iNew int32 = (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl + 1
		var pLvl uintptr
		if iNew >= (*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl {
			var nNew int32 = iNew + 1
			var nByte sqlite3_int64 = sqlite3_int64(uint32(nNew) * uint32(unsafe.Sizeof(FsdirLevel{})))
			var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl, uint64(nByte))
			if aNew == uintptr(0) {
				return SQLITE_NOMEM
			}
			libc.Xmemset(tls, aNew+uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl)*8, 0, uint32(unsafe.Sizeof(FsdirLevel{}))*uint32(nNew-(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl))
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = aNew
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = nNew
		}
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = iNew
		pLvl = (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(iNew)*8

		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = libc.Xopendir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir == uintptr(0) {
			fsdirSetErrmsg(tls, pCur, ts+5537, libc.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
			return SQLITE_ERROR
		}
	}

	for (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl >= 0 {
		var pLvl uintptr = (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl)*8
		var pEntry uintptr = libc.Xreaddir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		if pEntry != 0 {
			if int32(*(*int8)(unsafe.Pointer(pEntry + 24))) == '.' {
				if int32(*(*int8)(unsafe.Pointer(pEntry + 24 + 1))) == '.' && int32(*(*int8)(unsafe.Pointer(pEntry + 24 + 2))) == 0 {
					continue
				}
				if int32(*(*int8)(unsafe.Pointer(pEntry + 24 + 1))) == 0 {
					continue
				}
			}
			sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+5563, libc.VaList(bp+8, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir, pEntry+24))
			if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
				return SQLITE_NOMEM
			}
			if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, pCur+24) != 0 {
				fsdirSetErrmsg(tls, pCur, ts+5569, libc.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
				return SQLITE_ERROR
			}
			return SQLITE_OK
		}
		libc.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = uintptr(0)
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl--
	}

	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	return SQLITE_OK
}

func fsdirColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pCur uintptr = cur
	switch i {
	case FSDIR_COLUMN_NAME:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath+uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase), -1, libc.UintptrFromInt32(-1))
			break

		}

	case FSDIR_COLUMN_MODE:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode))
		break

	case FSDIR_COLUMN_MTIME:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mtim.Ftv_sec))
		break

	case FSDIR_COLUMN_DATA:
		{
			var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode
			if int32(m)&0170000 == 0040000 {
				sqlite3.Xsqlite3_result_null(tls, ctx)
			} else if int32(m)&0170000 == 0120000 {
				var aBuf uintptr = bp
				var nBuf sqlite3_int64 = int64(64)
				var n int32

				for 1 != 0 {
					n = libc.Xreadlink(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, aBuf, uint32(nBuf))
					if sqlite3_int64(n) < nBuf {
						break
					}
					if aBuf != bp {
						sqlite3.Xsqlite3_free(tls, aBuf)
					}
					nBuf = nBuf * int64(2)
					aBuf = sqlite3.Xsqlite3_malloc64(tls, uint64(nBuf))
					if aBuf == uintptr(0) {
						sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
						return SQLITE_NOMEM
					}
				}

				sqlite3.Xsqlite3_result_text(tls, ctx, aBuf, n, libc.UintptrFromInt32(-1))
				if aBuf != bp {
					sqlite3.Xsqlite3_free(tls, aBuf)
				}
			} else {
				readFileContents(tls, ctx, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			}

		}
		fallthrough
	case FSDIR_COLUMN_PATH:
		fallthrough
	default:
		{
			break

		}
	}
	return SQLITE_OK
}

func fsdirRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func fsdirEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0))
}

func fsdirFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zDir uintptr = uintptr(0)
	var pCur uintptr = cur
	_ = idxStr
	fsdirResetCursor(tls, pCur)

	if idxNum == 0 {
		fsdirSetErrmsg(tls, pCur, ts+5590, 0)
		return SQLITE_ERROR
	}

	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zDir == uintptr(0) {
		fsdirSetErrmsg(tls, pCur, ts+5632, 0)
		return SQLITE_ERROR
	}
	if argc == 2 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	}
	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase != 0 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = int32(libc.Xstrlen(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase)) + 1
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+5563, libc.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase, zDir))
	} else {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+16, zDir))
	}

	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
		return SQLITE_NOMEM
	}
	if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, pCur+24) != 0 {
		fsdirSetErrmsg(tls, pCur, ts+5569, libc.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
		return SQLITE_ERROR
	}

	return SQLITE_OK
}

func fsdirBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var i int32
	var idxPath int32 = -1
	var idxDir int32 = -1
	var seenPath int32 = 0
	var seenDir int32 = 0
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case FSDIR_COLUMN_PATH:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxPath = i
					seenPath = 0
				} else if idxPath < 0 {
					seenPath = 1
				}
				break

			}
		case FSDIR_COLUMN_DIR:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxDir = i
					seenDir = 0
				} else if idxDir < 0 {
					seenDir = 1
				}
				break

			}
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if seenPath != 0 || seenDir != 0 {
		return SQLITE_CONSTRAINT
	}

	if idxPath < 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0

		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(0x7fffffff)
	} else {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).Fomit = uint8(1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).FargvIndex = 1
		if idxDir >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).FargvIndex = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		} else {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100.0
		}
	}

	return SQLITE_OK
}

func fsdirRegister(tls *libc.TLS, db uintptr) int32 {
	var rc int32 = sqlite3.Xsqlite3_create_module(tls, db, ts+5682, uintptr(unsafe.Pointer(&fsdirModule1)), uintptr(0))
	return rc
}

var fsdirModule1 = sqlite3_module{
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_fileio_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5688, 1,
		SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{readfileFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5697, -1,
			SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{writefileFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5707, 1, SQLITE_UTF8, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{lsModeFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = fsdirRegister(tls, db)
	}
	return rc
}

type fuzzer_vtab1 = struct {
	Fbase       sqlite3_vtab
	FzClassName uintptr
	FpRule      uintptr
	FnCursor    int32
}

type fuzzer_vtab = fuzzer_vtab1
type fuzzer_cursor1 = struct {
	Fbase     sqlite3_vtab_cursor
	FiRowid   sqlite3_int64
	FpVtab    uintptr
	FrLimit   fuzzer_cost
	FpStem    uintptr
	FpDone    uintptr
	FaQueue   [20]uintptr
	FmxQueue  int32
	FzBuf     uintptr
	FnBuf     int32
	FnStem    int32
	FiRuleset int32
	FnullRule fuzzer_rule
	FapHash   [4001]uintptr
}

type fuzzer_cursor = fuzzer_cursor1
type fuzzer_rule1 = struct {
	FpNext       uintptr
	FzFrom       uintptr
	FrCost       fuzzer_cost
	FnFrom       fuzzer_len
	FnTo         fuzzer_len
	F__ccgo_pad1 [2]byte
	FiRuleset    fuzzer_ruleid
	FzTo         [4]int8
}

type fuzzer_rule = fuzzer_rule1
type fuzzer_stem1 = struct {
	FzBasis      uintptr
	FpRule       uintptr
	FpNext       uintptr
	FpHash       uintptr
	FrBaseCost   fuzzer_cost
	FrCostX      fuzzer_cost
	FnBasis      fuzzer_len
	Fn           fuzzer_len
	F__ccgo_pad1 [2]byte
}

type fuzzer_stem = fuzzer_stem1

type fuzzer_cost = int32
type fuzzer_len = int8
type fuzzer_ruleid = int32

func fuzzerMergeRules(tls *libc.TLS, pA uintptr, pB uintptr) uintptr {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pTail uintptr

	pTail = bp
	for pA != 0 && pB != 0 {
		if (*fuzzer_rule)(unsafe.Pointer(pA)).FrCost <= (*fuzzer_rule)(unsafe.Pointer(pB)).FrCost {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_rule)(unsafe.Pointer(bp)).FpNext
}

func fuzzerLoadOneRule(tls *libc.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iRuleset sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var nCost int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = SQLITE_OK
	var nFrom int32
	var nTo int32
	var pRule uintptr = uintptr(0)

	if zFrom == uintptr(0) {
		zFrom = ts + 584
	}
	if zTo == uintptr(0) {
		zTo = ts + 584
	}
	nFrom = int32(libc.Xstrlen(tls, zFrom))
	nTo = int32(libc.Xstrlen(tls, zTo))

	if libc.Xstrcmp(tls, zFrom, zTo) == 0 {
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return SQLITE_OK
	}

	if nCost <= 0 || nCost > FUZZER_MX_COST {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3248,
			libc.VaList(bp, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_COST))
		rc = SQLITE_ERROR
	} else if nFrom > FUZZER_MX_LENGTH || nTo > FUZZER_MX_LENGTH {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3282,
			libc.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_LENGTH))
		rc = SQLITE_ERROR
	} else if iRuleset < int64(0) || iRuleset > int64(FUZZER_MX_RULEID) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+5714,
			libc.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_RULEID))
		rc = SQLITE_ERROR
	} else {
		pRule = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(fuzzer_rule{}))+uint32(nFrom)+uint32(nTo)))
		if pRule == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pRule, 0, uint32(unsafe.Sizeof(fuzzer_rule{})))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom = pRule + 20
			*(*uintptr)(unsafe.Pointer(pRule + 4)) += uintptr(nTo + 1)
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom = fuzzer_len(nFrom)
			libc.Xmemcpy(tls, (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, uint32(nFrom+1))
			libc.Xmemcpy(tls, pRule+20, zTo, uint32(nTo+1))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo = fuzzer_len(nTo)
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FrCost = nCost
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset = int32(iRuleset)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

func fuzzerLoadRules(tls *libc.TLS, db uintptr, p uintptr, zDb uintptr, zData uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var rc int32 = SQLITE_OK
	var zSql uintptr
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+3351, libc.VaList(bp, zDb, zData))
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var rc2 int32
		*(*uintptr)(unsafe.Pointer(bp + 56)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3371, libc.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3378,
				libc.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, zData, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))))
			rc = SQLITE_ERROR
		} else {
			for rc == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) {
				*(*uintptr)(unsafe.Pointer(bp + 60)) = uintptr(0)
				rc = fuzzerLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56)), bp+60, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 60)) != 0 {
					(*fuzzer_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 60)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 60))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	if rc == SQLITE_OK {
		var i uint32
		var pX uintptr

		for i = uint32(0); i < uint32(unsafe.Sizeof([15]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) = uintptr(0)
		}
		for libc.AssignUintptr(&pX, pHead) != uintptr(0) {
			pHead = (*fuzzer_rule)(unsafe.Pointer(pX)).FpNext
			(*fuzzer_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) != 0 && i < uint32(unsafe.Sizeof([15]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0)))-uint32(1); i++ {
				pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 64))
		i = uint32(1)
		for ; i < uint32(unsafe.Sizeof([15]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0))); i++ {
			pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 64 + uintptr(i)*4)), pX)
		}
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = fuzzerMergeRules(tls, (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

func fuzzerDequote(tls *libc.TLS, zIn uintptr) uintptr {
	var nIn sqlite3_int64
	var zOut uintptr

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+int64(1)))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn))

		if int32(q) != '[' && int32(q) != '\'' && int32(q) != '"' && int32(q) != '`' {
			libc.Xmemcpy(tls, zOut, zIn, size_t(nIn+int64(1)))
		} else {
			var iOut int32 = 0
			var iIn int32

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

func fuzzerDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab

	for (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func fuzzerConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	var pNew uintptr = uintptr(0)
	var zModule uintptr = *(*uintptr)(unsafe.Pointer(argv))
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+5751, libc.VaList(bp, zModule))
		rc = SQLITE_ERROR
	} else {
		var nModule sqlite3_int64

		nModule = sqlite3_int64(libc.Xstrlen(tls, zModule))
		pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(sqlite3_int64(unsafe.Sizeof(fuzzer_vtab{}))+nModule+int64(1)))
		if pNew == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			var zTab uintptr

			libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(fuzzer_vtab{})))
			(*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName = pNew + 1*24
			libc.Xmemcpy(tls, (*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName, zModule, size_t(nModule+int64(1)))

			zTab = fuzzerDequote(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
			if zTab == uintptr(0) {
				rc = SQLITE_NOMEM
			} else {
				rc = fuzzerLoadRules(tls, db, pNew, zDb, zTab, pzErr)
				sqlite3.Xsqlite3_free(tls, zTab)
			}

			if rc == SQLITE_OK {
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+5802)
			}
			if rc != SQLITE_OK {
				fuzzerDisconnect(tls, pNew)
				pNew = uintptr(0)
			} else {
				sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
			}
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

func fuzzerOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fuzzer_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(fuzzer_cursor{})))
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	(*fuzzer_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

func fuzzerClearStemList(tls *libc.TLS, pStem uintptr) {
	for pStem != 0 {
		var pNext uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext
		sqlite3.Xsqlite3_free(tls, pStem)
		pStem = pNext
	}
}

func fuzzerClearCursor(tls *libc.TLS, pCur uintptr, clearHash int32) {
	var i int32
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone)
	for i = 0; i < FUZZER_NQUEUE; i++ {
		fuzzerClearStemList(tls, *(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(i)*4)))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	if clearHash != 0 && (*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = 0
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = uintptr(0)
		libc.Xmemset(tls, pCur+28, 0, uint32(unsafe.Sizeof([20]uintptr{})))
		libc.Xmemset(tls, pCur+152, 0, uint32(unsafe.Sizeof([4001]uintptr{})))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem = 0
}

func fuzzerClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	fuzzerClearCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func fuzzerRender(tls *libc.TLS, pStem uintptr, pzBuf uintptr, pnBuf uintptr) int32 {
	var pRule uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule
	var n int32
	var z uintptr

	n = int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)
	if *(*int32)(unsafe.Pointer(pnBuf)) < n+1 {
		*(*uintptr)(unsafe.Pointer(pzBuf)) = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(pzBuf)), n+100)
		if *(*uintptr)(unsafe.Pointer(pzBuf)) == uintptr(0) {
			return SQLITE_NOMEM
		}
		*(*int32)(unsafe.Pointer(pnBuf)) = n + 100
	}
	n = int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn)
	z = *(*uintptr)(unsafe.Pointer(pzBuf))
	if n < 0 {
		libc.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, uint32(int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)+1))
	} else {
		libc.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, uint32(n))
		libc.Xmemcpy(tls, z+uintptr(n), pRule+20, uint32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo))
		libc.Xmemcpy(tls, z+uintptr(n+int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)), (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis+uintptr(n+int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)),
			uint32(int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)-n-int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)+1))
	}

	return SQLITE_OK
}

func fuzzerHash(tls *libc.TLS, z uintptr) uint32 {
	var h uint32 = uint32(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		h = h<<3 ^ h>>29 ^ uint32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
	}
	return h % uint32(FUZZER_HASH)
}

func fuzzerCost(tls *libc.TLS, pStem uintptr) fuzzer_cost {
	return libc.AssignPtrInt32(pStem+20, (*fuzzer_stem)(unsafe.Pointer(pStem)).FrBaseCost+(*fuzzer_rule)(unsafe.Pointer((*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule)).FrCost)
}

func fuzzerSeen(tls *libc.TLS, pCur uintptr, pStem uintptr) int32 {
	var h uint32
	var pLookup uintptr

	if fuzzerRender(tls, pStem, pCur+112, pCur+116) == SQLITE_NOMEM {
		return -1
	}
	h = fuzzerHash(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pLookup = *(*uintptr)(unsafe.Pointer(pCur + 152 + uintptr(h)*4))
	for pLookup != 0 && libc.Xstrcmp(tls, (*fuzzer_stem)(unsafe.Pointer(pLookup)).FzBasis, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf) != 0 {
		pLookup = (*fuzzer_stem)(unsafe.Pointer(pLookup)).FpHash
	}
	return libc.Bool32(pLookup != uintptr(0))
}

func fuzzerSkipRule(tls *libc.TLS, pRule uintptr, pStem uintptr, iRuleset int32) int32 {
	return libc.Bool32(pRule != 0 && ((*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset != iRuleset ||
		int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)+int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)-int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) > FUZZER_MX_OUTPUT_LENGTH))
}

func fuzzerAdvance(tls *libc.TLS, pCur uintptr, pStem uintptr) int32 {
	var pRule uintptr
	for libc.AssignUintptr(&pRule, (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule) != uintptr(0) {
		for int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn) < int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)-int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn++
			if int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) == 0 ||
				libc.Xmemcmp(tls, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis+uintptr((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn), (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, uint32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0 {
				var rc int32 = fuzzerSeen(tls, pCur, pStem)
				if rc < 0 {
					return -1
				}
				if rc == 0 {
					fuzzerCost(tls, pStem)
					return 1
				}
			}
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = int8(-1)
		for __ccgo := true; __ccgo; __ccgo = fuzzerSkipRule(tls, pRule, pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
			pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = pRule
		if pRule != 0 && fuzzerCost(tls, pStem) > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = uintptr(0)
		}
	}
	return 0
}

func fuzzerMergeStems(tls *libc.TLS, pA uintptr, pB uintptr) uintptr {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var pTail uintptr

	pTail = bp
	for pA != 0 && pB != 0 {
		if (*fuzzer_stem)(unsafe.Pointer(pA)).FrCostX <= (*fuzzer_stem)(unsafe.Pointer(pB)).FrCostX {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_stem)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_stem)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_stem)(unsafe.Pointer(bp)).FpNext
}

func fuzzerLowestCostStem(tls *libc.TLS, pCur uintptr) uintptr {
	var pBest uintptr
	var pX uintptr
	var iBest int32
	var i int32

	if (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem == uintptr(0) {
		iBest = -1
		pBest = uintptr(0)
		for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
			pX = *(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(i)*4))
			if pX == uintptr(0) {
				continue
			}
			if pBest == uintptr(0) || (*fuzzer_stem)(unsafe.Pointer(pBest)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX {
				pBest = pX
				iBest = i
			}
		}
		if pBest != 0 {
			*(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(iBest)*4)) = (*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext
			(*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext = uintptr(0)
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pBest
		}
	}
	return (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
}

func fuzzerInsert(tls *libc.TLS, pCur uintptr, pNew uintptr) uintptr {
	var pX uintptr
	var i int32

	if libc.AssignUintptr(&pX, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem) != uintptr(0) && (*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pNew)).FrCostX {
		(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pNew
		pNew = pX
	}

	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
	pX = pNew
	for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
		if *(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(i)*4)) != 0 {
			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(i)*4)))
			*(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(i)*4)) = uintptr(0)
		} else {
			*(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(i)*4)) = pX
			break
		}
	}
	if i > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue {
		if i < FUZZER_NQUEUE {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = i
			*(*uintptr)(unsafe.Pointer(pCur + 28 + uintptr(i)*4)) = pX
		} else {
			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer(pCur + 28 + 19*4)))
			*(*uintptr)(unsafe.Pointer(pCur + 28 + 19*4)) = pX
		}
	}

	return fuzzerLowestCostStem(tls, pCur)
}

func fuzzerNewStem(tls *libc.TLS, pCur uintptr, zWord uintptr, rBaseCost fuzzer_cost) uintptr {
	var pNew uintptr
	var pRule uintptr
	var h uint32

	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(fuzzer_stem{}))+libc.Xstrlen(tls, zWord)+uint32(1)))
	if pNew == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(fuzzer_stem{})))
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis = pNew + 1*28
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis = fuzzer_len(libc.Xstrlen(tls, zWord))
	libc.Xmemcpy(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis, zWord, uint32(int32((*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis)+1))
	pRule = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	for fuzzerSkipRule(tls, pRule, pNew, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
		pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
	}
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpRule = pRule
	(*fuzzer_stem)(unsafe.Pointer(pNew)).Fn = int8(-1)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FrBaseCost = libc.AssignPtrInt32(pNew+20, rBaseCost)
	h = fuzzerHash(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpHash = *(*uintptr)(unsafe.Pointer(pCur + 152 + uintptr(h)*4))
	*(*uintptr)(unsafe.Pointer(pCur + 152 + uintptr(h)*4)) = pNew
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem++
	return pNew
}

func fuzzerNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	var rc int32
	var pStem uintptr
	var pNew uintptr

	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid++

	pStem = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
	if (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX > 0 {
		rc = fuzzerRender(tls, pStem, pCur+112, pCur+116)
		if rc == SQLITE_NOMEM {
			return SQLITE_NOMEM
		}
		pNew = fuzzerNewStem(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX)
		if pNew != 0 {
			if fuzzerAdvance(tls, pCur, pNew) == 0 {
				(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
				(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pNew
			} else {
				if fuzzerInsert(tls, pCur, pNew) == pNew {
					return SQLITE_OK
				}
			}
		} else {
			return SQLITE_NOMEM
		}
	}

	for libc.AssignUintptr(&pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem) != uintptr(0) {
		var res int32 = fuzzerAdvance(tls, pCur, pStem)
		if res < 0 {
			return SQLITE_NOMEM
		} else if res > 0 {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
			pStem = fuzzerInsert(tls, pCur, pStem)
			if libc.AssignInt32(&rc, fuzzerSeen(tls, pCur, pStem)) != 0 {
				if rc < 0 {
					return SQLITE_NOMEM
				}
				continue
			}
			return SQLITE_OK
		}
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pStem
		if fuzzerLowestCostStem(tls, pCur) != 0 {
			rc = fuzzerSeen(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
			if rc < 0 {
				return SQLITE_NOMEM
			}
			if rc == 0 {
				return SQLITE_OK
			}
		}
	}

	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	return SQLITE_OK
}

func fuzzerFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 584
	var pStem uintptr
	var idx int32

	fuzzerClearCursor(tls, pCur, 1)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 2147483647
	idx = 0
	if idxNum&1 != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		idx++
	}
	if idxNum&2 != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	if idxNum&4 != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*4)))
		idx++
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FpNext = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FrCost = 0
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnFrom = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnTo = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FzFrom = ts + 584
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)

	if int32(libc.Xstrlen(tls, zWord)) < FUZZER_MX_OUTPUT_LENGTH {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = libc.AssignUintptr(&pStem, fuzzerNewStem(tls, pCur, zWord, 0))
		if pStem == uintptr(0) {
			return SQLITE_NOMEM
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = pCur + 128
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = (*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis
	} else {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	}

	return SQLITE_OK
}

func fuzzerColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	if i == 0 {
		if fuzzerRender(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem, pCur+112, pCur+116) == SQLITE_NOMEM {
			return SQLITE_NOMEM
		}
		sqlite3.Xsqlite3_result_text(tls, ctx, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, libc.UintptrFromInt32(-1))
	} else if i == 1 {
		sqlite3.Xsqlite3_result_int(tls, ctx, (*fuzzer_stem)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)).FrCostX)
	} else {
		sqlite3.Xsqlite3_result_null(tls, ctx)
	}
	return SQLITE_OK
}

func fuzzerRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func fuzzerEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit <= 0)
}

func fuzzerBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iRulesetTerm int32 = -1
	var i int32
	var seenMatch int32 = 0
	var pConstraint uintptr
	var rCost float64 = 1e12

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			seenMatch = 1
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if iPlan&1 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			iPlan = iPlan | 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / 1e6
		}
		if iPlan&2 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1 &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE) {
			iPlan = iPlan | 2
			iDistTerm = i
			rCost = rCost / 10.0
		}
		if iPlan&4 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | 4
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iRulesetTerm = i
			rCost = rCost / 10.0
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if iPlan&2 != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = 1 + libc.Bool32(iPlan&1 != 0)
	}
	if iPlan&4 != 0 {
		var idx int32 = 1
		if iPlan&1 != 0 {
			idx++
		}
		if iPlan&2 != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRulesetTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == 1 &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if seenMatch != 0 && iPlan&1 == 0 {
		rCost = 1e99
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return SQLITE_OK
}

var fuzzerModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_fuzzer_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5840, uintptr(unsafe.Pointer(&fuzzerModule)), uintptr(0))
	return rc
}

func ieee754func(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(156)
	defer tls.Free(156)

	if argc == 1 {
		var m sqlite3_int64

		var e int32
		var isNeg int32

		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB &&
			uint32(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))) == uint32(unsafe.Sizeof(float64(0))) {
			var x uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var i uint32
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 24)) = uint64(0)
			for i = uint32(0); i < uint32(unsafe.Sizeof(float64(0))); i++ {
				*(*sqlite3_uint64)(unsafe.Pointer(bp + 24)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 24))<<8 | sqlite3_uint64(*(*uint8)(unsafe.Pointer(x + uintptr(i))))
			}
			libc.Xmemcpy(tls, bp+16, bp+24, uint32(unsafe.Sizeof(float64(0))))
		} else {
			*(*float64)(unsafe.Pointer(bp + 16)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
		}
		if *(*float64)(unsafe.Pointer(bp + 16)) < 0.0 {
			isNeg = 1
			*(*float64)(unsafe.Pointer(bp + 16)) = -*(*float64)(unsafe.Pointer(bp + 16))
		} else {
			isNeg = 0
		}
		libc.Xmemcpy(tls, bp+32, bp+16, uint32(unsafe.Sizeof(sqlite3_int64(0))))
		if *(*sqlite3_int64)(unsafe.Pointer(bp + 32)) == int64(0) {
			e = 0
			m = int64(0)
		} else {
			e = int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 32)) >> 52)
			m = *(*sqlite3_int64)(unsafe.Pointer(bp + 32)) & (int64(1)<<52 - int64(1))
			if e == 0 {
				m <<= 1
			} else {
				m = m | int64(1)<<52
			}
			for e < 1075 && m > int64(0) && m&int64(1) == int64(0) {
				m >>= 1
				e++
			}
			if isNeg != 0 {
				m = -m
			}
		}
		switch *(*int32)(unsafe.Pointer(sqlite3.Xsqlite3_user_data(tls, context))) {
		case 0:
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40, ts+5847,
				libc.VaList(bp, m, e-1075))
			sqlite3.Xsqlite3_result_text(tls, context, bp+40, -1, libc.UintptrFromInt32(-1))
			break
			fallthrough
		case 1:
			sqlite3.Xsqlite3_result_int64(tls, context, m)
			break
			fallthrough
		case 2:
			sqlite3.Xsqlite3_result_int(tls, context, e-1075)
			break
		}
	} else {
		var m sqlite3_int64
		var e sqlite3_int64

		var isNeg int32 = 0
		m = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
		e = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))

		if e > int64(10000) {
			e = int64(10000)
		} else if e < int64(-10000) {
			e = int64(-10000)
		}

		if m < int64(0) {
			isNeg = 1
			m = -m
			if m < int64(0) {
				return
			}
		} else if m == int64(0) && e > int64(-1000) && e < int64(1000) {
			sqlite3.Xsqlite3_result_double(tls, context, 0.0)
			return
		}
		for m>>32&int64(0xffe00000) != 0 {
			m >>= 1
			e++
		}
		for m != int64(0) && m>>32&int64(0xfff00000) == int64(0) {
			m <<= 1
			e--
		}
		e = e + int64(1075)
		if e <= int64(0) {
			if int64(1)-e >= int64(64) {
				m = int64(0)
			} else {
				m >>= int64(1) - e
			}
			e = int64(0)
		} else if e > int64(0x7ff) {
			e = int64(0x7ff)
		}
		*(*sqlite3_int64)(unsafe.Pointer(bp + 148)) = m & (int64(1)<<52 - int64(1))
		*(*sqlite3_int64)(unsafe.Pointer(bp + 148)) |= e << 52
		if isNeg != 0 {
			*(*sqlite3_int64)(unsafe.Pointer(bp + 148)) |= libc.Int64FromUint64(uint64(1) << 63)
		}
		libc.Xmemcpy(tls, bp+140, bp+148, uint32(unsafe.Sizeof(float64(0))))
		sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 140)))
	}
}

func ieee754func_from_blob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	_ = argc
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB &&
		uint32(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))) == uint32(unsafe.Sizeof(float64(0))) {
		var x uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var i uint32
		*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = uint64(0)
		for i = uint32(0); i < uint32(unsafe.Sizeof(float64(0))); i++ {
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 8))<<8 | sqlite3_uint64(*(*uint8)(unsafe.Pointer(x + uintptr(i))))
		}
		libc.Xmemcpy(tls, bp, bp+8, uint32(unsafe.Sizeof(float64(0))))
		sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp)))
	}
}

func ieee754func_to_blob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_FLOAT ||
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_INTEGER {
		*(*float64)(unsafe.Pointer(bp + 8)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))

		var i uint32
		libc.Xmemcpy(tls, bp, bp+8, uint32(unsafe.Sizeof(float64(0))))
		for i = uint32(1); i <= uint32(unsafe.Sizeof(float64(0))); i++ {
			*(*uint8)(unsafe.Pointer(bp + 16 + uintptr(uint32(unsafe.Sizeof(float64(0)))-i))) = uint8(*(*sqlite3_uint64)(unsafe.Pointer(bp)) & uint64(0xff))
			*(*sqlite3_uint64)(unsafe.Pointer(bp)) >>= 8
		}
		sqlite3.Xsqlite3_result_blob(tls, context, bp+16, int32(unsafe.Sizeof(float64(0))), libc.UintptrFromInt32(-1))
	}
}

func sqlite3_ieee_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var i uint32
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	for i = uint32(0); i < uint32(unsafe.Sizeof(aFunc1))/uint32(unsafe.Sizeof(struct {
		FzFName uintptr
		FnArg   int32
		FiAux   int32
		FxFunc  uintptr
	}{})) && rc == SQLITE_OK; i++ {
		rc = sqlite3.Xsqlite3_create_function(tls, db, aFunc1[i].FzFName, aFunc1[i].FnArg,
			SQLITE_UTF8|SQLITE_INNOCUOUS,
			uintptr(unsafe.Pointer(&aFunc1))+uintptr(i)*16+8,
			aFunc1[i].FxFunc, uintptr(0), uintptr(0))
	}
	return rc
}

var aFunc1 = [6]struct {
	FzFName uintptr
	FnArg   int32
	FiAux   int32
	FxFunc  uintptr
}{
	{FzFName: ts + 5864, FnArg: 1, FxFunc: 0},
	{FzFName: ts + 5864, FnArg: 2, FxFunc: 0},
	{FzFName: ts + 5872, FnArg: 1, FiAux: 1, FxFunc: 0},
	{FzFName: ts + 5889, FnArg: 1, FiAux: 2, FxFunc: 0},
	{FzFName: ts + 5906, FnArg: 1, FxFunc: 0},
	{FzFName: ts + 5922, FnArg: 1, FxFunc: 0},
}

func sqlite3_mmap_warm(tls *libc.TLS, db uintptr, zDb uintptr) int32 {
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var rc int32 = SQLITE_OK
	var zSql uintptr = uintptr(0)
	var pgsz int32 = 0
	var nTotal int32 = 0

	if 0 == sqlite3.Xsqlite3_get_autocommit(tls, db) {
		return SQLITE_MISUSE
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5940,
		libc.VaList(bp, func() uintptr {
			if zDb != 0 {
				return ts + 5981
			}
			return ts + 584
		}(), func() uintptr {
			if zDb != 0 {
				return zDb
			}
			return ts + 584
		}(), func() uintptr {
			if zDb != 0 {
				return ts + 5983
			}
			return ts + 584
		}()))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	if rc == SQLITE_OK {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5986,
			libc.VaList(bp+24, func() uintptr {
				if zDb != 0 {
					return ts + 5981
				}
				return ts + 584
			}(), func() uintptr {
				if zDb != 0 {
					return zDb
				}
				return ts + 584
			}(), func() uintptr {
				if zDb != 0 {
					return ts + 5983
				}
				return ts + 584
			}()))
		if zSql == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 64)) = uintptr(0)
			rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+64, uintptr(0))
			sqlite3.Xsqlite3_free(tls, zSql)
			if rc == SQLITE_OK {
				if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64))) == SQLITE_ROW {
					pgsz = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), 0)
				}
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64)))
			}
			if rc == SQLITE_OK && pgsz == 0 {
				rc = SQLITE_ERROR
			}
		}
	}

	if rc == SQLITE_OK {
		var rc2 int32
		*(*uintptr)(unsafe.Pointer(bp + 68)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, db, zDb, SQLITE_FCNTL_FILE_POINTER, bp+68)
		if rc == SQLITE_OK && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 68)))).FpMethods)).FiVersion >= 3 {
			var iPg sqlite3_int64 = int64(1)
			var p uintptr = (*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 68)))).FpMethods
			for 1 != 0 {
				rc = (*struct {
					f func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods)(unsafe.Pointer(p)).FxFetch})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 68)), sqlite3_int64(pgsz)*iPg, pgsz, bp+72)
				if rc != SQLITE_OK || *(*uintptr)(unsafe.Pointer(bp + 72)) == uintptr(0) {
					break
				}

				nTotal = nTotal + int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))))
				nTotal = nTotal + int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)) + uintptr(pgsz-1))))

				rc = (*struct {
					f func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods)(unsafe.Pointer(p)).FxUnfetch})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 68)), sqlite3_int64(pgsz)*iPg, *(*uintptr)(unsafe.Pointer(bp + 72)))
				if rc != SQLITE_OK {
					break
				}
				iPg++
			}
			sqlite3.Xsqlite3_log(tls, SQLITE_OK,
				ts+6009, libc.VaList(bp+48, func() int64 {
					if iPg == int64(1) {
						return int64(0)
					}
					return iPg
				}(),
					sqlite3.Xsqlite3_db_filename(tls, db, zDb)))
		}

		rc2 = sqlite3.Xsqlite3_exec(tls, db, ts+6059, uintptr(0), uintptr(0), uintptr(0))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}

	return rc
}

type nextCharContext1 = struct {
	Fdb           uintptr
	FpStmt        uintptr
	FzPrefix      uintptr
	FnPrefix      int32
	FnAlloc       int32
	FnUsed        int32
	FaResult      uintptr
	FmallocFailed int32
	FotherError   int32
}

type nextCharContext = nextCharContext1

func nextCharAppend(tls *libc.TLS, p uintptr, c uint32) {
	var i int32
	for i = 0; i < (*nextCharContext)(unsafe.Pointer(p)).FnUsed; i++ {
		if *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(i)*4)) == c {
			return
		}
	}
	if (*nextCharContext)(unsafe.Pointer(p)).FnUsed+1 > (*nextCharContext)(unsafe.Pointer(p)).FnAlloc {
		var aNew uintptr
		var n int32 = (*nextCharContext)(unsafe.Pointer(p)).FnAlloc*2 + 30
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*nextCharContext)(unsafe.Pointer(p)).FaResult, uint64(uint32(n)*uint32(unsafe.Sizeof(uint32(0)))))
		if aNew == uintptr(0) {
			(*nextCharContext)(unsafe.Pointer(p)).FmallocFailed = 1
			return
		} else {
			(*nextCharContext)(unsafe.Pointer(p)).FaResult = aNew
			(*nextCharContext)(unsafe.Pointer(p)).FnAlloc = n
		}
	}
	*(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(libc.PostIncInt32(&(*nextCharContext)(unsafe.Pointer(p)).FnUsed, 1))*4)) = c
}

func writeUtf8(tls *libc.TLS, z uintptr, c uint32) int32 {
	if c < uint32(0x00080) {
		*(*uint8)(unsafe.Pointer(z)) = uint8(c & uint32(0xff))
		return 1
	}
	if c < uint32(0x00800) {
		*(*uint8)(unsafe.Pointer(z)) = uint8(0xC0 + int32(uint8(c>>6&uint32(0x1F))))
		*(*uint8)(unsafe.Pointer(z + 1)) = uint8(0x80 + int32(uint8(c&uint32(0x3F))))
		return 2
	}
	if c < uint32(0x10000) {
		*(*uint8)(unsafe.Pointer(z)) = uint8(0xE0 + int32(uint8(c>>12&uint32(0x0F))))
		*(*uint8)(unsafe.Pointer(z + 1)) = uint8(0x80 + int32(uint8(c>>6&uint32(0x3F))))
		*(*uint8)(unsafe.Pointer(z + 2)) = uint8(0x80 + int32(uint8(c&uint32(0x3F))))
		return 3
	}
	*(*uint8)(unsafe.Pointer(z)) = uint8(0xF0 + int32(uint8(c>>18&uint32(0x07))))
	*(*uint8)(unsafe.Pointer(z + 1)) = uint8(0x80 + int32(uint8(c>>12&uint32(0x3F))))
	*(*uint8)(unsafe.Pointer(z + 2)) = uint8(0x80 + int32(uint8(c>>6&uint32(0x3F))))
	*(*uint8)(unsafe.Pointer(z + 3)) = uint8(0x80 + int32(uint8(c&uint32(0x3F))))
	return 4
}

func readUtf8(tls *libc.TLS, z uintptr, pOut uintptr) int32 {
	var c uint32 = uint32(*(*uint8)(unsafe.Pointer(z)))
	if c < uint32(0xc0) {
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return 1
	} else {
		var n int32 = 1
		c = uint32(validBits[c-uint32(0xc0)])
		for int32(*(*uint8)(unsafe.Pointer(z + uintptr(n))))&0xc0 == 0x80 {
			c = c<<6 + uint32(0x3f&int32(*(*uint8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&n, 1))))))
		}
		if c < uint32(0x80) || c&0xFFFFF800 == uint32(0xD800) || c&0xFFFFFFFE == uint32(0xFFFE) {
			c = uint32(0xFFFD)
		}
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return n
	}
	return int32(0)
}

var validBits = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
}

func findNextChars(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var cPrev uint32 = uint32(0)

	var n int32
	var rc int32

	for {
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 1, (*nextCharContext)(unsafe.Pointer(p)).FzPrefix, (*nextCharContext)(unsafe.Pointer(p)).FnPrefix,
			uintptr(0))
		n = writeUtf8(tls, bp, cPrev+uint32(1))
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 2, bp, n, uintptr(0))
		rc = sqlite3.Xsqlite3_step(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
		if rc == SQLITE_DONE {
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			return
		} else if rc != SQLITE_ROW {
			(*nextCharContext)(unsafe.Pointer(p)).FotherError = rc
			return
		} else {
			var zOut uintptr = sqlite3.Xsqlite3_column_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 0)

			n = readUtf8(tls, zOut+uintptr((*nextCharContext)(unsafe.Pointer(p)).FnPrefix), bp+8)
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			nextCharAppend(tls, p, *(*uint32)(unsafe.Pointer(bp + 8)))
			cPrev = *(*uint32)(unsafe.Pointer(bp + 8))
			if (*nextCharContext)(unsafe.Pointer(p)).FmallocFailed != 0 {
				return
			}
		}
	}
}

func nextCharFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	var zField uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	var zWhere uintptr
	var zCollName uintptr
	var zWhereClause uintptr = uintptr(0)
	var zColl uintptr = uintptr(0)
	var zSql uintptr
	var rc int32

	libc.Xmemset(tls, bp+80, 0, uint32(unsafe.Sizeof(nextCharContext{})))
	(*nextCharContext)(unsafe.Pointer(bp + 80)).Fdb = sqlite3.Xsqlite3_context_db_handle(tls, context)
	(*nextCharContext)(unsafe.Pointer(bp + 80)).FzPrefix = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	(*nextCharContext)(unsafe.Pointer(bp + 80)).FnPrefix = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zTable == uintptr(0) || zField == uintptr(0) || (*nextCharContext)(unsafe.Pointer(bp+80)).FzPrefix == uintptr(0) {
		return
	}
	if argc >= 4 &&
		libc.AssignUintptr(&zWhere, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))) != uintptr(0) &&
		int32(*(*uint8)(unsafe.Pointer(zWhere))) != 0 {
		zWhereClause = sqlite3.Xsqlite3_mprintf(tls, ts+6063, libc.VaList(bp, zWhere))
		if zWhereClause == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
	} else {
		zWhereClause = ts + 584
	}
	if argc >= 5 &&
		libc.AssignUintptr(&zCollName, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)))) != uintptr(0) &&
		int32(*(*uint8)(unsafe.Pointer(zCollName))) != 0 {
		zColl = sqlite3.Xsqlite3_mprintf(tls, ts+6072, libc.VaList(bp+8, zCollName))
		if zColl == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			if *(*int8)(unsafe.Pointer(zWhereClause)) != 0 {
				sqlite3.Xsqlite3_free(tls, zWhereClause)
			}
			return
		}
	} else {
		zColl = ts + 584
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+6085,
		libc.VaList(bp+16, zField, zTable, zField, zColl, zField, zColl, zWhereClause, zColl))
	if *(*int8)(unsafe.Pointer(zWhereClause)) != 0 {
		sqlite3.Xsqlite3_free(tls, zWhereClause)
	}
	if *(*int8)(unsafe.Pointer(zColl)) != 0 {
		sqlite3.Xsqlite3_free(tls, zColl)
	}
	if zSql == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		return
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*nextCharContext)(unsafe.Pointer(bp+80)).Fdb, zSql, -1, bp+80+4, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, sqlite3.Xsqlite3_errmsg(tls, (*nextCharContext)(unsafe.Pointer(bp+80)).Fdb), -1)
		return
	}
	findNextChars(tls, bp+80)
	if (*nextCharContext)(unsafe.Pointer(bp+80)).FmallocFailed != 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		var pRes uintptr
		pRes = sqlite3.Xsqlite3_malloc64(tls, uint64((*nextCharContext)(unsafe.Pointer(bp+80)).FnUsed*4+1))
		if pRes == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			var i int32
			var n int32 = 0
			for i = 0; i < (*nextCharContext)(unsafe.Pointer(bp+80)).FnUsed; i++ {
				n = n + writeUtf8(tls, pRes+uintptr(n), *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(bp+80)).FaResult + uintptr(i)*4)))
			}
			*(*uint8)(unsafe.Pointer(pRes + uintptr(n))) = uint8(0)
			sqlite3.Xsqlite3_result_text(tls, context, pRes, n, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}
	sqlite3.Xsqlite3_finalize(tls, (*nextCharContext)(unsafe.Pointer(bp+80)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*nextCharContext)(unsafe.Pointer(bp+80)).FaResult)
}

func sqlite3_nextchar_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6193, 3,
		SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{nextCharFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6193, 4,
			SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6193, 5,
			SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

var aiClass = [256]uint8{
	uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(7), uint8(7), uint8(27), uint8(7), uint8(7), uint8(27), uint8(27),
	uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27),
	uint8(7), uint8(15), uint8(8), uint8(5), uint8(4), uint8(22), uint8(24), uint8(8), uint8(17), uint8(18), uint8(21), uint8(20), uint8(23), uint8(11), uint8(26), uint8(16),
	uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(5), uint8(19), uint8(12), uint8(14), uint8(13), uint8(6),
	uint8(5), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(9), uint8(27), uint8(27), uint8(27), uint8(1),
	uint8(8), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(27), uint8(10), uint8(27), uint8(25), uint8(27),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
}

var sqlite3UpperToLower = [256]uint8{
	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17),
	uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35),
	uint8(36), uint8(37), uint8(38), uint8(39), uint8(40), uint8(41), uint8(42), uint8(43), uint8(44), uint8(45), uint8(46), uint8(47), uint8(48), uint8(49), uint8(50), uint8(51), uint8(52), uint8(53),
	uint8(54), uint8(55), uint8(56), uint8(57), uint8(58), uint8(59), uint8(60), uint8(61), uint8(62), uint8(63), uint8(64), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103),
	uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121),
	uint8(122), uint8(91), uint8(92), uint8(93), uint8(94), uint8(95), uint8(96), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103), uint8(104), uint8(105), uint8(106), uint8(107),
	uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121), uint8(122), uint8(123), uint8(124), uint8(125),
	uint8(126), uint8(127), uint8(128), uint8(129), uint8(130), uint8(131), uint8(132), uint8(133), uint8(134), uint8(135), uint8(136), uint8(137), uint8(138), uint8(139), uint8(140), uint8(141), uint8(142), uint8(143),
	uint8(144), uint8(145), uint8(146), uint8(147), uint8(148), uint8(149), uint8(150), uint8(151), uint8(152), uint8(153), uint8(154), uint8(155), uint8(156), uint8(157), uint8(158), uint8(159), uint8(160), uint8(161),
	uint8(162), uint8(163), uint8(164), uint8(165), uint8(166), uint8(167), uint8(168), uint8(169), uint8(170), uint8(171), uint8(172), uint8(173), uint8(174), uint8(175), uint8(176), uint8(177), uint8(178), uint8(179),
	uint8(180), uint8(181), uint8(182), uint8(183), uint8(184), uint8(185), uint8(186), uint8(187), uint8(188), uint8(189), uint8(190), uint8(191), uint8(192), uint8(193), uint8(194), uint8(195), uint8(196), uint8(197),
	uint8(198), uint8(199), uint8(200), uint8(201), uint8(202), uint8(203), uint8(204), uint8(205), uint8(206), uint8(207), uint8(208), uint8(209), uint8(210), uint8(211), uint8(212), uint8(213), uint8(214), uint8(215),
	uint8(216), uint8(217), uint8(218), uint8(219), uint8(220), uint8(221), uint8(222), uint8(223), uint8(224), uint8(225), uint8(226), uint8(227), uint8(228), uint8(229), uint8(230), uint8(231), uint8(232), uint8(233),
	uint8(234), uint8(235), uint8(236), uint8(237), uint8(238), uint8(239), uint8(240), uint8(241), uint8(242), uint8(243), uint8(244), uint8(245), uint8(246), uint8(247), uint8(248), uint8(249), uint8(250), uint8(251),
	uint8(252), uint8(253), uint8(254), uint8(255),
}

var sqlite3CtypeMap = [256]uint8{
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x01), uint8(0x00), uint8(0x80), uint8(0x00), uint8(0x40), uint8(0x00), uint8(0x00), uint8(0x80),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c),
	uint8(0x0c), uint8(0x0c), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x02),
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02),
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02),
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x80), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x40),
	uint8(0x80), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x22),
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22),
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22),
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40),
}

func sqlite3GetToken(tls *libc.TLS, z uintptr, tokenType uintptr) int32 {
	var i int32
	var c int32
	switch int32(aiClass[*(*uint8)(unsafe.Pointer(z))]) {
	case CC_SPACE:
		{
			for i = 1; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x01 != 0; i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
			return i

		}
	case CC_MINUS:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) == '-' {
				for i = 2; libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0 && c != '\n'; i++ {
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
				return i
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_LP:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_RP:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_SEMI:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_PLUS:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_STAR:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_SLASH:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '*' || int32(*(*uint8)(unsafe.Pointer(z + 2))) == 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}
			i = 3
			c = int32(*(*uint8)(unsafe.Pointer(z + 2)))
			for ; (c != '*' || int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '/') && libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
			}
			if c != 0 {
				i++
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
			return i

		}
	case CC_PERCENT:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_EQ:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1 + libc.Bool32(int32(*(*uint8)(unsafe.Pointer(z + 1))) == '=')

		}
	case CC_LT:
		{
			if libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + 1)))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '<' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}

		}
		fallthrough
	case CC_GT:
		{
			if libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + 1)))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}

		}
		fallthrough
	case CC_BANG:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			}

		}
		fallthrough
	case CC_PIPE:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '|' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			}

		}
		fallthrough
	case CC_COMMA:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_AND:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_TILDA:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_QUOTE:
		{
			var delim int32 = int32(*(*uint8)(unsafe.Pointer(z)))

			for i = 1; libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
				if c == delim {
					if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == delim {
						i++
					} else {
						break
					}
				}
			}
			if c == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
				return i + 1
			} else if c != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
				return i + 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				return i
			}

		}
		fallthrough
	case CC_DOT:
		{
			if !(int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + 1))])&0x04 != 0) {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}

		}
		fallthrough
	case CC_DIGIT:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			if int32(*(*uint8)(unsafe.Pointer(z))) == '0' && (int32(*(*uint8)(unsafe.Pointer(z + 1))) == 'x' || int32(*(*uint8)(unsafe.Pointer(z + 1))) == 'X') && int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + 2))])&0x08 != 0 {
				for i = 3; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x08 != 0; i++ {
				}
				return i
			}
			for i = 0; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0; i++ {
			}
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == '.' {
				i++
				for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			}
			if (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'e' || int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'E') && (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))])&0x04 != 0 ||
				(int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == '+' || int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == '-') && int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i+2)))])&0x04 != 0) {
				i = i + 2
				for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			}
			for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x46 != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				i++
			}
			return i

		}
	case CC_QUOTE2:
		{
			i = 1
			c = int32(*(*uint8)(unsafe.Pointer(z)))
			for ; c != ']' && libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = func() int32 {
				if c == ']' {
					return TK_NAME
				}
				return TK_ERROR
			}()
			return i

		}
	case CC_VARNUM:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			for i = 1; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0; i++ {
			}
			return i

		}
	case CC_DOLLAR:
		fallthrough
	case CC_VARALPHA:
		{
			var n int32 = 0

			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			for i = 1; libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
				if int32(sqlite3CtypeMap[uint8(c)])&0x46 != 0 {
					n++
				} else if c == '(' && n > 0 {
					for __ccgo := true; __ccgo; __ccgo = libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0 && !(int32(sqlite3CtypeMap[uint8(c)])&0x01 != 0) && c != ')' {
						i++
					}
					if c == ')' {
						i++
					} else {
						*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
					}
					break
				} else if c == ':' && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == ':' {
					i++
				} else {
					break
				}
			}
			if n == 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
			}
			return i

		}
	case CC_KYWD:
		{
			for i = 1; int32(aiClass[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) <= CC_KYWD; i++ {
			}
			if int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x46 != 0 {
				i++
				break
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
			return i

		}
	case CC_X:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
				for i = 2; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x08 != 0; i++ {
				}
				if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'' || i%2 != 0 {
					*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
					for *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'' {
						i++
					}
				}
				if *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 {
					i++
				}
				return i
			}

		}
		fallthrough
	case CC_ID:
		{
			i = 1
			break

		}
	default:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
			return 1

		}
	}
	for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x46 != 0 {
		i++
	}
	*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
	return i
}

func sqlite3_normalize(tls *libc.TLS, zSql uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var z uintptr
	var nZ sqlite3_int64
	var nSql sqlite3_int64
	var i int32
	var j int32

	var n int32
	var k int32

	nSql = sqlite3_int64(libc.Xstrlen(tls, zSql))
	nZ = nSql
	z = sqlite3.Xsqlite3_malloc64(tls, uint64(nZ+int64(2)))
	if z == uintptr(0) {
		return uintptr(0)
	}
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; i = i + n {
		n = sqlite3GetToken(tls, zSql+uintptr(i), bp)
		switch *(*int32)(unsafe.Pointer(bp)) {
		case TK_SPACE:
			{
				break

			}
		case TK_ERROR:
			{
				sqlite3.Xsqlite3_free(tls, z)
				return uintptr(0)

			}
		case TK_LITERAL:
			{
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
				break

			}
		case TK_PUNCT:
			fallthrough
		case TK_NAME:
			{
				if n == 4 && sqlite3.Xsqlite3_strnicmp(tls, zSql+uintptr(i), ts+6203, 4) == 0 {
					if j >= 3 && libc.Xstrncmp(tls, z+uintptr(j)-uintptr(2), ts+6208, uint32(2)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(j-3))))])&0x46 != 0) ||
						j >= 4 && libc.Xstrncmp(tls, z+uintptr(j)-uintptr(3), ts+6211, uint32(3)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(j-4))))])&0x46 != 0) {
					} else {
						*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
						break
					}
				}
				if j > 0 && int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(j-1))))])&0x46 != 0 && int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr(i))))])&0x46 != 0 {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(' ')
				}
				for k = 0; k < n; k++ {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(sqlite3UpperToLower[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr(i+k))))])
				}
				break

			}
		}
	}
	for j > 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(j-1)))) == ' ' {
		j--
	}
	if j > 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(j-1)))) != ';' {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(';')
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)

	for i = 0; i < j; i = n {
		var zIn uintptr = libc.Xstrstr(tls, z+uintptr(i), ts+6215)
		var nParen int32
		if zIn == uintptr(0) {
			break
		}
		n = (int32(zIn)-int32(z))/1 + 3
		if n != 0 && int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + libc.UintptrFromInt32(-1))))])&0x46 != 0 {
			continue
		}
		if libc.Xstrncmp(tls, zIn, ts+6219, uint32(9)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + 9)))])&0x46 != 0) {
			continue
		}
		if libc.Xstrncmp(tls, zIn, ts+6229, uint32(7)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + 7)))])&0x46 != 0) {
			continue
		}
		nParen = 1
		k = 0
		for ; *(*int8)(unsafe.Pointer(z + uintptr(n+k))) != 0; k++ {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n+k)))) == '(' {
				nParen++
			}
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n+k)))) == ')' {
				nParen--
				if nParen == 0 {
					break
				}
			}
		}

		if k < 5 {
			z = sqlite3.Xsqlite3_realloc64(tls, z, uint64(j+(5-k)+1))
			if z == uintptr(0) {
				return uintptr(0)
			}
			libc.Xmemmove(tls, z+uintptr(n)+uintptr(5), z+uintptr(n)+uintptr(k), uint32(j-(n+k)))
		} else if k > 5 {
			libc.Xmemmove(tls, z+uintptr(n)+uintptr(5), z+uintptr(n)+uintptr(k), uint32(j-(n+k)))
		}
		j = j - k + 5
		*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
		libc.Xmemcpy(tls, z+uintptr(n), ts+6237, uint32(5))
	}
	return z
}

type Percentile1 = struct {
	FnAlloc uint32
	FnUsed  uint32
	FrPct   float64
	Fa      uintptr
}

type Percentile = Percentile1

func isInfinity(tls *libc.TLS, r float64) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*float64)(unsafe.Pointer(bp + 8)) = r

	libc.Xmemcpy(tls, bp, bp+8, uint32(unsafe.Sizeof(sqlite3_uint64(0))))
	return libc.Bool32(*(*sqlite3_uint64)(unsafe.Pointer(bp))>>52&uint64(0x7ff) == uint64(0x7ff))
}

func sameValue(tls *libc.TLS, a float64, b float64) int32 {
	a = a - b
	return libc.Bool32(a >= -0.001 && a <= 0.001)
}

func percentStep(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) {
	var p uintptr
	var rPct float64
	var eType int32
	var y float64

	eType = sqlite3.Xsqlite3_value_numeric_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rPct = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if eType != SQLITE_INTEGER && eType != SQLITE_FLOAT ||
		rPct < 0.0 || rPct > 100.0 {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+6243, -1)
		return
	}

	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(Percentile{})))
	if p == uintptr(0) {
		return
	}

	if (*Percentile)(unsafe.Pointer(p)).FrPct == 0.0 {
		(*Percentile)(unsafe.Pointer(p)).FrPct = rPct + 1.0
	} else if !(sameValue(tls, (*Percentile)(unsafe.Pointer(p)).FrPct, rPct+1.0) != 0) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+6310, -1)
		return
	}

	eType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if eType == SQLITE_NULL {
		return
	}

	if eType != SQLITE_INTEGER && eType != SQLITE_FLOAT {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+6374, -1)
		return
	}

	y = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if isInfinity(tls, y) != 0 {
		sqlite3.Xsqlite3_result_error(tls, pCtx, ts+6418, -1)
		return
	}

	if (*Percentile)(unsafe.Pointer(p)).FnUsed >= (*Percentile)(unsafe.Pointer(p)).FnAlloc {
		var n uint32 = (*Percentile)(unsafe.Pointer(p)).FnAlloc*uint32(2) + uint32(250)
		var a uintptr = sqlite3.Xsqlite3_realloc64(tls, (*Percentile)(unsafe.Pointer(p)).Fa, uint64(uint32(unsafe.Sizeof(float64(0)))*n))
		if a == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
			libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(Percentile{})))
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		(*Percentile)(unsafe.Pointer(p)).FnAlloc = n
		(*Percentile)(unsafe.Pointer(p)).Fa = a
	}
	*(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(libc.PostIncUint32(&(*Percentile)(unsafe.Pointer(p)).FnUsed, 1))*8)) = y
}

func doubleCmp(tls *libc.TLS, pA uintptr, pB uintptr) int32 {
	var a float64 = *(*float64)(unsafe.Pointer(pA))
	var b float64 = *(*float64)(unsafe.Pointer(pB))
	if a == b {
		return 0
	}
	if a < b {
		return -1
	}
	return +1
}

func percentFinal(tls *libc.TLS, pCtx uintptr) {
	var p uintptr
	var i1 uint32
	var i2 uint32
	var v1 float64
	var v2 float64
	var ix float64
	var vx float64
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, 0)
	if p == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).Fa == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).FnUsed != 0 {
		libc.Xqsort(tls, (*Percentile)(unsafe.Pointer(p)).Fa, (*Percentile)(unsafe.Pointer(p)).FnUsed, uint32(unsafe.Sizeof(float64(0))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		}{doubleCmp})))
		ix = ((*Percentile)(unsafe.Pointer(p)).FrPct - 1.0) * float64((*Percentile)(unsafe.Pointer(p)).FnUsed-uint32(1)) * 0.01
		i1 = uint32(ix)
		if ix == float64(i1) || i1 == (*Percentile)(unsafe.Pointer(p)).FnUsed-uint32(1) {
			i2 = i1
		} else {
			i2 = i1 + uint32(1)
		}
		v1 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i1)*8))
		v2 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i2)*8))
		vx = v1 + (v2-v1)*(ix-float64(i1))
		sqlite3.Xsqlite3_result_double(tls, pCtx, vx)
	}
	sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(Percentile{})))
}

func sqlite3_percentile_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6444, 2,
		SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{percentStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{percentFinal})))
	return rc
}

type prefixes_vtab1 = struct{ Fbase sqlite3_vtab }

type prefixes_vtab = prefixes_vtab1

type prefixes_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FiRowid sqlite3_int64
	FzStr   uintptr
	FnStr   int32
}

type prefixes_cursor = prefixes_cursor1

func prefixesConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pNew uintptr
	var rc int32

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+6455)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(prefixes_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	}
	return rc
}

func prefixesDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func prefixesOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(prefixes_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func prefixesClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func prefixesNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

func prefixesColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, (*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr-int32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid),
			uintptr(0))
		break
	default:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, (*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr, uintptr(0))
		break
	}
	return SQLITE_OK
}

func prefixesRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func prefixesEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid > sqlite3_int64((*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr))
}

func prefixesFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	if argc > 0 {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))))
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = func() int32 {
			if (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr != 0 {
				return int32(libc.Xstrlen(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr))
			}
			return 0
		}()
	} else {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = uintptr(0)
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = 0
	}
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	return SQLITE_OK
}

func prefixesBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var i int32
	var p uintptr

	i = 0
	p = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != 1 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			goto __2
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(10)
		return SQLITE_OK

	}
	goto __2
__2:
	i++
	p += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000000)
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000000000)
	return SQLITE_OK
}

var prefixesModule = sqlite3_module{
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func prefixLengthFunc(tls *libc.TLS, ctx uintptr, nVal int32, apVal uintptr) {
	var nByte int32
	var nRet int32 = 0
	var zL uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	var zR uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*4)))
	var nL int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	var nR int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*4)))
	var i int32

	nByte = func() int32 {
		if nL > nR {
			return nL
		}
		return nR
	}()
	for i = 0; i < nByte; i++ {
		if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) != int32(*(*uint8)(unsafe.Pointer(zR + uintptr(i)))) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i))))&0xC0 != 0x80 {
			nRet++
		}
	}

	if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i))))&0xC0 == 0x80 {
		nRet--
	}
	sqlite3.Xsqlite3_result_int(tls, ctx, nRet)
}

func sqlite3_prefixes_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+6519, uintptr(unsafe.Pointer(&prefixesModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls,
			db, ts+6528, 2, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{prefixLengthFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

type qpvtab_vtab1 = struct{ Fbase sqlite3_vtab }

type qpvtab_vtab = qpvtab_vtab1

type qpvtab_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FiRowid sqlite3_int64
	FzData  uintptr
	FnData  int32
	Fflags  int32
}

type qpvtab_cursor = qpvtab_cursor1

var azColname = [13]uintptr{
	ts + 6542,
	ts + 6545,
	ts + 6548,
	ts + 6551,
	ts + 6554,
	ts + 6557,
	ts + 6561, ts + 6563, ts + 6565, ts + 6567, ts + 6569,
	ts + 6571,
	ts + 584,
}

func qpvtabConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pNew uintptr
	var rc int32

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+6577)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(qpvtab_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(qpvtab_vtab{})))
	}
	return rc
}

func qpvtabDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func qpvtabOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(qpvtab_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(qpvtab_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func qpvtabClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func qpvtabNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	if (*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid < sqlite3_int64((*qpvtab_cursor)(unsafe.Pointer(pCur)).FnData) {
		var z uintptr = (*qpvtab_cursor)(unsafe.Pointer(pCur)).FzData + uintptr((*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid)
		var zEnd uintptr = libc.Xstrchr(tls, z, '\n')
		if zEnd != 0 {
			zEnd++
		}
		(*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid = sqlite3_int64((int32(zEnd) - int32((*qpvtab_cursor)(unsafe.Pointer(pCur)).FzData)) / 1)
	}
	return SQLITE_OK
}

func qpvtabColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	bp := tls.Alloc(1)
	defer tls.Free(1)

	var pCur uintptr = cur
	if i >= QPVTAB_VN && i <= QPVTAB_RHS && (*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid < sqlite3_int64((*qpvtab_cursor)(unsafe.Pointer(pCur)).FnData) {
		var z uintptr = (*qpvtab_cursor)(unsafe.Pointer(pCur)).FzData + uintptr((*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid)
		var zEnd uintptr
		var j int32
		j = QPVTAB_VN
		for 1 != 0 {
			zEnd = libc.Xstrchr(tls, z, func() int32 {
				if j == QPVTAB_RHS {
					return '\n'
				}
				return ','
			}())
			if j == i || zEnd == uintptr(0) {
				break
			}
			z = zEnd + uintptr(1)
			j++
		}
		if zEnd == z {
			sqlite3.Xsqlite3_result_null(tls, ctx)
		} else if i == QPVTAB_IX || i == QPVTAB_OP || i == QPVTAB_UX {
			sqlite3.Xsqlite3_result_int(tls, ctx, libc.Xatoi(tls, z))
		} else {
			sqlite3.Xsqlite3_result_text64(tls, ctx, z, uint64((int32(zEnd)-int32(z))/1), libc.UintptrFromInt32(-1), uint8(SQLITE_UTF8))
		}
	} else if i >= QPVTAB_A && i <= QPVTAB_E {
		if (*qpvtab_cursor)(unsafe.Pointer(pCur)).Fflags&0x001 != 0 {
			sqlite3.Xsqlite3_result_int(tls, ctx, i-QPVTAB_A+1)
		} else {
			*(*int8)(unsafe.Pointer(bp)) = int8('a' + i - QPVTAB_A)
			sqlite3.Xsqlite3_result_text64(tls, ctx, bp, uint64(1), libc.UintptrFromInt32(-1), uint8(SQLITE_UTF8))
		}
	} else if i == QPVTAB_FLAGS {
		sqlite3.Xsqlite3_result_int(tls, ctx, (*qpvtab_cursor)(unsafe.Pointer(pCur)).Fflags)
	}
	return SQLITE_OK
}

func qpvtabRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func qpvtabEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid >= sqlite3_int64((*qpvtab_cursor)(unsafe.Pointer(pCur)).FnData))
}

func qpvtabFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = pVtabCursor
	(*qpvtab_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	(*qpvtab_cursor)(unsafe.Pointer(pCur)).FzData = idxStr
	(*qpvtab_cursor)(unsafe.Pointer(pCur)).FnData = int32(libc.Xstrlen(tls, idxStr))
	(*qpvtab_cursor)(unsafe.Pointer(pCur)).Fflags = idxNum
	return SQLITE_OK
}

func qpvtabStrAppendValue(tls *libc.TLS, pStr uintptr, pVal uintptr) {
	bp := tls.Alloc(25)
	defer tls.Free(25)

	switch sqlite3.Xsqlite3_value_type(tls, pVal) {
	case SQLITE_NULL:
		sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6203, 0)
		break
	case SQLITE_INTEGER:
		sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6682, libc.VaList(bp, sqlite3.Xsqlite3_value_int64(tls, pVal)))
		break
	case SQLITE_FLOAT:
		sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6687, libc.VaList(bp+8, sqlite3.Xsqlite3_value_double(tls, pVal)))
		break
	case SQLITE_TEXT:
		{
			var i int32
			var a uintptr = sqlite3.Xsqlite3_value_text(tls, pVal)
			var n int32 = sqlite3.Xsqlite3_value_bytes(tls, pVal)
			sqlite3.Xsqlite3_str_append(tls, pStr, ts+5981, 1)
			for i = 0; i < n; i++ {
				*(*int8)(unsafe.Pointer(bp + 24)) = *(*int8)(unsafe.Pointer(a + uintptr(i)))
				if int32(*(*int8)(unsafe.Pointer(bp + 24))) == '\n' {
					*(*int8)(unsafe.Pointer(bp + 24)) = int8(' ')
				}
				sqlite3.Xsqlite3_str_append(tls, pStr, bp+24, 1)
				if int32(*(*int8)(unsafe.Pointer(bp + 24))) == '\'' {
					sqlite3.Xsqlite3_str_append(tls, pStr, bp+24, 1)
				}
			}
			sqlite3.Xsqlite3_str_append(tls, pStr, ts+5981, 1)
			break

		}
	case SQLITE_BLOB:
		{
			var i int32
			var a uintptr = sqlite3.Xsqlite3_value_blob(tls, pVal)
			var n int32 = sqlite3.Xsqlite3_value_bytes(tls, pVal)
			sqlite3.Xsqlite3_str_append(tls, pStr, ts+6691, 2)
			for i = 0; i < n; i++ {
				sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6694, libc.VaList(bp+16, int32(*(*uint8)(unsafe.Pointer(a + uintptr(i))))))
			}
			sqlite3.Xsqlite3_str_append(tls, pStr, ts+5981, 1)
			break

		}
	}
}

func qpvtabBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var pStr uintptr = sqlite3.Xsqlite3_str_new(tls, uintptr(0))
	var i int32
	var k int32 = 0
	var rc int32
	_ = rc
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6699, libc.VaList(bp, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint))
	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var iCol int32 = (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).FiColumn
		var op int32 = int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).Fop)
		if iCol == QPVTAB_FLAGS && (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(i)*12)).Fusable != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 112)) = uintptr(0)
			rc = sqlite3.Xsqlite3_vtab_rhs_value(tls, pIdxInfo, i, bp+112)

			if *(*uintptr)(unsafe.Pointer(bp + 112)) != 0 {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(bp + 112)))
				if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum&0x002 != 0 {
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
				}
			}
		}
		if op == SQLITE_INDEX_CONSTRAINT_LIMIT ||
			op == SQLITE_INDEX_CONSTRAINT_OFFSET {
			iCol = QPVTAB_NONE
		}
		sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6719,
			libc.VaList(bp+8, i,
				azColname[iCol],
				op,
				int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(i)*12)).Fusable)))
		*(*uintptr)(unsafe.Pointer(bp + 112)) = uintptr(0)
		rc = sqlite3.Xsqlite3_vtab_rhs_value(tls, pIdxInfo, i, bp+112)

		if *(*uintptr)(unsafe.Pointer(bp + 112)) != 0 {
			qpvtabStrAppendValue(tls, pStr, *(*uintptr)(unsafe.Pointer(bp + 112)))
		}
		sqlite3.Xsqlite3_str_append(tls, pStr, ts+4215, 1)
	}
	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var iCol int32 = (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).FiColumn
		var op int32 = int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).Fop)
		if op == SQLITE_INDEX_CONSTRAINT_LIMIT ||
			op == SQLITE_INDEX_CONSTRAINT_OFFSET {
			iCol = QPVTAB_NONE
		}
		if iCol >= QPVTAB_A && (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(i)*12)).Fusable != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&k, 1)
			if iCol <= QPVTAB_FLAGS || (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum&0x004 != 0 {
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			}
		}
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6744, libc.VaList(bp+40, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy))
	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy; i++ {
		var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).FiColumn
		sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6761, libc.VaList(bp+48, i,
			func() uintptr {
				if iCol >= 0 {
					return azColname[iCol]
				}
				return ts + 6782
			}(),
			int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(i)*8)).Fdesc)))
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6788,
		libc.VaList(bp+72, sqlite3.Xsqlite3_vtab_distinct(tls, pIdxInfo)))
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6818, libc.VaList(bp+80, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxFlags))
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6835, libc.VaList(bp+88, int32((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed)))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(10)
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6851, libc.VaList(bp+96, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum))
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+6866,
		libc.VaList(bp+104, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = sqlite3.Xsqlite3_str_finish(tls, pStr)
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
	return SQLITE_OK
}

var qpvtabModule = sqlite3_module{
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_qpvtab_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+6890, uintptr(unsafe.Pointer(&qpvtabModule)), uintptr(0))
	return rc
}

type ReStateNumber = uint16

type ReStateSet1 = struct {
	FnState uint32
	FaState uintptr
}

type ReStateSet = ReStateSet1

type ReInput1 = struct {
	Fz  uintptr
	Fi  int32
	Fmx int32
}

type ReInput = ReInput1

type ReCompiled1 = struct {
	FsIn       ReInput
	FzErr      uintptr
	FaOp       uintptr
	FaArg      uintptr
	FxNextChar uintptr
	FzInit     [12]uint8
	FnInit     int32
	FnState    uint32
	FnAlloc    uint32
}

type ReCompiled = ReCompiled1

func re_add_state(tls *libc.TLS, pSet uintptr, newState int32) {
	var i uint32
	for i = uint32(0); i < (*ReStateSet)(unsafe.Pointer(pSet)).FnState; i++ {
		if int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(i)*2))) == newState {
			return
		}
	}
	*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(libc.PostIncUint32(&(*ReStateSet)(unsafe.Pointer(pSet)).FnState, 1))*2)) = ReStateNumber(newState)
}

func re_next_char(tls *libc.TLS, p uintptr) uint32 {
	var c uint32
	if (*ReInput)(unsafe.Pointer(p)).Fi >= (*ReInput)(unsafe.Pointer(p)).Fmx {
		return uint32(0)
	}
	c = uint32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1)))))
	if c >= uint32(0x80) {
		if c&uint32(0xe0) == uint32(0xc0) && (*ReInput)(unsafe.Pointer(p)).Fi < (*ReInput)(unsafe.Pointer(p)).Fmx && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0xc0 == 0x80 {
			c = c&uint32(0x1f)<<6 | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1)))))&0x3f)
			if c < uint32(0x80) {
				c = uint32(0xfffd)
			}
		} else if c&uint32(0xf0) == uint32(0xe0) && (*ReInput)(unsafe.Pointer(p)).Fi+1 < (*ReInput)(unsafe.Pointer(p)).Fmx && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0xc0 == 0x80 &&
			int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0xc0 == 0x80 {
			c = c&uint32(0x0f)<<12 | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0x3f<<6) | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0x3f)
			*(*int32)(unsafe.Pointer(p + 4)) += 2
			if c <= uint32(0x7ff) || c >= uint32(0xd800) && c <= uint32(0xdfff) {
				c = uint32(0xfffd)
			}
		} else if c&uint32(0xf8) == uint32(0xf0) && (*ReInput)(unsafe.Pointer(p)).Fi+2 < (*ReInput)(unsafe.Pointer(p)).Fmx && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0xc0 == 0x80 &&
			int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0xc0 == 0x80 && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+2))))&0xc0 == 0x80 {
			c = c&uint32(0x07)<<18 | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0x3f<<12) | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0x3f<<6) |
				uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+2))))&0x3f)
			*(*int32)(unsafe.Pointer(p + 4)) += 3
			if c <= uint32(0xffff) || c > uint32(0x10ffff) {
				c = uint32(0xfffd)
			}
		} else {
			c = uint32(0xfffd)
		}
	}
	return c
}

func re_next_char_nocase(tls *libc.TLS, p uintptr) uint32 {
	var c uint32 = re_next_char(tls, p)
	if c >= uint32('A') && c <= uint32('Z') {
		c = c + uint32('a'-'A')
	}
	return c
}

func re_word_char(tls *libc.TLS, c int32) int32 {
	return libc.Bool32(c >= '0' && c <= '9' || c >= 'a' && c <= 'z' ||
		c >= 'A' && c <= 'Z' || c == '_')
}

func re_digit_char(tls *libc.TLS, c int32) int32 {
	return libc.Bool32(c >= '0' && c <= '9')
}

func re_space_char(tls *libc.TLS, c int32) int32 {
	return libc.Bool32(c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\v' || c == '\f')
}

func sqlite3re_match(tls *libc.TLS, pRe uintptr, zIn uintptr, nIn int32) int32 {
	bp := tls.Alloc(228)
	defer tls.Free(228)

	var pThis uintptr
	var pNext uintptr

	var pToFree uintptr
	var i uint32
	var iSwap uint32
	var c int32
	var cPrev int32
	var rc int32

	var x uint8
	var j int32
	var n int32
	var hit int32
	var x1 int32
	var x2 int32
	i = uint32(0)
	iSwap = uint32(0)
	c = RE_START
	cPrev = 0
	rc = 0

	(*ReInput)(unsafe.Pointer(bp + 216)).Fz = zIn
	(*ReInput)(unsafe.Pointer(bp + 216)).Fi = 0
	(*ReInput)(unsafe.Pointer(bp + 216)).Fmx = func() int32 {
		if nIn >= 0 {
			return nIn
		}
		return int32(libc.Xstrlen(tls, zIn))
	}()

	if !((*ReCompiled)(unsafe.Pointer(pRe)).FnInit != 0) {
		goto __1
	}
	x = *(*uint8)(unsafe.Pointer(pRe + 28))
__2:
	if !((*ReInput)(unsafe.Pointer(bp+216)).Fi+(*ReCompiled)(unsafe.Pointer(pRe)).FnInit <= (*ReInput)(unsafe.Pointer(bp+216)).Fmx &&
		(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((*ReInput)(unsafe.Pointer(bp+216)).Fi)))) != int32(x) || libc.Xstrncmp(tls, zIn+uintptr((*ReInput)(unsafe.Pointer(bp+216)).Fi), pRe+28, uint32((*ReCompiled)(unsafe.Pointer(pRe)).FnInit)) != 0)) {
		goto __3
	}
	(*ReInput)(unsafe.Pointer(bp+216)).Fi++
	goto __2
__3:
	;
	if !((*ReInput)(unsafe.Pointer(bp+216)).Fi+(*ReCompiled)(unsafe.Pointer(pRe)).FnInit > (*ReInput)(unsafe.Pointer(bp+216)).Fmx) {
		goto __4
	}
	return 0
__4:
	;
	c = RE_START - 1
__1:
	;
	if !((*ReCompiled)(unsafe.Pointer(pRe)).FnState <= uint32(unsafe.Sizeof([100]ReStateNumber{}))/(uint32(unsafe.Sizeof(ReStateNumber(0)))*uint32(2))) {
		goto __5
	}
	pToFree = uintptr(0)
	(*ReStateSet)(unsafe.Pointer(bp)).FaState = bp + 16
	goto __6
__5:
	pToFree = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(ReStateNumber(0)))*uint32(2)*(*ReCompiled)(unsafe.Pointer(pRe)).FnState))
	if !(pToFree == uintptr(0)) {
		goto __7
	}
	return -1
__7:
	;
	(*ReStateSet)(unsafe.Pointer(bp)).FaState = pToFree
__6:
	;
	(*ReStateSet)(unsafe.Pointer(bp + 1*8)).FaState = (*ReStateSet)(unsafe.Pointer(bp)).FaState + uintptr((*ReCompiled)(unsafe.Pointer(pRe)).FnState)*2
	pNext = bp + 1*8
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	re_add_state(tls, pNext, 0)
__8:
	if !(c != RE_EOF && (*ReStateSet)(unsafe.Pointer(pNext)).FnState > uint32(0)) {
		goto __9
	}
	cPrev = c
	c = int32((*struct {
		f func(*libc.TLS, uintptr) uint32
	})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(pRe)).FxNextChar})).f(tls, bp+216))
	pThis = pNext
	pNext = bp + uintptr(iSwap)*8
	iSwap = uint32(1) - iSwap
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	i = uint32(0)
__10:
	if !(i < (*ReStateSet)(unsafe.Pointer(pThis)).FnState) {
		goto __12
	}
	x1 = int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pThis)).FaState + uintptr(i)*2)))
	switch int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) {
	case RE_OP_MATCH:
		goto __14
	case RE_OP_ATSTART:
		goto __15
	case RE_OP_ANY:
		goto __16
	case RE_OP_WORD:
		goto __17
	case RE_OP_NOTWORD:
		goto __18
	case RE_OP_DIGIT:
		goto __19
	case RE_OP_NOTDIGIT:
		goto __20
	case RE_OP_SPACE:
		goto __21
	case RE_OP_NOTSPACE:
		goto __22
	case RE_OP_BOUNDARY:
		goto __23
	case RE_OP_ANYSTAR:
		goto __24
	case RE_OP_FORK:
		goto __25
	case RE_OP_GOTO:
		goto __26
	case RE_OP_ACCEPT:
		goto __27
	case RE_OP_CC_EXC:
		goto __28
	case RE_OP_CC_INC:
		goto __29
	}
	goto __13
__14:
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)) == c) {
		goto __30
	}
	re_add_state(tls, pNext, x1+1)
__30:
	;
	goto __13

__15:
	if !(cPrev == RE_START) {
		goto __31
	}
	re_add_state(tls, pThis, x1+1)
__31:
	;
	goto __13

__16:
	if !(c != 0) {
		goto __32
	}
	re_add_state(tls, pNext, x1+1)
__32:
	;
	goto __13

__17:
	if !(re_word_char(tls, c) != 0) {
		goto __33
	}
	re_add_state(tls, pNext, x1+1)
__33:
	;
	goto __13

__18:
	if !(!(re_word_char(tls, c) != 0) && c != 0) {
		goto __34
	}
	re_add_state(tls, pNext, x1+1)
__34:
	;
	goto __13

__19:
	if !(re_digit_char(tls, c) != 0) {
		goto __35
	}
	re_add_state(tls, pNext, x1+1)
__35:
	;
	goto __13

__20:
	if !(!(re_digit_char(tls, c) != 0) && c != 0) {
		goto __36
	}
	re_add_state(tls, pNext, x1+1)
__36:
	;
	goto __13

__21:
	if !(re_space_char(tls, c) != 0) {
		goto __37
	}
	re_add_state(tls, pNext, x1+1)
__37:
	;
	goto __13

__22:
	if !(!(re_space_char(tls, c) != 0) && c != 0) {
		goto __38
	}
	re_add_state(tls, pNext, x1+1)
__38:
	;
	goto __13

__23:
	if !(re_word_char(tls, c) != re_word_char(tls, cPrev)) {
		goto __39
	}
	re_add_state(tls, pThis, x1+1)
__39:
	;
	goto __13

__24:
	re_add_state(tls, pNext, x1)
	re_add_state(tls, pThis, x1+1)
	goto __13

__25:
	re_add_state(tls, pThis, x1+*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)))
	re_add_state(tls, pThis, x1+1)
	goto __13

__26:
	re_add_state(tls, pThis, x1+*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)))
	goto __13

__27:
	rc = 1
	goto re_match_end

__28:
	if !(c == 0) {
		goto __40
	}
	goto __13
__40:
	;
	goto re_op_cc_inc

__29:
re_op_cc_inc:
	j = 1
	n = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))
	hit = 0
	j = 1
__41:
	if !(j > 0 && j < n) {
		goto __43
	}
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1+j)))) == RE_OP_CC_VALUE) {
		goto __44
	}
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1+j)*4)) == c) {
		goto __46
	}
	hit = 1
	j = -1
__46:
	;
	goto __45
__44:
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1+j)*4)) <= c && *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1+j+1)*4)) >= c) {
		goto __47
	}
	hit = 1
	j = -1
	goto __48
__47:
	j++
__48:
	;
__45:
	;
	goto __42
__42:
	j++
	goto __41
	goto __43
__43:
	;
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) == RE_OP_CC_EXC) {
		goto __49
	}
	hit = libc.BoolInt32(!(hit != 0))
__49:
	;
	if !(hit != 0) {
		goto __50
	}
	re_add_state(tls, pNext, x1+n)
__50:
	;
	goto __13

__13:
	;
	goto __11
__11:
	i++
	goto __10
	goto __12
__12:
	;
	goto __8
__9:
	;
	i = uint32(0)
__51:
	if !(i < (*ReStateSet)(unsafe.Pointer(pNext)).FnState) {
		goto __53
	}
	x2 = int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pNext)).FaState + uintptr(i)*2)))
__54:
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x2)))) == RE_OP_GOTO) {
		goto __55
	}
	x2 = x2 + *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x2)*4))
	goto __54
__55:
	;
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x2)))) == RE_OP_ACCEPT) {
		goto __56
	}
	rc = 1
	goto __53
__56:
	;
	goto __52
__52:
	i++
	goto __51
	goto __53
__53:
	;
re_match_end:
	sqlite3.Xsqlite3_free(tls, pToFree)
	return rc
}

func re_resize(tls *libc.TLS, p uintptr, N int32) int32 {
	var aOp uintptr
	var aArg uintptr
	aOp = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaOp, uint64(uint32(N)*uint32(unsafe.Sizeof(int8(0)))))
	if aOp == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaOp = aOp
	aArg = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaArg, uint64(uint32(N)*uint32(unsafe.Sizeof(int32(0)))))
	if aArg == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaArg = aArg
	(*ReCompiled)(unsafe.Pointer(p)).FnAlloc = uint32(N)
	return 0
}

func re_insert(tls *libc.TLS, p uintptr, iBefore int32, op int32, arg int32) int32 {
	var i int32
	if (*ReCompiled)(unsafe.Pointer(p)).FnAlloc <= (*ReCompiled)(unsafe.Pointer(p)).FnState && re_resize(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2))) != 0 {
		return 0
	}
	for i = int32((*ReCompiled)(unsafe.Pointer(p)).FnState); i > iBefore; i-- {
		*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(i))) = *(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(i-1)))
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(i-1)*4))
	}
	(*ReCompiled)(unsafe.Pointer(p)).FnState++
	*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(iBefore))) = int8(op)
	*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iBefore)*4)) = arg
	return iBefore
}

func re_append(tls *libc.TLS, p uintptr, op int32, arg int32) int32 {
	return re_insert(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnState), op, arg)
}

func re_copy(tls *libc.TLS, p uintptr, iStart int32, N int32) {
	if (*ReCompiled)(unsafe.Pointer(p)).FnState+uint32(N) >= (*ReCompiled)(unsafe.Pointer(p)).FnAlloc && re_resize(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2)+uint32(N))) != 0 {
		return
	}
	libc.Xmemcpy(tls, (*ReCompiled)(unsafe.Pointer(p)).FaOp+uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState), (*ReCompiled)(unsafe.Pointer(p)).FaOp+uintptr(iStart), uint32(N)*uint32(unsafe.Sizeof(int8(0))))
	libc.Xmemcpy(tls, (*ReCompiled)(unsafe.Pointer(p)).FaArg+uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState)*4, (*ReCompiled)(unsafe.Pointer(p)).FaArg+uintptr(iStart)*4, uint32(N)*uint32(unsafe.Sizeof(int32(0))))
	*(*uint32)(unsafe.Pointer(p + 44)) += uint32(N)
}

func re_hex(tls *libc.TLS, c int32, pV uintptr) int32 {
	if c >= '0' && c <= '9' {
		c = c - '0'
	} else if c >= 'a' && c <= 'f' {
		c = c - ('a' - 10)
	} else if c >= 'A' && c <= 'F' {
		c = c - ('A' - 10)
	} else {
		return 0
	}
	*(*int32)(unsafe.Pointer(pV)) = *(*int32)(unsafe.Pointer(pV))*16 + c&0xff
	return 1
}

func re_esc_char(tls *libc.TLS, p uintptr) uint32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	*(*int32)(unsafe.Pointer(bp)) = 0
	var c int8
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return uint32(0)
	}
	c = int8(*(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))))
	if int32(c) == 'u' && (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi+4 < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		var zIn uintptr = (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)
		if re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 1))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 2))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 3))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 4))), bp) != 0 {
			*(*int32)(unsafe.Pointer(p + 4)) += 5
			return uint32(*(*int32)(unsafe.Pointer(bp)))
		}
	}
	if int32(c) == 'x' && (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi+2 < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		var zIn uintptr = (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)
		if re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 1))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 2))), bp) != 0 {
			*(*int32)(unsafe.Pointer(p + 4)) += 3
			return uint32(*(*int32)(unsafe.Pointer(bp)))
		}
	}
	for i = 0; zEsc[i] != 0 && int32(zEsc[i]) != int32(c); i++ {
	}
	if zEsc[i] != 0 {
		if i < 6 {
			c = zTrans[i]
		}
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
	} else {
		(*ReCompiled)(unsafe.Pointer(p)).FzErr = ts + 6897
	}
	return uint32(c)
}

var zEsc = *(*[21]int8)(unsafe.Pointer(ts + 6914))
var zTrans = *(*[7]int8)(unsafe.Pointer(ts + 6935))

func rePeek(tls *libc.TLS, p uintptr) uint8 {
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return *(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)))
	}
	return uint8(0)
}

func re_subcompile_re(tls *libc.TLS, p uintptr) uintptr {
	var zErr uintptr
	var iStart int32
	var iEnd int32
	var iGoto int32
	iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
	zErr = re_subcompile_string(tls, p)
	if zErr != 0 {
		return zErr
	}
	for int32(rePeek(tls, p)) == '|' {
		iEnd = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		re_insert(tls, p, iStart, RE_OP_FORK, iEnd+2-iStart)
		iGoto = re_append(tls, p, RE_OP_GOTO, 0)
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
		zErr = re_subcompile_string(tls, p)
		if zErr != 0 {
			return zErr
		}
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iGoto)*4)) = int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iGoto))
	}
	return uintptr(0)
}

func re_subcompile_string(tls *libc.TLS, p uintptr) uintptr {
	var iPrev int32 = -1
	var iStart int32
	var c uint32
	var zErr uintptr
	for libc.AssignUint32(&c, (*struct {
		f func(*libc.TLS, uintptr) uint32
	})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(p)).FxNextChar})).f(tls, p)) != uint32(0) {
		iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		switch c {
		case uint32('|'):
			fallthrough
		case uint32(')'):
			{
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi--
				return uintptr(0)

			}
		case uint32('('):
			{
				zErr = re_subcompile_re(tls, p)
				if zErr != 0 {
					return zErr
				}
				if int32(rePeek(tls, p)) != ')' {
					return ts + 6942
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				break

			}
		case uint32('.'):
			{
				if int32(rePeek(tls, p)) == '*' {
					re_append(tls, p, RE_OP_ANYSTAR, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, RE_OP_ANY, 0)
				}
				break

			}
		case uint32('*'):
			{
				if iPrev < 0 {
					return ts + 6956
				}
				re_insert(tls, p, iPrev, RE_OP_GOTO, int32((*ReCompiled)(unsafe.Pointer(p)).FnState-uint32(iPrev)+uint32(1)))
				re_append(tls, p, RE_OP_FORK, int32(uint32(iPrev)-(*ReCompiled)(unsafe.Pointer(p)).FnState+uint32(1)))
				break

			}
		case uint32('+'):
			{
				if iPrev < 0 {
					return ts + 6976
				}
				re_append(tls, p, RE_OP_FORK, int32(uint32(iPrev)-(*ReCompiled)(unsafe.Pointer(p)).FnState))
				break

			}
		case uint32('?'):
			{
				if iPrev < 0 {
					return ts + 6996
				}
				re_insert(tls, p, iPrev, RE_OP_FORK, int32((*ReCompiled)(unsafe.Pointer(p)).FnState-uint32(iPrev)+uint32(1)))
				break

			}
		case uint32('$'):
			{
				re_append(tls, p, RE_OP_MATCH, RE_EOF)
				break

			}
		case uint32('^'):
			{
				re_append(tls, p, RE_OP_ATSTART, 0)
				break

			}
		case uint32('{'):
			{
				var m int32 = 0
				var n int32 = 0
				var sz int32
				var j int32
				if iPrev < 0 {
					return ts + 7016
				}
				for libc.AssignUint32(&c, uint32(rePeek(tls, p))) >= uint32('0') && c <= uint32('9') {
					m = int32(uint32(m*10) + c - uint32('0'))
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				}
				n = m
				if c == uint32(',') {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					n = 0
					for libc.AssignUint32(&c, uint32(rePeek(tls, p))) >= uint32('0') && c <= uint32('9') {
						n = int32(uint32(n*10) + c - uint32('0'))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					}
				}
				if c != uint32('}') {
					return ts + 7040
				}
				if n > 0 && n < m {
					return ts + 7054
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				sz = int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev))
				if m == 0 {
					if n == 0 {
						return ts + 7079
					}
					re_insert(tls, p, iPrev, RE_OP_FORK, sz+1)
					iPrev++
					n--
				} else {
					for j = 1; j < m; j++ {
						re_copy(tls, p, iPrev, sz)
					}
				}
				for j = m; j < n; j++ {
					re_append(tls, p, RE_OP_FORK, sz+1)
					re_copy(tls, p, iPrev, sz)
				}
				if n == 0 && m > 0 {
					re_append(tls, p, RE_OP_FORK, -sz)
				}
				break

			}
		case uint32('['):
			{
				var iFirst int32 = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
				if int32(rePeek(tls, p)) == '^' {
					re_append(tls, p, RE_OP_CC_EXC, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, RE_OP_CC_INC, 0)
				}
				for libc.AssignUint32(&c, (*struct {
					f func(*libc.TLS, uintptr) uint32
				})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(p)).FxNextChar})).f(tls, p)) != uint32(0) {
					if c == uint32('[') && int32(rePeek(tls, p)) == ':' {
						return ts + 7112
					}
					if c == uint32('\\') {
						c = re_esc_char(tls, p)
					}
					if int32(rePeek(tls, p)) == '-' {
						re_append(tls, p, RE_OP_CC_RANGE, int32(c))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						c = (*struct {
							f func(*libc.TLS, uintptr) uint32
						})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(p)).FxNextChar})).f(tls, p)
						if c == uint32('\\') {
							c = re_esc_char(tls, p)
						}
						re_append(tls, p, RE_OP_CC_RANGE, int32(c))
					} else {
						re_append(tls, p, RE_OP_CC_VALUE, int32(c))
					}
					if int32(rePeek(tls, p)) == ']' {
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						break
					}
				}
				if c == uint32(0) {
					return ts + 7150
				}
				*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iFirst)*4)) = int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iFirst))
				break

			}
		case uint32('\\'):
			{
				var specialOp int32 = 0
				switch int32(rePeek(tls, p)) {
				case 'b':
					specialOp = RE_OP_BOUNDARY
					break
				case 'd':
					specialOp = RE_OP_DIGIT
					break
				case 'D':
					specialOp = RE_OP_NOTDIGIT
					break
				case 's':
					specialOp = RE_OP_SPACE
					break
				case 'S':
					specialOp = RE_OP_NOTSPACE
					break
				case 'w':
					specialOp = RE_OP_WORD
					break
				case 'W':
					specialOp = RE_OP_NOTWORD
					break
				}
				if specialOp != 0 {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					re_append(tls, p, specialOp, 0)
				} else {
					c = re_esc_char(tls, p)
					re_append(tls, p, RE_OP_MATCH, int32(c))
				}
				break

			}
		default:
			{
				re_append(tls, p, RE_OP_MATCH, int32(c))
				break

			}
		}
		iPrev = iStart
	}
	return uintptr(0)
}

func sqlite3re_free(tls *libc.TLS, pRe uintptr) {
	if pRe != 0 {
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaOp)
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaArg)
		sqlite3.Xsqlite3_free(tls, pRe)
	}
}

func sqlite3re_compile(tls *libc.TLS, ppRe uintptr, zIn uintptr, noCase int32) uintptr {
	var pRe uintptr
	var zErr uintptr
	var i int32
	var j int32

	*(*uintptr)(unsafe.Pointer(ppRe)) = uintptr(0)
	pRe = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ReCompiled{})))
	if pRe == uintptr(0) {
		return ts + 2069
	}
	libc.Xmemset(tls, pRe, 0, uint32(unsafe.Sizeof(ReCompiled{})))
	(*ReCompiled)(unsafe.Pointer(pRe)).FxNextChar = func() uintptr {
		if noCase != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) uint32
			}{re_next_char_nocase}))
		}
		return *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) uint32
		}{re_next_char}))
	}()
	if re_resize(tls, pRe, 30) != 0 {
		sqlite3re_free(tls, pRe)
		return ts + 2069
	}
	if int32(*(*int8)(unsafe.Pointer(zIn))) == '^' {
		zIn++
	} else {
		re_append(tls, pRe, RE_OP_ANYSTAR, 0)
	}
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fz = zIn
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi = 0
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx = int32(libc.Xstrlen(tls, zIn))
	zErr = re_subcompile_re(tls, pRe)
	if zErr != 0 {
		sqlite3re_free(tls, pRe)
		return zErr
	}
	if (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx {
		re_append(tls, pRe, RE_OP_ACCEPT, 0)
		*(*uintptr)(unsafe.Pointer(ppRe)) = pRe
	} else {
		sqlite3re_free(tls, pRe)
		return ts + 7163
	}

	if int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp))) == RE_OP_ANYSTAR && !(noCase != 0) {
		j = 0
		i = 1
		for ; j < int32(unsafe.Sizeof([12]uint8{}))-2 && int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(i)))) == RE_OP_MATCH; i++ {
			var x uint32 = uint32(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(i)*4)))
			if x <= uint32(0x7f) {
				*(*uint8)(unsafe.Pointer(pRe + 28 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(x)
			} else if x <= uint32(0x7ff) {
				*(*uint8)(unsafe.Pointer(pRe + 28 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0xc0) | x>>6)
				*(*uint8)(unsafe.Pointer(pRe + 28 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0x80) | x&uint32(0x3f))
			} else if x <= uint32(0xffff) {
				*(*uint8)(unsafe.Pointer(pRe + 28 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0xe0) | x>>12)
				*(*uint8)(unsafe.Pointer(pRe + 28 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0x80) | x>>6&uint32(0x3f))
				*(*uint8)(unsafe.Pointer(pRe + 28 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0x80) | x&uint32(0x3f))
			} else {
				break
			}
		}
		if j > 0 && int32(*(*uint8)(unsafe.Pointer(pRe + 28 + uintptr(j-1)))) == 0 {
			j--
		}
		(*ReCompiled)(unsafe.Pointer(pRe)).FnInit = j
	}
	return (*ReCompiled)(unsafe.Pointer(pRe)).FzErr
}

func re_sql_func(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zPattern uintptr
	var zStr uintptr
	var zErr uintptr
	var setAux int32 = 0

	_ = argc
	*(*uintptr)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3_get_auxdata(tls, context, 0)
	if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) {
		zPattern = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		if zPattern == uintptr(0) {
			return
		}
		zErr = sqlite3re_compile(tls, bp, zPattern, libc.Bool32(sqlite3.Xsqlite3_user_data(tls, context) != uintptr(0)))
		if zErr != 0 {
			sqlite3re_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
			sqlite3.Xsqlite3_result_error(tls, context, zErr, -1)
			return
		}
		if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		setAux = 1
	}
	zStr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if zStr != uintptr(0) {
		sqlite3.Xsqlite3_result_int(tls, context, sqlite3re_match(tls, *(*uintptr)(unsafe.Pointer(bp)), zStr, -1))
	}
	if setAux != 0 {
		sqlite3.Xsqlite3_set_auxdata(tls, context, 0, *(*uintptr)(unsafe.Pointer(bp)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3re_free})))
	}
}

func sqlite3_regexp_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7186, 2,
		SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{re_sql_func})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7193, 2,
			SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,
			db, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{re_sql_func})), uintptr(0), uintptr(0))
	}
	return rc
}

func rememberFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) {
	var v sqlite3_int64
	var ptr uintptr

	v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	ptr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+4417)
	if ptr != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(ptr)) = v
	}
	sqlite3.Xsqlite3_result_int64(tls, pCtx, v)
}

func sqlite3_remember_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7201, 2, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{rememberFunc})), uintptr(0), uintptr(0))
	return rc
}

type series_cursor1 = struct {
	Fbase    sqlite3_vtab_cursor
	FisDesc  int32
	FiRowid  sqlite3_int64
	FiValue  sqlite3_int64
	FmnValue sqlite3_int64
	FmxValue sqlite3_int64
	FiStep   sqlite3_int64
}

type series_cursor = series_cursor1

func seriesConnect(tls *libc.TLS, db uintptr, pUnused uintptr, argcUnused int32, argvUnused uintptr, ppVtab uintptr, pzErrUnused uintptr) int32 {
	var pNew uintptr
	var rc int32

	_ = pUnused
	_ = argcUnused
	_ = argvUnused
	_ = pzErrUnused
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+7210)
	if rc == SQLITE_OK {
		pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(sqlite3_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	}
	return rc
}

func seriesDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func seriesOpen(tls *libc.TLS, pUnused uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	_ = pUnused
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(series_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(series_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func seriesClose(tls *libc.TLS, cur uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

func seriesNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 16)) -= (*series_cursor)(unsafe.Pointer(pCur)).FiStep
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 16)) += (*series_cursor)(unsafe.Pointer(pCur)).FiStep
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

func seriesColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case SERIES_COLUMN_START:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
		break
	case SERIES_COLUMN_STOP:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		break
	case SERIES_COLUMN_STEP:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiStep
		break
	default:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiValue
		break
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return SQLITE_OK
}

func seriesRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*series_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

func seriesEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		return libc.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue < (*series_cursor)(unsafe.Pointer(pCur)).FmnValue)
	} else {
		return libc.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue > (*series_cursor)(unsafe.Pointer(pCur)).FmxValue)
	}
	return int32(0)
}

func seriesFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStrUnused uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = pVtabCursor
	var i int32 = 0
	_ = idxStrUnused
	if idxNum&1 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*4)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(0)
	}
	if idxNum&2 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*4)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff)
	}
	if idxNum&4 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*4)))
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep == int64(0) {
			(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
		} else if (*series_cursor)(unsafe.Pointer(pCur)).FiStep < int64(0) {
			(*series_cursor)(unsafe.Pointer(pCur)).FiStep = -(*series_cursor)(unsafe.Pointer(pCur)).FiStep
			if idxNum&16 == 0 {
				idxNum = idxNum | 8
			}
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
	}
	for i = 0; i < argc; i++ {
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) == SQLITE_NULL {
			(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(1)
			(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0)
			break
		}
	}
	if idxNum&8 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 1
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep > int64(0) {
			*(*sqlite3_int64)(unsafe.Pointer(pCur + 16)) -= ((*series_cursor)(unsafe.Pointer(pCur)).FmxValue - (*series_cursor)(unsafe.Pointer(pCur)).FmnValue) % (*series_cursor)(unsafe.Pointer(pCur)).FiStep
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 0
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return SQLITE_OK
}

func seriesBestIndex(tls *libc.TLS, pVTab uintptr, pIdxInfo uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var i int32
	var j int32
	var idxNum int32 = 0
	var bStartSeen int32 = 0
	var unusableMask int32 = 0
	var nArg int32 = 0

	var pConstraint uintptr

	*(*int32)(unsafe.Pointer(bp)) = libc.AssignPtrInt32(bp+1*4, libc.AssignPtrInt32(bp+2*4, -1))
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		var iCol int32
		var iMask int32
		if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < SERIES_COLUMN_START {
			goto __2
		}
		iCol = (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn - SERIES_COLUMN_START

		iMask = int32(1) << iCol
		if iCol == 0 {
			bStartSeen = 1
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			unusableMask = unusableMask | iMask
			goto __2
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idxNum = idxNum | iMask
			*(*int32)(unsafe.Pointer(bp + uintptr(iCol)*4)) = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	for i = 0; i < 3; i++ {
		if libc.AssignInt32(&j, *(*int32)(unsafe.Pointer(bp + uintptr(i)*4))) >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).FargvIndex = libc.PreIncInt32(&nArg, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).Fomit = libc.BoolUint8(!(1 != 0))
		}
	}

	if !(bStartSeen != 0) {
		sqlite3.Xsqlite3_free(tls, (*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg)
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+7269, 0)
		return SQLITE_ERROR
	}
	if unusableMask & ^idxNum != 0 {
		return SQLITE_CONSTRAINT
	}
	if idxNum&3 == 3 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(2 - libc.Bool32(idxNum&4 != 0))
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000)
		if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy >= 1 && (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == 0 {
			if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc != 0 {
				idxNum = idxNum | 8
			} else {
				idxNum = idxNum | 16
			}
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	return SQLITE_OK
}

var seriesModule = sqlite3_module{
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_series_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	if sqlite3.Xsqlite3_libversion_number(tls) < 3008012 && pzErrMsg != uintptr(0) {
		*(*uintptr)(unsafe.Pointer(pzErrMsg)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+7327, 0)
		return SQLITE_ERROR
	}
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+7377, uintptr(unsafe.Pointer(&seriesModule)), uintptr(0))
	return rc
}

type u16 = uint16

var midClass = [128]uint8{
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_SPACE), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_SPACE), uint8(CCLASS_SPACE), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_SPACE),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_SILENT), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT),
	uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT),
	uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT),
	uint8(CCLASS_DIGIT), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_VOWEL),
	uint8(CCLASS_B), uint8(CCLASS_C), uint8(CCLASS_D),
	uint8(CCLASS_VOWEL), uint8(CCLASS_B), uint8(CCLASS_C),
	uint8(CCLASS_SILENT), uint8(CCLASS_VOWEL), uint8(CCLASS_C),
	uint8(CCLASS_C), uint8(CCLASS_L), uint8(CCLASS_M),
	uint8(CCLASS_M), uint8(CCLASS_VOWEL), uint8(CCLASS_B),
	uint8(CCLASS_C), uint8(CCLASS_R), uint8(CCLASS_C),
	uint8(CCLASS_D), uint8(CCLASS_VOWEL), uint8(CCLASS_B),
	uint8(CCLASS_B), uint8(CCLASS_C), uint8(CCLASS_VOWEL),
	uint8(CCLASS_C), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_VOWEL), uint8(CCLASS_B),
	uint8(CCLASS_C), uint8(CCLASS_D), uint8(CCLASS_VOWEL),
	uint8(CCLASS_B), uint8(CCLASS_C), uint8(CCLASS_SILENT),
	uint8(CCLASS_VOWEL), uint8(CCLASS_C), uint8(CCLASS_C),
	uint8(CCLASS_L), uint8(CCLASS_M), uint8(CCLASS_M),
	uint8(CCLASS_VOWEL), uint8(CCLASS_B), uint8(CCLASS_C),
	uint8(CCLASS_R), uint8(CCLASS_C), uint8(CCLASS_D),
	uint8(CCLASS_VOWEL), uint8(CCLASS_B), uint8(CCLASS_B),
	uint8(CCLASS_C), uint8(CCLASS_VOWEL), uint8(CCLASS_C),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
}

var initClass = [128]uint8{
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_SPACE), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_SPACE), uint8(CCLASS_SPACE), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_SPACE),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT),
	uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT),
	uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT), uint8(CCLASS_DIGIT),
	uint8(CCLASS_DIGIT), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_VOWEL),
	uint8(CCLASS_B), uint8(CCLASS_C), uint8(CCLASS_D),
	uint8(CCLASS_VOWEL), uint8(CCLASS_B), uint8(CCLASS_C),
	uint8(CCLASS_SILENT), uint8(CCLASS_VOWEL), uint8(CCLASS_C),
	uint8(CCLASS_C), uint8(CCLASS_L), uint8(CCLASS_M),
	uint8(CCLASS_M), uint8(CCLASS_VOWEL), uint8(CCLASS_B),
	uint8(CCLASS_C), uint8(CCLASS_R), uint8(CCLASS_C),
	uint8(CCLASS_D), uint8(CCLASS_VOWEL), uint8(CCLASS_B),
	uint8(CCLASS_B), uint8(CCLASS_C), uint8(CCLASS_Y),
	uint8(CCLASS_C), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_VOWEL), uint8(CCLASS_B),
	uint8(CCLASS_C), uint8(CCLASS_D), uint8(CCLASS_VOWEL),
	uint8(CCLASS_B), uint8(CCLASS_C), uint8(CCLASS_SILENT),
	uint8(CCLASS_VOWEL), uint8(CCLASS_C), uint8(CCLASS_C),
	uint8(CCLASS_L), uint8(CCLASS_M), uint8(CCLASS_M),
	uint8(CCLASS_VOWEL), uint8(CCLASS_B), uint8(CCLASS_C),
	uint8(CCLASS_R), uint8(CCLASS_C), uint8(CCLASS_D),
	uint8(CCLASS_VOWEL), uint8(CCLASS_B), uint8(CCLASS_B),
	uint8(CCLASS_C), uint8(CCLASS_Y), uint8(CCLASS_C),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
	uint8(CCLASS_OTHER), uint8(CCLASS_OTHER),
}

var className = *(*[14]uint8)(unsafe.Pointer(ts + 7393))

func phoneticHash(tls *libc.TLS, zIn uintptr, nIn int32) uintptr {
	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+1))
	var i int32
	var nOut int32 = 0
	var cPrev int8 = int8(0x77)
	var cPrevX int8 = int8(0x77)
	var aClass uintptr = uintptr(unsafe.Pointer(&initClass))

	if zOut == uintptr(0) {
		return uintptr(0)
	}
	if nIn > 2 {
		switch int32(*(*uint8)(unsafe.Pointer(zIn))) {
		case 'g':
			fallthrough
		case 'k':
			{
				if int32(*(*uint8)(unsafe.Pointer(zIn + 1))) == 'n' {
					zIn++
					nIn--
				}
				break

			}
		}
	}
	for i = 0; i < nIn; i++ {
		var c uint8 = *(*uint8)(unsafe.Pointer(zIn + uintptr(i)))
		if i+1 < nIn {
			if int32(c) == 'w' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'r' {
				continue
			}
			if int32(c) == 'd' && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'j' || int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'g') {
				continue
			}
			if i+2 < nIn {
				if int32(c) == 't' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'c' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+2)))) == 'h' {
					continue
				}
			}
		}
		c = *(*uint8)(unsafe.Pointer(aClass + uintptr(int32(c)&0x7f)))
		if int32(c) == CCLASS_SPACE {
			continue
		}
		if int32(c) == CCLASS_OTHER && int32(cPrev) != CCLASS_DIGIT {
			continue
		}
		aClass = uintptr(unsafe.Pointer(&midClass))
		if int32(c) == CCLASS_VOWEL && (int32(cPrevX) == CCLASS_R || int32(cPrevX) == CCLASS_L) {
			continue
		}
		if (int32(c) == CCLASS_R || int32(c) == CCLASS_L) && int32(cPrevX) == CCLASS_VOWEL {
			nOut--
		}
		cPrev = int8(c)
		if int32(c) == CCLASS_SILENT {
			continue
		}
		cPrevX = int8(c)
		c = className[c]

		if nOut == 0 || int32(c) != int32(*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut-1)))) {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = c
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

func phoneticHashSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var zIn uintptr
	var zOut uintptr

	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zIn == uintptr(0) {
		return
	}
	zOut = phoneticHash(tls, zIn, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv))))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func characterClass(tls *libc.TLS, cPrev int8, c int8) int8 {
	if int32(cPrev) == 0 {
		return int8(initClass[int32(c)&0x7f])
	}
	return int8(midClass[int32(c)&0x7f])
}

func insertOrDeleteCost(tls *libc.TLS, cPrev int8, c int8, cNext int8) int32 {
	var classC int8 = characterClass(tls, cPrev, c)
	var classCprev int8

	if int32(classC) == CCLASS_SILENT {
		return 1
	}
	if int32(cPrev) == int32(c) {
		return 10
	}
	if int32(classC) == CCLASS_VOWEL && (int32(cPrev) == 'r' || int32(cNext) == 'r') {
		return 20
	}
	classCprev = characterClass(tls, cPrev, cPrev)
	if int32(classC) == int32(classCprev) {
		if int32(classC) == CCLASS_VOWEL {
			return 15
		} else {
			return 50
		}
	}

	return 100
}

func substituteCost(tls *libc.TLS, cPrev int8, cFrom int8, cTo int8) int32 {
	var classFrom int8
	var classTo int8
	if int32(cFrom) == int32(cTo) {
		return 0
	}
	if int32(cFrom) == int32(cTo)^0x20 && (int32(cTo) >= 'A' && int32(cTo) <= 'Z' || int32(cTo) >= 'a' && int32(cTo) <= 'z') {
		return 0
	}
	classFrom = characterClass(tls, cPrev, cFrom)
	classTo = characterClass(tls, cPrev, cTo)
	if int32(classFrom) == int32(classTo) {
		return 40
	}
	if int32(classFrom) >= CCLASS_B && int32(classFrom) <= CCLASS_Y &&
		int32(classTo) >= CCLASS_B && int32(classTo) <= CCLASS_Y {
		return 75
	}

	return 100
}

func editdist1(tls *libc.TLS, zA uintptr, zB uintptr, pnMatch uintptr) int32 {
	bp := tls.Alloc(300)
	defer tls.Free(300)

	var nA int32
	var nB int32
	var xA int32
	var xB int32
	var cA int8 = int8(0)
	var cB int8
	var cAprev int8
	var cBprev int8
	var cAnext int8
	var cBnext int8
	var d int32
	var dc int32 = 0
	var res int32
	var m uintptr
	var cx uintptr
	var toFree uintptr = uintptr(0)
	var nMatch int32 = 0

	if zA == uintptr(0) || zB == uintptr(0) {
		return -1
	}

	for *(*int8)(unsafe.Pointer(zA)) != 0 && int32(*(*int8)(unsafe.Pointer(zA))) == int32(*(*int8)(unsafe.Pointer(zB))) {
		dc = int32(*(*int8)(unsafe.Pointer(zA)))
		zA++
		zB++
		nMatch++
	}
	if pnMatch != 0 {
		*(*int32)(unsafe.Pointer(pnMatch)) = nMatch
	}
	if int32(*(*int8)(unsafe.Pointer(zA))) == 0 && int32(*(*int8)(unsafe.Pointer(zB))) == 0 {
		return 0
	}

	for nA = 0; *(*int8)(unsafe.Pointer(zA + uintptr(nA))) != 0; nA++ {
		if int32(*(*int8)(unsafe.Pointer(zA + uintptr(nA))))&0x80 != 0 {
			return -2
		}
	}
	for nB = 0; *(*int8)(unsafe.Pointer(zB + uintptr(nB))) != 0; nB++ {
		if int32(*(*int8)(unsafe.Pointer(zB + uintptr(nB))))&0x80 != 0 {
			return -2
		}
	}

	if nA == 0 {
		cBprev = int8(dc)
		for xB = libc.AssignInt32(&res, 0); int32(libc.AssignInt8(&cB, *(*int8)(unsafe.Pointer(zB + uintptr(xB))))) != 0; xB++ {
			res = res + insertOrDeleteCost(tls, cBprev, cB, *(*int8)(unsafe.Pointer(zB + uintptr(xB+1))))/FINAL_INS_COST_DIV
			cBprev = cB
		}
		return res
	}
	if nB == 0 {
		cAprev = int8(dc)
		for xA = libc.AssignInt32(&res, 0); int32(libc.AssignInt8(&cA, *(*int8)(unsafe.Pointer(zA + uintptr(xA))))) != 0; xA++ {
			res = res + insertOrDeleteCost(tls, cAprev, cA, *(*int8)(unsafe.Pointer(zA + uintptr(xA+1))))
			cAprev = cA
		}
		return res
	}

	if int32(*(*int8)(unsafe.Pointer(zA))) == '*' && int32(*(*int8)(unsafe.Pointer(zA + 1))) == 0 {
		return 0
	}

	if uint32(nB) < uint32(unsafe.Sizeof([75]int32{}))*uint32(4)/(uint32(unsafe.Sizeof(int32(0)))*uint32(5)) {
		m = bp
	} else {
		m = libc.AssignUintptr(&toFree, sqlite3.Xsqlite3_malloc64(tls, uint64(uint32((nB+1)*5)*uint32(unsafe.Sizeof(int32(0)))/uint32(4))))
		if m == uintptr(0) {
			return -3
		}
	}
	cx = m + uintptr(nB+1)*4

	*(*int32)(unsafe.Pointer(m)) = 0
	*(*int8)(unsafe.Pointer(cx)) = int8(dc)
	cBprev = int8(dc)
	for xB = 1; xB <= nB; xB++ {
		cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))
		cB = *(*int8)(unsafe.Pointer(zB + uintptr(xB-1)))
		*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = cB
		*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = *(*int32)(unsafe.Pointer(m + uintptr(xB-1)*4)) + insertOrDeleteCost(tls, cBprev, cB, cBnext)
		cBprev = cB
	}
	cAprev = int8(dc)
	for xA = 1; xA <= nA; xA++ {
		var lastA int32 = libc.Bool32(xA == nA)
		cA = *(*int8)(unsafe.Pointer(zA + uintptr(xA-1)))
		cAnext = *(*int8)(unsafe.Pointer(zA + uintptr(xA)))
		if int32(cA) == '*' && lastA != 0 {
			break
		}
		d = *(*int32)(unsafe.Pointer(m))
		dc = int32(*(*int8)(unsafe.Pointer(cx)))
		*(*int32)(unsafe.Pointer(m)) = d + insertOrDeleteCost(tls, cAprev, cA, cAnext)
		cBprev = int8(0)
		for xB = 1; xB <= nB; xB++ {
			var totalCost int32
			var insCost int32
			var delCost int32
			var subCost int32
			var ncx int32
			cB = *(*int8)(unsafe.Pointer(zB + uintptr(xB-1)))
			cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))

			insCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB-1))), cB, cBnext)
			if lastA != 0 {
				insCost = insCost / FINAL_INS_COST_DIV
			}

			delCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB))), cA, cBnext)

			subCost = substituteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB-1))), cA, cB)

			totalCost = insCost + *(*int32)(unsafe.Pointer(m + uintptr(xB-1)*4))
			ncx = int32(cB)
			if delCost+*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) < totalCost {
				totalCost = delCost + *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
				ncx = int32(cA)
			}
			if subCost+d < totalCost {
				totalCost = subCost + d
			}

			d = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
			dc = int32(*(*int8)(unsafe.Pointer(cx + uintptr(xB))))
			*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = totalCost
			*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = int8(ncx)
			cBprev = cB
		}
		cAprev = cA
	}

	if int32(cA) == '*' {
		res = *(*int32)(unsafe.Pointer(m + 1*4))
		for xB = 1; xB <= nB; xB++ {
			if *(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) < res {
				res = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
				if pnMatch != 0 {
					*(*int32)(unsafe.Pointer(pnMatch)) = xB + nMatch
				}
			}
		}
	} else {
		res = *(*int32)(unsafe.Pointer(m + uintptr(nB)*4))

	}
	sqlite3.Xsqlite3_free(tls, toFree)
	return res
}

func editdistSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var res int32 = editdist1(tls,
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))),
		uintptr(0))
	if res < 0 {
		if res == -3 {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else if res == -2 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+7407, -1)
		} else {
			sqlite3.Xsqlite3_result_error(tls, context, ts+7437, -1)
		}
	} else {
		sqlite3.Xsqlite3_result_int(tls, context, res)
	}
}

type EditDist3Cost1 = struct {
	FpNext uintptr
	FnFrom u8
	FnTo   u8
	FiCost u16
	Fa     [4]int8
}

type EditDist3Cost = EditDist3Cost1
type EditDist3Config1 = struct {
	FnLang int32
	Fa     uintptr
}

type EditDist3Config = EditDist3Config1
type EditDist3From1 = struct {
	FnSubst  int32
	FnDel    int32
	FnByte   int32
	FapSubst uintptr
	FapDel   uintptr
}

type EditDist3From = EditDist3From1
type EditDist3FromString1 = struct {
	Fz        uintptr
	Fn        int32
	FisPrefix int32
	Fa        uintptr
}

type EditDist3FromString = EditDist3FromString1
type EditDist3To1 = struct {
	FnIns  int32
	FnByte int32
	FapIns uintptr
}

type EditDist3To = EditDist3To1
type EditDist3ToString1 = struct {
	Fz uintptr
	Fn int32
	Fa uintptr
}

type EditDist3ToString = EditDist3ToString1
type EditDist3Lang1 = struct {
	FiLang    int32
	FiInsCost int32
	FiDelCost int32
	FiSubCost int32
	FpCost    uintptr
}

type EditDist3Lang = EditDist3Lang1

var editDist3Lang = EditDist3Lang{FiInsCost: 100, FiDelCost: 100, FiSubCost: 150}

func editDist3ConfigClear(tls *libc.TLS, p uintptr) {
	var i int32
	if p == uintptr(0) {
		return
	}
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; i++ {
		var pCost uintptr
		var pNext uintptr
		pCost = (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(i)*20)).FpCost
		for pCost != 0 {
			pNext = (*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext
			sqlite3.Xsqlite3_free(tls, pCost)
			pCost = pNext
		}
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa)
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(EditDist3Config{})))
}

func editDist3ConfigDelete(tls *libc.TLS, pIn uintptr) {
	var p uintptr = pIn
	editDist3ConfigClear(tls, p)
	sqlite3.Xsqlite3_free(tls, p)
}

func editDist3CostCompare(tls *libc.TLS, pA uintptr, pB uintptr) int32 {
	var n int32 = int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom)
	var rc int32
	if n > int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom) {
		n = int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom)
	}
	rc = libc.Xstrncmp(tls, pA+8, pB+8, uint32(n))
	if rc == 0 {
		rc = int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom) - int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom)
	}
	return rc
}

func editDist3CostMerge(tls *libc.TLS, pA uintptr, pB uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	var ppTail uintptr = bp
	var p uintptr
	for pA != 0 && pB != 0 {
		if editDist3CostCompare(tls, pA, pB) <= 0 {
			p = pA
			pA = (*EditDist3Cost)(unsafe.Pointer(pA)).FpNext
		} else {
			p = pB
			pB = (*EditDist3Cost)(unsafe.Pointer(pB)).FpNext
		}
		*(*uintptr)(unsafe.Pointer(ppTail)) = p
		ppTail = p
	}
	if pA != 0 {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pA
	} else {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pB
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

func editDist3CostSort(tls *libc.TLS, pList uintptr) uintptr {
	bp := tls.Alloc(240)
	defer tls.Free(240)

	var p uintptr
	var i int32
	var mx int32 = 0
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 1*4)) = uintptr(0)
	for pList != 0 {
		p = pList
		pList = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
		(*EditDist3Cost)(unsafe.Pointer(p)).FpNext = uintptr(0)
		for i = 0; *(*uintptr)(unsafe.Pointer(bp + uintptr(i)*4)) != 0; i++ {
			p = editDist3CostMerge(tls, *(*uintptr)(unsafe.Pointer(bp + uintptr(i)*4)), p)
			*(*uintptr)(unsafe.Pointer(bp + uintptr(i)*4)) = uintptr(0)
		}
		*(*uintptr)(unsafe.Pointer(bp + uintptr(i)*4)) = p
		if i > mx {
			mx = i
			*(*uintptr)(unsafe.Pointer(bp + uintptr(i+1)*4)) = uintptr(0)
		}
	}
	p = uintptr(0)
	for i = 0; i <= mx; i++ {
		if *(*uintptr)(unsafe.Pointer(bp + uintptr(i)*4)) != 0 {
			p = editDist3CostMerge(tls, p, *(*uintptr)(unsafe.Pointer(bp + uintptr(i)*4)))
		}
	}
	return p
}

func editDist3ConfigLoad(tls *libc.TLS, p uintptr, db uintptr, zTable uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	var rc2 int32
	var zSql uintptr
	var iLangPrev int32 = -9999
	var pLang uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+7462, libc.VaList(bp, zTable))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+8, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		return rc
	}
	editDist3ConfigClear(tls, p)
	for sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8))) == SQLITE_ROW {
		var iLang int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 0)
		var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 1)
		var nFrom int32
		if zFrom != 0 {
			nFrom = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 1)
		} else {
			nFrom = 0
		}
		var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 2)
		var nTo int32
		if zTo != 0 {
			nTo = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 2)
		} else {
			nTo = 0
		}
		var iCost int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 3)

		if nFrom > 100 || nTo > 100 {
			continue
		}
		if iCost < 0 {
			continue
		}
		if iCost >= 10000 {
			continue
		}
		if pLang == uintptr(0) || iLang != iLangPrev {
			var pNew uintptr
			pNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa, uint64(uint32((*EditDist3Config)(unsafe.Pointer(p)).FnLang+1)*uint32(unsafe.Sizeof(EditDist3Lang{}))))
			if pNew == uintptr(0) {
				rc = SQLITE_NOMEM
				break
			}
			(*EditDist3Config)(unsafe.Pointer(p)).Fa = pNew
			pLang = (*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr((*EditDist3Config)(unsafe.Pointer(p)).FnLang)*20
			(*EditDist3Config)(unsafe.Pointer(p)).FnLang++
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiLang = iLang
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = 150
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = uintptr(0)
			iLangPrev = iLang
		}
		if nFrom == 1 && int32(*(*int8)(unsafe.Pointer(zFrom))) == '?' && nTo == 0 {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = iCost
		} else if nFrom == 0 && nTo == 1 && int32(*(*int8)(unsafe.Pointer(zTo))) == '?' {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = iCost
		} else if nFrom == 1 && nTo == 1 && int32(*(*int8)(unsafe.Pointer(zFrom))) == '?' && int32(*(*int8)(unsafe.Pointer(zTo))) == '?' {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = iCost
		} else {
			var pCost uintptr
			var nExtra int32 = nFrom + nTo - 4
			if nExtra < 0 {
				nExtra = 0
			}
			pCost = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(EditDist3Cost{}))+uint32(nExtra)))
			if pCost == uintptr(0) {
				rc = SQLITE_NOMEM
				break
			}
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnFrom = u8(nFrom)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnTo = u8(nTo)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FiCost = u16(iCost)
			libc.Xmemcpy(tls, pCost+8, zFrom, uint32(nFrom))
			libc.Xmemcpy(tls, pCost+8+uintptr(nFrom), zTo, uint32(nTo))
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = pCost
		}
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	if rc == SQLITE_OK {
		rc = rc2
	}
	if rc == SQLITE_OK {
		var iLang int32
		for iLang = 0; iLang < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; iLang++ {
			(*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(iLang)*20)).FpCost = editDist3CostSort(tls, (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa+uintptr(iLang)*20)).FpCost)
		}
	}
	return rc
}

func utf8Len(tls *libc.TLS, c uint8, N int32) int32 {
	var len int32 = 1
	if int32(c) > 0x7f {
		if int32(c)&0xe0 == 0xc0 {
			len = 2
		} else if int32(c)&0xf0 == 0xe0 {
			len = 3
		} else {
			len = 4
		}
	}
	if len > N {
		len = N
	}
	return len
}

func matchTo(tls *libc.TLS, p uintptr, z uintptr, n int32) int32 {
	if int32(*(*int8)(unsafe.Pointer(p + 8 + uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)))) != int32(*(*int8)(unsafe.Pointer(z))) {
		return 0
	}
	if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) > n {
		return 0
	}
	if libc.Xstrncmp(tls, p+8+uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom), z, uint32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)) != 0 {
		return 0
	}
	return 1
}

func matchFrom(tls *libc.TLS, p uintptr, z uintptr, n int32) int32 {
	if (*EditDist3Cost)(unsafe.Pointer(p)).FnFrom != 0 {
		if int32(*(*int8)(unsafe.Pointer(p + 8))) != int32(*(*int8)(unsafe.Pointer(z))) {
			return 0
		}
		if libc.Xstrncmp(tls, p+8, z, uint32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) != 0 {
			return 0
		}
	}
	return 1
}

func matchFromTo(tls *libc.TLS, pStr uintptr, n1 int32, z2 uintptr, n2 int32) int32 {
	var b1 int32 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n1)*20)).FnByte
	if b1 > n2 {
		return 0
	}

	if int32(*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n1)))) != int32(*(*int8)(unsafe.Pointer(z2))) {
		return 0
	}
	if libc.Xstrncmp(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fz+uintptr(n1), z2, uint32(b1)) != 0 {
		return 0
	}
	return 1
}

func editDist3FromStringDelete(tls *libc.TLS, p uintptr) {
	var i int32
	if p != 0 {
		for i = 0; i < (*EditDist3FromString)(unsafe.Pointer(p)).Fn; i++ {
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*20)).FapDel)
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*20)).FapSubst)
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func editDist3FromStringNew(tls *libc.TLS, pLang uintptr, z uintptr, n int32) uintptr {
	var pStr uintptr
	var p uintptr
	var i int32

	if z == uintptr(0) {
		return uintptr(0)
	}
	if n < 0 {
		n = int32(libc.Xstrlen(tls, z))
	}
	pStr = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(EditDist3FromString{}))+uint32(unsafe.Sizeof(EditDist3From{}))*uint32(n)+uint32(n)+uint32(1)))
	if pStr == uintptr(0) {
		return uintptr(0)
	}
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fa = pStr + 1*16
	libc.Xmemset(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa, 0, uint32(unsafe.Sizeof(EditDist3From{}))*uint32(n))
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn = n
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fz = (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n)*20
	libc.Xmemcpy(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fz, z, uint32(n+1))
	if n != 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(n-1)))) == '*' {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 1
		n--
		(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn--
		*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n))) = int8(0)
	} else {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 0
	}

	for i = 0; i < n; i++ {
		var pFrom uintptr = (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(i)*20
		libc.Xmemset(tls, pFrom, 0, uint32(unsafe.Sizeof(EditDist3From{})))
		(*EditDist3From)(unsafe.Pointer(pFrom)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))), n-i)
		for p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost; p != 0; p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext {
			var apNew uintptr
			if i+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom) > n {
				continue
			}
			if matchFrom(tls, p, z+uintptr(i), n-i) == 0 {
				continue
			}
			if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) == 0 {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapDel,
					uint64(uint32(unsafe.Sizeof(uintptr(0)))*uint32((*EditDist3From)(unsafe.Pointer(pFrom)).FnDel+1)))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapDel = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(libc.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnDel, 1))*4)) = p
			} else {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst,
					uint64(uint32(unsafe.Sizeof(uintptr(0)))*uint32((*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst+1)))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(libc.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst, 1))*4)) = p
			}
		}
		if p != 0 {
			editDist3FromStringDelete(tls, pStr)
			pStr = uintptr(0)
			break
		}
	}
	return pStr
}

func updateCost(tls *libc.TLS, m uintptr, i int32, j int32, iCost int32) {
	var b uint32

	b = *(*uint32)(unsafe.Pointer(m + uintptr(j)*4)) + uint32(iCost)
	if b < *(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) {
		*(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) = b
	}
}

func editDist3Core(tls *libc.TLS, pFrom uintptr, z2 uintptr, n2 int32, pLang uintptr, pnMatch uintptr) int32 {
	bp := tls.Alloc(1040)
	defer tls.Free(1040)

	var k int32
	var n int32
	var i1 int32
	var b1 int32
	var i2 int32
	var b2 int32

	var a2 uintptr
	var m uintptr
	var pToFree uintptr
	var szRow int32
	var p uintptr
	var res int32
	var nByte sqlite3_uint64

	var apNew uintptr
	var cx int32
	var cxp int32
	var cxd int32
	var cxu int32
	var rx int32
	var rxp int32
	var b int32
	var nExtra int32
	*(*EditDist3FromString)(unsafe.Pointer(bp + 1024)) = *(*EditDist3FromString)(unsafe.Pointer(pFrom))

	n = ((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn + 1) * (n2 + 1)
	n = (n + 1) & libc.CplInt32(1)
	nByte = sqlite3_uint64(uint32(n)*uint32(unsafe.Sizeof(uint32(0))) + uint32(unsafe.Sizeof(EditDist3To{}))*uint32(n2))
	if !(nByte <= sqlite3_uint64(unsafe.Sizeof([256]uint32{}))) {
		goto __1
	}
	m = bp
	pToFree = uintptr(0)
	goto __2
__1:
	m = libc.AssignUintptr(&pToFree, sqlite3.Xsqlite3_malloc64(tls, nByte))
	if !(m == uintptr(0)) {
		goto __3
	}
	return -1
__3:
	;
__2:
	;
	a2 = m + uintptr(n)*4
	libc.Xmemset(tls, a2, 0, uint32(unsafe.Sizeof(EditDist3To{}))*uint32(n2))

	i2 = 0
__4:
	if !(i2 < n2) {
		goto __6
	}
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*12)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z2 + uintptr(i2)))), n2-i2)
	p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
__7:
	if !(p != 0) {
		goto __9
	}
	if !(int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom) > 0) {
		goto __10
	}
	goto __9
__10:
	;
	if !(i2+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) > n2) {
		goto __11
	}
	goto __8
__11:
	;
	if !(int32(*(*int8)(unsafe.Pointer(p + 8))) > int32(*(*int8)(unsafe.Pointer(z2 + uintptr(i2))))) {
		goto __12
	}
	goto __9
__12:
	;
	if !(matchTo(tls, p, z2+uintptr(i2), n2-i2) == 0) {
		goto __13
	}
	goto __8
__13:
	;
	(*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns++
	apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns, uint64(uint32(unsafe.Sizeof(uintptr(0)))*uint32((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns)))
	if !(apNew == uintptr(0)) {
		goto __14
	}
	res = -1
	goto editDist3Abort
__14:
	;
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*12)).FapIns = apNew
	*(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns + uintptr((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns-1)*4)) = p
	goto __8
__8:
	p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	i2++
	goto __4
	goto __6
__6:
	;
	szRow = (*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn + 1
	libc.Xmemset(tls, m, 0x01, uint32((n2+1)*szRow)*uint32(unsafe.Sizeof(uint32(0))))
	*(*uint32)(unsafe.Pointer(m)) = uint32(0)

	i1 = 0
__15:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn) {
		goto __17
	}
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa + uintptr(i1)*20)).FnByte
	updateCost(tls, m, i1+b1, i1, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__18:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*20)).FnDel) {
		goto __20
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*20)).FapDel + uintptr(k)*4))
	updateCost(tls, m, i1+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom), i1, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __19
__19:
	k++
	goto __18
	goto __20
__20:
	;
	goto __16
__16:
	i1 = i1 + b1
	goto __15
	goto __17
__17:
	;
	i2 = 0
__21:
	if !(i2 < n2) {
		goto __23
	}
	b2 = (*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*12)).FnByte
	rx = szRow * (i2 + b2)
	rxp = szRow * i2
	updateCost(tls, m, rx, rxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	k = 0
__24:
	if !(k < (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FnIns) {
		goto __26
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns + uintptr(k)*4))
	updateCost(tls, m, szRow*(i2+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)), rxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __25
__25:
	k++
	goto __24
	goto __26
__26:
	;
	i1 = 0
__27:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn) {
		goto __29
	}
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa + uintptr(i1)*20)).FnByte
	cxp = rx + i1
	cx = cxp + b1
	cxd = rxp + i1
	cxu = cxd + b1
	updateCost(tls, m, cx, cxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__30:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*20)).FnDel) {
		goto __32
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*20)).FapDel + uintptr(k)*4))
	updateCost(tls, m, cxp+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom), cxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __31
__31:
	k++
	goto __30
	goto __32
__32:
	;
	updateCost(tls, m, cx, cxu, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	if !(matchFromTo(tls, bp+1024, i1, z2+uintptr(i2), n2-i2) != 0) {
		goto __33
	}
	updateCost(tls, m, cx, cxd, 0)
__33:
	;
	updateCost(tls, m, cx, cxd, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost)
	k = 0
__34:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*20)).FnSubst) {
		goto __36
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*20)).FapSubst + uintptr(k)*4))
	if !(matchTo(tls, p, z2+uintptr(i2), n2-i2) != 0) {
		goto __37
	}
	updateCost(tls, m, cxd+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)+szRow*int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo), cxd, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
__37:
	;
	goto __35
__35:
	k++
	goto __34
	goto __36
__36:
	;
	goto __28
__28:
	i1 = i1 + b1
	goto __27
	goto __29
__29:
	;
	goto __22
__22:
	i2 = i2 + b2
	goto __21
	goto __23
__23:
	;
	res = int32(*(*uint32)(unsafe.Pointer(m + uintptr(szRow*(n2+1)-1)*4)))
	n = n2
	if !((*EditDist3FromString)(unsafe.Pointer(bp+1024)).FisPrefix != 0) {
		goto __38
	}
	i2 = 1
__39:
	if !(i2 <= n2) {
		goto __41
	}
	b = int32(*(*uint32)(unsafe.Pointer(m + uintptr(szRow*i2-1)*4)))
	if !(b <= res) {
		goto __42
	}
	res = b
	n = i2 - 1
__42:
	;
	goto __40
__40:
	i2++
	goto __39
	goto __41
__41:
	;
__38:
	;
	if !(pnMatch != 0) {
		goto __43
	}
	nExtra = 0
	k = 0
__44:
	if !(k < n) {
		goto __46
	}
	if !(int32(*(*int8)(unsafe.Pointer(z2 + uintptr(k))))&0xc0 == 0x80) {
		goto __47
	}
	nExtra++
__47:
	;
	goto __45
__45:
	k++
	goto __44
	goto __46
__46:
	;
	*(*int32)(unsafe.Pointer(pnMatch)) = n - nExtra
__43:
	;
editDist3Abort:
	i2 = 0
__48:
	if !(i2 < n2) {
		goto __50
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*12)).FapIns)
	goto __49
__49:
	i2++
	goto __48
	goto __50
__50:
	;
	sqlite3.Xsqlite3_free(tls, pToFree)
	return res
}

func editDist3FindLang(tls *libc.TLS, pConfig uintptr, iLang int32) uintptr {
	var i int32
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(pConfig)).FnLang; i++ {
		if (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(pConfig)).Fa+uintptr(i)*20)).FiLang == iLang {
			return (*EditDist3Config)(unsafe.Pointer(pConfig)).Fa + uintptr(i)*20
		}
	}
	return uintptr(unsafe.Pointer(&editDist3Lang))
}

func editDist3SqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var pConfig uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var rc int32
	if argc == 1 {
		var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		rc = editDist3ConfigLoad(tls, pConfig, db, zTable)
		if rc != 0 {
			sqlite3.Xsqlite3_result_error_code(tls, context, rc)
		}
	} else {
		var zA uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var zB uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		var nA int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var nB int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		var iLang int32
		if argc == 3 {
			iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		} else {
			iLang = 0
		}
		var pLang uintptr = editDist3FindLang(tls, pConfig, iLang)
		var pFrom uintptr
		var dist int32

		pFrom = editDist3FromStringNew(tls, pLang, zA, nA)
		if pFrom == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		dist = editDist3Core(tls, pFrom, zB, nB, pLang, uintptr(0))
		editDist3FromStringDelete(tls, pFrom)
		if dist == -1 {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, dist)
		}
	}
}

func editDist3Install(tls *libc.TLS, db uintptr) int32 {
	var rc int32
	var pConfig uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if pConfig == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pConfig, 0, uint32(unsafe.Sizeof(EditDist3Config{})))
	rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+7534,
		2, SQLITE_UTF8|SQLITE_DETERMINISTIC, pConfig,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+7534,
			3, SQLITE_UTF8|SQLITE_DETERMINISTIC, pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+7534,
			1, SQLITE_UTF8|SQLITE_DETERMINISTIC, pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{editDist3ConfigDelete})))
	} else {
		sqlite3.Xsqlite3_free(tls, pConfig)
	}
	return rc
}

var sqlite3Utf8Trans1 = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
}

func utf8Read(tls *libc.TLS, z uintptr, n int32, pSize uintptr) int32 {
	var c int32
	var i int32

	if 0 != 0 {
		c = libc.AssignInt32(&i, 0)
	} else {
		c = int32(*(*uint8)(unsafe.Pointer(z)))
		i = 1
		if c >= 0xc0 {
			c = int32(sqlite3Utf8Trans1[c-0xc0])
			for i < n && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))&0xc0 == 0x80 {
				c = c<<6 + 0x3f&int32(*(*uint8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))))
			}
		}
	}
	*(*int32)(unsafe.Pointer(pSize)) = i
	return c
}

func utf8Charlen(tls *libc.TLS, zIn uintptr, nIn int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	var nChar int32 = 0
	for i = 0; i < nIn; nChar++ {
		utf8Read(tls, zIn+uintptr(i), nIn-i, bp)
		i = i + *(*int32)(unsafe.Pointer(bp))
	}
	return nChar
}

type Transliteration1 = struct {
	FcFrom uint16
	FcTo0  uint8
	FcTo1  uint8
	FcTo2  uint8
	FcTo3  uint8
}

type Transliteration = Transliteration1

var translit = [389]Transliteration{
	{FcFrom: uint16(0x00A0), FcTo0: uint8(0x20)},
	{FcFrom: uint16(0x00B5), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x00C0), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x00C1), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x00C2), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x00C3), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x00C4), FcTo0: uint8(0x41), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x00C5), FcTo0: uint8(0x41), FcTo1: uint8(0x61)},
	{FcFrom: uint16(0x00C6), FcTo0: uint8(0x41), FcTo1: uint8(0x45)},
	{FcFrom: uint16(0x00C7), FcTo0: uint8(0x43)},
	{FcFrom: uint16(0x00C8), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x00C9), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x00CA), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x00CB), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x00CC), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x00CD), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x00CE), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x00CF), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x00D0), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x00D1), FcTo0: uint8(0x4E)},
	{FcFrom: uint16(0x00D2), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x00D3), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x00D4), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x00D5), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x00D6), FcTo0: uint8(0x4F), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x00D7), FcTo0: uint8(0x78)},
	{FcFrom: uint16(0x00D8), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x00D9), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x00DA), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x00DB), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x00DC), FcTo0: uint8(0x55), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x00DD), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x00DE), FcTo0: uint8(0x54), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x00DF), FcTo0: uint8(0x73), FcTo1: uint8(0x73)},
	{FcFrom: uint16(0x00E0), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x00E1), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x00E2), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x00E3), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x00E4), FcTo0: uint8(0x61), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x00E5), FcTo0: uint8(0x61), FcTo1: uint8(0x61)},
	{FcFrom: uint16(0x00E6), FcTo0: uint8(0x61), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x00E7), FcTo0: uint8(0x63)},
	{FcFrom: uint16(0x00E8), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x00E9), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x00EA), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x00EB), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x00EC), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x00ED), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x00EE), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x00EF), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x00F0), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x00F1), FcTo0: uint8(0x6E)},
	{FcFrom: uint16(0x00F2), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x00F3), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x00F4), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x00F5), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x00F6), FcTo0: uint8(0x6F), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x00F7), FcTo0: uint8(0x3A)},
	{FcFrom: uint16(0x00F8), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x00F9), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x00FA), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x00FB), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x00FC), FcTo0: uint8(0x75), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x00FD), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x00FE), FcTo0: uint8(0x74), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x00FF), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x0100), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x0101), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x0102), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x0103), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x0104), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x0105), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x0106), FcTo0: uint8(0x43)},
	{FcFrom: uint16(0x0107), FcTo0: uint8(0x63)},
	{FcFrom: uint16(0x0108), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0109), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x010A), FcTo0: uint8(0x43)},
	{FcFrom: uint16(0x010B), FcTo0: uint8(0x63)},
	{FcFrom: uint16(0x010C), FcTo0: uint8(0x43)},
	{FcFrom: uint16(0x010D), FcTo0: uint8(0x63)},
	{FcFrom: uint16(0x010E), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x010F), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x0110), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x0111), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x0112), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0113), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x0114), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0115), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x0116), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0117), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x0118), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0119), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x011A), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x011B), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x011C), FcTo0: uint8(0x47), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x011D), FcTo0: uint8(0x67), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x011E), FcTo0: uint8(0x47)},
	{FcFrom: uint16(0x011F), FcTo0: uint8(0x67)},
	{FcFrom: uint16(0x0120), FcTo0: uint8(0x47)},
	{FcFrom: uint16(0x0121), FcTo0: uint8(0x67)},
	{FcFrom: uint16(0x0122), FcTo0: uint8(0x47)},
	{FcFrom: uint16(0x0123), FcTo0: uint8(0x67)},
	{FcFrom: uint16(0x0124), FcTo0: uint8(0x48), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0125), FcTo0: uint8(0x68), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0126), FcTo0: uint8(0x48)},
	{FcFrom: uint16(0x0127), FcTo0: uint8(0x68)},
	{FcFrom: uint16(0x0128), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x0129), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x012A), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x012B), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x012C), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x012D), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x012E), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x012F), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x0130), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x0131), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x0132), FcTo0: uint8(0x49), FcTo1: uint8(0x4A)},
	{FcFrom: uint16(0x0133), FcTo0: uint8(0x69), FcTo1: uint8(0x6A)},
	{FcFrom: uint16(0x0134), FcTo0: uint8(0x4A), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0135), FcTo0: uint8(0x6A), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0136), FcTo0: uint8(0x4B)},
	{FcFrom: uint16(0x0137), FcTo0: uint8(0x6B)},
	{FcFrom: uint16(0x0138), FcTo0: uint8(0x6B)},
	{FcFrom: uint16(0x0139), FcTo0: uint8(0x4C)},
	{FcFrom: uint16(0x013A), FcTo0: uint8(0x6C)},
	{FcFrom: uint16(0x013B), FcTo0: uint8(0x4C)},
	{FcFrom: uint16(0x013C), FcTo0: uint8(0x6C)},
	{FcFrom: uint16(0x013D), FcTo0: uint8(0x4C)},
	{FcFrom: uint16(0x013E), FcTo0: uint8(0x6C)},
	{FcFrom: uint16(0x013F), FcTo0: uint8(0x4C), FcTo1: uint8(0x2E)},
	{FcFrom: uint16(0x0140), FcTo0: uint8(0x6C), FcTo1: uint8(0x2E)},
	{FcFrom: uint16(0x0141), FcTo0: uint8(0x4C)},
	{FcFrom: uint16(0x0142), FcTo0: uint8(0x6C)},
	{FcFrom: uint16(0x0143), FcTo0: uint8(0x4E)},
	{FcFrom: uint16(0x0144), FcTo0: uint8(0x6E)},
	{FcFrom: uint16(0x0145), FcTo0: uint8(0x4E)},
	{FcFrom: uint16(0x0146), FcTo0: uint8(0x6E)},
	{FcFrom: uint16(0x0147), FcTo0: uint8(0x4E)},
	{FcFrom: uint16(0x0148), FcTo0: uint8(0x6E)},
	{FcFrom: uint16(0x0149), FcTo0: uint8(0x27), FcTo1: uint8(0x6E)},
	{FcFrom: uint16(0x014A), FcTo0: uint8(0x4E), FcTo1: uint8(0x47)},
	{FcFrom: uint16(0x014B), FcTo0: uint8(0x6E), FcTo1: uint8(0x67)},
	{FcFrom: uint16(0x014C), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x014D), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x014E), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x014F), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x0150), FcTo0: uint8(0x4F)},
	{FcFrom: uint16(0x0151), FcTo0: uint8(0x6F)},
	{FcFrom: uint16(0x0152), FcTo0: uint8(0x4F), FcTo1: uint8(0x45)},
	{FcFrom: uint16(0x0153), FcTo0: uint8(0x6F), FcTo1: uint8(0x65)},
	{FcFrom: uint16(0x0154), FcTo0: uint8(0x52)},
	{FcFrom: uint16(0x0155), FcTo0: uint8(0x72)},
	{FcFrom: uint16(0x0156), FcTo0: uint8(0x52)},
	{FcFrom: uint16(0x0157), FcTo0: uint8(0x72)},
	{FcFrom: uint16(0x0158), FcTo0: uint8(0x52)},
	{FcFrom: uint16(0x0159), FcTo0: uint8(0x72)},
	{FcFrom: uint16(0x015A), FcTo0: uint8(0x53)},
	{FcFrom: uint16(0x015B), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x015C), FcTo0: uint8(0x53), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x015D), FcTo0: uint8(0x73), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x015E), FcTo0: uint8(0x53)},
	{FcFrom: uint16(0x015F), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x0160), FcTo0: uint8(0x53)},
	{FcFrom: uint16(0x0161), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x0162), FcTo0: uint8(0x54)},
	{FcFrom: uint16(0x0163), FcTo0: uint8(0x74)},
	{FcFrom: uint16(0x0164), FcTo0: uint8(0x54)},
	{FcFrom: uint16(0x0165), FcTo0: uint8(0x74)},
	{FcFrom: uint16(0x0166), FcTo0: uint8(0x54)},
	{FcFrom: uint16(0x0167), FcTo0: uint8(0x74)},
	{FcFrom: uint16(0x0168), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x0169), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x016A), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x016B), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x016C), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x016D), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x016E), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x016F), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x0170), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x0171), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x0172), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x0173), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x0174), FcTo0: uint8(0x57)},
	{FcFrom: uint16(0x0175), FcTo0: uint8(0x77)},
	{FcFrom: uint16(0x0176), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x0177), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x0178), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x0179), FcTo0: uint8(0x5A)},
	{FcFrom: uint16(0x017A), FcTo0: uint8(0x7A)},
	{FcFrom: uint16(0x017B), FcTo0: uint8(0x5A)},
	{FcFrom: uint16(0x017C), FcTo0: uint8(0x7A)},
	{FcFrom: uint16(0x017D), FcTo0: uint8(0x5A)},
	{FcFrom: uint16(0x017E), FcTo0: uint8(0x7A)},
	{FcFrom: uint16(0x017F), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x0192), FcTo0: uint8(0x66)},
	{FcFrom: uint16(0x0218), FcTo0: uint8(0x53)},
	{FcFrom: uint16(0x0219), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x021A), FcTo0: uint8(0x54)},
	{FcFrom: uint16(0x021B), FcTo0: uint8(0x74)},
	{FcFrom: uint16(0x0386), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x0388), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0389), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x038A), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x038C), FcTo0: uint8(0x4f)},
	{FcFrom: uint16(0x038E), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x038F), FcTo0: uint8(0x4f)},
	{FcFrom: uint16(0x0390), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x0391), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x0392), FcTo0: uint8(0x42)},
	{FcFrom: uint16(0x0393), FcTo0: uint8(0x47)},
	{FcFrom: uint16(0x0394), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x0395), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0396), FcTo0: uint8(0x5a)},
	{FcFrom: uint16(0x0397), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x0398), FcTo0: uint8(0x54), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0399), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x039A), FcTo0: uint8(0x4b)},
	{FcFrom: uint16(0x039B), FcTo0: uint8(0x4c)},
	{FcFrom: uint16(0x039C), FcTo0: uint8(0x4d)},
	{FcFrom: uint16(0x039D), FcTo0: uint8(0x4e)},
	{FcFrom: uint16(0x039E), FcTo0: uint8(0x58)},
	{FcFrom: uint16(0x039F), FcTo0: uint8(0x4f)},
	{FcFrom: uint16(0x03A0), FcTo0: uint8(0x50)},
	{FcFrom: uint16(0x03A1), FcTo0: uint8(0x52)},
	{FcFrom: uint16(0x03A3), FcTo0: uint8(0x53)},
	{FcFrom: uint16(0x03A4), FcTo0: uint8(0x54)},
	{FcFrom: uint16(0x03A5), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x03A6), FcTo0: uint8(0x46)},
	{FcFrom: uint16(0x03A7), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x03A8), FcTo0: uint8(0x50), FcTo1: uint8(0x73)},
	{FcFrom: uint16(0x03A9), FcTo0: uint8(0x4f)},
	{FcFrom: uint16(0x03AA), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x03AB), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x03AC), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x03AD), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x03AE), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x03AF), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x03B1), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x03B2), FcTo0: uint8(0x62)},
	{FcFrom: uint16(0x03B3), FcTo0: uint8(0x67)},
	{FcFrom: uint16(0x03B4), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x03B5), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x03B6), FcTo0: uint8(0x7a)},
	{FcFrom: uint16(0x03B7), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x03B8), FcTo0: uint8(0x74), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x03B9), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x03BA), FcTo0: uint8(0x6b)},
	{FcFrom: uint16(0x03BB), FcTo0: uint8(0x6c)},
	{FcFrom: uint16(0x03BC), FcTo0: uint8(0x6d)},
	{FcFrom: uint16(0x03BD), FcTo0: uint8(0x6e)},
	{FcFrom: uint16(0x03BE), FcTo0: uint8(0x78)},
	{FcFrom: uint16(0x03BF), FcTo0: uint8(0x6f)},
	{FcFrom: uint16(0x03C0), FcTo0: uint8(0x70)},
	{FcFrom: uint16(0x03C1), FcTo0: uint8(0x72)},
	{FcFrom: uint16(0x03C3), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x03C4), FcTo0: uint8(0x74)},
	{FcFrom: uint16(0x03C5), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x03C6), FcTo0: uint8(0x66)},
	{FcFrom: uint16(0x03C7), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x03C8), FcTo0: uint8(0x70), FcTo1: uint8(0x73)},
	{FcFrom: uint16(0x03C9), FcTo0: uint8(0x6f)},
	{FcFrom: uint16(0x03CA), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x03CB), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x03CC), FcTo0: uint8(0x6f)},
	{FcFrom: uint16(0x03CD), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x03CE), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x0400), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0401), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0402), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x0403), FcTo0: uint8(0x47)},
	{FcFrom: uint16(0x0404), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0405), FcTo0: uint8(0x5a)},
	{FcFrom: uint16(0x0406), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x0407), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x0408), FcTo0: uint8(0x4a)},
	{FcFrom: uint16(0x0409), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x040A), FcTo0: uint8(0x4e)},
	{FcFrom: uint16(0x040B), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x040C), FcTo0: uint8(0x4b)},
	{FcFrom: uint16(0x040D), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x040E), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x040F), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x0410), FcTo0: uint8(0x41)},
	{FcFrom: uint16(0x0411), FcTo0: uint8(0x42)},
	{FcFrom: uint16(0x0412), FcTo0: uint8(0x56)},
	{FcFrom: uint16(0x0413), FcTo0: uint8(0x47)},
	{FcFrom: uint16(0x0414), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x0415), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x0416), FcTo0: uint8(0x5a), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0417), FcTo0: uint8(0x5a)},
	{FcFrom: uint16(0x0418), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x0419), FcTo0: uint8(0x49)},
	{FcFrom: uint16(0x041A), FcTo0: uint8(0x4b)},
	{FcFrom: uint16(0x041B), FcTo0: uint8(0x4c)},
	{FcFrom: uint16(0x041C), FcTo0: uint8(0x4d)},
	{FcFrom: uint16(0x041D), FcTo0: uint8(0x4e)},
	{FcFrom: uint16(0x041E), FcTo0: uint8(0x4f)},
	{FcFrom: uint16(0x041F), FcTo0: uint8(0x50)},
	{FcFrom: uint16(0x0420), FcTo0: uint8(0x52)},
	{FcFrom: uint16(0x0421), FcTo0: uint8(0x53)},
	{FcFrom: uint16(0x0422), FcTo0: uint8(0x54)},
	{FcFrom: uint16(0x0423), FcTo0: uint8(0x55)},
	{FcFrom: uint16(0x0424), FcTo0: uint8(0x46)},
	{FcFrom: uint16(0x0425), FcTo0: uint8(0x4b), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0426), FcTo0: uint8(0x54), FcTo1: uint8(0x63)},
	{FcFrom: uint16(0x0427), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0428), FcTo0: uint8(0x53), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0429), FcTo0: uint8(0x53), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)},
	{FcFrom: uint16(0x042A), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x042B), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x042C), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x042D), FcTo0: uint8(0x45)},
	{FcFrom: uint16(0x042E), FcTo0: uint8(0x49), FcTo1: uint8(0x75)},
	{FcFrom: uint16(0x042F), FcTo0: uint8(0x49), FcTo1: uint8(0x61)},
	{FcFrom: uint16(0x0430), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x0431), FcTo0: uint8(0x62)},
	{FcFrom: uint16(0x0432), FcTo0: uint8(0x76)},
	{FcFrom: uint16(0x0433), FcTo0: uint8(0x67)},
	{FcFrom: uint16(0x0434), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x0435), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x0436), FcTo0: uint8(0x7a), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0437), FcTo0: uint8(0x7a)},
	{FcFrom: uint16(0x0438), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x0439), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x043A), FcTo0: uint8(0x6b)},
	{FcFrom: uint16(0x043B), FcTo0: uint8(0x6c)},
	{FcFrom: uint16(0x043C), FcTo0: uint8(0x6d)},
	{FcFrom: uint16(0x043D), FcTo0: uint8(0x6e)},
	{FcFrom: uint16(0x043E), FcTo0: uint8(0x6f)},
	{FcFrom: uint16(0x043F), FcTo0: uint8(0x70)},
	{FcFrom: uint16(0x0440), FcTo0: uint8(0x72)},
	{FcFrom: uint16(0x0441), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x0442), FcTo0: uint8(0x74)},
	{FcFrom: uint16(0x0443), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x0444), FcTo0: uint8(0x66)},
	{FcFrom: uint16(0x0445), FcTo0: uint8(0x6b), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0446), FcTo0: uint8(0x74), FcTo1: uint8(0x63)},
	{FcFrom: uint16(0x0447), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0448), FcTo0: uint8(0x73), FcTo1: uint8(0x68)},
	{FcFrom: uint16(0x0449), FcTo0: uint8(0x73), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)},
	{FcFrom: uint16(0x044A), FcTo0: uint8(0x61)},
	{FcFrom: uint16(0x044B), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x044C), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0x044D), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x044E), FcTo0: uint8(0x69), FcTo1: uint8(0x75)},
	{FcFrom: uint16(0x044F), FcTo0: uint8(0x69), FcTo1: uint8(0x61)},
	{FcFrom: uint16(0x0450), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x0451), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x0452), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x0453), FcTo0: uint8(0x67)},
	{FcFrom: uint16(0x0454), FcTo0: uint8(0x65)},
	{FcFrom: uint16(0x0455), FcTo0: uint8(0x7a)},
	{FcFrom: uint16(0x0456), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x0457), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x0458), FcTo0: uint8(0x6a)},
	{FcFrom: uint16(0x0459), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x045A), FcTo0: uint8(0x6e)},
	{FcFrom: uint16(0x045B), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x045C), FcTo0: uint8(0x6b)},
	{FcFrom: uint16(0x045D), FcTo0: uint8(0x69)},
	{FcFrom: uint16(0x045E), FcTo0: uint8(0x75)},
	{FcFrom: uint16(0x045F), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x1E02), FcTo0: uint8(0x42)},
	{FcFrom: uint16(0x1E03), FcTo0: uint8(0x62)},
	{FcFrom: uint16(0x1E0A), FcTo0: uint8(0x44)},
	{FcFrom: uint16(0x1E0B), FcTo0: uint8(0x64)},
	{FcFrom: uint16(0x1E1E), FcTo0: uint8(0x46)},
	{FcFrom: uint16(0x1E1F), FcTo0: uint8(0x66)},
	{FcFrom: uint16(0x1E40), FcTo0: uint8(0x4D)},
	{FcFrom: uint16(0x1E41), FcTo0: uint8(0x6D)},
	{FcFrom: uint16(0x1E56), FcTo0: uint8(0x50)},
	{FcFrom: uint16(0x1E57), FcTo0: uint8(0x70)},
	{FcFrom: uint16(0x1E60), FcTo0: uint8(0x53)},
	{FcFrom: uint16(0x1E61), FcTo0: uint8(0x73)},
	{FcFrom: uint16(0x1E6A), FcTo0: uint8(0x54)},
	{FcFrom: uint16(0x1E6B), FcTo0: uint8(0x74)},
	{FcFrom: uint16(0x1E80), FcTo0: uint8(0x57)},
	{FcFrom: uint16(0x1E81), FcTo0: uint8(0x77)},
	{FcFrom: uint16(0x1E82), FcTo0: uint8(0x57)},
	{FcFrom: uint16(0x1E83), FcTo0: uint8(0x77)},
	{FcFrom: uint16(0x1E84), FcTo0: uint8(0x57)},
	{FcFrom: uint16(0x1E85), FcTo0: uint8(0x77)},
	{FcFrom: uint16(0x1EF2), FcTo0: uint8(0x59)},
	{FcFrom: uint16(0x1EF3), FcTo0: uint8(0x79)},
	{FcFrom: uint16(0xFB00), FcTo0: uint8(0x66), FcTo1: uint8(0x66)},
	{FcFrom: uint16(0xFB01), FcTo0: uint8(0x66), FcTo1: uint8(0x69)},
	{FcFrom: uint16(0xFB02), FcTo0: uint8(0x66), FcTo1: uint8(0x6C)},
	{FcFrom: uint16(0xFB05), FcTo0: uint8(0x73), FcTo1: uint8(0x74)},
	{FcFrom: uint16(0xFB06), FcTo0: uint8(0x73), FcTo1: uint8(0x74)},
}

func spellfixFindTranslit(tls *libc.TLS, c int32, pxTop uintptr) uintptr {
	*(*int32)(unsafe.Pointer(pxTop)) = int32(uint32(unsafe.Sizeof(translit))/uint32(unsafe.Sizeof(Transliteration{})) - uint32(1))
	return uintptr(unsafe.Pointer(&translit))
}

func transliterate(tls *libc.TLS, zIn uintptr, nIn int32) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn*4+1))
	var c int32

	var nOut int32
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	nOut = 0
	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp)))
		nIn = nIn - *(*int32)(unsafe.Pointer(bp))
		if c <= 127 {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = uint8(c)
		} else {
			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4)) >= xBtm {
				x = (*(*int32)(unsafe.Pointer(bp + 4)) + xBtm) / 2
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo0
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo1
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo2
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo3
							}
						}
					}
					c = 0
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4)) = x - 1
				} else {
					xBtm = x + 1
				}
			}
			if c != 0 {
				*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = uint8('?')
			}
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

func translen_to_charlen(tls *libc.TLS, zIn uintptr, nIn int32, nTrans int32) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var c int32

	var nOut int32
	var nChar int32

	i = libc.AssignInt32(&nOut, 0)
	for nChar = 0; i < nIn && nOut < nTrans; nChar++ {
		c = utf8Read(tls, zIn+uintptr(i), nIn-i, bp)
		i = i + *(*int32)(unsafe.Pointer(bp))

		nOut++
		if c >= 128 {
			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4)) >= xBtm {
				x = (*(*int32)(unsafe.Pointer(bp + 4)) + xBtm) / 2
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						nOut++
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							nOut++
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								nOut++
							}
						}
					}
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4)) = x - 1
				} else {
					xBtm = x + 1
				}
			}
		}
	}

	return nChar
}

func transliterateSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var zOut uintptr = transliterate(tls, zIn, nIn)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func scriptCodeSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var c int32

	var scriptMask int32 = 0
	var res int32
	var seenDigit int32 = 0

	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp)))
		nIn = nIn - *(*int32)(unsafe.Pointer(bp))
		if c < 0x02af {
			if c >= 0x80 || int32(midClass[c&0x7f]) < CCLASS_DIGIT {
				scriptMask = scriptMask | SCRIPT_LATIN
			} else if c >= '0' && c <= '9' {
				seenDigit = 1
			}
		} else if c >= 0x0400 && c <= 0x04ff {
			scriptMask = scriptMask | SCRIPT_CYRILLIC
		} else if c >= 0x0386 && c <= 0x03ce {
			scriptMask = scriptMask | SCRIPT_GREEK
		} else if c >= 0x0590 && c <= 0x05ff {
			scriptMask = scriptMask | SCRIPT_HEBREW
		} else if c >= 0x0600 && c <= 0x06ff {
			scriptMask = scriptMask | SCRIPT_ARABIC
		}
	}
	if scriptMask == 0 && seenDigit != 0 {
		scriptMask = SCRIPT_LATIN
	}
	switch scriptMask {
	case 0:
		res = 999
		break
	case SCRIPT_LATIN:
		res = 215
		break
	case SCRIPT_CYRILLIC:
		res = 220
		break
	case SCRIPT_GREEK:
		res = 200
		break
	case SCRIPT_HEBREW:
		res = 125
		break
	case SCRIPT_ARABIC:
		res = 160
		break
	default:
		res = 998
		break
	}
	sqlite3.Xsqlite3_result_int(tls, context, res)
}

type spellfix1_vtab1 = struct {
	Fbase       sqlite3_vtab
	Fdb         uintptr
	FzDbName    uintptr
	FzTableName uintptr
	FzCostTable uintptr
	FpConfig3   uintptr
}

type spellfix1_vtab = spellfix1_vtab1
type spellfix1_cursor1 = struct {
	Fbase      sqlite3_vtab_cursor
	FpVTab     uintptr
	FzPattern  uintptr
	FidxNum    int32
	FnRow      int32
	FnAlloc    int32
	FiRow      int32
	FiLang     int32
	FiTop      int32
	FiScope    int32
	FnSearch   int32
	FpFullScan uintptr
	Fa         uintptr
}

type spellfix1_cursor = spellfix1_cursor1

type spellfix1_row = struct {
	FiRowid    sqlite3_int64
	FzWord     uintptr
	FiRank     int32
	FiDistance int32
	FiScore    int32
	FiMatchlen int32
	FzHash     [32]int8
}

func spellfix1DbExec(tls *libc.TLS, pRc uintptr, db uintptr, zFormat uintptr, va uintptr) {
	var ap va_list
	_ = ap
	var zSql uintptr
	if *(*int32)(unsafe.Pointer(pRc)) != 0 {
		return
	}
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	if zSql == uintptr(0) {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
}

func spellfix1Uninit(tls *libc.TLS, isDestroy int32, pVTab uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr = pVTab
	*(*int32)(unsafe.Pointer(bp + 16)) = SQLITE_OK
	if isDestroy != 0 {
		var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
		spellfix1DbExec(tls, bp+16, db, ts+7544,
			libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
	}
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
		sqlite3.Xsqlite3_free(tls, p)
	}
	return *(*int32)(unsafe.Pointer(bp + 16))
}

func spellfix1Disconnect(tls *libc.TLS, pVTab uintptr) int32 {
	return spellfix1Uninit(tls, 0, pVTab)
}

func spellfix1Destroy(tls *libc.TLS, pVTab uintptr) int32 {
	return spellfix1Uninit(tls, 1, pVTab)
}

func spellfix1Dequote(tls *libc.TLS, zIn uintptr) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr
	var i int32
	var j int32
	var c int8
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zIn)))), uint32(X_CTYPE_S)) != 0 {
		zIn++
	}
	zOut = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zIn))
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	i = int32(libc.Xstrlen(tls, zOut))
	*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = int8(0)
	c = *(*int8)(unsafe.Pointer(zOut))
	if int32(c) == '\'' || int32(c) == '"' {
		i = 1
		j = 0
		for ; 1 != 0; i++ {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zOut + uintptr(i)))
			if int32(*(*int8)(unsafe.Pointer(zOut + uintptr(i)))) == int32(c) {
				if int32(*(*int8)(unsafe.Pointer(zOut + uintptr(i+1)))) == int32(c) {
					i++
				} else {
					*(*int8)(unsafe.Pointer(zOut + uintptr(j-1))) = int8(0)
					break
				}
			}
		}
	}
	return zOut
}

func spellfix1Init(tls *libc.TLS, isCreate int32, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var pNew uintptr = uintptr(0)

	var zDbName uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*4))
	var zTableName uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	var nDbName int32
	*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_OK
	var i int32

	nDbName = int32(libc.Xstrlen(tls, zDbName))
	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(spellfix1_vtab{}))+uint32(nDbName)+uint32(1)))
	if pNew == uintptr(0) {
		*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_NOMEM
	} else {
		libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(spellfix1_vtab{})))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName = pNew + 1*32
		libc.Xmemcpy(tls, (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName, zDbName, uint32(nDbName+1))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zTableName))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).Fdb = db
		if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_NOMEM
		} else {
			sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
			*(*int32)(unsafe.Pointer(bp + 56)) = sqlite3.Xsqlite3_declare_vtab(tls, db,
				ts+7581)
		}
		if *(*int32)(unsafe.Pointer(bp + 56)) == SQLITE_OK && isCreate != 0 {
			spellfix1DbExec(tls, bp+56, db,
				ts+7735,
				libc.VaList(bp+8, zDbName, zTableName))
			spellfix1DbExec(tls, bp+56, db,
				ts+7869,
				libc.VaList(bp+24, zDbName, zTableName, zTableName))
		}
		for i = 3; *(*int32)(unsafe.Pointer(bp + 56)) == SQLITE_OK && i < argc; i++ {
			if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), ts+7954, uint32(16)) == 0 && (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0) {
				(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable = spellfix1Dequote(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))+16)
				if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_NOMEM
				}
				continue
			}
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+7971, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
			*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_ERROR
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 56)) != 0 && pNew != 0 {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = uintptr(0)
		spellfix1Uninit(tls, 0, pNew)
	} else {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = pNew
	}
	return *(*int32)(unsafe.Pointer(bp + 56))
}

func spellfix1Connect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 {
	return spellfix1Init(tls, 0, db, pAux, argc, argv, ppVTab, pzErr)
}

func spellfix1Create(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 {
	return spellfix1Init(tls, 1, db, pAux, argc, argv, ppVTab, pzErr)
}

func spellfix1ResetCursor(tls *libc.TLS, pCur uintptr) {
	var i int32
	for i = 0; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(i)*60)).FzWord)
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch = 0
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan = uintptr(0)
	}
}

func spellfix1ResizeCursor(tls *libc.TLS, pCur uintptr, N int32) {
	var aNew uintptr

	aNew = sqlite3.Xsqlite3_realloc64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, uint64(uint32(unsafe.Sizeof(spellfix1_row{}))*uint32(N)))
	if aNew == uintptr(0) && N > 0 {
		spellfix1ResetCursor(tls, pCur)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = 0
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = uintptr(0)
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = N
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = aNew
	}
}

func spellfix1Close(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func spellfix1BestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var iPlan int32 = 0
	var iLangTerm int32 = -1
	var iTopTerm int32 = -1
	var iScopeTerm int32 = -1
	var iDistTerm int32 = -1
	var iRowidTerm int32 = -1
	var i int32
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}

		if iPlan&SPELLFIX_IDXNUM_MATCH == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_WORD &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			iPlan = iPlan | SPELLFIX_IDXNUM_MATCH
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}

		if iPlan&SPELLFIX_IDXNUM_LANGID == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_LANGID &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_LANGID
			iLangTerm = i
		}

		if iPlan&SPELLFIX_IDXNUM_TOP == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_TOP &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_TOP
			iTopTerm = i
		}

		if iPlan&SPELLFIX_IDXNUM_SCOPE == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_SCOPE &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_SCOPE
			iScopeTerm = i
		}

		if iPlan&(0x10|0x20) == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_DISTANCE &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE) {
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
				iPlan = iPlan | SPELLFIX_IDXNUM_DISTLT
			} else {
				iPlan = iPlan | SPELLFIX_IDXNUM_DISTLE
			}
			iDistTerm = i
		}

		if iPlan&SPELLFIX_IDXNUM_ROWID == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_ROWID
			iRowidTerm = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if iPlan&SPELLFIX_IDXNUM_MATCH != 0 {
		var idx int32 = 2
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
		if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
			(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == SPELLFIX_COL_SCORE &&
			int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
		}
		if iPlan&SPELLFIX_IDXNUM_LANGID != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).Fomit = uint8(1)
		}
		if iPlan&SPELLFIX_IDXNUM_TOP != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).Fomit = uint8(1)
		}
		if iPlan&SPELLFIX_IDXNUM_SCOPE != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).Fomit = uint8(1)
		}
		if iPlan&(0x10|0x20) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).Fomit = uint8(1)
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e5
	} else if iPlan&SPELLFIX_IDXNUM_ROWID != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = SPELLFIX_IDXNUM_ROWID
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e50
	}
	return SQLITE_OK
}

func spellfix1Open(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(spellfix1_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(spellfix1_cursor{})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func spellfix1Score(tls *libc.TLS, iDistance int32, iRank int32) int32 {
	var iLog2 int32
	iLog2 = 0
__1:
	if !(iRank > 0) {
		goto __3
	}
	{
	}
	goto __2
__2:
	iLog2++
	iRank >>= 1
	goto __1
	goto __3
__3:
	;
	return iDistance + 32 - iLog2
}

func spellfix1RowCompare(tls *libc.TLS, A uintptr, B uintptr) int32 {
	var a uintptr = A
	var b uintptr = B
	return (*spellfix1_row)(unsafe.Pointer(a)).FiScore - (*spellfix1_row)(unsafe.Pointer(b)).FiScore
}

type MatchQuery1 = struct {
	FpCur       uintptr
	FpStmt      uintptr
	FzHash      [32]int8
	FzPattern   uintptr
	FnPattern   int32
	FpMatchStr3 uintptr
	FpConfig3   uintptr
	FpLang      uintptr
	FiLang      int32
	FiScope     int32
	FiMaxDist   int32
	Frc         int32
	FnRun       int32
	FazPrior    [1][32]int8
}

type MatchQuery = MatchQuery1

func spellfix1RunQuery(tls *libc.TLS, p uintptr, zQuery uintptr, nQuery int32) {
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var zK1 uintptr
	var zWord uintptr
	var iDist int32
	var iRank int32
	var iScore int32
	var iWorst int32 = 0
	var idx int32
	var idxWorst int32 = -1
	var i int32
	var iScope int32 = (*MatchQuery)(unsafe.Pointer(p)).FiScope
	var pCur uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpCur
	var pStmt uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpStmt

	var zClass uintptr
	var nClass int32
	var rc int32

	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0) || (*MatchQuery)(unsafe.Pointer(p)).Frc != 0 {
		return
	}
	zClass = phoneticHash(tls, zQuery, nQuery)
	if zClass == uintptr(0) {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
		return
	}
	nClass = int32(libc.Xstrlen(tls, zClass))
	if nClass > SPELLFIX_MX_HASH-2 {
		nClass = SPELLFIX_MX_HASH - 2
		*(*int8)(unsafe.Pointer(zClass + uintptr(nClass))) = int8(0)
	}
	if nClass <= iScope {
		if nClass > 2 {
			iScope = nClass - 1
		} else {
			iScope = nClass
		}
	}
	libc.Xmemcpy(tls, bp+8, zClass, uint32(iScope))
	sqlite3.Xsqlite3_free(tls, zClass)
	*(*int8)(unsafe.Pointer(bp + 8 + uintptr(iScope))) = int8(0)
	libc.Xmemcpy(tls, bp+40, bp+8, uint32(iScope))
	*(*int8)(unsafe.Pointer(bp + 40 + uintptr(iScope))) = int8('Z')
	*(*int8)(unsafe.Pointer(bp + 40 + uintptr(iScope+1))) = int8(0)

	libc.Xmemcpy(tls, p+80+uintptr(libc.PostIncInt32(&(*MatchQuery)(unsafe.Pointer(p)).FnRun, 1))*32, bp+8, uint32(iScope+1))
	if sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, bp+8, -1, uintptr(0)) == SQLITE_NOMEM ||
		sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, bp+40, -1, uintptr(0)) == SQLITE_NOMEM {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
		return
	}
	for sqlite3.Xsqlite3_step(tls, pStmt) == SQLITE_ROW {
		*(*int32)(unsafe.Pointer(bp + 72)) = -1
		iRank = sqlite3.Xsqlite3_column_int(tls, pStmt, 2)
		if (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3 != 0 {
			var nWord int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 1)
			zWord = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			iDist = editDist3Core(tls, (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3, zWord, nWord, (*MatchQuery)(unsafe.Pointer(p)).FpLang, bp+72)
		} else {
			zK1 = sqlite3.Xsqlite3_column_text(tls, pStmt, 3)
			if zK1 == uintptr(0) {
				continue
			}
			iDist = editdist1(tls, (*MatchQuery)(unsafe.Pointer(p)).FzPattern, zK1, uintptr(0))
		}
		if iDist < 0 {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
			break
		}
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch++

		if (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist >= 0 {
			if iDist > (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist {
				continue
			}
			if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc && (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum&SPELLFIX_IDXNUM_TOP == 0 {
				spellfix1ResizeCursor(tls, pCur, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc*2+10)
				if (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0) {
					break
				}
			}
		}

		iScore = spellfix1Score(tls, iDist, iRank)
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			idx = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
		} else if iScore < iWorst {
			idx = idxWorst
			sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*60)).FzWord)
		} else {
			continue
		}

		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*60)).FzWord = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pStmt, 1)))
		if (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*60)).FzWord == uintptr(0) {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
			break
		}
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*60)).FiRowid = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*60)).FiRank = iRank
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*60)).FiDistance = iDist
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*60)).FiScore = iScore
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*60)).FiMatchlen = *(*int32)(unsafe.Pointer(bp + 72))
		libc.Xmemcpy(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*60+28, bp+8, uint32(iScope+1))
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow++
		}
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow == (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			iWorst = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa)).FiScore
			idxWorst = 0
			for i = 1; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
				iScore = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(i)*60)).FiScore
				if iWorst < iScore {
					iWorst = iScore
					idxWorst = i
				}
			}
		}
	}
	rc = sqlite3.Xsqlite3_reset(tls, pStmt)
	if rc != 0 {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = rc
	}
}

func spellfix1FilterForMatch(tls *libc.TLS, pCur uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var idxNum int32
	var zMatchThis uintptr
	var pMatchStr3 uintptr
	var zPattern uintptr
	var nPattern int32
	var iLimit int32
	var iScope int32
	var iLang int32
	var zSql uintptr

	var rc int32
	var idx int32
	var p uintptr

	idxNum = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	pMatchStr3 = uintptr(0)
	iLimit = 20
	iScope = 3
	iLang = 0
	*(*uintptr)(unsafe.Pointer(bp + 136)) = uintptr(0)
	idx = 1
	p = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab

	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable != uintptr(0) && (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0)) {
		goto __1
	}
	(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0)) {
		goto __2
	}
	return SQLITE_NOMEM
__2:
	;
	libc.Xmemset(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, 0, uint32(unsafe.Sizeof(EditDist3Config{})))
	rc = editDist3ConfigLoad(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
	if !(rc != 0) {
		goto __3
	}
	return rc
__3:
	;
__1:
	;
	libc.Xmemset(tls, bp+24, 0, uint32(unsafe.Sizeof(MatchQuery{})))
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiScope = 3
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiMaxDist = -1

	if !(idxNum&2 != 0) {
		goto __4
	}
	iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
__4:
	;
	if !(idxNum&4 != 0) {
		goto __5
	}
	iLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
	if !(iLimit < 1) {
		goto __6
	}
	iLimit = 1
__6:
	;
__5:
	;
	if !(idxNum&8 != 0) {
		goto __7
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiScope = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).FiScope < 1) {
		goto __8
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiScope = 1
__8:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).FiScope > SPELLFIX_MX_HASH-2) {
		goto __9
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiScope = SPELLFIX_MX_HASH - 2
__9:
	;
__7:
	;
	if !(idxNum&(16|32) != 0) {
		goto __10
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiMaxDist = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*4)))
	if !(idxNum&16 != 0) {
		goto __11
	}
	(*MatchQuery)(unsafe.Pointer(bp+24)).FiMaxDist--
__11:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).FiMaxDist < 0) {
		goto __12
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiMaxDist = 0
__12:
	;
__10:
	;
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, iLimit)
	zMatchThis = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if !(zMatchThis == uintptr(0)) {
		goto __13
	}
	return SQLITE_OK
__13:
	;
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 != 0) {
		goto __14
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FpLang = editDist3FindLang(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, iLang)
	pMatchStr3 = editDist3FromStringNew(tls, (*MatchQuery)(unsafe.Pointer(bp+24)).FpLang, zMatchThis, -1)
	if !(pMatchStr3 == uintptr(0)) {
		goto __16
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).Frc = SQLITE_NOMEM
	goto filter_exit
__16:
	;
	goto __15
__14:
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FpLang = uintptr(0)
__15:
	;
	zPattern = transliterate(tls, zMatchThis, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv))))
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern = zPattern
	if !(zPattern == uintptr(0)) {
		goto __17
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).Frc = SQLITE_NOMEM
	goto filter_exit
__17:
	;
	nPattern = int32(libc.Xstrlen(tls, zPattern))
	if !(int32(*(*int8)(unsafe.Pointer(zPattern + uintptr(nPattern-1)))) == '*') {
		goto __18
	}
	nPattern--
__18:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+8005,
		libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, iLang))
	if !(zSql == uintptr(0)) {
		goto __19
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24)).Frc = SQLITE_NOMEM
	*(*uintptr)(unsafe.Pointer(bp + 136)) = uintptr(0)
	goto filter_exit
__19:
	;
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, bp+136, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FpCur = pCur
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FpStmt = *(*uintptr)(unsafe.Pointer(bp + 136))
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FzPattern = zPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FnPattern = nPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FpMatchStr3 = pMatchStr3
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24)).Frc = rc
	(*MatchQuery)(unsafe.Pointer(bp + 24)).FpConfig3 = (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).Frc == SQLITE_OK) {
		goto __20
	}
	spellfix1RunQuery(tls, bp+24, zPattern, nPattern)
__20:
	;
	if !((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa != 0) {
		goto __21
	}
	libc.Xqsort(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, uint32((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow), uint32(unsafe.Sizeof(spellfix1_row{})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{spellfix1RowCompare})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop = iLimit
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope = iScope
	goto __22
__21:
	(*MatchQuery)(unsafe.Pointer(bp + 24)).Frc = SQLITE_NOMEM
__22:
	;
filter_exit:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 136)))
	editDist3FromStringDelete(tls, pMatchStr3)
	return (*MatchQuery)(unsafe.Pointer(bp + 24)).Frc
}

func spellfix1FilterForFullScan(tls *libc.TLS, pCur uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	var idxNum int32 = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	var zSql uintptr
	var pVTab uintptr = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab
	spellfix1ResetCursor(tls, pCur)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+8105,
		libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzTableName,
			func() uintptr {
				if idxNum&64 != 0 {
					return ts + 8164
				}
				return ts + 584
			}()))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).Fdb, zSql, -1, pCur+44, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc == SQLITE_OK && idxNum&64 != 0 {
		rc = sqlite3.Xsqlite3_bind_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 1, *(*uintptr)(unsafe.Pointer(argv)))
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = libc.AssignPtrInt32(pCur+24, 0)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		if rc == SQLITE_ROW {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = -1
			rc = SQLITE_OK
		}
		if rc == SQLITE_DONE {
			rc = SQLITE_OK
		}
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	}
	return rc
}

func spellfix1Filter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = cur
	var rc int32
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum = idxNum
	if idxNum&1 != 0 {
		rc = spellfix1FilterForMatch(tls, pCur, argc, argv)
	} else {
		rc = spellfix1FilterForFullScan(tls, pCur, argc, argv)
	}
	return rc
}

func spellfix1Next(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	var rc int32 = SQLITE_OK
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow {
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
			rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
			if rc != SQLITE_ROW {
				(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
			}
			if rc == SQLITE_ROW || rc == SQLITE_DONE {
				rc = SQLITE_OK
			}
		} else {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow++
		}
	}
	return rc
}

func spellfix1Eof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow)
}

func spellfix1Column(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		if i <= SPELLFIX_COL_LANGID {
			sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, i))
		} else {
			sqlite3.Xsqlite3_result_null(tls, ctx)
		}
		return SQLITE_OK
	}
	switch i {
	case SPELLFIX_COL_WORD:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60)).FzWord, -1, uintptr(0))
			break

		}
	case SPELLFIX_COL_RANK:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60)).FiRank)
			break

		}
	case SPELLFIX_COL_DISTANCE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60)).FiDistance)
			break

		}
	case SPELLFIX_COL_LANGID:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang)
			break

		}
	case SPELLFIX_COL_SCORE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60)).FiScore)
			break

		}
	case SPELLFIX_COL_MATCHLEN:
		{
			*(*int32)(unsafe.Pointer(bp)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60)).FiMatchlen
			if *(*int32)(unsafe.Pointer(bp)) < 0 {
				var nPattern int32 = int32(libc.Xstrlen(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern))
				var zWord uintptr = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60)).FzWord
				var nWord int32 = int32(libc.Xstrlen(tls, zWord))

				if nPattern > 0 && int32(*(*int8)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern + uintptr(nPattern-1)))) == '*' {
					var zTranslit uintptr
					var res int32
					zTranslit = transliterate(tls, zWord, nWord)
					if !(zTranslit != 0) {
						return SQLITE_NOMEM
					}
					res = editdist1(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern, zTranslit, bp)
					sqlite3.Xsqlite3_free(tls, zTranslit)
					if res < 0 {
						return SQLITE_NOMEM
					}
					*(*int32)(unsafe.Pointer(bp)) = translen_to_charlen(tls, zWord, nWord, *(*int32)(unsafe.Pointer(bp)))
				} else {
					*(*int32)(unsafe.Pointer(bp)) = utf8Charlen(tls, zWord, nWord)
				}
			}

			sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(bp)))
			break

		}
	case SPELLFIX_COL_PHONEHASH:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60+28, -1, uintptr(0))
			break

		}
	case SPELLFIX_COL_TOP:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop)
			break

		}
	case SPELLFIX_COL_SCOPE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope)
			break

		}
	case SPELLFIX_COL_SRCHCNT:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch)
			break

		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	}
	return SQLITE_OK
}

func spellfix1Rowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 4)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*60)).FiRowid
	}
	return SQLITE_OK
}

func spellfix1GetConflict(tls *libc.TLS, db uintptr) uintptr {
	var eConflict int32 = sqlite3.Xsqlite3_vtab_on_conflict(tls, db)

	return azConflict[eConflict-1]
}

var azConflict = [5]uintptr{
	ts + 8179, ts + 8188, ts + 8195, ts + 8195, ts + 8201,
}

func spellfix1Update(tls *libc.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 {
	bp := tls.Alloc(284)
	defer tls.Free(284)

	*(*int32)(unsafe.Pointer(bp + 280)) = SQLITE_OK
	var rowid sqlite3_int64
	var newRowid sqlite3_int64
	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb

	if argc == 1 {
		rowid = libc.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
		spellfix1DbExec(tls, bp+280, db,
			ts+8209,
			libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, rowid))
	} else {
		var zWord uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		var nWord int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		var iLang int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4)))
		var iRank int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
		var zSoundslike uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 12*4)))
		var nSoundslike int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 12*4)))
		var zK1 uintptr
		var zK2 uintptr
		var i int32
		var c int8
		var zConflict uintptr = spellfix1GetConflict(tls, db)

		if zWord == uintptr(0) {
			var zCmd uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 13*4)))
			if zCmd == uintptr(0) {
				(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+8252,
					libc.VaList(bp+24, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
				return SQLITE_CONSTRAINT | int32(5)<<8
			}
			if libc.Xstrcmp(tls, zCmd, ts+8288) == 0 {
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				return SQLITE_OK
			}
			if libc.Xstrncmp(tls, zCmd, ts+7954, uint32(16)) == 0 {
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = spellfix1Dequote(tls, zCmd+uintptr(16))
				if (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable == uintptr(0) {
					return SQLITE_NOMEM
				}
				if int32(*(*int8)(unsafe.Pointer((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable))) == 0 || sqlite3.Xsqlite3_stricmp(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable, ts+8294) == 0 {
					sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
					(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = uintptr(0)
				}
				return SQLITE_OK
			}
			(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+8299,
				libc.VaList(bp+32, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zCmd))
			return SQLITE_ERROR
		}
		if iRank < 1 {
			iRank = 1
		}
		if zSoundslike != 0 {
			zK1 = transliterate(tls, zSoundslike, nSoundslike)
		} else {
			zK1 = transliterate(tls, zWord, nWord)
		}
		if zK1 == uintptr(0) {
			return SQLITE_NOMEM
		}
		for i = 0; int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(zK1 + uintptr(i))))) != 0; i++ {
			if int32(c) >= 'A' && int32(c) <= 'Z' {
				*(*int8)(unsafe.Pointer(zK1 + uintptr(i))) += int8('a' - 'A')
			}
		}
		zK2 = phoneticHash(tls, zK1, i)
		if zK2 == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, zK1)
			return SQLITE_NOMEM
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
			if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))) == SQLITE_NULL {
				spellfix1DbExec(tls, bp+280, db,
					ts+8334,
					libc.VaList(bp+48, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						iRank, iLang, zWord, zK1, zWord, zK2))
			} else {
				newRowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
				spellfix1DbExec(tls, bp+280, db,
					ts+8420,
					libc.VaList(bp+112, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						newRowid, iRank, iLang, zWord, zK1, zWord, zK2))
			}
			*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
		} else {
			rowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			newRowid = libc.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
			spellfix1DbExec(tls, bp+280, db,
				ts+8520,
				libc.VaList(bp+192, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, newRowid, iRank, iLang,
					zWord, zK1, zWord, zK2, rowid))
		}
		sqlite3.Xsqlite3_free(tls, zK1)
		sqlite3.Xsqlite3_free(tls, zK2)
	}
	return *(*int32)(unsafe.Pointer(bp + 280))
}

func spellfix1Rename(tls *libc.TLS, pVTab uintptr, zNew uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
	*(*int32)(unsafe.Pointer(bp + 32)) = SQLITE_OK
	var zNewName uintptr = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zNew))
	if zNewName == uintptr(0) {
		return SQLITE_NOMEM
	}
	spellfix1DbExec(tls, bp+32, db,
		ts+8629,
		libc.VaList(bp+8, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zNewName))
	if *(*int32)(unsafe.Pointer(bp + 32)) == SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		(*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName = zNewName
	} else {
		sqlite3.Xsqlite3_free(tls, zNewName)
	}
	return *(*int32)(unsafe.Pointer(bp + 32))
}

var spellfix1Module = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
	FxUpdate:     0,
	FxRename:     0,
}

func spellfix1Register(tls *libc.TLS, db uintptr) int32 {
	var rc int32 = SQLITE_OK
	var i int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8678, 1,
		SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{transliterateSqlFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8697, 2,
			SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editdistSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8716, 1,
			SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{phoneticHashSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8736, 1,
			SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{scriptCodeSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8757, uintptr(unsafe.Pointer(&spellfix1Module)), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = editDist3Install(tls, db)
	}

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(translit))/uint32(unsafe.Sizeof(Transliteration{}))-uint32(1); i++ {
	}

	return rc
}

func sqlite3_spellfix_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	_ = pApi

	return spellfix1Register(tls, db)
	return SQLITE_OK
}

func totypeIsspace(tls *libc.TLS, c uint8) int32 {
	return libc.Bool32(int32(c) == ' ' || int32(c) == '\t' || int32(c) == '\n' || int32(c) == '\v' || int32(c) == '\f' || int32(c) == '\r')
}

func totypeIsdigit(tls *libc.TLS, c uint8) int32 {
	return libc.Bool32(int32(c) >= '0' && int32(c) <= '9')
}

func totypeCompare2pow63(tls *libc.TLS, zNum uintptr) int32 {
	var c int32 = 0
	var i int32

	var pow63 uintptr = ts + 8767
	for i = 0; c == 0 && i < 18; i++ {
		c = (int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i)))) - int32(*(*int8)(unsafe.Pointer(pow63 + uintptr(i))))) * 10
	}
	if c == 0 {
		c = int32(*(*int8)(unsafe.Pointer(zNum + 18))) - '8'
	}
	return c
}

func totypeAtoi64(tls *libc.TLS, zNum uintptr, pNum uintptr, length int32) int32 {
	var u sqlite3_uint64 = uint64(0)
	var neg int32 = 0
	var i int32
	var c int32 = 0
	var nonNum int32 = 0
	var zStart uintptr
	var zEnd uintptr = zNum + uintptr(length)

	for zNum < zEnd && totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(zNum)))) != 0 {
		zNum++
	}
	if zNum < zEnd {
		if int32(*(*int8)(unsafe.Pointer(zNum))) == '-' {
			neg = 1
			zNum++
		} else if int32(*(*int8)(unsafe.Pointer(zNum))) == '+' {
			zNum++
		}
	}
	zStart = zNum
	for zNum < zEnd && int32(*(*int8)(unsafe.Pointer(zNum))) == '0' {
		zNum++
	}
	for i = 0; zNum+uintptr(i) < zEnd && libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i))))) >= '0' && c <= '9'; i++ {
		u = u*uint64(10) + sqlite3_uint64(c) - uint64('0')
	}
	if u > uint64(int64(0xffffffff)|int64(0x7fffffff)<<32) {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = int64(-1) - (int64(0xffffffff) | int64(0x7fffffff)<<32)
	} else if neg != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = -sqlite3_int64(u)
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = sqlite3_int64(u)
	}
	if c != 0 && zNum+uintptr(i) < zEnd || i == 0 && zStart == zNum || i > 19 || nonNum != 0 {
		return 1
	} else if i < 19 {
		return 0
	} else {
		c = totypeCompare2pow63(tls, zNum)
		if c < 0 {
			return 0
		} else if c > 0 {
			return 1
		} else {
			if neg != 0 {
				return 0
			}
			return 2
		}
	}
	return int32(0)
}

func totypeAtoF(tls *libc.TLS, z uintptr, pResult uintptr, length int32) int32 {
	var zEnd uintptr

	var sign int32
	var s sqlite3_int64
	var d int32
	var esign int32
	var e int32
	var eValid int32
	var result float64
	var nDigits int32
	var nonNum int32
	var scale float64
	zEnd = z + uintptr(length)
	sign = 1
	s = int64(0)
	d = 0
	esign = 1
	e = 0
	eValid = 1
	nDigits = 0
	nonNum = 0

	*(*float64)(unsafe.Pointer(pResult)) = 0.0

__1:
	if !(z < zEnd && totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __2
	}
	z++
	goto __1
__2:
	;
	if !(z >= zEnd) {
		goto __3
	}
	return 0
__3:
	;
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __4
	}
	sign = -1
	z++
	goto __5
__4:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __6
	}
	z++
__6:
	;
__5:
	;
__7:
	if !(z < zEnd && int32(*(*int8)(unsafe.Pointer(z))) == '0') {
		goto __8
	}
	z++
	nDigits++
	goto __7
__8:
	;
__9:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0 && s < (int64(0xffffffff)|int64(0x7fffffff)<<32-int64(9))/int64(10)) {
		goto __10
	}
	s = s*int64(10) + sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z)))-'0')
	z++
	nDigits++
	goto __9
__10:
	;
__11:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __12
	}
	z++
	nDigits++
	d++
	goto __11
__12:
	;
	if !(z >= zEnd) {
		goto __13
	}
	goto totype_atof_calc
__13:
	;
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '.') {
		goto __14
	}
	z++

__15:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0 && s < (int64(0xffffffff)|int64(0x7fffffff)<<32-int64(9))/int64(10)) {
		goto __16
	}
	s = s*int64(10) + sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z)))-'0')
	z++
	nDigits++
	d--
	goto __15
__16:
	;
__17:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __18
	}
	z++
	nDigits++
	goto __17
__18:
	;
__14:
	;
	if !(z >= zEnd) {
		goto __19
	}
	goto totype_atof_calc
__19:
	;
	if !(int32(*(*int8)(unsafe.Pointer(z))) == 'e' || int32(*(*int8)(unsafe.Pointer(z))) == 'E') {
		goto __20
	}
	z++
	eValid = 0
	if !(z >= zEnd) {
		goto __21
	}
	goto totype_atof_calc
__21:
	;
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __22
	}
	esign = -1
	z++
	goto __23
__22:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __24
	}
	z++
__24:
	;
__23:
	;
__25:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __26
	}
	if e < 10000 {
		e = e*10 + (int32(*(*int8)(unsafe.Pointer(z))) - '0')
	} else {
		e = 10000
	}
	z++
	eValid = 1
	goto __25
__26:
	;
__20:
	;
	if !(nDigits != 0 && eValid != 0) {
		goto __27
	}
__28:
	if !(z < zEnd && totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __29
	}
	z++
	goto __28
__29:
	;
__27:
	;
totype_atof_calc:
	e = e*esign + d
	if !(e < 0) {
		goto __30
	}
	esign = -1
	e = e * -1
	goto __31
__30:
	esign = 1
__31:
	;
	if !!(s != 0) {
		goto __32
	}

	if sign < 0 && nDigits != 0 {
		result = -libc.Float64FromFloat64(float64(0))
	} else {
		result = float64(0)
	}
	goto __33
__32:
	if !(esign > 0) {
		goto __34
	}
__36:
	if !(s < (int64(0xffffffff)|int64(0x7fffffff)<<32)/int64(10) && e > 0) {
		goto __37
	}
	e--
	s = s * int64(10)
	goto __36
__37:
	;
	goto __35
__34:
__38:
	if !(!(int32(s%int64(10)) != 0) && e > 0) {
		goto __39
	}
	e--
	s = s / int64(10)
	goto __38
__39:
	;
__35:
	;
	if sign < 0 {
		s = -s
	} else {
		s = s
	}

	if !(e != 0) {
		goto __40
	}
	scale = 1.0

	if !(e > 307 && e < 342) {
		goto __42
	}
__44:
	if !(e%308 != 0) {
		goto __45
	}
	scale = scale * 1.0e+1
	e = e - 1
	goto __44
__45:
	;
	if !(esign < 0) {
		goto __46
	}
	result = float64(s) / scale
	result = result / 1.0e+308
	goto __47
__46:
	result = float64(s) * scale
	result = result * 1.0e+308
__47:
	;
	goto __43
__42:
	if !(e >= 342) {
		goto __48
	}
	if !(esign < 0) {
		goto __50
	}
	result = 0.0 * float64(s)
	goto __51
__50:
	result = libc.Float64(1e308) * libc.Float64(1e308) * float64(s)
__51:
	;
	goto __49
__48:
__52:
	if !(e%22 != 0) {
		goto __53
	}
	scale = scale * 1.0e+1
	e = e - 1
	goto __52
__53:
	;
__54:
	if !(e > 0) {
		goto __55
	}
	scale = scale * 1.0e+22
	e = e - 22
	goto __54
__55:
	;
	if !(esign < 0) {
		goto __56
	}
	result = float64(s) / scale
	goto __57
__56:
	result = float64(s) * scale
__57:
	;
__49:
	;
__43:
	;
	goto __41
__40:
	result = float64(s)
__41:
	;
__33:
	;
	*(*float64)(unsafe.Pointer(pResult)) = result

	return libc.Bool32(z >= zEnd && nDigits > 0 && eValid != 0 && nonNum == 0)
}

func tointegerFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) {
	case SQLITE_FLOAT:
		{
			var rVal float64 = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var iVal sqlite3_int64 = sqlite3_int64(rVal)
			if rVal == float64(iVal) {
				sqlite3.Xsqlite3_result_int64(tls, context, iVal)
			}
			break

		}
	case SQLITE_INTEGER:
		{
			sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
			break

		}
	case SQLITE_BLOB:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if uint32(nBlob) == uint32(unsafe.Sizeof(sqlite3_int64(0))) {
					if 0 != 0 {
						var i int32

						for i = 0; uint32(i) < uint32(unsafe.Sizeof(sqlite3_int64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(uint32(unsafe.Sizeof(sqlite3_int64(0)))-uint32(1)-uint32(i))))
						}
						libc.Xmemcpy(tls, bp+8, bp, uint32(unsafe.Sizeof(sqlite3_int64(0))))
					} else {
						libc.Xmemcpy(tls, bp+8, zBlob, uint32(unsafe.Sizeof(sqlite3_int64(0))))
					}
					sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 8)))
				}
			}
			break

		}
	case SQLITE_TEXT:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if nStr != 0 && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr))) != 0) {
					if !(totypeAtoi64(tls, zStr, bp+16, nStr) != 0) {
						sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 16)))
					}
				}
			}
			break

		}
	default:
		{
			break

		}
	}
}

func torealFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) {
	case SQLITE_FLOAT:
		{
			sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv))))
			break

		}
	case SQLITE_INTEGER:
		{
			var iVal sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var rVal float64 = float64(iVal)
			if iVal == sqlite3_int64(rVal) {
				sqlite3.Xsqlite3_result_double(tls, context, rVal)
			}
			break

		}
	case SQLITE_BLOB:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if uint32(nBlob) == uint32(unsafe.Sizeof(float64(0))) {
					if 1 != 0 {
						var i int32

						for i = 0; uint32(i) < uint32(unsafe.Sizeof(float64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(uint32(unsafe.Sizeof(float64(0)))-uint32(1)-uint32(i))))
						}
						libc.Xmemcpy(tls, bp+8, bp, uint32(unsafe.Sizeof(float64(0))))
					} else {
						libc.Xmemcpy(tls, bp+8, zBlob, uint32(unsafe.Sizeof(float64(0))))
					}
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 8)))
				}
			}
			break

		}
	case SQLITE_TEXT:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if nStr != 0 && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr))) != 0) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr + uintptr(nStr-1)))) != 0) {
					if totypeAtoF(tls, zStr, bp+16, nStr) != 0 {
						sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 16)))
						return
					}
				}
			}
			break

		}
	default:
		{
			break

		}
	}
}

func sqlite3_totype_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8786, 1,
		SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tointegerFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8796, 1,
			SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{torealFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

type UnionCsr1 = struct {
	Fbase      sqlite3_vtab_cursor
	FpStmt     uintptr
	FiMaxRowid sqlite3_int64
	FiTab      int32
}

type UnionCsr = UnionCsr1
type UnionTab1 = struct {
	Fbase        sqlite3_vtab
	Fdb          uintptr
	FbSwarm      int32
	FiPK         int32
	FnSrc        int32
	FaSrc        uintptr
	FbHasContext int32
	FzSourceStr  uintptr
	FpNotFound   uintptr
	FpOpenClose  uintptr
	FpClosable   uintptr
	FnOpen       int32
	FnMaxOpen    int32
}

type UnionTab = UnionTab1
type UnionSrc1 = struct {
	FzDb           uintptr
	FzTab          uintptr
	FiMin          sqlite3_int64
	FiMax          sqlite3_int64
	FzFile         uintptr
	FzContext      uintptr
	FnUser         int32
	Fdb            uintptr
	FpNextClosable uintptr
}

type UnionSrc = UnionSrc1

func unionMalloc(tls *libc.TLS, pRc uintptr, nByte sqlite3_int64) uintptr {
	var pRet uintptr

	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		pRet = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
		if pRet != 0 {
			libc.Xmemset(tls, pRet, 0, size_t(nByte))
		} else {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
	} else {
		pRet = uintptr(0)
	}
	return pRet
}

func unionStrdup(tls *libc.TLS, pRc uintptr, zIn uintptr) uintptr {
	var zRet uintptr = uintptr(0)
	if zIn != 0 {
		var nByte sqlite3_int64 = sqlite3_int64(libc.Xstrlen(tls, zIn) + size_t(1))
		zRet = unionMalloc(tls, pRc, nByte)
		if zRet != 0 {
			libc.Xmemcpy(tls, zRet, zIn, size_t(nByte))
		}
	}
	return zRet
}

func unionDequote(tls *libc.TLS, z uintptr) {
	if z != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(z))

		if int32(q) == '[' || int32(q) == '\'' || int32(q) == '"' || int32(q) == '`' {
			var iIn int32 = 1
			var iOut int32 = 0
			if int32(q) == '[' {
				q = int8(']')
			}
			for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
					if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(q) {
						iIn++
						break
					} else {
						iIn = iIn + 2
						*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
					}
				} else {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
				}
			}
			*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
		}
	}
}

func unionPrepare(tls *libc.TLS, pRc uintptr, db uintptr, zSql uintptr, pzErr uintptr) uintptr {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(0)

	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8803, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
			*(*int32)(unsafe.Pointer(pRc)) = rc
		}
	}
	return *(*uintptr)(unsafe.Pointer(bp + 8))
}

func unionPreparePrintf(tls *libc.TLS, pRc uintptr, pzErr uintptr, db uintptr, zFmt uintptr, va uintptr) uintptr {
	var pRet uintptr = uintptr(0)
	var zSql uintptr
	var ap va_list
	_ = ap
	ap = va

	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		} else {
			pRet = unionPrepare(tls, pRc, db, zSql, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	_ = ap
	return pRet
}

func unionFinalize(tls *libc.TLS, pRc uintptr, pStmt uintptr, pzErr uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var db uintptr = sqlite3.Xsqlite3_db_handle(tls, pStmt)
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = rc
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}
}

func unionInvokeOpenClose(tls *libc.TLS, pTab uintptr, pSrc uintptr, bClose int32, pzErr uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_bind_int(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 2+(*UnionTab)(unsafe.Pointer(pTab)).FbHasContext, bClose)
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		if SQLITE_OK != libc.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)) {
			if pzErr != 0 {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			}
		}
	}
	return rc
}

func unionCloseSources(tls *libc.TLS, pTab uintptr, nMax int32) {
	for (*UnionTab)(unsafe.Pointer(pTab)).FpClosable != 0 && (*UnionTab)(unsafe.Pointer(pTab)).FnOpen > nMax {
		var p uintptr
		var pp uintptr
		for pp = pTab + 48; (*UnionSrc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNextClosable != 0; pp = *(*uintptr)(unsafe.Pointer(pp)) + 40 {
		}
		p = *(*uintptr)(unsafe.Pointer(pp))

		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(p)).Fdb)
		(*UnionSrc)(unsafe.Pointer(p)).Fdb = uintptr(0)
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		(*UnionTab)(unsafe.Pointer(pTab)).FnOpen--
		unionInvokeOpenClose(tls, pTab, p, 1, uintptr(0))
	}
}

func unionDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	if pVtab != 0 {
		var pTab uintptr = pVtab
		var i int32
		for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
			var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*44
			var bHaveSrcDb int32 = libc.Bool32((*UnionSrc)(unsafe.Pointer(pSrc)).Fdb != uintptr(0))
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			if bHaveSrcDb != 0 {
				unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
			}
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext)
		}
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc)
		sqlite3.Xsqlite3_free(tls, pTab)
	}
	return SQLITE_OK
}

func unionIsIntkeyTable(tls *libc.TLS, db uintptr, pSrc uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*int32)(unsafe.Pointer(bp + 28)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 24)) = uintptr(0)
	var rc int32

	sqlite3.Xsqlite3_table_column_metadata(tls,
		db, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, ts+8817, bp+24, uintptr(0), uintptr(0), bp+28, uintptr(0))
	rc = sqlite3.Xsqlite3_errcode(tls, db)
	if rc == SQLITE_ERROR ||
		rc == SQLITE_OK && (!(*(*int32)(unsafe.Pointer(bp + 28)) != 0) || sqlite3.Xsqlite3_stricmp(tls, ts+8825, *(*uintptr)(unsafe.Pointer(bp + 24))) != 0) {
		rc = SQLITE_ERROR
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8833,
			libc.VaList(bp, func() uintptr {
				if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
				}
				return ts + 584
			}(),
				func() uintptr {
					if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
						return ts + 8861
					}
					return ts + 584
				}(),
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
	}
	return rc
}

func unionSourceToStr(tls *libc.TLS, pRc uintptr, pTab uintptr, pSrc uintptr, pzErr uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zRet uintptr = uintptr(0)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		*(*int32)(unsafe.Pointer(bp)) = unionIsIntkeyTable(tls, db, pSrc, pzErr)
		var pStmt uintptr = unionPrepare(tls, bp, db,
			ts+8863, pzErr)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, -1, uintptr(0))
			if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
				var z uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
				zRet = unionStrdup(tls, bp, z)
			}
			unionFinalize(tls, bp, pStmt, pzErr)
		}
		*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp))
	}

	return zRet
}

func unionSourceCheck(tls *libc.TLS, pTab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var z0 uintptr = uintptr(0)
	var i int32

	z0 = unionSourceToStr(tls, bp, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc, pzErr)
	for i = 1; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var z uintptr = unionSourceToStr(tls, bp, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc+uintptr(i)*44, pzErr)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && sqlite3.Xsqlite3_stricmp(tls, z, z0) != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8947, 0)
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_ERROR
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	sqlite3.Xsqlite3_free(tls, z0)

	return *(*int32)(unsafe.Pointer(bp))
}

func unionOpenDatabaseInner(tls *libc.TLS, pTab uintptr, pSrc uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32

	rc = unionInvokeOpenClose(tls, pTab, pSrc, 0, pzErr)
	if rc != SQLITE_OK {
		return rc
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, pSrc+36, openFlags, uintptr(0))
	if rc == SQLITE_OK {
		return rc
	}
	if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
		(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		if SQLITE_OK != libc.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			return rc
		}
		rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, pSrc+36, openFlags, uintptr(0))
	}
	if rc != SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, sqlite3.Xsqlite3_errmsg(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)))
	}
	return rc
}

var openFlags int32 = SQLITE_OPEN_READONLY | SQLITE_OPEN_URI

func unionOpenDatabase(tls *libc.TLS, pTab uintptr, iSrc int32, pzErr uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iSrc)*44

	if (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb == uintptr(0) {
		unionCloseSources(tls, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen-1)
		*(*int32)(unsafe.Pointer(bp)) = unionOpenDatabaseInner(tls, pTab, pSrc, pzErr)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			var z uintptr = unionSourceToStr(tls, bp, pTab, pSrc, pzErr)
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				if (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr == uintptr(0) {
					(*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr = z
				} else {
					if sqlite3.Xsqlite3_stricmp(tls, z, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr) != 0 {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8947, 0)
						*(*int32)(unsafe.Pointer(bp)) = SQLITE_ERROR
					}
					sqlite3.Xsqlite3_free(tls, z)
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
			(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			(*UnionTab)(unsafe.Pointer(pTab)).FnOpen++
		} else {
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
			unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
		}
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func unionIncrRefcount(tls *libc.TLS, pTab uintptr, iTab int32) {
	if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
		var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iTab)*44

		if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
			var pp uintptr
			for pp = pTab + 48; *(*uintptr)(unsafe.Pointer(pp)) != pSrc; pp = *(*uintptr)(unsafe.Pointer(pp)) + 40 {
			}
			*(*uintptr)(unsafe.Pointer(pp)) = (*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = uintptr(0)
		}
		(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser++
	}
}

func unionFinalizeCsrStmt(tls *libc.TLS, pCsr uintptr) int32 {
	var rc int32 = SQLITE_OK
	if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*44
		rc = sqlite3.Xsqlite3_finalize(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser--

			if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
				(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
				(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			}
			unionCloseSources(tls, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen)
		}
	}
	return rc
}

func union_isspace(tls *libc.TLS, c int8) int32 {
	return libc.Bool32(int32(c) == ' ' || int32(c) == '\n' || int32(c) == '\r' || int32(c) == '\t')
}

func union_isidchar(tls *libc.TLS, c int8) int32 {
	return libc.Bool32(int32(c) >= 'a' && int32(c) <= 'z' || int32(c) >= 'A' && int32(c) < 'Z' || int32(c) >= '0' && int32(c) <= '9')
}

func unionConfigureVtab(tls *libc.TLS, pRc uintptr, pTab uintptr, pStmt uintptr, nArg int32, azArg uintptr, pzErr uintptr) {
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*int32)(unsafe.Pointer(bp + 64)) = *(*int32)(unsafe.Pointer(pRc))
	var i int32
	if *(*int32)(unsafe.Pointer(bp + 64)) == SQLITE_OK {
		(*UnionTab)(unsafe.Pointer(pTab)).FbHasContext = libc.Bool32(sqlite3.Xsqlite3_column_count(tls, pStmt) > 4)
	}
	for i = 0; *(*int32)(unsafe.Pointer(bp + 64)) == SQLITE_OK && i < nArg; i++ {
		var zArg uintptr = unionStrdup(tls, bp+64, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4)))
		if zArg != 0 {
			var nOpt int32 = 0
			var zOpt uintptr
			var zVal uintptr

			unionDequote(tls, zArg)
			zOpt = zArg
			for union_isspace(tls, *(*int8)(unsafe.Pointer(zOpt))) != 0 {
				zOpt++
			}
			zVal = zOpt
			if int32(*(*int8)(unsafe.Pointer(zVal))) == ':' {
				zVal++
			}
			for union_isidchar(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			nOpt = (int32(zVal) - int32(zOpt)) / 1

			for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			if int32(*(*int8)(unsafe.Pointer(zVal))) == '=' {
				*(*int8)(unsafe.Pointer(zOpt + uintptr(nOpt))) = int8(0)
				zVal++
				for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
					zVal++
				}
				zVal = unionStrdup(tls, bp+64, zVal)
				if zVal != 0 {
					unionDequote(tls, zVal)
					if int32(*(*int8)(unsafe.Pointer(zOpt))) == ':' {
						var iParam int32 = sqlite3.Xsqlite3_bind_parameter_index(tls, pStmt, zOpt)
						if iParam == 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8976, libc.VaList(bp, zOpt))
							*(*int32)(unsafe.Pointer(bp + 64)) = SQLITE_ERROR
						} else {
							*(*int32)(unsafe.Pointer(bp + 64)) = sqlite3.Xsqlite3_bind_text(tls, pStmt, iParam, zVal, -1, libc.UintptrFromInt32(-1))
						}
					} else if nOpt == 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+9013, 7) {
						(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = libc.Xatoi(tls, zVal)
						if (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen <= 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9021, 0)
							*(*int32)(unsafe.Pointer(bp + 64)) = SQLITE_ERROR
						}
					} else if nOpt == 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+9054, 7) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+9062, 0)
							*(*int32)(unsafe.Pointer(bp + 64)) = SQLITE_ERROR
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+9100, libc.VaList(bp+8, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 9117
									}
									return ts + 584
								}()))
						}
					} else if nOpt == 9 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+9120, 9) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+9130, 0)
							*(*int32)(unsafe.Pointer(bp + 64)) = SQLITE_ERROR
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose = unionPreparePrintf(tls, bp+64, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+9170, libc.VaList(bp+24, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 9117
									}
									return ts + 584
								}()))
						}
					} else {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9189, libc.VaList(bp+40, zOpt))
						*(*int32)(unsafe.Pointer(bp + 64)) = SQLITE_ERROR
					}
					sqlite3.Xsqlite3_free(tls, zVal)
				}
			} else {
				if i == 0 && nArg == 1 {
					(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
						ts+9224, libc.VaList(bp+48, zArg))
				} else {
					*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9239, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))))
					*(*int32)(unsafe.Pointer(bp + 64)) = SQLITE_ERROR
				}
			}
			sqlite3.Xsqlite3_free(tls, zArg)
		}
	}
	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 64))
}

func unionConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var pTab uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
	var bSwarm int32 = func() int32 {
		if pAux == uintptr(0) {
			return 0
		}
		return 1
	}()
	var zVtab uintptr = func() uintptr {
		if bSwarm != 0 {
			return ts + 9266
		}
		return ts + 9276
	}()

	if sqlite3.Xsqlite3_stricmp(tls, ts+9286, *(*uintptr)(unsafe.Pointer(argv + 1*4))) != 0 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9291, libc.VaList(bp, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_ERROR
	} else if argc < 4 || argc > 4 && bSwarm == 0 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9332, libc.VaList(bp+8, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_ERROR
	} else {
		var nAlloc int32 = 0
		var pStmt uintptr = uintptr(0)
		var zArg uintptr = unionStrdup(tls, bp+40, *(*uintptr)(unsafe.Pointer(argv + 3*4)))

		unionDequote(tls, zArg)
		pStmt = unionPreparePrintf(tls, bp+40, pzErr, db,
			ts+9365, libc.VaList(bp+16, zArg))

		pTab = unionMalloc(tls, bp+40, int64(unsafe.Sizeof(UnionTab{})))
		if pTab != 0 {
			(*UnionTab)(unsafe.Pointer(pTab)).Fdb = db
			(*UnionTab)(unsafe.Pointer(pTab)).FbSwarm = bSwarm
			(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = SWARMVTAB_MAX_OPEN
		}

		if bSwarm != 0 {
			unionConfigureVtab(tls, bp+40, pTab, pStmt, argc-4, argv+4*4, pzErr)
		}

		for *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
			var zDb uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			var iMin sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 2)
			var iMax sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 3)
			var pSrc uintptr

			if nAlloc <= (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var nNew int32
				if nAlloc != 0 {
					nNew = nAlloc * 2
				} else {
					nNew = 8
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls,
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc, uint64(uint32(nNew)*uint32(unsafe.Sizeof(UnionSrc{}))))
				if aNew == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_NOMEM
					break
				} else {
					libc.Xmemset(tls, aNew+uintptr((*UnionTab)(unsafe.Pointer(pTab)).FnSrc)*44, 0, uint32(nNew-(*UnionTab)(unsafe.Pointer(pTab)).FnSrc)*uint32(unsafe.Sizeof(UnionSrc{})))
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc = aNew
					nAlloc = nNew
				}
			}

			if iMax < iMin || (*UnionTab)(unsafe.Pointer(pTab)).FnSrc > 0 && iMin <= (*UnionSrc)(unsafe.Pointer((*UnionTab)(unsafe.Pointer(pTab)).FaSrc+uintptr((*UnionTab)(unsafe.Pointer(pTab)).FnSrc-1)*44)).FiMax {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9395, 0)
				*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_ERROR
			}

			if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
				pSrc = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(libc.PostIncInt32(&(*UnionTab)(unsafe.Pointer(pTab)).FnSrc, 1))*44
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab = unionStrdup(tls, bp+40, zTab)
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMin = iMin
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMax = iMax
				if bSwarm != 0 {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzFile = unionStrdup(tls, bp+40, zDb)
				} else {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzDb = unionStrdup(tls, bp+40, zDb)
				}
				if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
					var zContext uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 4)
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzContext = unionStrdup(tls, bp+40, zContext)
				}
			}
		}
		unionFinalize(tls, bp+40, pStmt, pzErr)
		pStmt = uintptr(0)

		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK && (*UnionTab)(unsafe.Pointer(pTab)).FnSrc == 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9422, 0)
			*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_ERROR
		}

		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
			if bSwarm != 0 {
				*(*int32)(unsafe.Pointer(bp + 40)) = unionOpenDatabase(tls, pTab, 0, pzErr)
			} else {
				*(*int32)(unsafe.Pointer(bp + 40)) = unionSourceCheck(tls, pTab, pzErr)
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
			var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc
			var tdb uintptr = func() uintptr {
				if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
				}
				return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
			}()
			pStmt = unionPreparePrintf(tls, bp+40, pzErr, tdb,
				ts+9450,
				libc.VaList(bp+24, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb))
		}
		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
			var zDecl uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			*(*int32)(unsafe.Pointer(bp + 40)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zDecl)
			(*UnionTab)(unsafe.Pointer(pTab)).FiPK = sqlite3.Xsqlite3_column_int(tls, pStmt, 1)
		}

		unionFinalize(tls, bp+40, pStmt, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 40)) != SQLITE_OK {
		unionDisconnect(tls, pTab)
		pTab = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	return *(*int32)(unsafe.Pointer(bp + 40))
}

func unionOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr
	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	_ = p
	pCsr = unionMalloc(tls, bp, int64(unsafe.Sizeof(UnionCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return *(*int32)(unsafe.Pointer(bp))
}

func unionClose(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	unionFinalizeCsrStmt(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

func doUnionNext(tls *libc.TLS, pCsr uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	*(*int32)(unsafe.Pointer(bp + 24)) = SQLITE_OK

	if sqlite3.Xsqlite3_step(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt) != SQLITE_ROW {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		*(*int32)(unsafe.Pointer(bp + 24)) = unionFinalizeCsrStmt(tls, pCsr)
		if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK && (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab++
			if (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*44
				if (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid >= (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
					*(*int32)(unsafe.Pointer(bp + 24)) = unionOpenDatabase(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab, pTab+8)
					(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPreparePrintf(tls, bp+24, pTab+8, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb,
						ts+9628,
						libc.VaList(bp, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab,
							func() uintptr {
								if (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax > (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid {
									return ts + 9660
								}
								return ts + 9677
							}(),
							(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid))
					if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
						unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
						*(*int32)(unsafe.Pointer(bp + 24)) = SQLITE_ROW
					}
				}
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 24))
}

func unionNext(tls *libc.TLS, cur uintptr) int32 {
	var rc int32
	for __ccgo := true; __ccgo; __ccgo = rc == SQLITE_ROW {
		rc = doUnionNext(tls, cur)
	}
	return rc
}

func unionColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, i+1))
	return SQLITE_OK
}

func unionRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return SQLITE_OK
}

func unionEof(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	return libc.Bool32((*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0))
}

func unionFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCsr uintptr = pVtabCursor
	*(*int32)(unsafe.Pointer(bp + 104)) = SQLITE_OK
	var i int32
	var zSql uintptr = uintptr(0)
	var bZero int32 = 0

	var iMin sqlite3_int64 = int64(-1) - (int64(0xffffffff) | int64(0x7fffffff)<<32)
	var iMax sqlite3_int64 = int64(0xffffffff) | int64(0x7fffffff)<<32

	_ = idxStr

	if idxNum == SQLITE_INDEX_CONSTRAINT_EQ {
		iMin = libc.AssignInt64(&iMax, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
	} else {
		if idxNum&(SQLITE_INDEX_CONSTRAINT_LE|SQLITE_INDEX_CONSTRAINT_LT) != 0 {
			iMax = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if idxNum&SQLITE_INDEX_CONSTRAINT_LT != 0 {
				if iMax == int64(-1)-(int64(0xffffffff)|int64(0x7fffffff)<<32) {
					bZero = 1
				} else {
					iMax--
				}
			}
		}

		if idxNum&(SQLITE_INDEX_CONSTRAINT_GE|SQLITE_INDEX_CONSTRAINT_GT) != 0 {
			iMin = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(argc-1)*4)))
			if idxNum&SQLITE_INDEX_CONSTRAINT_GT != 0 {
				if iMin == int64(0xffffffff)|int64(0x7fffffff)<<32 {
					bZero = 1
				} else {
					iMin++
				}
			}
		}
	}

	unionFinalizeCsrStmt(tls, pCsr)
	if bZero != 0 {
		return SQLITE_OK
	}

	for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*44
		if iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax || iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
			continue
		}

		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9681, libc.VaList(bp, zSql, func() uintptr {
			if zSql != 0 {
				return ts + 9715
			}
			return ts + 584
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5981
			}
			return ts + 584
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
			}
			return ts + 584
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5983
			}
			return ts + 584
		}(), (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 104)) = SQLITE_NOMEM
			break
		}

		if iMin == iMax {
			zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9727, libc.VaList(bp+48, zSql, iMin))
		} else {
			var zWhere uintptr = ts + 9747
			if iMin != int64(-1)-(int64(0xffffffff)|int64(0x7fffffff)<<32) && iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9753, libc.VaList(bp+64, zSql, iMin))
				zWhere = ts + 9774
			}
			if iMax != int64(0xffffffff)|int64(0x7fffffff)<<32 && iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9778, libc.VaList(bp+80, zSql, zWhere, iMax))
			}
		}

		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab = i
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid = iMax
			*(*int32)(unsafe.Pointer(bp + 104)) = unionOpenDatabase(tls, pTab, i, pTab+8)
			break
		}
	}

	if zSql == uintptr(0) {
		return *(*int32)(unsafe.Pointer(bp + 104))
	} else {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*44)).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPrepare(tls, bp+104, db, zSql, pTab+8)
		if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
			unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
		}
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if *(*int32)(unsafe.Pointer(bp + 104)) != SQLITE_OK {
		return *(*int32)(unsafe.Pointer(bp + 104))
	}
	return unionNext(tls, pVtabCursor)
}

func unionBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var pTab uintptr = tab
	var iEq int32 = -1
	var iLt int32 = -1
	var iGt int32 = -1
	var i int32

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0 && ((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn < 0 || (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == (*UnionTab)(unsafe.Pointer(pTab)).FiPK) {
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) {
			case SQLITE_INDEX_CONSTRAINT_EQ:
				iEq = i
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LE:
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LT:
				iLt = i
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GE:
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GT:
				iGt = i
				break
			}
		}
	}

	if iEq >= 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxFlags = SQLITE_INDEX_SCAN_UNIQUE
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 3.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = SQLITE_INDEX_CONSTRAINT_EQ
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).Fomit = uint8(1)
	} else {
		var iCons int32 = 1
		var idxNum int32 = 0
		var nRow sqlite3_int64 = int64(1000000)
		if iLt >= 0 {
			nRow = nRow / int64(2)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).FargvIndex = libc.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).Fomit = uint8(1)
			idxNum = idxNum | int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(iLt)*12)).Fop)
		}
		if iGt >= 0 {
			nRow = nRow / int64(2)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).FargvIndex = libc.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).Fomit = uint8(1)
			idxNum = idxNum | int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(iGt)*12)).Fop)
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = nRow
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 3.0 * float64(nRow)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	}

	return SQLITE_OK
}

func createUnionVtab(tls *libc.TLS, db uintptr) int32 {
	var rc int32

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+9276, uintptr(unsafe.Pointer(&unionModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+9266, uintptr(unsafe.Pointer(&unionModule)), db)
	}
	return rc
}

var unionModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_unionvtab_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = createUnionVtab(tls, db)
	return rc
}

type wholenumber_cursor1 = struct {
	Fbase    sqlite3_vtab_cursor
	FiValue  sqlite3_int64
	FmxValue sqlite3_int64
}

type wholenumber_cursor = wholenumber_cursor1

func wholenumberConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pNew uintptr
	pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+9796)
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(sqlite3_vtab{})))
	return SQLITE_OK
}

func wholenumberDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func wholenumberOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(wholenumber_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(wholenumber_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func wholenumberClose(tls *libc.TLS, cur uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

func wholenumberNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue++
	return SQLITE_OK
}

func wholenumberColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	sqlite3.Xsqlite3_result_int64(tls, ctx, (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue)
	return SQLITE_OK
}

func wholenumberRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue
	return SQLITE_OK
}

func wholenumberEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32((*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue || (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue == int64(0))
}

func wholenumberFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = pVtabCursor
	var v sqlite3_int64
	var i int32 = 0
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = int64(1)
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff)
	if idxNum&3 != 0 {
		v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))) + sqlite3_int64(idxNum&1)
		if v > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue && v <= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = v
		}
		i++
	}
	if idxNum&12 != 0 {
		v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) - sqlite3_int64(idxNum>>2&1)
		if v >= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue && v < (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = v
		}
	}
	return SQLITE_OK
}

func wholenumberBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var i int32
	var idxNum int32 = 0
	var argvIdx int32 = 1
	var ltIdx int32 = -1
	var gtIdx int32 = -1
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if idxNum&3 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_GT {
			idxNum = idxNum | 1
			ltIdx = i
		}
		if idxNum&3 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_GE {
			idxNum = idxNum | 2
			ltIdx = i
		}
		if idxNum&12 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
			idxNum = idxNum | 4
			gtIdx = i
		}
		if idxNum&12 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE {
			idxNum = idxNum | 8
			gtIdx = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	if ltIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).FargvIndex = libc.PostIncInt32(&argvIdx, 1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).Fomit = uint8(1)
	}
	if gtIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).FargvIndex = argvIdx
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).Fomit = uint8(1)
	}
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if idxNum&12 == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e99
	} else if idxNum&3 == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
	}
	return SQLITE_OK
}

var wholenumberModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_wholenumber_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+9818, uintptr(unsafe.Pointer(&wholenumberModule)), uintptr(0))
	return rc
}

type TestRbu1 = struct {
	FpRbu    uintptr
	Finterp  uintptr
	FxRename uintptr
}

type TestRbu = TestRbu1

func test_rbu_delta(tls *libc.TLS, pCtx uintptr, nArg int32, apVal uintptr) {
	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pScript uintptr
	var i int32

	pScript = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, ts+9830, -1))
	for i = 0; i < nArg; i++ {
		var pIn uintptr = *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*4))
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, pIn)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, z, -1))
	}

	if TCL_OK == tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_GLOBAL_ONLY) {
		var z uintptr = tcl.XTcl_GetStringResult(tls, interp)
		sqlite3.Xsqlite3_result_text(tls, pCtx, z, -1, libc.UintptrFromInt32(-1))
	} else {
		tcl.XTcl_BackgroundError(tls, interp)
	}

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func xRenameCallback(tls *libc.TLS, pArg uintptr, zOld uintptr, zNew uintptr) int32 {
	var rc int32 = SQLITE_OK
	var pTest uintptr = pArg
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, (*TestRbu)(unsafe.Pointer(pTest)).FxRename)

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*TestRbu)(unsafe.Pointer(pTest)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zOld, -1))
	tcl.XTcl_ListObjAppendElement(tls, (*TestRbu)(unsafe.Pointer(pTest)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zNew, -1))

	rc = tcl.XTcl_EvalObjEx(tls, (*TestRbu)(unsafe.Pointer(pTest)).Finterp, pEval, TCL_GLOBAL_ONLY)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	if rc != 0 {
		return SQLITE_IOERR
	}
	return SQLITE_OK
}

func test_sqlite3rbu_cmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(308)
	defer tls.Free(308)

	var ret int32 = TCL_OK
	var pTest uintptr = clientData
	var pRbu uintptr = (*TestRbu)(unsafe.Pointer(pTest)).FpRbu
	*(*[15]RbuCmd)(unsafe.Pointer(bp + 24)) = [15]RbuCmd{
		{FzName: ts + 9840, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9845, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9851, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9868, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9878, FnArg: 3, FzUsage: ts + 9890},
		{FzName: ts + 9894, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9906, FnArg: 3, FzUsage: ts + 9909},
		{FzName: ts + 9913, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9919, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9928, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9943, FnArg: 3, FzUsage: ts + 9959},
		{FzName: ts + 9965, FnArg: 2, FzUsage: ts + 584},
		{FzName: ts + 9975, FnArg: 3, FzUsage: ts + 9890},
		{FzName: ts + 9986, FnArg: 3, FzUsage: ts + 10001},
		{},
	}

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10008)
		return TCL_ERROR
	}
	ret = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+24, int32(unsafe.Sizeof(RbuCmd{})), ts+10015, 0, bp+204)
	if ret != 0 {
		return TCL_ERROR
	}
	if objc != (*RbuCmd)(unsafe.Pointer(bp+24+uintptr(*(*int32)(unsafe.Pointer(bp + 204)))*12)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, (*RbuCmd)(unsafe.Pointer(bp+24+uintptr(*(*int32)(unsafe.Pointer(bp + 204)))*12)).FzUsage)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 204)) {
	case 0:
		{
			var rc int32 = sqlite3.Xsqlite3rbu_step(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			break

		}

	case 9:
		fallthrough
	case 1:
		{
			*(*uintptr)(unsafe.Pointer(bp + 208)) = uintptr(0)
			var rc int32
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
			if *(*int32)(unsafe.Pointer(bp + 204)) == 1 {
				rc = sqlite3.Xsqlite3rbu_close(tls, pRbu, bp+208)
			} else {
				rc = sqlite3.Xsqlite3rbu_close(tls, pRbu, uintptr(0))
			}
			if rc == SQLITE_OK || rc == SQLITE_DONE {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))

			} else {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
				if *(*uintptr)(unsafe.Pointer(bp + 208)) != 0 {
					tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10022, *(*uintptr)(unsafe.Pointer(bp + 208)), 0))
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 208)))
				}
				ret = TCL_ERROR
			}
			if (*TestRbu)(unsafe.Pointer(pTest)).FxRename != 0 {
				for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
					var _objPtr uintptr = (*TestRbu)(unsafe.Pointer(pTest)).FxRename
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			tcl.XTcl_Free(tls, pTest)
			break

		}

	case 2:
		{
			var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, 0)
			var rc int32 = sqlite3.Xsqlite3_create_function(tls,
				db, ts+9830, -1, SQLITE_UTF8, interp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{test_rbu_delta})), uintptr(0), uintptr(0))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == SQLITE_OK {
					return TCL_OK
				}
				return TCL_ERROR
			}()
			break

		}

	case 3:
		{
			var rc int32 = sqlite3.Xsqlite3rbu_savestate(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == SQLITE_OK {
					return TCL_OK
				}
				return TCL_ERROR
			}()
			break

		}

	case 12:
		fallthrough
	case 4:
		{
			var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 204)) == 12))
			var rc int32 = sqlite3.Xsqlite3_exec(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), uintptr(0), uintptr(0), uintptr(0))
			if rc != SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, db), -1))
				ret = TCL_ERROR
			}
			break

		}

	case 5:
		{
			var pObj uintptr
			sqlite3.Xsqlite3rbu_bp_progress(tls, pRbu, bp+212, bp+216)

			pObj = tcl.XTcl_NewObj(tls)
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 212))))
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 216))))
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break

		}

	case 6:
		{
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+220) != 0 {
				ret = TCL_ERROR
			} else {
				var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, *(*int32)(unsafe.Pointer(bp + 220)))
				if sqlite3TestMakePointerStr(tls, interp, bp+224, db) != 0 {
					ret = TCL_ERROR
				} else {
					tcl.XTcl_SetResult(tls, interp, bp+224, uintptr(1))
				}
			}
			break

		}
	case 7:
		{
			*(*[6]uintptr)(unsafe.Pointer(bp + 276)) = [6]uintptr{uintptr(0), ts + 10026, ts + 10030, ts + 10035, ts + 10046, ts + 10051}
			var eState int32 = sqlite3.Xsqlite3rbu_state(tls, pRbu)

			tcl.XTcl_SetResult(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 276 + uintptr(eState)*4)), uintptr(0))
			break

		}
	case 8:
		{
			var nStep sqlite3_int64 = sqlite3.Xsqlite3rbu_progress(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, nStep))
			break

		}

	case 10:
		{
			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+300) != 0 {
				ret = TCL_ERROR
			} else {
				*(*sqlite3_int64)(unsafe.Pointer(bp + 300)) = sqlite3.Xsqlite3rbu_temp_size_limit(tls, pRbu, *(*sqlite3_int64)(unsafe.Pointer(bp + 300)))
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 300))))
			}
			break

		}
	case 11:
		{
			var sz sqlite3_int64 = sqlite3.Xsqlite3rbu_temp_size(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, sz))
			break

		}

	case 13:
		{
			var pScript uintptr = *(*uintptr)(unsafe.Pointer(objv + 2*4))

			if tcl.XTcl_GetCharLength(tls, pScript) == 0 {
				sqlite3.Xsqlite3rbu_rename_handler(tls, pRbu, uintptr(0), uintptr(0))
			} else {
				(*TestRbu)(unsafe.Pointer(pTest)).FxRename = tcl.XTcl_DuplicateObj(tls, pScript)
				(*Tcl_Obj)(unsafe.Pointer((*TestRbu)(unsafe.Pointer(pTest)).FxRename)).FrefCount++
				sqlite3.Xsqlite3rbu_rename_handler(tls, pRbu, pTest, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				}{xRenameCallback})))
			}
			break

		}

	default:
		break
	}

	return ret
}

type RbuCmd = struct {
	FzName  uintptr
	FnArg   int32
	FzUsage uintptr
}

func createRbuWrapper(tls *libc.TLS, interp uintptr, zCmd uintptr, pRbu uintptr) {
	var pTest uintptr = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestRbu{})))
	libc.Xmemset(tls, pTest, 0, uint32(unsafe.Sizeof(TestRbu{})))
	(*TestRbu)(unsafe.Pointer(pTest)).FpRbu = pRbu
	(*TestRbu)(unsafe.Pointer(pTest)).Finterp = interp
	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{test_sqlite3rbu_cmd})), pTest, uintptr(0))
}

func test_sqlite3rbu(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zRbu uintptr
	var zStateDb uintptr = uintptr(0)

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10057)
		return TCL_ERROR
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zRbu = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if objc == 5 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	}

	pRbu = sqlite3.Xsqlite3rbu_open(tls, zTarget, zRbu, zStateDb)
	createRbuWrapper(tls, interp, zCmd, pRbu)
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func test_sqlite3rbu_vacuum(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zStateDb uintptr = uintptr(0)

	if objc != 3 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10090)
		return TCL_ERROR
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if objc == 4 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	}
	if zStateDb != 0 && int32(*(*int8)(unsafe.Pointer(zStateDb))) == 0 {
		zStateDb = uintptr(0)
	}

	pRbu = sqlite3.Xsqlite3rbu_vacuum(tls, zTarget, zStateDb)
	createRbuWrapper(tls, interp, zCmd, pRbu)
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func test_sqlite3rbu_create_vfs(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var zName uintptr
	var zParent uintptr
	var rc int32

	if objc != 3 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10116)
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*4)))
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4)))
	if int32(*(*int8)(unsafe.Pointer(zParent))) == 0 {
		zParent = uintptr(0)
	}

	rc = sqlite3.Xsqlite3rbu_create_vfs(tls, zName, zParent)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else if objc == 4 {
		var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, zName)
		sqlite3.Xsqlite3_vfs_register(tls, pVfs, 1)
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func test_sqlite3rbu_destroy_vfs(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var zName uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10139)
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	sqlite3.Xsqlite3rbu_destroy_vfs(tls, zName)
	return TCL_OK
}

func test_sqlite3rbu_internal_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var db uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	db = sqlite3.Xsqlite3rbu_db(tls, uintptr(0), 0)
	if db != uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10144, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func SqliteRbu_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd[i].FzName, aObjCmd[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 10167, FxProc: 0},
	{FzName: ts + 10178, FxProc: 0},
	{FzName: ts + 10196, FxProc: 0},
	{FzName: ts + 10218, FxProc: 0},
	{FzName: ts + 10241, FxProc: 0},
}

type DbdataTable1 = struct {
	Fbase  sqlite3_vtab
	Fdb    uintptr
	FpStmt uintptr
	FbPtr  int32
}

type DbdataTable = DbdataTable1
type DbdataCursor1 = struct {
	Fbase     sqlite3_vtab_cursor
	FpStmt    uintptr
	FiPgno    int32
	FaPage    uintptr
	FnPage    int32
	FnCell    int32
	FiCell    int32
	FbOnePage int32
	FszDb     int32
	FiRowid   sqlite3_int64
	FpRec     uintptr
	FnRec     sqlite3_int64
	FnHdr     sqlite3_int64
	FiField   int32
	FpHdrPtr  uintptr
	FpPtr     uintptr
	Fenc      u32
	FiIntkey  sqlite3_int64
}

type DbdataCursor = DbdataCursor1

func dbdataConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pTab uintptr = uintptr(0)
	var rc int32 = sqlite3.Xsqlite3_declare_vtab(tls, db, func() uintptr {
		if pAux != 0 {
			return ts + 10266
		}
		return ts + 10334
	}())

	_ = argc
	_ = argv
	_ = pzErr
	if rc == SQLITE_OK {
		pTab = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(DbdataTable{})))
		if pTab == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(DbdataTable{})))
			(*DbdataTable)(unsafe.Pointer(pTab)).Fdb = db
			(*DbdataTable)(unsafe.Pointer(pTab)).FbPtr = libc.Bool32(pAux != uintptr(0))
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	return rc
}

func dbdataDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var pTab uintptr = pVtab
	if pTab != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*DbdataTable)(unsafe.Pointer(pTab)).FpStmt)
		sqlite3.Xsqlite3_free(tls, pVtab)
	}
	return SQLITE_OK
}

func dbdataBestIndex(tls *libc.TLS, tab uintptr, pIdx uintptr) int32 {
	var pTab uintptr = tab
	var i int32
	var iSchema int32 = -1
	var iPgno int32 = -1
	var colSchema int32 = func() int32 {
		if (*DbdataTable)(unsafe.Pointer(pTab)).FbPtr != 0 {
			return DBPTR_COLUMN_SCHEMA
		}
		return DBDATA_COLUMN_SCHEMA
	}()

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdx)).FnConstraint; i++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaConstraint + uintptr(i)*12
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == colSchema {
				if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) == 0 {
					return SQLITE_CONSTRAINT
				}
				iSchema = i
			}
			if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == DBDATA_COLUMN_PGNO && (*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0 {
				iPgno = i
			}
		}
	}

	if iSchema >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaConstraintUsage + uintptr(iSchema)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaConstraintUsage + uintptr(iSchema)*8)).Fomit = uint8(1)
	}
	if iPgno >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaConstraintUsage + uintptr(iPgno)*8)).FargvIndex = 1 + libc.Bool32(iSchema >= 0)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaConstraintUsage + uintptr(iPgno)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdx)).FestimatedCost = float64(100)
		(*sqlite3_index_info)(unsafe.Pointer(pIdx)).FestimatedRows = int64(50)

		if (*DbdataTable)(unsafe.Pointer(pTab)).FbPtr == 0 && (*sqlite3_index_info)(unsafe.Pointer(pIdx)).FnOrderBy != 0 && int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaOrderBy)).Fdesc) == 0 {
			var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaOrderBy)).FiColumn
			if (*sqlite3_index_info)(unsafe.Pointer(pIdx)).FnOrderBy == 1 {
				(*sqlite3_index_info)(unsafe.Pointer(pIdx)).ForderByConsumed = libc.Bool32(iCol == 0 || iCol == 1)
			} else if (*sqlite3_index_info)(unsafe.Pointer(pIdx)).FnOrderBy == 2 && int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaOrderBy+1*8)).Fdesc) == 0 && iCol == 0 {
				(*sqlite3_index_info)(unsafe.Pointer(pIdx)).ForderByConsumed = libc.Bool32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdx)).FaOrderBy+1*8)).FiColumn == 1)
			}
		}

	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdx)).FestimatedCost = float64(100000000)
		(*sqlite3_index_info)(unsafe.Pointer(pIdx)).FestimatedRows = int64(1000000000)
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdx)).FidxNum = func() int32 {
		if iSchema >= 0 {
			return 0x01
		}
		return 0x00
	}() | func() int32 {
		if iPgno >= 0 {
			return 0x02
		}
		return 0x00
	}()
	return SQLITE_OK
}

func dbdataOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCsr uintptr

	pCsr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(DbdataCursor{})))
	if pCsr == uintptr(0) {
		return SQLITE_NOMEM
	} else {
		libc.Xmemset(tls, pCsr, 0, uint32(unsafe.Sizeof(DbdataCursor{})))
		(*DbdataCursor)(unsafe.Pointer(pCsr)).Fbase.FpVtab = pVTab
	}

	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return SQLITE_OK
}

func dbdataResetCursor(tls *libc.TLS, pCsr uintptr) {
	var pTab uintptr = (*DbdataCursor)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	if (*DbdataTable)(unsafe.Pointer(pTab)).FpStmt == uintptr(0) {
		(*DbdataTable)(unsafe.Pointer(pTab)).FpStmt = (*DbdataCursor)(unsafe.Pointer(pCsr)).FpStmt
	} else {
		sqlite3.Xsqlite3_finalize(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpStmt)
	}
	(*DbdataCursor)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	(*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno = 1
	(*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell = 0
	(*DbdataCursor)(unsafe.Pointer(pCsr)).FiField = 0
	(*DbdataCursor)(unsafe.Pointer(pCsr)).FbOnePage = 0
	sqlite3.Xsqlite3_free(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage)
	sqlite3.Xsqlite3_free(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec)
	(*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec = uintptr(0)
	(*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage = uintptr(0)
}

func dbdataClose(tls *libc.TLS, pCursor uintptr) int32 {
	var pCsr uintptr = pCursor
	dbdataResetCursor(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

func get_uint16(tls *libc.TLS, a uintptr) u32 {
	return u32(int32(*(*uint8)(unsafe.Pointer(a)))<<8 | int32(*(*uint8)(unsafe.Pointer(a + 1))))
}

func get_uint32(tls *libc.TLS, a uintptr) u32 {
	return u32(*(*uint8)(unsafe.Pointer(a)))<<24 |
		u32(*(*uint8)(unsafe.Pointer(a + 1)))<<16 |
		u32(*(*uint8)(unsafe.Pointer(a + 2)))<<8 |
		u32(*(*uint8)(unsafe.Pointer(a + 3)))
}

func dbdataLoadPage(tls *libc.TLS, pCsr uintptr, pgno u32, ppPage uintptr, pnPage uintptr) int32 {
	var rc2 int32
	var rc int32 = SQLITE_OK
	var pStmt uintptr = (*DbdataCursor)(unsafe.Pointer(pCsr)).FpStmt

	*(*uintptr)(unsafe.Pointer(ppPage)) = uintptr(0)
	*(*int32)(unsafe.Pointer(pnPage)) = 0
	if pgno > u32(0) {
		sqlite3.Xsqlite3_bind_int64(tls, pStmt, 2, int64(pgno))
		if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
			var nCopy int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 0)
			if nCopy > 0 {
				var pPage uintptr
				pPage = sqlite3.Xsqlite3_malloc64(tls, uint64(nCopy+DBDATA_PADDING_BYTES))
				if pPage == uintptr(0) {
					rc = SQLITE_NOMEM
				} else {
					var pCopy uintptr = sqlite3.Xsqlite3_column_blob(tls, pStmt, 0)
					libc.Xmemcpy(tls, pPage, pCopy, uint32(nCopy))
					libc.Xmemset(tls, pPage+uintptr(nCopy), 0, uint32(DBDATA_PADDING_BYTES))
				}
				*(*uintptr)(unsafe.Pointer(ppPage)) = pPage
				*(*int32)(unsafe.Pointer(pnPage)) = nCopy
			}
		}
		rc2 = sqlite3.Xsqlite3_reset(tls, pStmt)
		if rc == SQLITE_OK {
			rc = rc2
		}
	}

	return rc
}

func dbdataGetVarint(tls *libc.TLS, z uintptr, pVal uintptr) int32 {
	var u sqlite3_uint64 = uint64(0)
	var i int32
	for i = 0; i < 8; i++ {
		u = u<<7 + sqlite3_uint64(int32(*(*u8)(unsafe.Pointer(z + uintptr(i))))&0x7f)
		if int32(*(*u8)(unsafe.Pointer(z + uintptr(i))))&0x80 == 0 {
			*(*sqlite3_int64)(unsafe.Pointer(pVal)) = sqlite3_int64(u)
			return i + 1
		}
	}
	u = u<<8 + sqlite3_uint64(int32(*(*u8)(unsafe.Pointer(z + uintptr(i))))&0xff)
	*(*sqlite3_int64)(unsafe.Pointer(pVal)) = sqlite3_int64(u)
	return 9
}

func dbdataGetVarintU32(tls *libc.TLS, z uintptr, pVal uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var nRet int32 = dbdataGetVarint(tls, z, bp)
	if *(*sqlite3_int64)(unsafe.Pointer(bp)) < int64(0) || *(*sqlite3_int64)(unsafe.Pointer(bp)) > int64(0xFFFFFFFF) {
		*(*sqlite3_int64)(unsafe.Pointer(bp)) = int64(0)
	}
	*(*sqlite3_int64)(unsafe.Pointer(pVal)) = *(*sqlite3_int64)(unsafe.Pointer(bp))
	return nRet
}

func dbdataValueBytes(tls *libc.TLS, eType int32) int32 {
	switch eType {
	case 0:
		fallthrough
	case 8:
		fallthrough
	case 9:
		fallthrough
	case 10:
		fallthrough
	case 11:
		return 0
	case 1:
		return 1
	case 2:
		return 2
	case 3:
		return 3
	case 4:
		return 4
	case 5:
		return 6
	case 6:
		fallthrough
	case 7:
		return 8
	default:
		if eType > 0 {
			return (eType - 12) / 2
		}
		return 0
	}
	return int32(0)
}

func dbdataValue(tls *libc.TLS, pCtx uintptr, enc u32, eType int32, pData uintptr, nData sqlite3_int64) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if eType >= 0 && sqlite3_int64(dbdataValueBytes(tls, eType)) <= nData {
		switch eType {
		case 0:
			fallthrough
		case 10:
			fallthrough
		case 11:
			sqlite3.Xsqlite3_result_null(tls, pCtx)
			break
			fallthrough

		case 8:
			sqlite3.Xsqlite3_result_int(tls, pCtx, 0)
			break
			fallthrough
		case 9:
			sqlite3.Xsqlite3_result_int(tls, pCtx, 1)
			break
			fallthrough

		case 1:
			fallthrough
		case 2:
			fallthrough
		case 3:
			fallthrough
		case 4:
			fallthrough
		case 5:
			fallthrough
		case 6:
			fallthrough
		case 7:
			{
				*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = sqlite3_uint64(int8(*(*u8)(unsafe.Pointer(pData))))
				pData++
				switch eType {
				case 7:
					fallthrough
				case 6:
					*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 8))<<16 + sqlite3_uint64(int32(*(*u8)(unsafe.Pointer(pData)))<<8) + sqlite3_uint64(*(*u8)(unsafe.Pointer(pData + 1)))
					pData += uintptr(2)
					fallthrough
				case 5:
					*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 8))<<16 + sqlite3_uint64(int32(*(*u8)(unsafe.Pointer(pData)))<<8) + sqlite3_uint64(*(*u8)(unsafe.Pointer(pData + 1)))
					pData += uintptr(2)
					fallthrough
				case 4:
					*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 8))<<8 + sqlite3_uint64(*(*u8)(unsafe.Pointer(pData)))
					pData++
					fallthrough
				case 3:
					*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 8))<<8 + sqlite3_uint64(*(*u8)(unsafe.Pointer(pData)))
					pData++
					fallthrough
				case 2:
					*(*sqlite3_uint64)(unsafe.Pointer(bp + 8)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 8))<<8 + sqlite3_uint64(*(*u8)(unsafe.Pointer(pData)))
					pData++
				}

				if eType == 7 {
					libc.Xmemcpy(tls, bp, bp+8, uint32(unsafe.Sizeof(float64(0))))
					sqlite3.Xsqlite3_result_double(tls, pCtx, *(*float64)(unsafe.Pointer(bp)))
				} else {
					sqlite3.Xsqlite3_result_int64(tls, pCtx, sqlite3_int64(*(*sqlite3_uint64)(unsafe.Pointer(bp + 8))))
				}
				break

			}
			fallthrough

		default:
			{
				var n int32 = (eType - 12) / 2
				if eType%2 != 0 {
					switch enc {
					case u32(SQLITE_UTF16BE):
						sqlite3.Xsqlite3_result_text16be(tls, pCtx, pData, n, libc.UintptrFromInt32(-1))
						break
						fallthrough
					case u32(SQLITE_UTF16LE):
						sqlite3.Xsqlite3_result_text16le(tls, pCtx, pData, n, libc.UintptrFromInt32(-1))
						break
						fallthrough
					default:
						sqlite3.Xsqlite3_result_text(tls, pCtx, pData, n, libc.UintptrFromInt32(-1))
						break
					}
				} else {
					sqlite3.Xsqlite3_result_blob(tls, pCtx, pData, n, libc.UintptrFromInt32(-1))
				}

			}
		}
	}
}

func dbdataNext(tls *libc.TLS, pCursor uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pCsr uintptr = pCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab

	(*DbdataCursor)(unsafe.Pointer(pCsr)).FiRowid++
	for 1 != 0 {
		var rc int32
		var iOff int32 = func() int32 {
			if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno == 1 {
				return 100
			}
			return 0
		}()
		var bNextPage int32 = 0

		if (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage == uintptr(0) {
			for 1 != 0 {
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FbOnePage == 0 && (*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno > (*DbdataCursor)(unsafe.Pointer(pCsr)).FszDb {
					return SQLITE_OK
				}
				rc = dbdataLoadPage(tls, pCsr, uint32((*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno), pCsr+12, pCsr+16)
				if rc != SQLITE_OK {
					return rc
				}
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage != 0 && (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage >= 256 {
					break
				}
				sqlite3.Xsqlite3_free(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage)
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage = uintptr(0)
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FbOnePage != 0 {
					return SQLITE_OK
				}
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno++
			}

			(*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell = func() int32 {
				if (*DbdataTable)(unsafe.Pointer(pTab)).FbPtr != 0 {
					return -2
				}
				return 0
			}()
			(*DbdataCursor)(unsafe.Pointer(pCsr)).FnCell = int32(get_uint16(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff+3)))
		}

		if (*DbdataTable)(unsafe.Pointer(pTab)).FbPtr != 0 {
			if int32(*(*u8)(unsafe.Pointer((*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage + uintptr(iOff)))) != 0x02 && int32(*(*u8)(unsafe.Pointer((*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage + uintptr(iOff)))) != 0x05 {
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell = (*DbdataCursor)(unsafe.Pointer(pCsr)).FnCell
			}
			(*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell++
			if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell >= (*DbdataCursor)(unsafe.Pointer(pCsr)).FnCell {
				sqlite3.Xsqlite3_free(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage)
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage = uintptr(0)
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FbOnePage != 0 {
					return SQLITE_OK
				}
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno++
			} else {
				return SQLITE_OK
			}
		} else {
			if (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec == uintptr(0) {
				var bHasRowid int32 = 0
				var nPointer int32 = 0
				*(*sqlite3_int64)(unsafe.Pointer(bp)) = int64(0)
				*(*sqlite3_int64)(unsafe.Pointer(bp + 16)) = int64(0)
				var iHdr int32
				var U int32
				var X int32
				var nLocal int32

				switch int32(*(*u8)(unsafe.Pointer((*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage + uintptr(iOff)))) {
				case 0x02:
					nPointer = 4
					break
					fallthrough
				case 0x0a:
					break
					fallthrough
				case 0x0d:
					bHasRowid = 1
					break
					fallthrough
				default:
					(*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell = (*DbdataCursor)(unsafe.Pointer(pCsr)).FnCell
					break
				}

				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell >= (*DbdataCursor)(unsafe.Pointer(pCsr)).FnCell {
					bNextPage = 1
				} else {
					iOff = iOff + (8 + nPointer + (*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell*2)
					if iOff > (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage {
						bNextPage = 1
					} else {
						iOff = int32(get_uint16(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff)))
					}

					iOff = iOff + nPointer

					if bNextPage != 0 || iOff > (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage {
						bNextPage = 1
					} else {
						iOff = iOff + dbdataGetVarintU32(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff), bp)
					}

					if bHasRowid != 0 && !(bNextPage != 0) && iOff < (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage {
						iOff = iOff + dbdataGetVarint(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff), pCsr+80)
					}

					U = (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage
					if bHasRowid != 0 {
						X = U - 35
					} else {
						X = (U-12)*64/255 - 23
					}
					if *(*sqlite3_int64)(unsafe.Pointer(bp)) <= sqlite3_int64(X) {
						nLocal = int32(*(*sqlite3_int64)(unsafe.Pointer(bp)))
					} else {
						var M int32
						var K int32
						M = (U-12)*32/255 - 23
						K = int32(sqlite3_int64(M) + (*(*sqlite3_int64)(unsafe.Pointer(bp))-sqlite3_int64(M))%sqlite3_int64(U-4))
						if K <= X {
							nLocal = K
						} else {
							nLocal = M
						}
					}

					if bNextPage != 0 || nLocal+iOff > (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage {
						bNextPage = 1
					} else {
						(*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec = sqlite3.Xsqlite3_malloc64(tls, uint64(*(*sqlite3_int64)(unsafe.Pointer(bp))+int64(DBDATA_PADDING_BYTES)))
						if (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec == uintptr(0) {
							return SQLITE_NOMEM
						}
						libc.Xmemset(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec, 0, uint32(*(*sqlite3_int64)(unsafe.Pointer(bp))+int64(DBDATA_PADDING_BYTES)))
						(*DbdataCursor)(unsafe.Pointer(pCsr)).FnRec = *(*sqlite3_int64)(unsafe.Pointer(bp))

						libc.Xmemcpy(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff), uint32(nLocal))
						iOff = iOff + nLocal

						if *(*sqlite3_int64)(unsafe.Pointer(bp)) > sqlite3_int64(nLocal) {
							var nRem sqlite3_int64 = *(*sqlite3_int64)(unsafe.Pointer(bp)) - sqlite3_int64(nLocal)
							var pgnoOvfl u32 = get_uint32(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff))
							for nRem > int64(0) {
								*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(0)
								*(*int32)(unsafe.Pointer(bp + 12)) = 0
								var nCopy int32
								rc = dbdataLoadPage(tls, pCsr, pgnoOvfl, bp+8, bp+12)

								if rc != SQLITE_OK {
									return rc
								}
								if *(*uintptr)(unsafe.Pointer(bp + 8)) == uintptr(0) {
									break
								}

								nCopy = U - 4
								if sqlite3_int64(nCopy) > nRem {
									nCopy = int32(nRem)
								}
								libc.Xmemcpy(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec+uintptr(*(*sqlite3_int64)(unsafe.Pointer(bp))-nRem), *(*uintptr)(unsafe.Pointer(bp + 8))+4, uint32(nCopy))
								nRem = nRem - sqlite3_int64(nCopy)

								pgnoOvfl = get_uint32(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
								sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
							}
						}

						iHdr = dbdataGetVarintU32(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec, bp+16)
						if *(*sqlite3_int64)(unsafe.Pointer(bp + 16)) > *(*sqlite3_int64)(unsafe.Pointer(bp)) {
							*(*sqlite3_int64)(unsafe.Pointer(bp + 16)) = int64(0)
						}
						(*DbdataCursor)(unsafe.Pointer(pCsr)).FnHdr = *(*sqlite3_int64)(unsafe.Pointer(bp + 16))
						(*DbdataCursor)(unsafe.Pointer(pCsr)).FpHdrPtr = (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec + uintptr(iHdr)
						(*DbdataCursor)(unsafe.Pointer(pCsr)).FpPtr = (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec + uintptr((*DbdataCursor)(unsafe.Pointer(pCsr)).FnHdr)
						(*DbdataCursor)(unsafe.Pointer(pCsr)).FiField = func() int32 {
							if bHasRowid != 0 {
								return -1
							}
							return 0
						}()
					}
				}
			} else {
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FiField++
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiField > 0 {
					if (*DbdataCursor)(unsafe.Pointer(pCsr)).FpHdrPtr > (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec+uintptr((*DbdataCursor)(unsafe.Pointer(pCsr)).FnRec) {
						bNextPage = 1
					} else {
						*(*uintptr)(unsafe.Pointer(pCsr + 68)) += uintptr(dbdataGetVarintU32(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpHdrPtr, bp+24))
						*(*uintptr)(unsafe.Pointer(pCsr + 72)) += uintptr(dbdataValueBytes(tls, int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 24)))))
					}
				}
			}

			if bNextPage != 0 {
				sqlite3.Xsqlite3_free(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage)
				sqlite3.Xsqlite3_free(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec)
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage = uintptr(0)
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec = uintptr(0)
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FbOnePage != 0 {
					return SQLITE_OK
				}
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno++
			} else {
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiField < 0 || (*DbdataCursor)(unsafe.Pointer(pCsr)).FpHdrPtr < (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec+uintptr((*DbdataCursor)(unsafe.Pointer(pCsr)).FnHdr) {
					return SQLITE_OK
				}

				sqlite3.Xsqlite3_free(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec)
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec = uintptr(0)
				(*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell++
			}
		}
	}

	return SQLITE_OK
}

func dbdataEof(tls *libc.TLS, pCursor uintptr) int32 {
	var pCsr uintptr = pCursor
	return libc.Bool32((*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage == uintptr(0))
}

func dbdataIsFunction(tls *libc.TLS, zSchema uintptr) int32 {
	var n size_t = libc.Xstrlen(tls, zSchema)
	if n > size_t(2) && int32(*(*int8)(unsafe.Pointer(zSchema + uintptr(n-size_t(2))))) == '(' && int32(*(*int8)(unsafe.Pointer(zSchema + uintptr(n-size_t(1))))) == ')' {
		return int32(n) - 2
	}
	return 0
}

func dbdataDbsize(tls *libc.TLS, pCsr uintptr, zSchema uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var pTab uintptr = (*DbdataCursor)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	var zSql uintptr = uintptr(0)
	var rc int32
	var rc2 int32
	var nFunc int32 = 0
	*(*uintptr)(unsafe.Pointer(bp + 24)) = uintptr(0)

	if libc.AssignInt32(&nFunc, dbdataIsFunction(tls, zSchema)) > 0 {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+10429, libc.VaList(bp, nFunc, zSchema))
	} else {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+10444, libc.VaList(bp+16, zSchema))
	}
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*DbdataTable)(unsafe.Pointer(pTab)).Fdb, zSql, -1, bp+24, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24))) == SQLITE_ROW {
		(*DbdataCursor)(unsafe.Pointer(pCsr)).FszDb = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), 0)
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
	if rc == SQLITE_OK {
		rc = rc2
	}
	return rc
}

func dbdataGetEncoding(tls *libc.TLS, pCsr uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	*(*int32)(unsafe.Pointer(bp + 4)) = 0
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	rc = dbdataLoadPage(tls, pCsr, uint32(1), bp, bp+4)
	if rc == SQLITE_OK && *(*int32)(unsafe.Pointer(bp + 4)) >= 56+4 {
		(*DbdataCursor)(unsafe.Pointer(pCsr)).Fenc = get_uint32(tls, *(*uintptr)(unsafe.Pointer(bp))+56)
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp)))
	return rc
}

func dbdataFilter(tls *libc.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pCsr uintptr = pCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	var rc int32 = SQLITE_OK
	var zSchema uintptr = ts + 85
	_ = idxStr
	_ = argc

	dbdataResetCursor(tls, pCsr)

	if idxNum&0x01 != 0 {
		zSchema = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		if zSchema == uintptr(0) {
			zSchema = ts + 584
		}
	}
	if idxNum&0x02 != 0 {
		(*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum&0x01)*4)))
		(*DbdataCursor)(unsafe.Pointer(pCsr)).FbOnePage = 1
	} else {
		rc = dbdataDbsize(tls, pCsr, zSchema)
	}

	if rc == SQLITE_OK {
		var nFunc int32 = 0
		if (*DbdataTable)(unsafe.Pointer(pTab)).FpStmt != 0 {
			(*DbdataCursor)(unsafe.Pointer(pCsr)).FpStmt = (*DbdataTable)(unsafe.Pointer(pTab)).FpStmt
			(*DbdataTable)(unsafe.Pointer(pTab)).FpStmt = uintptr(0)
		} else if libc.AssignInt32(&nFunc, dbdataIsFunction(tls, zSchema)) > 0 {
			var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+10465, libc.VaList(bp, nFunc, zSchema))
			if zSql == uintptr(0) {
				rc = SQLITE_NOMEM
			} else {
				rc = sqlite3.Xsqlite3_prepare_v2(tls, (*DbdataTable)(unsafe.Pointer(pTab)).Fdb, zSql, -1, pCsr+4, uintptr(0))
				sqlite3.Xsqlite3_free(tls, zSql)
			}
		} else {
			rc = sqlite3.Xsqlite3_prepare_v2(tls, (*DbdataTable)(unsafe.Pointer(pTab)).Fdb,
				ts+10481, -1,
				pCsr+4, uintptr(0))
		}
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_bind_text(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpStmt, 1, zSchema, -1, libc.UintptrFromInt32(-1))
	} else {
		(*DbdataTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+16, sqlite3.Xsqlite3_errmsg(tls, (*DbdataTable)(unsafe.Pointer(pTab)).Fdb)))
	}

	if rc == SQLITE_OK {
		rc = dbdataGetEncoding(tls, pCsr)
	}

	if rc == SQLITE_OK {
		rc = dbdataNext(tls, pCursor)
	}
	return rc
}

func dbdataColumn(tls *libc.TLS, pCursor uintptr, ctx uintptr, i int32) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = pCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	if (*DbdataTable)(unsafe.Pointer(pTab)).FbPtr != 0 {
		switch i {
		case DBPTR_COLUMN_PGNO:
			sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno))
			break
			fallthrough
		case DBPTR_COLUMN_CHILD:
			{
				var iOff int32
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno == 1 {
					iOff = 100
				} else {
					iOff = 0
				}
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell < 0 {
					iOff = iOff + 8
				} else {
					iOff = iOff + (12 + (*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell*2)
					if iOff > (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage {
						return SQLITE_OK
					}
					iOff = int32(get_uint16(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff)))
				}
				if iOff <= (*DbdataCursor)(unsafe.Pointer(pCsr)).FnPage {
					sqlite3.Xsqlite3_result_int64(tls, ctx, int64(get_uint32(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FaPage+uintptr(iOff))))
				}
				break

			}
		}
	} else {
		switch i {
		case DBDATA_COLUMN_PGNO:
			sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*DbdataCursor)(unsafe.Pointer(pCsr)).FiPgno))
			break
			fallthrough
		case DBDATA_COLUMN_CELL:
			sqlite3.Xsqlite3_result_int(tls, ctx, (*DbdataCursor)(unsafe.Pointer(pCsr)).FiCell)
			break
			fallthrough
		case DBDATA_COLUMN_FIELD:
			sqlite3.Xsqlite3_result_int(tls, ctx, (*DbdataCursor)(unsafe.Pointer(pCsr)).FiField)
			break
			fallthrough
		case DBDATA_COLUMN_VALUE:
			{
				if (*DbdataCursor)(unsafe.Pointer(pCsr)).FiField < 0 {
					sqlite3.Xsqlite3_result_int64(tls, ctx, (*DbdataCursor)(unsafe.Pointer(pCsr)).FiIntkey)
				} else if (*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec+uintptr((*DbdataCursor)(unsafe.Pointer(pCsr)).FnRec) >= (*DbdataCursor)(unsafe.Pointer(pCsr)).FpPtr {
					dbdataGetVarintU32(tls, (*DbdataCursor)(unsafe.Pointer(pCsr)).FpHdrPtr, bp)
					dbdataValue(tls,
						ctx, (*DbdataCursor)(unsafe.Pointer(pCsr)).Fenc, int32(*(*sqlite3_int64)(unsafe.Pointer(bp))), (*DbdataCursor)(unsafe.Pointer(pCsr)).FpPtr,
						int64((int32((*DbdataCursor)(unsafe.Pointer(pCsr)).FpRec+uintptr((*DbdataCursor)(unsafe.Pointer(pCsr)).FnRec))-int32((*DbdataCursor)(unsafe.Pointer(pCsr)).FpPtr))/1))
				}
				break

			}
		}
	}
	return SQLITE_OK
}

func dbdataRowid(tls *libc.TLS, pCursor uintptr, pRowid uintptr) int32 {
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*DbdataCursor)(unsafe.Pointer(pCsr)).FiRowid
	return SQLITE_OK
}

func sqlite3DbdataRegister(tls *libc.TLS, db uintptr) int32 {
	var rc int32 = sqlite3.Xsqlite3_create_module(tls, db, ts+10528, uintptr(unsafe.Pointer(&dbdata_module)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+10542, uintptr(unsafe.Pointer(&dbdata_module)), uintptr(1))
	}
	return rc
}

var dbdata_module = sqlite3_module{
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_dbdata_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	_ = pApi

	_ = pzErrMsg
	return sqlite3DbdataRegister(tls, db)
}

type sqlite3_recover1 = struct {
	FdbIn              uintptr
	FzDb               uintptr
	FzUri              uintptr
	FpSqlCtx           uintptr
	FxSql              uintptr
	FzStateDb          uintptr
	FzLostAndFound     uintptr
	FbFreelistCorrupt  int32
	FbRecoverRowid     int32
	FbSlowIndexes      int32
	Fpgsz              int32
	Fdetected_pgsz     int32
	FnReserve          int32
	FpPage1Disk        uintptr
	FpPage1Cache       uintptr
	FerrCode           int32
	FzErrMsg           uintptr
	FeState            int32
	FbCloseTransaction int32
	Fw1                RecoverStateW1
	Flaf               RecoverStateLAF
	FdbOut             uintptr
	FpGetPage          uintptr
	FpTblList          uintptr
}

type sqlite3_recover = sqlite3_recover1

type RecoverTable1 = struct {
	FiRoot      u32
	FzTab       uintptr
	FnCol       int32
	FaCol       uintptr
	FbIntkey    int32
	FiRowidBind int32
	FpNext      uintptr
}

type RecoverTable = RecoverTable1
type RecoverColumn1 = struct {
	FiField  int32
	FiBind   int32
	FbIPK    int32
	FzCol    uintptr
	FeHidden int32
}

type RecoverColumn = RecoverColumn1

type RecoverBitmap1 = struct {
	FnPg   i64
	FaElem [1]u32
}

type RecoverBitmap = RecoverBitmap1

type RecoverStateW11 = struct {
	FpTbls      uintptr
	FpSel       uintptr
	FpInsert    uintptr
	FnInsert    int32
	FpTab       uintptr
	FnMax       int32
	FapVal      uintptr
	FnVal       int32
	FbHaveRowid int32
	FiRowid     i64
	FiPrevPage  i64
	FiPrevCell  int32
}

type RecoverStateW1 = RecoverStateW11

type RecoverStateLAF1 = struct {
	FpUsed         uintptr
	FnPg           i64
	FpAllAndParent uintptr
	FpMapInsert    uintptr
	FpMaxField     uintptr
	FpUsedPages    uintptr
	FpFindRoot     uintptr
	FpInsert       uintptr
	FpAllPage      uintptr
	FpPageData     uintptr
	FapVal         uintptr
	FnMaxField     int32
}

type RecoverStateLAF = RecoverStateLAF1

type RecoverGlobal1 = struct {
	FpMethods uintptr
	Fp        uintptr
}

type RecoverGlobal = RecoverGlobal1

var recover_g RecoverGlobal

func recoverEnterMutex(tls *libc.TLS) {
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_APP2))
}

func recoverLeaveMutex(tls *libc.TLS) {
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_APP2))
}

func recoverStrlen(tls *libc.TLS, zStr uintptr) int32 {
	if zStr == uintptr(0) {
		return 0
	}
	return int32(libc.Xstrlen(tls, zStr) & size_t(0x7fffffff))
}

func recoverMalloc(tls *libc.TLS, p uintptr, nByte i64) uintptr {
	var pRet uintptr = uintptr(0)

	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		pRet = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
		if pRet != 0 {
			libc.Xmemset(tls, pRet, 0, uint32(nByte))
		} else {
			(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = SQLITE_NOMEM
		}
	}
	return pRet
}

func recoverError(tls *libc.TLS, p uintptr, errCode int32, zFmt uintptr, va uintptr) int32 {
	var z uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	if zFmt != 0 {
		z = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
		_ = ap
	}
	sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FzErrMsg)
	(*sqlite3_recover)(unsafe.Pointer(p)).FzErrMsg = z
	(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = errCode
	return errCode
}

func recoverBitmapAlloc(tls *libc.TLS, p uintptr, nPg i64) uintptr {
	var nElem int32 = int32((nPg + int64(1) + int64(31)) / int64(32))
	var nByte int32 = int32(uint32(unsafe.Sizeof(RecoverBitmap{})) + uint32(nElem)*uint32(unsafe.Sizeof(u32(0))))
	var pRet uintptr = recoverMalloc(tls, p, int64(nByte))

	if pRet != 0 {
		(*RecoverBitmap)(unsafe.Pointer(pRet)).FnPg = nPg
	}
	return pRet
}

func recoverBitmapFree(tls *libc.TLS, pMap uintptr) {
	sqlite3.Xsqlite3_free(tls, pMap)
}

func recoverBitmapSet(tls *libc.TLS, pMap uintptr, iPg i64) {
	if iPg <= (*RecoverBitmap)(unsafe.Pointer(pMap)).FnPg {
		var iElem int32 = int32(iPg / int64(32))
		var iBit int32 = int32(iPg % int64(32))
		*(*u32)(unsafe.Pointer(pMap + 8 + uintptr(iElem)*4)) |= u32(1) << iBit
	}
}

func recoverBitmapQuery(tls *libc.TLS, pMap uintptr, iPg i64) int32 {
	var ret int32 = 1
	if iPg <= (*RecoverBitmap)(unsafe.Pointer(pMap)).FnPg && iPg > int64(0) {
		var iElem int32 = int32(iPg / int64(32))
		var iBit int32 = int32(iPg % int64(32))
		if *(*u32)(unsafe.Pointer(pMap + 8 + uintptr(iElem)*4))&(u32(1)<<iBit) != 0 {
			ret = 1
		} else {
			ret = 0
		}
	}
	return ret
}

func recoverDbError(tls *libc.TLS, p uintptr, db uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	return recoverError(tls, p, sqlite3.Xsqlite3_errcode(tls, db), ts, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
}

func recoverPrepare(tls *libc.TLS, p uintptr, db uintptr, zSql uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		if sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp, uintptr(0)) != 0 {
			recoverDbError(tls, p, db)
		}
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

func recoverPreparePrintf(tls *libc.TLS, p uintptr, db uintptr, zFmt uintptr, va uintptr) uintptr {
	var pStmt uintptr = uintptr(0)
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		var ap va_list
		_ = ap
		var z uintptr
		ap = va
		z = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
		_ = ap
		if z == uintptr(0) {
			(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = SQLITE_NOMEM
		} else {
			pStmt = recoverPrepare(tls, p, db, z)
			sqlite3.Xsqlite3_free(tls, z)
		}
	}
	return pStmt
}

func recoverReset(tls *libc.TLS, p uintptr, pStmt uintptr) uintptr {
	var rc int32 = sqlite3.Xsqlite3_reset(tls, pStmt)
	if rc != SQLITE_OK && rc != SQLITE_CONSTRAINT && (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		recoverDbError(tls, p, sqlite3.Xsqlite3_db_handle(tls, pStmt))
	}
	return pStmt
}

func recoverFinalize(tls *libc.TLS, p uintptr, pStmt uintptr) {
	var db uintptr = sqlite3.Xsqlite3_db_handle(tls, pStmt)
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if rc != SQLITE_OK && (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		recoverDbError(tls, p, db)
	}
}

func recoverExec(tls *libc.TLS, p uintptr, db uintptr, zSql uintptr) int32 {
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		var rc int32 = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		if rc != 0 {
			recoverDbError(tls, p, db)
		}
	}
	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func recoverBindValue(tls *libc.TLS, p uintptr, pStmt uintptr, iBind int32, pVal uintptr) {
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		var rc int32 = sqlite3.Xsqlite3_bind_value(tls, pStmt, iBind, pVal)
		if rc != 0 {
			recoverError(tls, p, rc, uintptr(0), 0)
		}
	}
}

func recoverMPrintf(tls *libc.TLS, p uintptr, zFmt uintptr, va uintptr) uintptr {
	var ap va_list
	_ = ap
	var z uintptr
	ap = va
	z = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		if z == uintptr(0) {
			(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = SQLITE_NOMEM
		}
	} else {
		sqlite3.Xsqlite3_free(tls, z)
		z = uintptr(0)
	}
	return z
}

func recoverPageCount(tls *libc.TLS, p uintptr) i64 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var nPg i64 = int64(0)
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		var pStmt uintptr = uintptr(0)
		pStmt = recoverPreparePrintf(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+10444, libc.VaList(bp, (*sqlite3_recover)(unsafe.Pointer(p)).FzDb))
		if pStmt != 0 {
			sqlite3.Xsqlite3_step(tls, pStmt)
			nPg = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
		}
		recoverFinalize(tls, p, pStmt)
	}
	return nPg
}

func recoverReadI32(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var pBlob uintptr
	var nBlob int32
	var iInt int32

	nBlob = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	pBlob = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	iInt = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))) & 0xFFFF

	if (iInt+1)*4 <= nBlob {
		var a uintptr = pBlob + uintptr(iInt*4)
		var iVal i64 = i64(*(*uint8)(unsafe.Pointer(a)))<<24 +
			i64(*(*uint8)(unsafe.Pointer(a + 1)))<<16 +
			i64(*(*uint8)(unsafe.Pointer(a + 2)))<<8 +
			i64(*(*uint8)(unsafe.Pointer(a + 3)))<<0
		sqlite3.Xsqlite3_result_int64(tls, context, iVal)
	}
}

func recoverPageIsUsed(tls *libc.TLS, pCtx uintptr, nArg int32, apArg uintptr) {
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pgno i64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg)))

	sqlite3.Xsqlite3_result_int(tls, pCtx, recoverBitmapQuery(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpUsed, pgno))
}

func recoverGetPage(tls *libc.TLS, pCtx uintptr, nArg int32, apArg uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pgno i64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg)))
	var pStmt uintptr = uintptr(0)

	if pgno == int64(0) {
		var nPg i64 = recoverPageCount(tls, p)
		sqlite3.Xsqlite3_result_int64(tls, pCtx, nPg)
		return
	} else {
		if (*sqlite3_recover)(unsafe.Pointer(p)).FpGetPage == uintptr(0) {
			pStmt = libc.AssignPtrUintptr(p+188, recoverPreparePrintf(tls,
				p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+10555, libc.VaList(bp, (*sqlite3_recover)(unsafe.Pointer(p)).FzDb)))
		} else if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
			pStmt = (*sqlite3_recover)(unsafe.Pointer(p)).FpGetPage
		}

		if pStmt != 0 {
			sqlite3.Xsqlite3_bind_int64(tls, pStmt, 1, pgno)
			if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
				var aPg uintptr
				var nPg int32

				aPg = sqlite3.Xsqlite3_column_blob(tls, pStmt, 0)
				nPg = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 0)
				if pgno == int64(1) && nPg == (*sqlite3_recover)(unsafe.Pointer(p)).Fpgsz && 0 == libc.Xmemcmp(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache, aPg, uint32(nPg)) {
					aPg = (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Disk
				}
				sqlite3.Xsqlite3_result_blob(tls, pCtx, aPg, nPg-(*sqlite3_recover)(unsafe.Pointer(p)).FnReserve, libc.UintptrFromInt32(-1))
			}
			recoverReset(tls, p, pStmt)
		}
	}

	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode != 0 {
		if (*sqlite3_recover)(unsafe.Pointer(p)).FzErrMsg != 0 {
			sqlite3.Xsqlite3_result_error(tls, pCtx, (*sqlite3_recover)(unsafe.Pointer(p)).FzErrMsg, -1)
		}
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode)
	}
}

func recoverUnusedString(tls *libc.TLS, z uintptr, zA uintptr, zB uintptr, zBuf uintptr) uintptr {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i uint32 = uint32(0)
	if libc.Xstrstr(tls, z, zA) == uintptr(0) {
		return zA
	}
	if libc.Xstrstr(tls, z, zB) == uintptr(0) {
		return zB
	}
	for __ccgo := true; __ccgo; __ccgo = libc.Xstrstr(tls, z, zBuf) != uintptr(0) {
		sqlite3.Xsqlite3_snprintf(tls, 20, zBuf, ts+10603, libc.VaList(bp, zA, libc.PostIncUint32(&i, 1)))
	}
	return zBuf
}

func recoverEscapeCrnl(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zText uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	_ = argc
	if zText != 0 && int32(*(*int8)(unsafe.Pointer(zText))) == '\'' {
		var nText int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var i int32

		var zNL uintptr = uintptr(0)
		var zCR uintptr = uintptr(0)
		var nCR int32 = 0
		var nNL int32 = 0

		for i = 0; *(*int8)(unsafe.Pointer(zText + uintptr(i))) != 0; i++ {
			if zNL == uintptr(0) && int32(*(*int8)(unsafe.Pointer(zText + uintptr(i)))) == '\n' {
				zNL = recoverUnusedString(tls, zText, ts+10610, ts+10613, bp)
				nNL = int32(libc.Xstrlen(tls, zNL))
			}
			if zCR == uintptr(0) && int32(*(*int8)(unsafe.Pointer(zText + uintptr(i)))) == '\r' {
				zCR = recoverUnusedString(tls, zText, ts+10618, ts+10621, bp+20)
				nCR = int32(libc.Xstrlen(tls, zCR))
			}
		}

		if zNL != 0 || zCR != 0 {
			var iOut int32 = 0
			var nMax i64
			if nNL > nCR {
				nMax = int64(nNL)
			} else {
				nMax = int64(nCR)
			}
			var nAlloc i64 = nMax*i64(nText) + (nMax+int64(64))*int64(2)
			var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(nAlloc))
			if zOut == uintptr(0) {
				sqlite3.Xsqlite3_result_error_nomem(tls, context)
				return
			}

			if zNL != 0 && zCR != 0 {
				libc.Xmemcpy(tls, zOut+uintptr(iOut), ts+10626, uint32(16))
				iOut = iOut + 16
			} else {
				libc.Xmemcpy(tls, zOut+uintptr(iOut), ts+10643, uint32(8))
				iOut = iOut + 8
			}
			for i = 0; *(*int8)(unsafe.Pointer(zText + uintptr(i))) != 0; i++ {
				if int32(*(*int8)(unsafe.Pointer(zText + uintptr(i)))) == '\n' {
					libc.Xmemcpy(tls, zOut+uintptr(iOut), zNL, uint32(nNL))
					iOut = iOut + nNL
				} else if int32(*(*int8)(unsafe.Pointer(zText + uintptr(i)))) == '\r' {
					libc.Xmemcpy(tls, zOut+uintptr(iOut), zCR, uint32(nCR))
					iOut = iOut + nCR
				} else {
					*(*int8)(unsafe.Pointer(zOut + uintptr(iOut))) = *(*int8)(unsafe.Pointer(zText + uintptr(i)))
					iOut++
				}
			}

			if zNL != 0 {
				libc.Xmemcpy(tls, zOut+uintptr(iOut), ts+10652, uint32(2))
				iOut = iOut + 2
				libc.Xmemcpy(tls, zOut+uintptr(iOut), zNL, uint32(nNL))
				iOut = iOut + nNL
				libc.Xmemcpy(tls, zOut+uintptr(iOut), ts+10655, uint32(12))
				iOut = iOut + 12
			}
			if zCR != 0 {
				libc.Xmemcpy(tls, zOut+uintptr(iOut), ts+10652, uint32(2))
				iOut = iOut + 2
				libc.Xmemcpy(tls, zOut+uintptr(iOut), zCR, uint32(nCR))
				iOut = iOut + nCR
				libc.Xmemcpy(tls, zOut+uintptr(iOut), ts+10668, uint32(12))
				iOut = iOut + 12
			}

			sqlite3.Xsqlite3_result_text(tls, context, zOut, iOut, libc.UintptrFromInt32(-1))
			sqlite3.Xsqlite3_free(tls, zOut)
			return
		}
	}

	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv)))
}

func recoverCacheSchema(tls *libc.TLS, p uintptr) int32 {
	return recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+10681)
}

func recoverSqlCallback(tls *libc.TLS, p uintptr, zSql uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && (*sqlite3_recover)(unsafe.Pointer(p)).FxSql != 0 {
		var res int32 = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_recover)(unsafe.Pointer(p)).FxSql})).f(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FpSqlCtx, zSql)
		if res != 0 {
			recoverError(tls, p, SQLITE_ERROR, ts+11167, libc.VaList(bp, res))
		}
	}
}

func recoverTransferSettings(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	*(*[5]uintptr)(unsafe.Pointer(bp + 36)) = [5]uintptr{
		ts + 11199,
		ts + 4538,
		ts + 11208,
		ts + 11220,
		ts + 11233,
	}
	var ii int32

	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 32)) = uintptr(0)
		var rc int32 = sqlite3.Xsqlite3_open(tls, ts+584, bp+32)
		if rc != SQLITE_OK {
			recoverDbError(tls, p, *(*uintptr)(unsafe.Pointer(bp + 32)))
			return
		}

		for ii = 0; ii < int32(uint32(unsafe.Sizeof([5]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0)))); ii++ {
			var zPrag uintptr = *(*uintptr)(unsafe.Pointer(bp + 36 + uintptr(ii)*4))
			var p1 uintptr = uintptr(0)
			p1 = recoverPreparePrintf(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+11248, libc.VaList(bp, (*sqlite3_recover)(unsafe.Pointer(p)).FzDb, zPrag))
			if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && sqlite3.Xsqlite3_step(tls, p1) == SQLITE_ROW {
				var zArg uintptr = sqlite3.Xsqlite3_column_text(tls, p1, 0)
				var z2 uintptr = recoverMPrintf(tls, p, ts+11261, libc.VaList(bp+16, zPrag, zArg))
				recoverSqlCallback(tls, p, z2)
				recoverExec(tls, p, *(*uintptr)(unsafe.Pointer(bp + 32)), z2)
				sqlite3.Xsqlite3_free(tls, z2)
				if zArg == uintptr(0) {
					recoverError(tls, p, SQLITE_NOMEM, uintptr(0), 0)
				}
			}
			recoverFinalize(tls, p, p1)
		}
		recoverExec(tls, p, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+11276)

		if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
			var db uintptr = (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut
			var pBackup uintptr = sqlite3.Xsqlite3_backup_init(tls, db, ts+85, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+85)
			if pBackup != 0 {
				sqlite3.Xsqlite3_backup_step(tls, pBackup, -1)
				(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = sqlite3.Xsqlite3_backup_finish(tls, pBackup)
			} else {
				recoverDbError(tls, p, db)
			}
		}

		sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	}
}

func recoverOpenOutput(tls *libc.TLS, p uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	*(*[4]Func)(unsafe.Pointer(bp + 4)) = [4]Func{
		{FzName: ts + 11311, FnArg: 1, FxFunc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{recoverGetPage}))},
		{FzName: ts + 11319, FnArg: 1, FxFunc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{recoverPageIsUsed}))},
		{FzName: ts + 11332, FnArg: 2, FxFunc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{recoverReadI32}))},
		{FzName: ts + 11341, FnArg: 1, FxFunc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{recoverEscapeCrnl}))},
	}

	var flags int32 = SQLITE_OPEN_URI | SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	var ii int32

	if sqlite3.Xsqlite3_open_v2(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FzUri, bp, flags, uintptr(0)) != 0 {
		recoverDbError(tls, p, *(*uintptr)(unsafe.Pointer(bp)))
	}

	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = sqlite3_dbdata_init(tls, *(*uintptr)(unsafe.Pointer(bp)), uintptr(0), uintptr(0))
	}

	for ii = 0; (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && ii < int32(uint32(unsafe.Sizeof([4]Func{}))/uint32(unsafe.Sizeof(Func{}))); ii++ {
		(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp)), (*Func)(unsafe.Pointer(bp+4+uintptr(ii)*12)).FzName,
			(*Func)(unsafe.Pointer(bp+4+uintptr(ii)*12)).FnArg, SQLITE_UTF8, p, (*Func)(unsafe.Pointer(bp+4+uintptr(ii)*12)).FxFunc, uintptr(0), uintptr(0))
	}

	(*sqlite3_recover)(unsafe.Pointer(p)).FdbOut = *(*uintptr)(unsafe.Pointer(bp))
	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

type Func = struct {
	FzName uintptr
	FnArg  int32
	FxFunc uintptr
}

func recoverOpenRecovery(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zSql uintptr = recoverMPrintf(tls, p, ts+11353, libc.VaList(bp, (*sqlite3_recover)(unsafe.Pointer(p)).FzStateDb))
	recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, zSql)
	recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+11376)
	sqlite3.Xsqlite3_free(tls, zSql)
}

func recoverAddTable(tls *libc.TLS, p uintptr, zName uintptr, iRoot i64) {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pStmt uintptr = recoverPreparePrintf(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+11534, libc.VaList(bp, zName))

	if pStmt != 0 {
		var iPk int32 = -1
		var iBind int32 = 1
		var pNew uintptr = uintptr(0)
		var nCol int32 = 0
		var nName int32 = recoverStrlen(tls, zName)
		var nByte int32 = 0
		for sqlite3.Xsqlite3_step(tls, pStmt) == SQLITE_ROW {
			nCol++
			nByte = nByte + (sqlite3.Xsqlite3_column_bytes(tls, pStmt, 1) + 1)
		}
		nByte = int32(uint32(nByte) + (uint32(unsafe.Sizeof(RecoverTable{})) + uint32(nCol)*uint32(unsafe.Sizeof(RecoverColumn{})) + uint32(nName) + uint32(1)))
		recoverReset(tls, p, pStmt)

		pNew = recoverMalloc(tls, p, int64(nByte))
		if pNew != 0 {
			var i int32 = 0
			var iField int32 = 0
			var csr uintptr = uintptr(0)
			(*RecoverTable)(unsafe.Pointer(pNew)).FaCol = pNew + 1*28
			(*RecoverTable)(unsafe.Pointer(pNew)).FzTab = libc.AssignUintptr(&csr, (*RecoverTable)(unsafe.Pointer(pNew)).FaCol+uintptr(nCol)*20)
			(*RecoverTable)(unsafe.Pointer(pNew)).FnCol = nCol
			(*RecoverTable)(unsafe.Pointer(pNew)).FiRoot = u32(iRoot)
			libc.Xmemcpy(tls, csr, zName, uint32(nName))
			csr += uintptr(nName + 1)

			for i = 0; sqlite3.Xsqlite3_step(tls, pStmt) == SQLITE_ROW; i++ {
				var iPKF int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 5)
				var n int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 1)
				var z uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
				var zType uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
				var eHidden int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 6)

				if iPk == -1 && iPKF == 1 && !(sqlite3.Xsqlite3_stricmp(tls, ts+8825, zType) != 0) {
					iPk = i
				}
				if iPKF > 1 {
					iPk = -2
				}
				(*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pNew)).FaCol + uintptr(i)*20)).FzCol = csr
				(*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pNew)).FaCol + uintptr(i)*20)).FeHidden = eHidden
				if eHidden == RECOVER_EHIDDEN_VIRTUAL {
					(*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pNew)).FaCol + uintptr(i)*20)).FiField = -1
				} else {
					(*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pNew)).FaCol + uintptr(i)*20)).FiField = libc.PostIncInt32(&iField, 1)
				}
				if eHidden != RECOVER_EHIDDEN_VIRTUAL &&
					eHidden != RECOVER_EHIDDEN_STORED {
					(*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pNew)).FaCol + uintptr(i)*20)).FiBind = libc.PostIncInt32(&iBind, 1)
				}
				libc.Xmemcpy(tls, csr, z, uint32(n))
				csr += uintptr(n + 1)
			}

			(*RecoverTable)(unsafe.Pointer(pNew)).FpNext = (*sqlite3_recover)(unsafe.Pointer(p)).FpTblList
			(*sqlite3_recover)(unsafe.Pointer(p)).FpTblList = pNew
			(*RecoverTable)(unsafe.Pointer(pNew)).FbIntkey = 1
		}

		recoverFinalize(tls, p, pStmt)

		pStmt = recoverPreparePrintf(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, ts+11557, libc.VaList(bp+8, zName))
		for pStmt != 0 && sqlite3.Xsqlite3_step(tls, pStmt) == SQLITE_ROW {
			var iField int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 0)
			var iCol int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 1)

			(*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pNew)).FaCol + uintptr(iCol)*20)).FiField = iField

			(*RecoverTable)(unsafe.Pointer(pNew)).FbIntkey = 0
			iPk = -2
		}
		recoverFinalize(tls, p, pStmt)

		if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
			if iPk >= 0 {
				(*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pNew)).FaCol + uintptr(iPk)*20)).FbIPK = 1
			} else if (*RecoverTable)(unsafe.Pointer(pNew)).FbIntkey != 0 {
				(*RecoverTable)(unsafe.Pointer(pNew)).FiRowidBind = libc.PostIncInt32(&iBind, 1)
			}
		}
	}
}

func recoverWriteSchema1(tls *libc.TLS, p uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pSelect uintptr = uintptr(0)
	var pTblname uintptr = uintptr(0)

	pSelect = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+11580)

	pTblname = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+11925)

	if pSelect != 0 {
		sqlite3.Xsqlite3_bind_int(tls, pSelect, 1, (*sqlite3_recover)(unsafe.Pointer(p)).FbSlowIndexes)
		for sqlite3.Xsqlite3_step(tls, pSelect) == SQLITE_ROW {
			var iRoot i64 = sqlite3.Xsqlite3_column_int64(tls, pSelect, 0)
			var bTable int32 = sqlite3.Xsqlite3_column_int(tls, pSelect, 1)
			var bVirtual int32 = sqlite3.Xsqlite3_column_int(tls, pSelect, 2)
			var zName uintptr = sqlite3.Xsqlite3_column_text(tls, pSelect, 3)
			var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, pSelect, 4)
			var zFree uintptr = uintptr(0)
			var rc int32 = SQLITE_OK

			if bVirtual != 0 {
				zSql = libc.AssignUintptr(&zFree, recoverMPrintf(tls, p,
					ts+12003,
					libc.VaList(bp, zName, zName, zSql)))
			}
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, zSql, uintptr(0), uintptr(0), uintptr(0))
			if rc == SQLITE_OK {
				recoverSqlCallback(tls, p, zSql)
				if bTable != 0 && !(bVirtual != 0) {
					if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pTblname) {
						var zTbl uintptr = sqlite3.Xsqlite3_column_text(tls, pTblname, 0)
						recoverAddTable(tls, p, zTbl, iRoot)
					}
					recoverReset(tls, p, pTblname)
				}
			} else if rc != SQLITE_ERROR {
				recoverDbError(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut)
			}
			sqlite3.Xsqlite3_free(tls, zFree)
		}
	}
	recoverFinalize(tls, p, pSelect)
	recoverFinalize(tls, p, pTblname)

	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func recoverWriteSchema2(tls *libc.TLS, p uintptr) int32 {
	var pSelect uintptr = uintptr(0)

	pSelect = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		func() uintptr {
			if (*sqlite3_recover)(unsafe.Pointer(p)).FbSlowIndexes != 0 {
				return ts + 12060
			}
			return ts + 12142
		}())

	if pSelect != 0 {
		for sqlite3.Xsqlite3_step(tls, pSelect) == SQLITE_ROW {
			var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, pSelect, 1)
			var rc int32 = sqlite3.Xsqlite3_exec(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, zSql, uintptr(0), uintptr(0), uintptr(0))
			if rc == SQLITE_OK {
				recoverSqlCallback(tls, p, zSql)
			} else if rc != SQLITE_ERROR {
				recoverDbError(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut)
			}
		}
	}
	recoverFinalize(tls, p, pSelect)

	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func recoverInsertStmt(tls *libc.TLS, p uintptr, pTab uintptr, nField int32) uintptr {
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var pRet uintptr = uintptr(0)
	var zSep uintptr = ts + 584
	var zSqlSep uintptr = ts + 584
	var zSql uintptr = uintptr(0)
	var zFinal uintptr = uintptr(0)
	var zBind uintptr = uintptr(0)
	var ii int32
	var bSql int32
	if (*sqlite3_recover)(unsafe.Pointer(p)).FxSql != 0 {
		bSql = 1
	} else {
		bSql = 0
	}

	if nField <= 0 {
		return uintptr(0)
	}

	zSql = recoverMPrintf(tls, p, ts+12253, libc.VaList(bp, (*RecoverTable)(unsafe.Pointer(pTab)).FzTab))

	if (*RecoverTable)(unsafe.Pointer(pTab)).FiRowidBind != 0 {
		zSql = recoverMPrintf(tls, p, ts+12279, libc.VaList(bp+8, zSql))
		if bSql != 0 {
			zBind = recoverMPrintf(tls, p, ts+12289, libc.VaList(bp+16, zBind, (*RecoverTable)(unsafe.Pointer(pTab)).FiRowidBind))
		} else {
			zBind = recoverMPrintf(tls, p, ts+12302, libc.VaList(bp+32, zBind, (*RecoverTable)(unsafe.Pointer(pTab)).FiRowidBind))
		}
		zSqlSep = ts + 12308
		zSep = ts + 97
	}

	for ii = 0; ii < nField; ii++ {
		var eHidden int32 = (*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pTab)).FaCol + uintptr(ii)*20)).FeHidden
		if eHidden != RECOVER_EHIDDEN_VIRTUAL &&
			eHidden != RECOVER_EHIDDEN_STORED {
			zSql = recoverMPrintf(tls, p, ts+12317, libc.VaList(bp+48, zSql, zSep, (*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pTab)).FaCol+uintptr(ii)*20)).FzCol))

			if bSql != 0 {
				zBind = recoverMPrintf(tls, p,
					ts+12324, libc.VaList(bp+72, zBind, zSqlSep, (*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pTab)).FaCol+uintptr(ii)*20)).FiBind))
				zSqlSep = ts + 12308
			} else {
				zBind = recoverMPrintf(tls, p, ts+12352, libc.VaList(bp+96, zBind, zSep, (*RecoverColumn)(unsafe.Pointer((*RecoverTable)(unsafe.Pointer(pTab)).FaCol+uintptr(ii)*20)).FiBind))
			}
			zSep = ts + 97
		}
	}

	if bSql != 0 {
		zFinal = recoverMPrintf(tls, p, ts+12360,
			libc.VaList(bp+120, zSql, zBind))
	} else {
		zFinal = recoverMPrintf(tls, p, ts+12399, libc.VaList(bp+136, zSql, zBind))
	}

	pRet = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, zFinal)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_free(tls, zBind)
	sqlite3.Xsqlite3_free(tls, zFinal)

	return pRet
}

func recoverFindTable(tls *libc.TLS, p uintptr, iRoot u32) uintptr {
	var pRet uintptr = uintptr(0)
	for pRet = (*sqlite3_recover)(unsafe.Pointer(p)).FpTblList; pRet != 0 && (*RecoverTable)(unsafe.Pointer(pRet)).FiRoot != iRoot; pRet = (*RecoverTable)(unsafe.Pointer(pRet)).FpNext {
	}
	return pRet
}

func recoverLostAndFoundCreate(tls *libc.TLS, p uintptr, nField int32) uintptr {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var zTbl uintptr = uintptr(0)
	var pProbe uintptr = uintptr(0)
	var ii int32 = 0

	pProbe = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+12415)
	for ii = -1; zTbl == uintptr(0) && (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && ii < 1000; ii++ {
		var bFail int32 = 0
		if ii < 0 {
			zTbl = recoverMPrintf(tls, p, ts, libc.VaList(bp, (*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound))
		} else {
			zTbl = recoverMPrintf(tls, p, ts+12456, libc.VaList(bp+8, (*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound, ii))
		}

		if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, pProbe, 1, zTbl, -1, uintptr(0))
			if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pProbe) {
				bFail = 1
			}
			recoverReset(tls, p, pProbe)
		}

		if bFail != 0 {
			sqlite3.Xsqlite3_clear_bindings(tls, pProbe)
			sqlite3.Xsqlite3_free(tls, zTbl)
			zTbl = uintptr(0)
		}
	}
	recoverFinalize(tls, p, pProbe)

	if zTbl != 0 {
		var zSep uintptr = uintptr(0)
		var zField uintptr = uintptr(0)
		var zSql uintptr = uintptr(0)

		zSep = ts + 12462
		for ii = 0; (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && ii < nField; ii++ {
			zField = recoverMPrintf(tls, p, ts+12523, libc.VaList(bp+24, zField, zSep, ii))
			zSep = ts + 97
		}

		zSql = recoverMPrintf(tls, p, ts+12531, libc.VaList(bp+48, zTbl, zField))
		sqlite3.Xsqlite3_free(tls, zField)

		recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, zSql)
		recoverSqlCallback(tls, p, zSql)
		sqlite3.Xsqlite3_free(tls, zSql)
	} else if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		recoverError(tls,
			p, SQLITE_ERROR, ts+12551, libc.VaList(bp+64, (*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound))
	}

	return zTbl
}

func recoverLostAndFoundInsert(tls *libc.TLS, p uintptr, zTab uintptr, nField int32) uintptr {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var nTotal int32 = nField + 4
	var ii int32
	var zBind uintptr = uintptr(0)
	var pRet uintptr = uintptr(0)

	if (*sqlite3_recover)(unsafe.Pointer(p)).FxSql == uintptr(0) {
		for ii = 0; ii < nTotal; ii++ {
			zBind = recoverMPrintf(tls, p, ts+12584, libc.VaList(bp, zBind, func() uintptr {
				if zBind != 0 {
					return ts + 97
				}
				return ts + 584
			}(), ii))
		}
		pRet = recoverPreparePrintf(tls,
			p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, ts+12590, libc.VaList(bp+24, zTab, zBind))
	} else {
		var zSep uintptr = ts + 584
		for ii = 0; ii < nTotal; ii++ {
			zBind = recoverMPrintf(tls, p, ts+12616, libc.VaList(bp+40, zBind, zSep))
			zSep = ts + 12629
		}
		pRet = recoverPreparePrintf(tls,
			p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, ts+12640, libc.VaList(bp+56, zTab, zBind))
	}

	sqlite3.Xsqlite3_free(tls, zBind)
	return pRet
}

func recoverLostAndFoundFindRoot(tls *libc.TLS, p uintptr, iPg i64, piRoot uintptr) int32 {
	var pLaf uintptr = p + 132

	if (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpFindRoot == uintptr(0) {
		(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpFindRoot = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
			ts+12685)
	}
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		sqlite3.Xsqlite3_bind_int64(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpFindRoot, 1, iPg)
		if sqlite3.Xsqlite3_step(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpFindRoot) == SQLITE_ROW {
			*(*i64)(unsafe.Pointer(piRoot)) = sqlite3.Xsqlite3_column_int64(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpFindRoot, 0)
		} else {
			*(*i64)(unsafe.Pointer(piRoot)) = iPg
		}
		recoverReset(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpFindRoot)
	}
	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func recoverLostAndFoundOnePage(tls *libc.TLS, p uintptr, iPage i64) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pLaf uintptr = p + 132
	var apVal uintptr = (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FapVal
	var pPageData uintptr = (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpPageData
	var pInsert uintptr = (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpInsert

	var nVal int32 = -1
	var iPrevCell int32 = 0
	*(*i64)(unsafe.Pointer(bp)) = int64(0)
	var bHaveRowid int32 = 0
	var iRowid i64 = int64(0)
	var ii int32 = 0

	if recoverLostAndFoundFindRoot(tls, p, iPage, bp) != 0 {
		return
	}
	sqlite3.Xsqlite3_bind_int64(tls, pPageData, 1, iPage)
	for (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pPageData) {
		var iCell int32 = int32(sqlite3.Xsqlite3_column_int64(tls, pPageData, 0))
		var iField int32 = int32(sqlite3.Xsqlite3_column_int64(tls, pPageData, 1))

		if iPrevCell != iCell && nVal >= 0 {
			sqlite3.Xsqlite3_bind_int64(tls, pInsert, 1, *(*i64)(unsafe.Pointer(bp)))
			sqlite3.Xsqlite3_bind_int64(tls, pInsert, 2, iPage)
			sqlite3.Xsqlite3_bind_int(tls, pInsert, 3, nVal)
			if bHaveRowid != 0 {
				sqlite3.Xsqlite3_bind_int64(tls, pInsert, 4, iRowid)
			}
			for ii = 0; ii < nVal; ii++ {
				recoverBindValue(tls, p, pInsert, 5+ii, *(*uintptr)(unsafe.Pointer(apVal + uintptr(ii)*4)))
			}
			if sqlite3.Xsqlite3_step(tls, pInsert) == SQLITE_ROW {
				recoverSqlCallback(tls, p, sqlite3.Xsqlite3_column_text(tls, pInsert, 0))
			}
			recoverReset(tls, p, pInsert)

			for ii = 0; ii < nVal; ii++ {
				sqlite3.Xsqlite3_value_free(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(ii)*4)))
				*(*uintptr)(unsafe.Pointer(apVal + uintptr(ii)*4)) = uintptr(0)
			}
			sqlite3.Xsqlite3_clear_bindings(tls, pInsert)
			bHaveRowid = 0
			nVal = -1
		}

		if iCell < 0 {
			break
		}

		if iField < 0 {
			iRowid = sqlite3.Xsqlite3_column_int64(tls, pPageData, 2)
			bHaveRowid = 1
			nVal = 0
		} else if iField < (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnMaxField {
			var pVal uintptr = sqlite3.Xsqlite3_column_value(tls, pPageData, 2)
			*(*uintptr)(unsafe.Pointer(apVal + uintptr(iField)*4)) = sqlite3.Xsqlite3_value_dup(tls, pVal)

			nVal = iField + 1
			if *(*uintptr)(unsafe.Pointer(apVal + uintptr(iField)*4)) == uintptr(0) {
				recoverError(tls, p, SQLITE_NOMEM, uintptr(0), 0)
			}
		}

		iPrevCell = iCell
	}
	recoverReset(tls, p, pPageData)

	for ii = 0; ii < nVal; ii++ {
		sqlite3.Xsqlite3_value_free(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(ii)*4)))
		*(*uintptr)(unsafe.Pointer(apVal + uintptr(ii)*4)) = uintptr(0)
	}
}

func recoverLostAndFound3Step(tls *libc.TLS, p uintptr) int32 {
	var pLaf uintptr = p + 132
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		if (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpInsert == uintptr(0) {
			return SQLITE_DONE
		} else {
			if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
				var res int32 = sqlite3.Xsqlite3_step(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllPage)
				if res == SQLITE_ROW {
					var iPage i64 = sqlite3.Xsqlite3_column_int64(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllPage, 0)
					if recoverBitmapQuery(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsed, iPage) == 0 {
						recoverLostAndFoundOnePage(tls, p, iPage)
					}
				} else {
					recoverReset(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllPage)
					return SQLITE_DONE
				}
			}
		}
	}
	return SQLITE_OK
}

func recoverLostAndFound3Init(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pLaf uintptr = p + 132

	if (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnMaxField > 0 {
		var zTab uintptr = uintptr(0)

		zTab = recoverLostAndFoundCreate(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnMaxField)
		(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpInsert = recoverLostAndFoundInsert(tls, p, zTab, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnMaxField)
		sqlite3.Xsqlite3_free(tls, zTab)

		(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllPage = recoverPreparePrintf(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
			ts+12876, libc.VaList(bp, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FnPg))
		(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpPageData = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
			ts+12978)

		(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FapVal = recoverMalloc(tls, p,
			int64(uint32((*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnMaxField)*uint32(unsafe.Sizeof(uintptr(0)))))
	}
}

func recoverWriteDataInit(tls *libc.TLS, p uintptr) int32 {
	var p1 uintptr = p + 76
	var pTbl uintptr = uintptr(0)
	var nByte int32 = 0

	for pTbl = (*sqlite3_recover)(unsafe.Pointer(p)).FpTblList; pTbl != 0; pTbl = (*RecoverTable)(unsafe.Pointer(pTbl)).FpNext {
		if (*RecoverTable)(unsafe.Pointer(pTbl)).FnCol > (*RecoverStateW1)(unsafe.Pointer(p1)).FnMax {
			(*RecoverStateW1)(unsafe.Pointer(p1)).FnMax = (*RecoverTable)(unsafe.Pointer(pTbl)).FnCol
		}
	}

	nByte = int32(uint32(unsafe.Sizeof(uintptr(0))) * uint32((*RecoverStateW1)(unsafe.Pointer(p1)).FnMax+1))
	(*RecoverStateW1)(unsafe.Pointer(p1)).FapVal = recoverMalloc(tls, p, int64(nByte))
	if (*RecoverStateW1)(unsafe.Pointer(p1)).FapVal == uintptr(0) {
		return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
	}

	(*RecoverStateW1)(unsafe.Pointer(p1)).FpTbls = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+13081)
	(*RecoverStateW1)(unsafe.Pointer(p1)).FpSel = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+13219)

	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func recoverWriteDataCleanup(tls *libc.TLS, p uintptr) {
	var p1 uintptr = p + 76
	var ii int32
	for ii = 0; ii < (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal; ii++ {
		sqlite3.Xsqlite3_value_free(tls, *(*uintptr)(unsafe.Pointer((*RecoverStateW1)(unsafe.Pointer(p1)).FapVal + uintptr(ii)*4)))
	}
	sqlite3.Xsqlite3_free(tls, (*RecoverStateW1)(unsafe.Pointer(p1)).FapVal)
	recoverFinalize(tls, p, (*RecoverStateW1)(unsafe.Pointer(p1)).FpInsert)
	recoverFinalize(tls, p, (*RecoverStateW1)(unsafe.Pointer(p1)).FpTbls)
	recoverFinalize(tls, p, (*RecoverStateW1)(unsafe.Pointer(p1)).FpSel)
	libc.Xmemset(tls, p1, 0, uint32(unsafe.Sizeof(RecoverStateW1{})))
}

func recoverWriteDataStep(tls *libc.TLS, p uintptr) int32 {
	var p1 uintptr = p + 76
	var pSel uintptr = (*RecoverStateW1)(unsafe.Pointer(p1)).FpSel
	var apVal uintptr = (*RecoverStateW1)(unsafe.Pointer(p1)).FapVal

	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && (*RecoverStateW1)(unsafe.Pointer(p1)).FpTab == uintptr(0) {
		if sqlite3.Xsqlite3_step(tls, (*RecoverStateW1)(unsafe.Pointer(p1)).FpTbls) == SQLITE_ROW {
			var iRoot i64 = sqlite3.Xsqlite3_column_int64(tls, (*RecoverStateW1)(unsafe.Pointer(p1)).FpTbls, 0)
			(*RecoverStateW1)(unsafe.Pointer(p1)).FpTab = recoverFindTable(tls, p, uint32(iRoot))

			recoverFinalize(tls, p, (*RecoverStateW1)(unsafe.Pointer(p1)).FpInsert)
			(*RecoverStateW1)(unsafe.Pointer(p1)).FpInsert = uintptr(0)

			if (*RecoverStateW1)(unsafe.Pointer(p1)).FpTab == uintptr(0) {
				return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
			}

			if sqlite3.Xsqlite3_stricmp(tls, ts+13467, (*RecoverTable)(unsafe.Pointer((*RecoverStateW1)(unsafe.Pointer(p1)).FpTab)).FzTab) == 0 {
				recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, ts+13483)
				recoverSqlCallback(tls, p, ts+13483)
			}

			sqlite3.Xsqlite3_bind_int64(tls, pSel, 1, iRoot)

			(*RecoverStateW1)(unsafe.Pointer(p1)).FnVal = 0
			(*RecoverStateW1)(unsafe.Pointer(p1)).FbHaveRowid = 0
			(*RecoverStateW1)(unsafe.Pointer(p1)).FiPrevPage = int64(-1)
			(*RecoverStateW1)(unsafe.Pointer(p1)).FiPrevCell = -1
		} else {
			return SQLITE_DONE
		}
	}

	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK && sqlite3.Xsqlite3_step(tls, pSel) == SQLITE_ROW {
		var pTab uintptr = (*RecoverStateW1)(unsafe.Pointer(p1)).FpTab

		var iPage i64 = sqlite3.Xsqlite3_column_int64(tls, pSel, 0)
		var iCell int32 = sqlite3.Xsqlite3_column_int(tls, pSel, 1)
		var iField int32 = sqlite3.Xsqlite3_column_int(tls, pSel, 2)
		var pVal uintptr = sqlite3.Xsqlite3_column_value(tls, pSel, 3)
		var bNewCell int32 = libc.Bool32((*RecoverStateW1)(unsafe.Pointer(p1)).FiPrevPage != iPage || (*RecoverStateW1)(unsafe.Pointer(p1)).FiPrevCell != iCell)

		if bNewCell != 0 {
			var ii int32 = 0
			if (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal >= 0 {
				if (*RecoverStateW1)(unsafe.Pointer(p1)).FpInsert == uintptr(0) || (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal != (*RecoverStateW1)(unsafe.Pointer(p1)).FnInsert {
					recoverFinalize(tls, p, (*RecoverStateW1)(unsafe.Pointer(p1)).FpInsert)
					(*RecoverStateW1)(unsafe.Pointer(p1)).FpInsert = recoverInsertStmt(tls, p, pTab, (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal)
					(*RecoverStateW1)(unsafe.Pointer(p1)).FnInsert = (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal
				}
				if (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal > 0 {
					var pInsert uintptr = (*RecoverStateW1)(unsafe.Pointer(p1)).FpInsert
					for ii = 0; ii < (*RecoverTable)(unsafe.Pointer(pTab)).FnCol; ii++ {
						var pCol uintptr = (*RecoverTable)(unsafe.Pointer(pTab)).FaCol + uintptr(ii)*20
						var iBind int32 = (*RecoverColumn)(unsafe.Pointer(pCol)).FiBind
						if iBind > 0 {
							if (*RecoverColumn)(unsafe.Pointer(pCol)).FbIPK != 0 {
								sqlite3.Xsqlite3_bind_int64(tls, pInsert, iBind, (*RecoverStateW1)(unsafe.Pointer(p1)).FiRowid)
							} else if (*RecoverColumn)(unsafe.Pointer(pCol)).FiField < (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal {
								recoverBindValue(tls, p, pInsert, iBind, *(*uintptr)(unsafe.Pointer(apVal + uintptr((*RecoverColumn)(unsafe.Pointer(pCol)).FiField)*4)))
							}
						}
					}
					if (*sqlite3_recover)(unsafe.Pointer(p)).FbRecoverRowid != 0 && (*RecoverTable)(unsafe.Pointer(pTab)).FiRowidBind > 0 && (*RecoverStateW1)(unsafe.Pointer(p1)).FbHaveRowid != 0 {
						sqlite3.Xsqlite3_bind_int64(tls, pInsert, (*RecoverTable)(unsafe.Pointer(pTab)).FiRowidBind, (*RecoverStateW1)(unsafe.Pointer(p1)).FiRowid)
					}
					if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pInsert) {
						var z uintptr = sqlite3.Xsqlite3_column_text(tls, pInsert, 0)
						recoverSqlCallback(tls, p, z)
					}
					recoverReset(tls, p, pInsert)

					if pInsert != 0 {
						sqlite3.Xsqlite3_clear_bindings(tls, pInsert)
					}
				}
			}

			for ii = 0; ii < (*RecoverStateW1)(unsafe.Pointer(p1)).FnVal; ii++ {
				sqlite3.Xsqlite3_value_free(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(ii)*4)))
				*(*uintptr)(unsafe.Pointer(apVal + uintptr(ii)*4)) = uintptr(0)
			}
			(*RecoverStateW1)(unsafe.Pointer(p1)).FnVal = -1
			(*RecoverStateW1)(unsafe.Pointer(p1)).FbHaveRowid = 0
		}

		if iPage != int64(0) {
			if iField < 0 {
				(*RecoverStateW1)(unsafe.Pointer(p1)).FiRowid = sqlite3.Xsqlite3_column_int64(tls, pSel, 3)

				(*RecoverStateW1)(unsafe.Pointer(p1)).FnVal = 0
				(*RecoverStateW1)(unsafe.Pointer(p1)).FbHaveRowid = 1
			} else if iField < (*RecoverTable)(unsafe.Pointer(pTab)).FnCol {
				*(*uintptr)(unsafe.Pointer(apVal + uintptr(iField)*4)) = sqlite3.Xsqlite3_value_dup(tls, pVal)
				if *(*uintptr)(unsafe.Pointer(apVal + uintptr(iField)*4)) == uintptr(0) {
					recoverError(tls, p, SQLITE_NOMEM, uintptr(0), 0)
				}
				(*RecoverStateW1)(unsafe.Pointer(p1)).FnVal = iField + 1
			}
			(*RecoverStateW1)(unsafe.Pointer(p1)).FiPrevCell = iCell
			(*RecoverStateW1)(unsafe.Pointer(p1)).FiPrevPage = iPage
		}
	} else {
		recoverReset(tls, p, pSel)
		(*RecoverStateW1)(unsafe.Pointer(p1)).FpTab = uintptr(0)
	}

	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func recoverLostAndFound1Init(tls *libc.TLS, p uintptr) {
	var pLaf uintptr = p + 132
	var pStmt uintptr = uintptr(0)

	(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnPg = recoverPageCount(tls, p)
	(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsed = recoverBitmapAlloc(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnPg)

	pStmt = recoverPrepare(tls,
		p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+13511)
	if pStmt != 0 {
		sqlite3.Xsqlite3_bind_int(tls, pStmt, 1, (*sqlite3_recover)(unsafe.Pointer(p)).FbFreelistCorrupt)
	}
	(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsedPages = pStmt
}

func recoverLostAndFound1Step(tls *libc.TLS, p uintptr) int32 {
	var pLaf uintptr = p + 132
	var rc int32 = (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_step(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsedPages)
		if rc == SQLITE_ROW {
			var iPg i64 = sqlite3.Xsqlite3_column_int64(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsedPages, 0)
			recoverBitmapSet(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsed, iPg)
			rc = SQLITE_OK
		} else {
			recoverFinalize(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsedPages)
			(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsedPages = uintptr(0)
		}
	}
	return rc
}

func recoverLostAndFound2Init(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pLaf uintptr = p + 132

	(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMapInsert = recoverPrepare(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+14184)
	(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllAndParent = recoverPreparePrintf(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+14246, libc.VaList(bp, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FnPg))
	(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMaxField = recoverPreparePrintf(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut,
		ts+14415, 0)
}

func recoverLostAndFound2Step(tls *libc.TLS, p uintptr) int32 {
	var pLaf uintptr = p + 132
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		var res int32 = sqlite3.Xsqlite3_step(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllAndParent)
		if res == SQLITE_ROW {
			var iChild i64 = i64(sqlite3.Xsqlite3_column_int(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllAndParent, 1))
			if recoverBitmapQuery(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpUsed, iChild) == 0 {
				sqlite3.Xsqlite3_bind_int64(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMapInsert, 1, iChild)
				sqlite3.Xsqlite3_bind_value(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMapInsert, 2,
					sqlite3.Xsqlite3_column_value(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllAndParent, 0))
				sqlite3.Xsqlite3_step(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMapInsert)
				recoverReset(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMapInsert)
				sqlite3.Xsqlite3_bind_int64(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMaxField, 1, iChild)
				if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMaxField) {
					var nMax int32 = sqlite3.Xsqlite3_column_int(tls, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMaxField, 0)
					if nMax > (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnMaxField {
						(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FnMaxField = nMax
					}
				}
				recoverReset(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpMaxField)
			}
		} else {
			recoverFinalize(tls, p, (*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllAndParent)
			(*RecoverStateLAF)(unsafe.Pointer(pLaf)).FpAllAndParent = uintptr(0)
			return SQLITE_DONE
		}
	}
	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func recoverLostAndFoundCleanup(tls *libc.TLS, p uintptr) {
	recoverBitmapFree(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpUsed)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpUsed = uintptr(0)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpUsedPages)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpAllAndParent)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpMapInsert)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpMaxField)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpFindRoot)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpInsert)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpAllPage)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpPageData)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpUsedPages = uintptr(0)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpAllAndParent = uintptr(0)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpMapInsert = uintptr(0)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpMaxField = uintptr(0)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpFindRoot = uintptr(0)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpInsert = uintptr(0)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpAllPage = uintptr(0)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpPageData = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FapVal)
	(*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FapVal = uintptr(0)
}

func recoverFinalCleanup(tls *libc.TLS, p uintptr) {
	var pTab uintptr = uintptr(0)
	var pNext uintptr = uintptr(0)

	recoverWriteDataCleanup(tls, p)
	recoverLostAndFoundCleanup(tls, p)

	for pTab = (*sqlite3_recover)(unsafe.Pointer(p)).FpTblList; pTab != 0; pTab = pNext {
		pNext = (*RecoverTable)(unsafe.Pointer(pTab)).FpNext
		sqlite3.Xsqlite3_free(tls, pTab)
	}
	(*sqlite3_recover)(unsafe.Pointer(p)).FpTblList = uintptr(0)
	sqlite3.Xsqlite3_finalize(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FpGetPage)
	(*sqlite3_recover)(unsafe.Pointer(p)).FpGetPage = uintptr(0)
	sqlite3.Xsqlite3_file_control(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, (*sqlite3_recover)(unsafe.Pointer(p)).FzDb, SQLITE_FCNTL_RESET_CACHE, uintptr(0))

	{
		sqlite3.Xsqlite3_close(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut)

	}
	(*sqlite3_recover)(unsafe.Pointer(p)).FdbOut = uintptr(0)
}

func recoverGetU16(tls *libc.TLS, a uintptr) u32 {
	return u32(*(*u8)(unsafe.Pointer(a)))<<8 + u32(*(*u8)(unsafe.Pointer(a + 1)))
}

func recoverGetU32(tls *libc.TLS, a uintptr) u32 {
	return u32(*(*u8)(unsafe.Pointer(a)))<<24 + u32(*(*u8)(unsafe.Pointer(a + 1)))<<16 + u32(*(*u8)(unsafe.Pointer(a + 2)))<<8 + u32(*(*u8)(unsafe.Pointer(a + 3)))
}

func recoverGetVarint(tls *libc.TLS, a uintptr, pVal uintptr) int32 {
	var u sqlite3_uint64 = uint64(0)
	var i int32
	for i = 0; i < 8; i++ {
		u = u<<7 + sqlite3_uint64(int32(*(*u8)(unsafe.Pointer(a + uintptr(i))))&0x7f)
		if int32(*(*u8)(unsafe.Pointer(a + uintptr(i))))&0x80 == 0 {
			*(*i64)(unsafe.Pointer(pVal)) = sqlite3_int64(u)
			return i + 1
		}
	}
	u = u<<8 + sqlite3_uint64(int32(*(*u8)(unsafe.Pointer(a + uintptr(i))))&0xff)
	*(*i64)(unsafe.Pointer(pVal)) = sqlite3_int64(u)
	return 9
}

func recoverIsValidPage(tls *libc.TLS, aTmp uintptr, a uintptr, n int32) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var aUsed uintptr = aTmp
	var nFrag int32 = 0
	var nActual int32 = 0
	var iFree int32 = 0
	var nCell int32 = 0
	var iCellOff int32 = 0
	var iContent int32 = 0
	var eType int32 = 0
	var ii int32 = 0

	eType = int32(*(*u8)(unsafe.Pointer(a)))
	if eType != 0x02 && eType != 0x05 && eType != 0x0A && eType != 0x0D {
		return 0
	}

	iFree = int32(recoverGetU16(tls, a+1))
	nCell = int32(recoverGetU16(tls, a+3))
	iContent = int32(recoverGetU16(tls, a+5))
	if iContent == 0 {
		iContent = 65536
	}
	nFrag = int32(*(*u8)(unsafe.Pointer(a + 7)))

	if iContent > n {
		return 0
	}

	libc.Xmemset(tls, aUsed, 0, uint32(n))
	libc.Xmemset(tls, aUsed, 0xFF, uint32(iContent))

	if iFree != 0 && iFree <= iContent {
		return 0
	}
	for iFree != 0 {
		var iNext int32 = 0
		var nByte int32 = 0
		if iFree > n-4 {
			return 0
		}
		iNext = int32(recoverGetU16(tls, a+uintptr(iFree)))
		nByte = int32(recoverGetU16(tls, a+uintptr(iFree+2)))
		if iFree+nByte > n {
			return 0
		}
		if iNext != 0 && iNext < iFree+nByte {
			return 0
		}
		libc.Xmemset(tls, aUsed+uintptr(iFree), 0xFF, uint32(nByte))
		iFree = iNext
	}

	if eType == 0x02 || eType == 0x05 {
		iCellOff = 12
	} else {
		iCellOff = 8
	}
	if iCellOff+2*nCell > iContent {
		return 0
	}
	for ii = 0; ii < nCell; ii++ {
		var iByte int32
		*(*i64)(unsafe.Pointer(bp)) = int64(0)
		var nByte int32 = 0
		var iOff int32 = int32(recoverGetU16(tls, a+uintptr(iCellOff+2*ii)))
		if iOff < iContent || iOff > n {
			return 0
		}
		if eType == 0x05 || eType == 0x02 {
			nByte = nByte + 4
		}
		nByte = nByte + recoverGetVarint(tls, a+uintptr(iOff+nByte), bp)
		if eType == 0x0D {
			*(*i64)(unsafe.Pointer(bp + 8)) = int64(0)
			nByte = nByte + recoverGetVarint(tls, a+uintptr(iOff+nByte), bp+8)
		}
		if eType != 0x05 {
			var X int32
			if eType == 0x0D {
				X = n - 35
			} else {
				X = (n-12)*64/255 - 23
			}
			var M int32 = (n-12)*32/255 - 23
			var K int32 = int32(i64(M) + (*(*i64)(unsafe.Pointer(bp))-i64(M))%i64(n-4))

			if *(*i64)(unsafe.Pointer(bp)) < i64(X) {
				nByte = int32(i64(nByte) + *(*i64)(unsafe.Pointer(bp)))
			} else if K <= X {
				nByte = nByte + (K + 4)
			} else {
				nByte = nByte + (M + 4)
			}
		}

		if iOff+nByte > n {
			return 0
		}
		for iByte = iOff; iByte < iOff+nByte; iByte++ {
			if int32(*(*u8)(unsafe.Pointer(aUsed + uintptr(iByte)))) != 0 {
				return 0
			}
			*(*u8)(unsafe.Pointer(aUsed + uintptr(iByte))) = u8(0xFF)
		}
	}

	nActual = 0
	for ii = 0; ii < n; ii++ {
		if int32(*(*u8)(unsafe.Pointer(aUsed + uintptr(ii)))) == 0 {
			nActual++
		}
	}
	return libc.Bool32(nActual == nFrag)
}

var recover_methods = sqlite3_io_methods{
	FiVersion:               2,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
	FxFetch:                 0,
	FxUnfetch:               0,
}

func recoverVfsClose(tls *libc.TLS, pFd uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxClose})).f(tls, pFd)
}

func recoverPutU16(tls *libc.TLS, a uintptr, v u32) {
	*(*u8)(unsafe.Pointer(a)) = u8(v >> 8 & u32(0x00FF))
	*(*u8)(unsafe.Pointer(a + 1)) = u8(v >> 0 & u32(0x00FF))
}

func recoverPutU32(tls *libc.TLS, a uintptr, v u32) {
	*(*u8)(unsafe.Pointer(a)) = u8(v >> 24 & u32(0x00FF))
	*(*u8)(unsafe.Pointer(a + 1)) = u8(v >> 16 & u32(0x00FF))
	*(*u8)(unsafe.Pointer(a + 2)) = u8(v >> 8 & u32(0x00FF))
	*(*u8)(unsafe.Pointer(a + 3)) = u8(v >> 0 & u32(0x00FF))
}

func recoverVfsDetectPagesize(tls *libc.TLS, p uintptr, pFd uintptr, nReserve u32, nSz i64) int32 {
	var rc int32 = SQLITE_OK
	var nMin int32 = 512
	var nMax int32 = 65536
	var nMaxBlk int32 = 4
	var pgsz u32 = u32(0)
	var iBlk int32 = 0
	var aPg uintptr = uintptr(0)
	var aTmp uintptr = uintptr(0)
	var nBlk int32 = 0

	aPg = sqlite3.Xsqlite3_malloc(tls, 2*nMax)
	if aPg == uintptr(0) {
		return SQLITE_NOMEM
	}
	aTmp = aPg + uintptr(nMax)

	nBlk = int32((nSz + i64(nMax) - int64(1)) / i64(nMax))
	if nBlk > nMaxBlk {
		nBlk = nMaxBlk
	}

	for __ccgo := true; __ccgo; __ccgo = 1 != 0 {
		for iBlk = 0; rc == SQLITE_OK && iBlk < nBlk; iBlk++ {
			var nByte int32
			if nSz >= i64((iBlk+1)*nMax) {
				nByte = nMax
			} else {
				nByte = int32(nSz % i64(nMax))
			}
			libc.Xmemset(tls, aPg, 0, uint32(nMax))
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxRead})).f(tls, pFd, aPg, nByte, int64(iBlk*nMax))
			if rc == SQLITE_OK {
				var pgsz2 int32
				for pgsz2 = func() int32 {
					if pgsz != 0 {
						return int32(pgsz * u32(2))
					}
					return nMin
				}(); pgsz2 <= nMax; pgsz2 = pgsz2 * 2 {
					var iOff int32
					for iOff = 0; iOff < nMax; iOff = iOff + pgsz2 {
						if recoverIsValidPage(tls, aTmp, aPg+uintptr(iOff), int32(u32(pgsz2)-nReserve)) != 0 {
							pgsz = u32(pgsz2)
							break
						}
					}
				}
			}
		}
		if pgsz > u32((*sqlite3_recover)(unsafe.Pointer(p)).Fdetected_pgsz) {
			(*sqlite3_recover)(unsafe.Pointer(p)).Fdetected_pgsz = int32(pgsz)
			(*sqlite3_recover)(unsafe.Pointer(p)).FnReserve = int32(nReserve)
		}
		if nReserve == u32(0) {
			break
		}
		nReserve = u32(0)
	}

	(*sqlite3_recover)(unsafe.Pointer(p)).Fdetected_pgsz = int32(pgsz)
	sqlite3.Xsqlite3_free(tls, aPg)
	return rc
}

func recoverVfsRead(tls *libc.TLS, pFd uintptr, aBuf uintptr, nByte int32, iOff i64) int32 {
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxRead})).f(tls, pFd, aBuf, nByte, iOff)
		if nByte == 16 {
			sqlite3.Xsqlite3_randomness(tls, 16, aBuf)
		} else if rc == SQLITE_OK && iOff == int64(0) && nByte >= 108 {
			*(*[6]int32)(unsafe.Pointer(bp + 116)) = [6]int32{32, 36, 52, 60, 64, 68}
			*(*[108]u8)(unsafe.Pointer(bp + 8)) = [108]u8{
				u8(0x53), u8(0x51), u8(0x4c), u8(0x69), u8(0x74), u8(0x65), u8(0x20), u8(0x66),
				u8(0x6f), u8(0x72), u8(0x6d), u8(0x61), u8(0x74), u8(0x20), u8(0x33), u8(0x00),
				u8(0xFF), u8(0xFF), u8(0x01), u8(0x01), u8(0x00), u8(0x40), u8(0x20), u8(0x20),
				u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF),
				u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF),
				u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x04),
				u8(0x00), u8(0x00), u8(0x10), u8(0x00), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF),
				u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF),
				u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF), u8(0xFF),
				u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00),
				u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00),
				u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0x00),
				u8(0x00), u8(0x2e), u8(0x5b), u8(0x30),
				u8(0x0D), u8(0x00), u8(0x00), u8(0x00), u8(0x00), u8(0xFF), u8(0xFF), u8(0x00),
			}
			var a uintptr = aBuf

			var pgsz u32 = recoverGetU16(tls, a+16)
			var nReserve u32 = u32(*(*u8)(unsafe.Pointer(a + 20)))
			var enc u32 = recoverGetU32(tls, a+56)
			var dbsz u32 = u32(0)
			*(*i64)(unsafe.Pointer(bp)) = int64(0)
			var ii int32
			var p uintptr = recover_g.Fp

			if pgsz == u32(0x01) {
				pgsz = u32(65536)
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxFileSize})).f(tls, pFd, bp)

			if rc == SQLITE_OK && (*sqlite3_recover)(unsafe.Pointer(p)).Fdetected_pgsz == 0 {
				rc = recoverVfsDetectPagesize(tls, p, pFd, nReserve, *(*i64)(unsafe.Pointer(bp)))
			}
			if (*sqlite3_recover)(unsafe.Pointer(p)).Fdetected_pgsz != 0 {
				pgsz = u32((*sqlite3_recover)(unsafe.Pointer(p)).Fdetected_pgsz)
				nReserve = u32((*sqlite3_recover)(unsafe.Pointer(p)).FnReserve)
			}

			if pgsz != 0 {
				dbsz = u32(*(*i64)(unsafe.Pointer(bp)) / i64(pgsz))
			}
			if enc != u32(SQLITE_UTF8) && enc != u32(SQLITE_UTF16BE) && enc != u32(SQLITE_UTF16LE) {
				enc = u32(SQLITE_UTF8)
			}

			sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache)
			(*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache = uintptr(0)
			(*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Disk = uintptr(0)

			(*sqlite3_recover)(unsafe.Pointer(p)).Fpgsz = nByte
			(*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache = recoverMalloc(tls, p, int64(nByte*2))
			if (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache != 0 {
				(*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Disk = (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache + uintptr(nByte)
				libc.Xmemcpy(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Disk, aBuf, uint32(nByte))
				*(*u8)(unsafe.Pointer(bp + 8 + 18)) = *(*u8)(unsafe.Pointer(a + 18))
				*(*u8)(unsafe.Pointer(bp + 8 + 19)) = *(*u8)(unsafe.Pointer(a + 19))
				recoverPutU32(tls, bp+8+28, dbsz)
				recoverPutU32(tls, bp+8+56, enc)
				recoverPutU16(tls, bp+8+105, pgsz-nReserve)
				if pgsz == u32(65536) {
					pgsz = u32(1)
				}
				recoverPutU16(tls, bp+8+16, pgsz)
				*(*u8)(unsafe.Pointer(bp + 8 + 20)) = u8(nReserve)
				for ii = 0; ii < int32(uint32(unsafe.Sizeof([6]int32{}))/uint32(unsafe.Sizeof(int32(0)))); ii++ {
					libc.Xmemcpy(tls, bp+8+uintptr(*(*int32)(unsafe.Pointer(bp + 116 + uintptr(ii)*4))), a+uintptr(*(*int32)(unsafe.Pointer(bp + 116 + uintptr(ii)*4))), uint32(4))
				}
				libc.Xmemcpy(tls, aBuf, bp+8, uint32(unsafe.Sizeof([108]u8{})))
				libc.Xmemset(tls, aBuf+108, 0, uint32(nByte)-uint32(unsafe.Sizeof([108]u8{})))

				libc.Xmemcpy(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache, aBuf, uint32(nByte))
			} else {
				rc = (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
			}

		}
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxRead})).f(tls, pFd, aBuf, nByte, iOff)
	}
	return rc
}

func recoverVfsWrite(tls *libc.TLS, pFd uintptr, aBuf uintptr, nByte int32, iOff i64) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxWrite})).f(tls, pFd, aBuf, nByte, iOff)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxWrite})).f(tls, pFd, aBuf, nByte, iOff)
	}
	return rc

	return int32(0)
}

func recoverVfsTruncate(tls *libc.TLS, pFd uintptr, size sqlite3_int64) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxTruncate})).f(tls, pFd, size)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxTruncate})).f(tls, pFd, size)
	}
	return rc

	return int32(0)
}

func recoverVfsSync(tls *libc.TLS, pFd uintptr, flags int32) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxSync})).f(tls, pFd, flags)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxSync})).f(tls, pFd, flags)
	}
	return rc

	return int32(0)
}

func recoverVfsFileSize(tls *libc.TLS, pFd uintptr, pSize uintptr) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxFileSize})).f(tls, pFd, pSize)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxFileSize})).f(tls, pFd, pSize)
	}
	return rc

	return int32(0)
}

func recoverVfsLock(tls *libc.TLS, pFd uintptr, eLock int32) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxLock})).f(tls, pFd, eLock)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxLock})).f(tls, pFd, eLock)
	}
	return rc

	return int32(0)
}

func recoverVfsUnlock(tls *libc.TLS, pFd uintptr, eLock int32) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxUnlock})).f(tls, pFd, eLock)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxUnlock})).f(tls, pFd, eLock)
	}
	return rc

	return int32(0)
}

func recoverVfsCheckReservedLock(tls *libc.TLS, pFd uintptr, pResOut uintptr) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxCheckReservedLock})).f(tls, pFd, pResOut)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxCheckReservedLock})).f(tls, pFd, pResOut)
	}
	return rc

	return int32(0)
}

func recoverVfsFileControl(tls *libc.TLS, pFd uintptr, op int32, pArg uintptr) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = func() int32 {
			if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods != 0 {
				return (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxFileControl})).f(tls, pFd, op, pArg)
			}
			return SQLITE_NOTFOUND
		}()
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = func() int32 {
			if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods != 0 {
				return (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxFileControl})).f(tls, pFd, op, pArg)
			}
			return SQLITE_NOTFOUND
		}()
	}
	return rc

	return int32(0)
}

func recoverVfsSectorSize(tls *libc.TLS, pFd uintptr) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxSectorSize})).f(tls, pFd)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxSectorSize})).f(tls, pFd)
	}
	return rc

	return int32(0)
}

func recoverVfsDeviceCharacteristics(tls *libc.TLS, pFd uintptr) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxDeviceCharacteristics})).f(tls, pFd)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxDeviceCharacteristics})).f(tls, pFd)
	}
	return rc

	return int32(0)
}

func recoverVfsShmMap(tls *libc.TLS, pFd uintptr, iPg int32, pgsz int32, bExtend int32, pp uintptr) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmMap})).f(tls, pFd, iPg, pgsz, bExtend, pp)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmMap})).f(tls, pFd, iPg, pgsz, bExtend, pp)
	}
	return rc

	return int32(0)
}

func recoverVfsShmLock(tls *libc.TLS, pFd uintptr, offset int32, n int32, flags int32) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmLock})).f(tls, pFd, offset, n, flags)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmLock})).f(tls, pFd, offset, n, flags)
	}
	return rc

	return int32(0)
}

func recoverVfsShmBarrier(tls *libc.TLS, pFd uintptr) {
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmBarrier})).f(tls, pFd)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmBarrier})).f(tls, pFd)
	}
}

func recoverVfsShmUnmap(tls *libc.TLS, pFd uintptr, deleteFlag int32) int32 {
	var rc int32 = SQLITE_OK
	if (*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods == uintptr(unsafe.Pointer(&recover_methods)) {
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = recover_g.FpMethods
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmUnmap})).f(tls, pFd, deleteFlag)
		(*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods)).FxShmUnmap})).f(tls, pFd, deleteFlag)
	}
	return rc

	return int32(0)
}

func recoverVfsFetch(tls *libc.TLS, pFd uintptr, iOff sqlite3_int64, iAmt int32, pp uintptr) int32 {
	_ = pFd
	_ = iOff
	_ = iAmt
	*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
	return SQLITE_OK
}

func recoverVfsUnfetch(tls *libc.TLS, pFd uintptr, iOff sqlite3_int64, p uintptr) int32 {
	_ = pFd
	_ = iOff
	_ = p
	return SQLITE_OK
}

func recoverInstallWrapper(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)

	sqlite3.Xsqlite3_file_control(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, (*sqlite3_recover)(unsafe.Pointer(p)).FzDb, SQLITE_FCNTL_FILE_POINTER, bp)

	if *(*uintptr)(unsafe.Pointer(bp)) != 0 && (*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods != 0 {
		var iVersion int32 = 1 + libc.Bool32((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods)).FiVersion > 1 && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods)).FxShmMap != uintptr(0))
		recover_g.FpMethods = (*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods
		recover_g.Fp = p
		recover_methods.FiVersion = iVersion
		(*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods = uintptr(unsafe.Pointer(&recover_methods))
	}
}

func recoverUninstallWrapper(tls *libc.TLS, p uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)

	sqlite3.Xsqlite3_file_control(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, (*sqlite3_recover)(unsafe.Pointer(p)).FzDb, SQLITE_FCNTL_FILE_POINTER, bp)
	if *(*uintptr)(unsafe.Pointer(bp)) != 0 && (*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods = recover_g.FpMethods
		recover_g.FpMethods = uintptr(0)
		recover_g.Fp = uintptr(0)
	}
}

func recoverStep(tls *libc.TLS, p uintptr) {
	switch (*sqlite3_recover)(unsafe.Pointer(p)).FeState {
	case RECOVER_STATE_INIT:
		recoverSqlCallback(tls, p, ts+14480)
		recoverSqlCallback(tls, p, ts+14486)

		recoverEnterMutex(tls)
		recoverInstallWrapper(tls, p)

		recoverOpenOutput(tls, p)

		sqlite3.Xsqlite3_file_control(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, (*sqlite3_recover)(unsafe.Pointer(p)).FzDb, SQLITE_FCNTL_RESET_CACHE, uintptr(0))
		recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+14486)
		recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+14480)
		if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
			(*sqlite3_recover)(unsafe.Pointer(p)).FbCloseTransaction = 1
		}
		recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+14514)
		recoverTransferSettings(tls, p)
		recoverOpenRecovery(tls, p)
		recoverCacheSchema(tls, p)

		recoverUninstallWrapper(tls, p)
		recoverLeaveMutex(tls)

		recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, ts+14480)

		recoverWriteSchema1(tls, p)
		(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_WRITING
		break

	case RECOVER_STATE_WRITING:
		{
			if (*sqlite3_recover)(unsafe.Pointer(p)).Fw1.FpTbls == uintptr(0) {
				recoverWriteDataInit(tls, p)
			}
			if SQLITE_DONE == recoverWriteDataStep(tls, p) {
				recoverWriteDataCleanup(tls, p)
				if (*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound != 0 {
					(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_LOSTANDFOUND1
				} else {
					(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_SCHEMA2
				}
			}
			break

		}

	case RECOVER_STATE_LOSTANDFOUND1:
		{
			if (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpUsed == uintptr(0) {
				recoverLostAndFound1Init(tls, p)
			}
			if SQLITE_DONE == recoverLostAndFound1Step(tls, p) {
				(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_LOSTANDFOUND2
			}
			break

		}
	case RECOVER_STATE_LOSTANDFOUND2:
		{
			if (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpAllAndParent == uintptr(0) {
				recoverLostAndFound2Init(tls, p)
			}
			if SQLITE_DONE == recoverLostAndFound2Step(tls, p) {
				(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_LOSTANDFOUND3
			}
			break

		}

	case RECOVER_STATE_LOSTANDFOUND3:
		{
			if (*sqlite3_recover)(unsafe.Pointer(p)).Flaf.FpInsert == uintptr(0) {
				recoverLostAndFound3Init(tls, p)
			}
			if SQLITE_DONE == recoverLostAndFound3Step(tls, p) {
				(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_SCHEMA2
			}
			break

		}

	case RECOVER_STATE_SCHEMA2:
		{
			var rc int32 = SQLITE_OK

			recoverWriteSchema2(tls, p)
			(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_DONE

			recoverExec(tls, p, (*sqlite3_recover)(unsafe.Pointer(p)).FdbOut, ts+14542)
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+6059, uintptr(0), uintptr(0), uintptr(0))
			if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
				(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = rc
			}

			recoverSqlCallback(tls, p, ts+14549)
			recoverSqlCallback(tls, p, ts+14542)
			(*sqlite3_recover)(unsafe.Pointer(p)).FeState = RECOVER_STATE_DONE
			recoverFinalCleanup(tls, p)
			break

		}

	case RECOVER_STATE_DONE:
		{
			break

		}

	}
}

func recoverInit(tls *libc.TLS, db uintptr, zDb uintptr, zUri uintptr, xSql uintptr, pSqlCtx uintptr) uintptr {
	var pRet uintptr = uintptr(0)
	var nDb int32 = 0
	var nUri int32 = 0
	var nByte int32 = 0

	if zDb == uintptr(0) {
		zDb = ts + 85
	}

	nDb = recoverStrlen(tls, zDb)
	nUri = recoverStrlen(tls, zUri)

	nByte = int32(uint32(unsafe.Sizeof(sqlite3_recover{})) + uint32(nDb) + uint32(1) + uint32(nUri) + uint32(1))
	pRet = sqlite3.Xsqlite3_malloc(tls, nByte)
	if pRet != 0 {
		libc.Xmemset(tls, pRet, 0, uint32(nByte))
		(*sqlite3_recover)(unsafe.Pointer(pRet)).FdbIn = db
		(*sqlite3_recover)(unsafe.Pointer(pRet)).FzDb = pRet + 1*196
		(*sqlite3_recover)(unsafe.Pointer(pRet)).FzUri = (*sqlite3_recover)(unsafe.Pointer(pRet)).FzDb + uintptr(nDb+1)
		libc.Xmemcpy(tls, (*sqlite3_recover)(unsafe.Pointer(pRet)).FzDb, zDb, uint32(nDb))
		if nUri > 0 && zUri != 0 {
			libc.Xmemcpy(tls, (*sqlite3_recover)(unsafe.Pointer(pRet)).FzUri, zUri, uint32(nUri))
		}
		(*sqlite3_recover)(unsafe.Pointer(pRet)).FxSql = xSql
		(*sqlite3_recover)(unsafe.Pointer(pRet)).FpSqlCtx = pSqlCtx
		(*sqlite3_recover)(unsafe.Pointer(pRet)).FbRecoverRowid = RECOVER_ROWID_DEFAULT
	}

	return pRet
}

func sqlite3_recover_init(tls *libc.TLS, db uintptr, zDb uintptr, zUri uintptr) uintptr {
	return recoverInit(tls, db, zDb, zUri, uintptr(0), uintptr(0))
}

func sqlite3_recover_init_sql(tls *libc.TLS, db uintptr, zDb uintptr, xSql uintptr, pSqlCtx uintptr) uintptr {
	return recoverInit(tls, db, zDb, uintptr(0), xSql, pSqlCtx)
}

func sqlite3_recover_errmsg(tls *libc.TLS, p uintptr) uintptr {
	if p != 0 && (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode != SQLITE_NOMEM {
		return (*sqlite3_recover)(unsafe.Pointer(p)).FzErrMsg
	}
	return ts + 2069
}

func sqlite3_recover_errcode(tls *libc.TLS, p uintptr) int32 {
	if p != 0 {
		return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
	}
	return SQLITE_NOMEM
}

func sqlite3_recover_config(tls *libc.TLS, p uintptr, op int32, pArg uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = SQLITE_OK
	if p == uintptr(0) {
		rc = SQLITE_NOMEM
	} else if (*sqlite3_recover)(unsafe.Pointer(p)).FeState != RECOVER_STATE_INIT {
		rc = SQLITE_MISUSE
	} else {
		switch op {
		case 789:
			sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FzStateDb)
			(*sqlite3_recover)(unsafe.Pointer(p)).FzStateDb = recoverMPrintf(tls, p, ts, libc.VaList(bp, pArg))
			break
			fallthrough

		case SQLITE_RECOVER_LOST_AND_FOUND:
			{
				var zArg uintptr = pArg
				sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound)
				if zArg != 0 {
					(*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound = recoverMPrintf(tls, p, ts, libc.VaList(bp+8, zArg))
				} else {
					(*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound = uintptr(0)
				}
				break

			}
			fallthrough

		case SQLITE_RECOVER_FREELIST_CORRUPT:
			(*sqlite3_recover)(unsafe.Pointer(p)).FbFreelistCorrupt = *(*int32)(unsafe.Pointer(pArg))
			break
			fallthrough

		case SQLITE_RECOVER_ROWIDS:
			(*sqlite3_recover)(unsafe.Pointer(p)).FbRecoverRowid = *(*int32)(unsafe.Pointer(pArg))
			break
			fallthrough

		case SQLITE_RECOVER_SLOWINDEXES:
			(*sqlite3_recover)(unsafe.Pointer(p)).FbSlowIndexes = *(*int32)(unsafe.Pointer(pArg))
			break
			fallthrough

		default:
			rc = SQLITE_NOTFOUND
			break
		}
	}

	return rc
}

func sqlite3_recover_step(tls *libc.TLS, p uintptr) int32 {
	if p == uintptr(0) {
		return SQLITE_NOMEM
	}
	if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		recoverStep(tls, p)
	}
	if (*sqlite3_recover)(unsafe.Pointer(p)).FeState == RECOVER_STATE_DONE && (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
		return SQLITE_DONE
	}
	return (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
}

func sqlite3_recover_run(tls *libc.TLS, p uintptr) int32 {
	for SQLITE_OK == sqlite3_recover_step(tls, p) {
	}
	return sqlite3_recover_errcode(tls, p)
}

func sqlite3_recover_finish(tls *libc.TLS, p uintptr) int32 {
	var rc int32
	if p == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		recoverFinalCleanup(tls, p)
		if (*sqlite3_recover)(unsafe.Pointer(p)).FbCloseTransaction != 0 && sqlite3.Xsqlite3_get_autocommit(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn) == 0 {
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FdbIn, ts+6059, uintptr(0), uintptr(0), uintptr(0))
			if (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode == SQLITE_OK {
				(*sqlite3_recover)(unsafe.Pointer(p)).FerrCode = rc
			}
		}
		rc = (*sqlite3_recover)(unsafe.Pointer(p)).FerrCode
		sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FzErrMsg)
		sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FzStateDb)
		sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FzLostAndFound)
		sqlite3.Xsqlite3_free(tls, (*sqlite3_recover)(unsafe.Pointer(p)).FpPage1Cache)
		sqlite3.Xsqlite3_free(tls, p)
	}
	return rc
}

type sqlite31 = sqlite32

type sqlite3_str = sqlite3_str1

type int_least8_t = int8
type int_least16_t = int16
type int_least32_t = int32
type int_least64_t = int64

type uint_least8_t = uint8
type uint_least16_t = uint16
type uint_least32_t = uint32
type uint_least64_t = uint64

type int_fast8_t = int32
type int_fast16_t = int32
type int_fast32_t = int32
type int_fast64_t = int64

type uint_fast8_t = uint32
type uint_fast16_t = uint32
type uint_fast32_t = uint32
type uint_fast64_t = uint64

type imaxdiv_t = struct {
	Fquot intmax_t
	Frem  intmax_t
}

type Hash1 = struct {
	Fhtsize uint32
	Fcount  uint32
	Ffirst  uintptr
	Fht     uintptr
}

type Hash = Hash1
type HashElem1 = struct {
	Fnext uintptr
	Fprev uintptr
	Fdata uintptr
	FpKey uintptr
}

type HashElem = HashElem1

type _ht = struct {
	Fcount uint32
	Fchain uintptr
}

type max_align_t = struct {
	F__max_align1 int64
	F__max_align2 float64
}
type i16 = int16_t
type i8 = int8_t

type tRowcnt = u64

type LogEst = int16_t

type uptr = uintptr_t

type BusyHandler1 = struct {
	FxBusyHandler uintptr
	FpBusyArg     uintptr
	FnBusy        int32
}

type BusyHandler = BusyHandler1

type AggInfo1 = struct {
	FdirectMode     u8
	FuseSortingIdx  u8
	FnSortingColumn u16
	FsortingIdx     int32
	FsortingIdxPTab int32
	FiFirstReg      int32
	FpGroupBy       uintptr
	FaCol           uintptr
	FnColumn        int32
	FnAccumulator   int32
	FaFunc          uintptr
	FnFunc          int32
	FselId          u32
}

type AggInfo = AggInfo1
type AuthContext1 = struct {
	FzAuthContext uintptr
	FpParse       uintptr
}

type AuthContext = AuthContext1
type AutoincInfo1 = struct {
	FpNext  uintptr
	FpTab   uintptr
	FiDb    int32
	FregCtr int32
}

type AutoincInfo = AutoincInfo1
type CollSeq1 = struct {
	FzName       uintptr
	Fenc         u8
	F__ccgo_pad1 [3]byte
	FpUser       uintptr
	FxCmp        uintptr
	FxDel        uintptr
}

type CollSeq = CollSeq1
type Column1 = struct {
	FzCnName     uintptr
	FnotNull     uint8
	F__ccgo_pad1 [1]byte
	Faffinity    int8
	FszEst       u8
	FhName       u8
	F__ccgo_pad2 [1]byte
	FiDflt       u16
	FcolFlags    u16
	F__ccgo_pad3 [2]byte
}

type Column = Column1
type Cte1 = struct {
	FzName       uintptr
	FpCols       uintptr
	FpSelect     uintptr
	FzCteErr     uintptr
	FpUse        uintptr
	FeM10d       u8
	F__ccgo_pad1 [3]byte
}

type Cte = Cte1
type CteUse1 = struct {
	FnUse        int32
	FaddrM9e     int32
	FregRtn      int32
	FiCur        int32
	FnRowEst     LogEst
	FeM10d       u8
	F__ccgo_pad1 [1]byte
}

type CteUse = CteUse1
type Db1 = struct {
	FzDbSName     uintptr
	FpBt          uintptr
	Fsafety_level u8
	FbSyncSet     u8
	F__ccgo_pad1  [2]byte
	FpSchema      uintptr
}

type Db = Db1
type DbFixer1 = struct {
	FpParse      uintptr
	Fw           Walker
	FpSchema     uintptr
	FbTemp       u8
	F__ccgo_pad1 [3]byte
	FzDb         uintptr
	FzType       uintptr
	FpName       uintptr
}

type DbFixer = DbFixer1
type Schema1 = struct {
	Fschema_cookie int32
	FiGeneration   int32
	FtblHash       Hash
	FidxHash       Hash
	FtrigHash      Hash
	FfkeyHash      Hash
	FpSeqTab       uintptr
	Ffile_format   u8
	Fenc           u8
	FschemaFlags   u16
	Fcache_size    int32
}

type Schema = Schema1
type Expr1 = struct {
	Fop          u8
	FaffExpr     int8
	Fop2         u8
	F__ccgo_pad1 [1]byte
	Fflags       u32
	Fu           struct{ FzToken uintptr }
	FpLeft       uintptr
	FpRight      uintptr
	Fx           struct{ FpList uintptr }
	FnHeight     int32
	FiTable      int32
	FiColumn     ynVar
	FiAgg        i16
	Fw           struct{ FiJoin int32 }
	FpAggInfo    uintptr
	Fy           struct {
		FpTab        uintptr
		F__ccgo_pad1 [4]byte
	}
}

type Expr = Expr1
type ExprList1 = struct {
	FnExpr  int32
	FnAlloc int32
	Fa      [1]struct {
		FpExpr  uintptr
		FzEName uintptr
		Ffg     struct {
			F__ccgo_pad1 [0]uint32
			FsortFlags   u8
			F__ccgo_pad2 [3]byte
			FeEName      uint16
			F__ccgo_pad3 [2]byte
		}
		Fu struct {
			F__ccgo_pad1 [0]uint32
			Fx           struct {
				FiOrderByCol u16
				FiAlias      u16
			}
		}
	}
}

type ExprList = ExprList1
type FKey1 = struct {
	FpFrom       uintptr
	FpNextFrom   uintptr
	FzTo         uintptr
	FpNextTo     uintptr
	FpPrevTo     uintptr
	FnCol        int32
	FisDeferred  u8
	FaAction     [2]u8
	F__ccgo_pad1 [1]byte
	FapTrigger   [2]uintptr
	FaCol        [1]struct {
		FiFrom int32
		FzCol  uintptr
	}
}

type FKey = FKey1
type FuncDestructor1 = struct {
	FnRef      int32
	FxDestroy  uintptr
	FpUserData uintptr
}

type FuncDestructor = FuncDestructor1
type FuncDef1 = struct {
	FnArg        i8
	F__ccgo_pad1 [3]byte
	FfuncFlags   u32
	FpUserData   uintptr
	FpNext       uintptr
	FxSFunc      uintptr
	FxFinalize   uintptr
	FxValue      uintptr
	FxInverse    uintptr
	FzName       uintptr
	Fu           struct{ FpHash uintptr }
}

type FuncDef = FuncDef1
type FuncDefHash1 = struct{ Fa [23]uintptr }

type FuncDefHash = FuncDefHash1
type IdList1 = struct {
	FnId         int32
	FeU4         u8
	F__ccgo_pad1 [3]byte
	Fa           [1]struct {
		FzName uintptr
		Fu4    struct{ Fidx int32 }
	}
}

type IdList = IdList1
type Index1 = struct {
	FzName         uintptr
	FaiColumn      uintptr
	FaiRowLogEst   uintptr
	FpTable        uintptr
	FzColAff       uintptr
	FpNext         uintptr
	FpSchema       uintptr
	FaSortOrder    uintptr
	FazColl        uintptr
	FpPartIdxWhere uintptr
	FaColExpr      uintptr
	Ftnum          Pgno
	FszIdxRow      LogEst
	FnKeyCol       u16
	FnColumn       u16
	FonError       u8
	F__ccgo_pad1   [1]byte
	FidxType       uint16
	F__ccgo_pad2   [2]byte
	FnSample       int32
	FnSampleCol    int32
	FaAvgEq        uintptr
	FaSample       uintptr
	FaiRowEst      uintptr
	FnRowEst0      tRowcnt
	FcolNotIdxed   Bitmask
}

type Index = Index1
type IndexedExpr1 = struct {
	FpExpr         uintptr
	FiDataCur      int32
	FiIdxCur       int32
	FiIdxCol       int32
	FbMaybeNullRow u8
	Faff           u8
	F__ccgo_pad1   [2]byte
	FpIENext       uintptr
	FzIdxName      uintptr
}

type IndexedExpr = IndexedExpr1
type IndexSample1 = struct {
	Fp     uintptr
	Fn     int32
	FanEq  uintptr
	FanLt  uintptr
	FanDLt uintptr
}

type IndexSample = IndexSample1
type KeyInfo1 = struct {
	FnRef        u32
	Fenc         u8
	F__ccgo_pad1 [1]byte
	FnKeyField   u16
	FnAllField   u16
	F__ccgo_pad2 [2]byte
	Fdb          uintptr
	FaSortFlags  uintptr
	FaColl       [1]uintptr
}

type KeyInfo = KeyInfo1
type Lookaside1 = struct {
	FbDisable    u32
	Fsz          u16
	FszTrue      u16
	FbMalloced   u8
	F__ccgo_pad1 [3]byte
	FnSlot       u32
	FanStat      [3]u32
	FpInit       uintptr
	FpFree       uintptr
	FpSmallInit  uintptr
	FpSmallFree  uintptr
	FpMiddle     uintptr
	FpStart      uintptr
	FpEnd        uintptr
	FpTrueEnd    uintptr
}

type Lookaside = Lookaside1
type LookasideSlot1 = struct{ FpNext uintptr }

type LookasideSlot = LookasideSlot1
type Module1 = struct {
	FpModule    uintptr
	FzName      uintptr
	FnRefModule int32
	FpAux       uintptr
	FxDestroy   uintptr
	FpEpoTab    uintptr
}

type Module = Module1
type NameContext1 = struct {
	FpParse     uintptr
	FpSrcList   uintptr
	FuNC        struct{ FpEList uintptr }
	FpNext      uintptr
	FnRef       int32
	FnNcErr     int32
	FncFlags    int32
	FpWinSelect uintptr
}

type NameContext = NameContext1
type OnOrUsing1 = struct {
	FpOn    uintptr
	FpUsing uintptr
}

type OnOrUsing = OnOrUsing1
type Parse1 = struct {
	Fdb               uintptr
	FzErrMsg          uintptr
	FpVdbe            uintptr
	Frc               int32
	FcolNamesSet      u8
	FcheckSchema      u8
	Fnested           u8
	FnTempReg         u8
	FisMultiWrite     u8
	FmayAbort         u8
	FhasCompound      u8
	FokConstFactor    u8
	FdisableLookaside u8
	FprepFlags        u8
	FwithinRJSubrtn   u8
	F__ccgo_pad1      [1]byte
	FnRangeReg        int32
	FiRangeReg        int32
	FnErr             int32
	FnTab             int32
	FnMem             int32
	FszOpAlloc        int32
	FiSelfTab         int32
	FnLabel           int32
	FnLabelAlloc      int32
	FaLabel           uintptr
	FpConstExpr       uintptr
	FpIdxEpr          uintptr
	FconstraintName   Token
	FwriteMask        yDbMask
	FcookieMask       yDbMask
	FregRowid         int32
	FregRoot          int32
	FnMaxArg          int32
	FnSelect          int32
	FnTableLock       int32
	FaTableLock       uintptr
	FpAinc            uintptr
	FpToplevel        uintptr
	FpTriggerTab      uintptr
	FpTriggerPrg      uintptr
	FpCleanup         uintptr
	Fu1               struct{ FaddrCrTab int32 }
	FnQueryLoop       u32
	Foldmask          u32
	Fnewmask          u32
	FnProgressSteps   u32
	FeTriggerOp       u8
	FbReturning       u8
	FeOrconf          u8
	FdisableTriggers  u8
	FaTempReg         [8]int32
	FpOuterParse      uintptr
	FsNameToken       Token
	FsLastToken       Token
	FnVar             ynVar
	FiPkSortOrder     u8
	Fexplain          u8
	FeParseMode       u8
	F__ccgo_pad2      [3]byte
	FnVtabLock        int32
	FnHeight          int32
	FaddrExplain      int32
	FpVList           uintptr
	FpReprepare       uintptr
	FzTail            uintptr
	FpNewTable        uintptr
	FpNewIndex        uintptr
	FpNewTrigger      uintptr
	FzAuthContext     uintptr
	FsArg             Token
	FapVtabLock       uintptr
	FpWith            uintptr
	FpRename          uintptr
}

type Parse = Parse1
type ParseCleanup1 = struct {
	FpNext    uintptr
	FpPtr     uintptr
	FxCleanup uintptr
}

type ParseCleanup = ParseCleanup1
type PreUpdate1 = struct {
	Fv            uintptr
	FpCsr         uintptr
	Fop           int32
	FaRecord      uintptr
	Fkeyinfo      KeyInfo
	FpUnpacked    uintptr
	FpNewUnpacked uintptr
	FiNewReg      int32
	FiBlobWrite   int32
	FiKey1        i64
	FiKey2        i64
	FaNew         uintptr
	FpTab         uintptr
	FpPk          uintptr
}

type PrintfArguments1 = struct {
	FnArg  int32
	FnUsed int32
	FapArg uintptr
}

type PrintfArguments = PrintfArguments1
type Returning1 = struct {
	FpParse    uintptr
	FpReturnEL uintptr
	FretTrig   Trigger
	FretTStep  TriggerStep
	FiRetCur   int32
	FnRetCol   int32
	FiRetReg   int32
}

type Returning = Returning1
type Savepoint1 = struct {
	FzName            uintptr
	FnDeferredCons    i64
	FnDeferredImmCons i64
	FpNext            uintptr
}

type Savepoint = Savepoint1
type Select1 = struct {
	Fop           u8
	F__ccgo_pad1  [1]byte
	FnSelectRow   LogEst
	FselFlags     u32
	FiLimit       int32
	FiOffset      int32
	FselId        u32
	FaddrOpenEphm [2]int32
	FpEList       uintptr
	FpSrc         uintptr
	FpWhere       uintptr
	FpGroupBy     uintptr
	FpHaving      uintptr
	FpOrderBy     uintptr
	FpPrior       uintptr
	FpNext        uintptr
	FpLimit       uintptr
	FpWith        uintptr
	FpWin         uintptr
	FpWinDefn     uintptr
}

type Select = Select1
type SelectDest1 = struct {
	FeDest       u8
	F__ccgo_pad1 [3]byte
	FiSDParm     int32
	FiSDParm2    int32
	FiSdst       int32
	FnSdst       int32
	FzAffSdst    uintptr
	FpOrderBy    uintptr
}

type SelectDest = SelectDest1
type SrcItem1 = struct {
	FpSchema     uintptr
	FzDatabase   uintptr
	FzName       uintptr
	FzAlias      uintptr
	FpTab        uintptr
	FpSelect     uintptr
	FaddrFillSub int32
	FregReturn   int32
	FregResult   int32
	Ffg          struct {
		F__ccgo_pad1 [0]uint32
		Fjointype    u8
		F__ccgo_pad2 [3]byte
		FnotIndexed  uint16
		F__ccgo_pad3 [2]byte
	}
	FiCursor int32
	Fu3      struct{ FpOn uintptr }
	FcolUsed Bitmask
	Fu1      struct{ FzIndexedBy uintptr }
	Fu2      struct{ FpIBIndex uintptr }
}

type SrcItem = SrcItem1
type SrcList1 = struct {
	FnSrc   int32
	FnAlloc u32
	Fa      [1]SrcItem
}

type SrcList = SrcList1
type StrAccum = sqlite3_str1
type Table1 = struct {
	FzName      uintptr
	FaCol       uintptr
	FpIndex     uintptr
	FzColAff    uintptr
	FpCheck     uintptr
	Ftnum       Pgno
	FnTabRef    u32
	FtabFlags   u32
	FiPKey      i16
	FnCol       i16
	FnNVCol     i16
	FnRowLogEst LogEst
	FszTabRow   LogEst
	FkeyConf    u8
	FeTabType   u8
	Fu          struct {
		Ftab struct {
			FaddColOffset int32
			FpFKey        uintptr
			FpDfltList    uintptr
		}
	}
	FpTrigger uintptr
	FpSchema  uintptr
}

type Table = Table1
type Token1 = struct {
	Fz uintptr
	Fn uint32
}

type Token = Token1
type Trigger1 = struct {
	FzName       uintptr
	Ftable       uintptr
	Fop          u8
	Ftr_tm       u8
	FbReturning  u8
	F__ccgo_pad1 [1]byte
	FpWhen       uintptr
	FpColumns    uintptr
	FpSchema     uintptr
	FpTabSchema  uintptr
	Fstep_list   uintptr
	FpNext       uintptr
}

type Trigger = Trigger1
type TriggerPrg1 = struct {
	FpTrigger uintptr
	FpNext    uintptr
	FpProgram uintptr
	Forconf   int32
	FaColmask [2]u32
}

type TriggerPrg = TriggerPrg1
type TriggerStep1 = struct {
	Fop          u8
	Forconf      u8
	F__ccgo_pad1 [2]byte
	FpTrig       uintptr
	FpSelect     uintptr
	FzTarget     uintptr
	FpFrom       uintptr
	FpWhere      uintptr
	FpExprList   uintptr
	FpIdList     uintptr
	FpUpsert     uintptr
	FzSpan       uintptr
	FpNext       uintptr
	FpLast       uintptr
}

type TriggerStep = TriggerStep1
type UnpackedRecord1 = struct {
	FpKeyInfo uintptr
	FaMem     uintptr
	Fu        struct {
		Fz           uintptr
		F__ccgo_pad1 [4]byte
	}
	Fn           int32
	FnField      u16
	Fdefault_rc  i8
	FerrCode     u8
	Fr1          i8
	Fr2          i8
	FeqSeen      u8
	F__ccgo_pad1 [1]byte
}

type UnpackedRecord = UnpackedRecord1
type Upsert1 = struct {
	FpUpsertTarget      uintptr
	FpUpsertTargetWhere uintptr
	FpUpsertSet         uintptr
	FpUpsertWhere       uintptr
	FpNextUpsert        uintptr
	FisDoUpdate         u8
	F__ccgo_pad1        [3]byte
	FpToFree            uintptr
	FpUpsertIdx         uintptr
	FpUpsertSrc         uintptr
	FregData            int32
	FiDataCur           int32
	FiIdxCur            int32
}

type Upsert = Upsert1
type VTable1 = struct {
	Fdb          uintptr
	FpMod        uintptr
	FpVtab       uintptr
	FnRef        int32
	FbConstraint u8
	FeVtabRisk   u8
	F__ccgo_pad1 [2]byte
	FiSavepoint  int32
	FpNext       uintptr
}

type VTable = VTable1
type Walker1 = struct {
	FpParse           uintptr
	FxExprCallback    uintptr
	FxSelectCallback  uintptr
	FxSelectCallback2 uintptr
	FwalkerDepth      int32
	FeCode            u16
	F__ccgo_pad1      [2]byte
	Fu                struct{ FpNC uintptr }
}

type Walker = Walker1
type Window1 = struct {
	FzName          uintptr
	FzBase          uintptr
	FpPartition     uintptr
	FpOrderBy       uintptr
	FeFrmType       u8
	FeStart         u8
	FeEnd           u8
	FbImplicitFrame u8
	FeExclude       u8
	F__ccgo_pad1    [3]byte
	FpStart         uintptr
	FpEnd           uintptr
	FppThis         uintptr
	FpNextWin       uintptr
	FpFilter        uintptr
	FpWFunc         uintptr
	FiEphCsr        int32
	FregAccum       int32
	FregResult      int32
	FcsrApp         int32
	FregApp         int32
	FregPart        int32
	FpOwner         uintptr
	FnBufferCol     int32
	FiArgCol        int32
	FregOne         int32
	FregStartRowid  int32
	FregEndRowid    int32
	FbExprArgs      u8
	F__ccgo_pad2    [3]byte
}

type Window = Window1
type With1 = struct {
	FnCte   int32
	FbView  int32
	FpOuter uintptr
	Fa      [1]Cte
}

type With = With1

type Bitmask = u64

type VList = int32

type Pgno = u32

type PgHdr1 = struct {
	FpPage       uintptr
	FpData       uintptr
	FpExtra      uintptr
	FpCache      uintptr
	FpDirty      uintptr
	FpPager      uintptr
	Fpgno        Pgno
	Fflags       u16
	F__ccgo_pad1 [2]byte
	FnRef        i64
	FpDirtyNext  uintptr
	FpDirtyPrev  uintptr
}

type DbPage = PgHdr1

type Btree1 = struct {
	Fdb             uintptr
	FpBt            uintptr
	FinTrans        u8
	Fsharable       u8
	Flocked         u8
	FhasIncrblobCur u8
	FwantToLock     int32
	FnBackup        int32
	FiBDataVersion  u32
	FpNext          uintptr
	FpPrev          uintptr
	Flock           BtLock
}

type BtCursor1 = struct {
	FeState        u8
	FcurFlags      u8
	FcurPagerFlags u8
	Fhints         u8
	FskipNext      int32
	FpBtree        uintptr
	FaOverflow     uintptr
	FpKey          uintptr
	FpBt           uintptr
	FpNext         uintptr
	Finfo          CellInfo
	FnKey          i64
	FpgnoRoot      Pgno
	FiPage         i8
	FcurIntKey     u8
	Fix            u16
	FaiIdx         [19]u16
	F__ccgo_pad1   [2]byte
	FpKeyInfo      uintptr
	FpPage         uintptr
	FapPage        [19]uintptr
}

type BtShared1 = struct {
	FpPager          uintptr
	Fdb              uintptr
	FpCursor         uintptr
	FpPage1          uintptr
	FopenFlags       u8
	FautoVacuum      u8
	FincrVacuum      u8
	FbDoTruncate     u8
	FinTransaction   u8
	Fmax1bytePayload u8
	FnReserveWanted  u8
	F__ccgo_pad1     [1]byte
	FbtsFlags        u16
	FmaxLocal        u16
	FminLocal        u16
	FmaxLeaf         u16
	FminLeaf         u16
	F__ccgo_pad2     [2]byte
	FpageSize        u32
	FusableSize      u32
	FnTransaction    int32
	FnPage           u32
	FpSchema         uintptr
	FxFreeSchema     uintptr
	Fmutex           uintptr
	FpHasContent     uintptr
	FnRef            int32
	FpNext           uintptr
	FpLock           uintptr
	FpWriter         uintptr
	FpTmpSpace       uintptr
	FnPreformatSize  int32
}

type BtreePayload1 = struct {
	FpKey        uintptr
	FnKey        sqlite3_int64
	FpData       uintptr
	FaMem        uintptr
	FnMem        u16
	F__ccgo_pad1 [2]byte
	FnData       int32
	FnZero       int32
}

type BtreePayload = BtreePayload1

type Vdbe1 = struct {
	Fdb                 uintptr
	FppVPrev            uintptr
	FpVNext             uintptr
	FpParse             uintptr
	FnVar               ynVar
	F__ccgo_pad1        [2]byte
	FnMem               int32
	FnCursor            int32
	FcacheCtr           u32
	Fpc                 int32
	Frc                 int32
	FnChange            i64
	FiStatement         int32
	FiCurrentTime       i64
	FnFkConstraint      i64
	FnStmtDefCons       i64
	FnStmtDefImmCons    i64
	FaMem               uintptr
	FapArg              uintptr
	FapCsr              uintptr
	FaVar               uintptr
	FaOp                uintptr
	FnOp                int32
	FnOpAlloc           int32
	FaColName           uintptr
	FpResultRow         uintptr
	FzErrMsg            uintptr
	FpVList             uintptr
	FstartTime          i64
	FnResColumn         u16
	FerrorAction        u8
	FminWriteFileFormat u8
	FprepFlags          u8
	FeVdbeState         u8
	F__ccgo_pad2        [2]byte
	Fexpired            uint8
	F__ccgo_pad3        [3]byte
	FbtreeMask          yDbMask
	FlockMask           yDbMask
	FaCounter           [9]u32
	FzSql               uintptr
	FpFree              uintptr
	FpFrame             uintptr
	FpDelFrame          uintptr
	FnFrame             int32
	Fexpmask            u32
	FpProgram           uintptr
	FpAuxData           uintptr
}

type SubProgram1 = struct {
	FaOp   uintptr
	FnOp   int32
	FnMem  int32
	FnCsr  int32
	FaOnce uintptr
	Ftoken uintptr
	FpNext uintptr
}

type SubProgram = SubProgram1

type VdbeOp1 = struct {
	Fopcode   u8
	Fp4type   int8
	Fp5       u16
	Fp1       int32
	Fp2       int32
	Fp3       int32
	Fp4       struct{ Fi int32 }
	FzComment uintptr
}

type p4union = struct{ Fi int32 }

type VdbeOp = VdbeOp1

type VdbeOpList1 = struct {
	Fopcode u8
	Fp1     int8
	Fp2     int8
	Fp3     int8
}

type VdbeOpList = VdbeOpList1

type RecordCompare = uintptr

type PgHdr = PgHdr1

type sqlite3_xauth = uintptr

type sqlite3InitInfo = struct {
	FnewTnum       Pgno
	FiDb           u8
	Fbusy          u8
	F__ccgo_pad1   [2]byte
	ForphanTrigger uint8
	F__ccgo_pad2   [3]byte
	FazInit        uintptr
}

type sColMap = struct {
	FiFrom int32
	FzCol  uintptr
}

type AggInfo_col = struct {
	FpTab          uintptr
	FpCExpr        uintptr
	FiTable        int32
	FiColumn       i16
	FiSorterColumn i16
}

type AggInfo_func = struct {
	FpFExpr    uintptr
	FpFunc     uintptr
	FiDistinct int32
	FiDistAddr int32
}

type ynVar = i16

type ExprList_item = struct {
	FpExpr  uintptr
	FzEName uintptr
	Ffg     struct {
		F__ccgo_pad1 [0]uint32
		FsortFlags   u8
		F__ccgo_pad2 [3]byte
		FeEName      uint16
		F__ccgo_pad3 [2]byte
	}
	Fu struct {
		F__ccgo_pad1 [0]uint32
		Fx           struct {
			FiOrderByCol u16
			FiAlias      u16
		}
	}
}

type IdList_item = struct {
	FzName uintptr
	Fu4    struct{ Fidx int32 }
}

type yDbMask = uint32

type InitData = struct {
	Fdb         uintptr
	FpzErrMsg   uintptr
	FiDb        int32
	Frc         int32
	FmInitFlags u32
	FnInitRow   u32
	FmxPage     Pgno
}

type Sqlite3Config = struct {
	FbMemstat            int32
	FbCoreMutex          u8
	FbFullMutex          u8
	FbOpenUri            u8
	FbUseCis             u8
	FbSmallMalloc        u8
	FbExtraSchemaChecks  u8
	F__ccgo_pad1         [2]byte
	FmxStrlen            int32
	FneverCorrupt        int32
	FszLookaside         int32
	FnLookaside          int32
	FnStmtSpill          int32
	Fm                   sqlite3_mem_methods
	Fmutex               sqlite3_mutex_methods
	Fpcache2             sqlite3_pcache_methods2
	FpHeap               uintptr
	FnHeap               int32
	FmnReq               int32
	FmxReq               int32
	FszMmap              sqlite3_int64
	FmxMmap              sqlite3_int64
	FpPage               uintptr
	FszPage              int32
	FnPage               int32
	FmxParserStack       int32
	FsharedCacheEnabled  int32
	FszPma               u32
	FisInit              int32
	FinProgress          int32
	FisMutexInit         int32
	FisMallocInit        int32
	FisPCacheInit        int32
	FnRefInitMutex       int32
	FpInitMutex          uintptr
	FxLog                uintptr
	FpLogArg             uintptr
	FmxMemdbSize         sqlite3_int64
	FxTestCallback       uintptr
	FbLocaltimeFault     int32
	FxAltLocaltime       uintptr
	FiOnceResetThreshold int32
	FszSorterRef         u32
	FiPrngSeed           uint32
}

type TestRecover1 = struct {
	Fp       uintptr
	Finterp  uintptr
	FpScript uintptr
}

type TestRecover = TestRecover1

func xSqlCallback(tls *libc.TLS, pSqlArg uintptr, zSql uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pSqlArg
	var pEval uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp)) = 0

	pEval = tcl.XTcl_DuplicateObj(tls, (*TestRecover)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++

	*(*int32)(unsafe.Pointer(bp)) = tcl.XTcl_ListObjAppendElement(tls, (*TestRecover)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zSql, -1))
	if *(*int32)(unsafe.Pointer(bp)) == TCL_OK {
		*(*int32)(unsafe.Pointer(bp)) = tcl.XTcl_EvalObjEx(tls, (*TestRecover)(unsafe.Pointer(p)).Finterp, pEval, 0)
	}

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if *(*int32)(unsafe.Pointer(bp)) != 0 {
		tcl.XTcl_BackgroundError(tls, (*TestRecover)(unsafe.Pointer(p)).Finterp)
		return TCL_ERROR
	} else {
		var pObj uintptr = tcl.XTcl_GetObjResult(tls, (*TestRecover)(unsafe.Pointer(p)).Finterp)
		if tcl.XTcl_GetCharLength(tls, pObj) == 0 {
			*(*int32)(unsafe.Pointer(bp)) = 0
		} else if tcl.XTcl_GetIntFromObj(tls, (*TestRecover)(unsafe.Pointer(p)).Finterp, pObj, bp) != 0 {
			tcl.XTcl_BackgroundError(tls, (*TestRecover)(unsafe.Pointer(p)).Finterp)
			return TCL_ERROR
		}
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func getDbPointer(tls *libc.TLS, interp uintptr, pObj uintptr, pDb uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, pObj), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930, tcl.XTcl_GetString(tls, pObj), 0))
		return TCL_ERROR
	}
	*(*uintptr)(unsafe.Pointer(pDb)) = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24)).FobjClientData))
	return TCL_OK
}

func testRecoverCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var rc int32 = TCL_OK
	*(*int32)(unsafe.Pointer(bp)) = 0
	var pTest uintptr = clientData

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&aSub)), int32(unsafe.Sizeof(RecoverSub{})), ts+2014, 0, bp)
	if rc != TCL_OK {
		return rc
	}
	if objc-2 != aSub[*(*int32)(unsafe.Pointer(bp))].FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, aSub[*(*int32)(unsafe.Pointer(bp))].FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp)) {
	case 0:
		{
			*(*[7]uintptr)(unsafe.Pointer(bp + 4)) = [7]uintptr{
				ts + 14578,
				ts + 14585,
				ts + 14598,
				ts + 14614,
				ts + 14621,
				ts + 2758,
				uintptr(0),
			}
			*(*int32)(unsafe.Pointer(bp + 32)) = 0
			var res int32 = 0
			if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4, int32(unsafe.Sizeof(uintptr(0))), ts+14633, 0, bp+32) != 0 {
				return TCL_ERROR
			}
			switch *(*int32)(unsafe.Pointer(bp + 32)) {
			case 0:
				res = sqlite3_recover_config(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp,
					789, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4))))
				break
			case 1:
				{
					var zStr uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
					res = sqlite3_recover_config(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp,
						SQLITE_RECOVER_LOST_AND_FOUND, func() uintptr {
							if *(*int8)(unsafe.Pointer(zStr)) != 0 {
								return zStr
							}
							return uintptr(0)
						}())
					break

				}
			case 2:
				{
					*(*int32)(unsafe.Pointer(bp + 36)) = 0
					if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+36) != 0 {
						return TCL_ERROR
					}
					res = sqlite3_recover_config(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp,
						SQLITE_RECOVER_FREELIST_CORRUPT, bp+36)
					break

				}
			case 3:
				{
					*(*int32)(unsafe.Pointer(bp + 40)) = 0
					if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+40) != 0 {
						return TCL_ERROR
					}
					res = sqlite3_recover_config(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp,
						SQLITE_RECOVER_ROWIDS, bp+40)
					break

				}
			case 4:
				{
					*(*int32)(unsafe.Pointer(bp + 44)) = 0
					if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+44) != 0 {
						return TCL_ERROR
					}
					res = sqlite3_recover_config(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp,
						SQLITE_RECOVER_SLOWINDEXES, bp+44)
					break

				}
			case 5:
				{
					res = sqlite3_recover_config(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp, 12345, uintptr(0))
					break

				}
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
			break

		}
	case 1:
		{
			var res int32 = sqlite3_recover_run(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
			break

		}
	case 2:
		{
			var zErr uintptr = sqlite3_recover_errmsg(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErr, -1))
			break

		}
	case 3:
		{
			var errCode int32 = sqlite3_recover_errcode(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, errCode))
			break

		}
	case 4:
		{
			var res int32 = sqlite3_recover_errcode(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp)
			var res2 int32
			_ = res2
			if res != SQLITE_OK {
				var zErr uintptr = sqlite3_recover_errmsg(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp)
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErr, -1))
			}
			res2 = sqlite3_recover_finish(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp)

			if res != 0 {
				return TCL_ERROR
			}
			break

		}
	case 5:
		{
			var res int32 = sqlite3_recover_step(tls, (*TestRecover)(unsafe.Pointer(pTest)).Fp)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
			break

		}
	}

	return TCL_OK
}

type RecoverSub = struct {
	FzSub uintptr
	FnArg int32
	FzMsg uintptr
}

var aSub = [7]RecoverSub{
	{FzSub: ts + 14640, FnArg: 2, FzMsg: ts + 14647},
	{FzSub: ts + 14651, FzMsg: ts + 584},
	{FzSub: ts + 14655, FzMsg: ts + 584},
	{FzSub: ts + 14662, FzMsg: ts + 584},
	{FzSub: ts + 14670, FzMsg: ts + 584},
	{FzSub: ts + 9840, FzMsg: ts + 584},
	{},
}

func test_sqlite3_recover_init(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pNew uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = uintptr(0)
	var zDb uintptr = uintptr(0)
	var zUri uintptr = uintptr(0)

	var bSql int32
	if clientData != 0 {
		bSql = 1
	} else {
		bSql = 0
	}

	if objc != 4 {
		var zErr uintptr = func() uintptr {
			if bSql != 0 {
				return ts + 14677
			}
			return ts + 14694
		}()
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, zErr)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if int32(*(*int8)(unsafe.Pointer(zDb))) == 0 {
		zDb = uintptr(0)
	}

	pNew = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestRecover{})))
	if bSql == 0 {
		zUri = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
		(*TestRecover)(unsafe.Pointer(pNew)).Fp = sqlite3_recover_init(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), zDb, zUri)
	} else {
		(*TestRecover)(unsafe.Pointer(pNew)).Finterp = interp
		(*TestRecover)(unsafe.Pointer(pNew)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
		(*Tcl_Obj)(unsafe.Pointer((*TestRecover)(unsafe.Pointer(pNew)).FpScript)).FrefCount++
		(*TestRecover)(unsafe.Pointer(pNew)).Fp = sqlite3_recover_init_sql(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), zDb, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		}{xSqlCallback})), pNew)
	}

	libc.Xsprintf(tls, bp+12, ts+14708, libc.VaList(bp, libc.PostIncInt32(&iTestRecoverCmd, 1)))
	tcl.XTcl_CreateObjCommand(tls, interp, bp+12, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testRecoverCmd})), pNew, uintptr(0))

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+12, -1))
	return TCL_OK
}

var iTestRecoverCmd int32 = 1

func test_sqlite3_dbdata_init(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3_dbdata_init(tls, *(*uintptr)(unsafe.Pointer(bp)), uintptr(0), uintptr(0))

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func TestRecover_Init(tls *libc.TLS, interp uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*[3]struct {
		FzCmd  uintptr
		FxProc uintptr
		FpArg  uintptr
	})(unsafe.Pointer(bp)) = [3]struct {
		FzCmd  uintptr
		FxProc uintptr
		FpArg  uintptr
	}{
		{FzCmd: ts + 14725, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3_recover_init}))},
		{FzCmd: ts + 14746, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3_recover_init})), FpArg: uintptr(1)},
		{FzCmd: ts + 14771, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3_dbdata_init})), FpArg: uintptr(1)},
	}
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof([3]struct {
		FzCmd  uintptr
		FxProc uintptr
		FpArg  uintptr
	}{}))/uint32(unsafe.Sizeof(struct {
		FzCmd  uintptr
		FxProc uintptr
		FpArg  uintptr
	}{})); i++ {
		var p uintptr = bp + uintptr(i)*12
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzCmd  uintptr
			FxProc uintptr
			FpArg  uintptr
		})(unsafe.Pointer(p)).FzCmd, (*struct {
			FzCmd  uintptr
			FxProc uintptr
			FpArg  uintptr
		})(unsafe.Pointer(p)).FxProc, (*struct {
			FzCmd  uintptr
			FxProc uintptr
			FpArg  uintptr
		})(unsafe.Pointer(p)).FpArg, uintptr(0))
	}
	return TCL_OK
}

type BoxGeomCtx1 = struct {
	Finterp  uintptr
	FpScript uintptr
}

type BoxGeomCtx = BoxGeomCtx1

type BoxQueryCtx1 = struct {
	Finterp  uintptr
	FpScript uintptr
}

type BoxQueryCtx = BoxQueryCtx1

func testDelUser(tls *libc.TLS, pCtx uintptr) {
	var p uintptr = pCtx
	tcl.XTcl_EvalObjEx(tls, (*BoxGeomCtx)(unsafe.Pointer(p)).Finterp, (*BoxGeomCtx)(unsafe.Pointer(p)).FpScript, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*BoxGeomCtx)(unsafe.Pointer(p)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func invokeTclGeomCb(tls *libc.TLS, zName uintptr, p uintptr, nCoord int32, aCoord uintptr) int32 {
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var rc int32 = SQLITE_OK
	if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpContext != 0 {
		var pCtx uintptr = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpContext
		var interp uintptr = (*BoxGeomCtx)(unsafe.Pointer(pCtx)).Finterp
		var pScript uintptr = uintptr(0)
		var pParam uintptr = uintptr(0)
		var pCoord uintptr = uintptr(0)
		var ii int32
		var pRes uintptr

		pScript = tcl.XTcl_DuplicateObj(tls, (*BoxGeomCtx)(unsafe.Pointer(pCtx)).FpScript)
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, zName, -1))

		sqlite3.Xsqlite3_snprintf(tls, int32(uint32(unsafe.Sizeof([64]int8{}))-uint32(1)), bp+16, ts+14791, libc.VaList(bp, (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpContext))
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, bp+16, -1))

		pParam = tcl.XTcl_NewObj(tls)
		for ii = 0; ii < (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam; ii++ {
			tcl.XTcl_ListObjAppendElement(tls,
				interp, pParam, tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + uintptr(ii)*8))))
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pParam)

		pCoord = tcl.XTcl_NewObj(tls)
		for ii = 0; ii < nCoord; ii++ {
			tcl.XTcl_ListObjAppendElement(tls, interp, pCoord, tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + uintptr(ii)*8))))
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pCoord)

		sqlite3.Xsqlite3_snprintf(tls, int32(uint32(unsafe.Sizeof([64]int8{}))-uint32(1)), bp+16, ts+14791, libc.VaList(bp+8, p))
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, bp+16, -1))

		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		if rc != TCL_OK {
			rc = SQLITE_ERROR
		} else {
			*(*int32)(unsafe.Pointer(bp + 80)) = 0
			*(*uintptr)(unsafe.Pointer(bp + 84)) = uintptr(0)

			pRes = tcl.XTcl_GetObjResult(tls, interp)
			if tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+80, bp+84) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 80)) > 0 {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 84)))))
				if 0 == sqlite3.Xsqlite3_stricmp(tls, zCmd, ts+14794) {
					*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam)) = 0.0
					(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam = 1
				} else if 0 == sqlite3.Xsqlite3_stricmp(tls, zCmd, ts+14799) {
					if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser != 0 || (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser != 0 {
						rc = SQLITE_ERROR
					} else {
						var pBGCtx uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(BoxGeomCtx{})))
						if pBGCtx == uintptr(0) {
							rc = SQLITE_NOMEM
						} else {
							(*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).Finterp = interp
							(*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).FpScript = tcl.XTcl_DuplicateObj(tls, pRes)
							(*Tcl_Obj)(unsafe.Pointer((*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).FpScript)).FrefCount++
							tcl.XTcl_ListObjReplace(tls, interp, (*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).FpScript, 0, 1, 0, uintptr(0))
							(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser = pBGCtx
							(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testDelUser}))
						}
					}
				} else if 0 == sqlite3.Xsqlite3_stricmp(tls, zCmd, ts+14804) {
					if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser != 0 || (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser != 0 {
						rc = SQLITE_ERROR
					}
				}
			}
		}
	}
	return rc
}

func box_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, pRes uintptr) int32 {
	var ii int32

	if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != nCoord {
		invokeTclGeomCb(tls, ts+14817, p, nCoord, aCoord)
		return SQLITE_ERROR
	}
	if invokeTclGeomCb(tls, ts+14817, p, nCoord, aCoord) != 0 {
		return SQLITE_ERROR
	}

	for ii = 0; ii < nCoord; ii = ii + 2 {
		if *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + uintptr(ii)*8)) > *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + uintptr(ii+1)*8)) || *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + uintptr(ii+1)*8)) < *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + uintptr(ii)*8)) {
			*(*int32)(unsafe.Pointer(pRes)) = 0
			return SQLITE_OK
		}
	}

	*(*int32)(unsafe.Pointer(pRes)) = 1

	return SQLITE_OK
}

func register_box_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var pCtx uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+14821)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+8) != 0 {
		return TCL_ERROR
	}

	pCtx = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(uintptr(0))))
	(*BoxGeomCtx)(unsafe.Pointer(pCtx)).Finterp = interp
	(*BoxGeomCtx)(unsafe.Pointer(pCtx)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	(*Tcl_Obj)(unsafe.Pointer((*BoxGeomCtx)(unsafe.Pointer(pCtx)).FpScript)).FrefCount++

	sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+14817, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{box_geom})), pCtx)

	sqlite3.Xsqlite3_snprintf(tls, 64, bp+12, ts+14791, libc.VaList(bp, pCtx))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+12, -1))
	return TCL_OK
}

func box_query(tls *libc.TLS, pInfo uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*[4]uintptr)(unsafe.Pointer(bp)) = [4]uintptr{ts + 6211, ts + 14831, ts + 14838, uintptr(0)}
	var pCtx uintptr = (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FpContext
	var interp uintptr = (*BoxQueryCtx)(unsafe.Pointer(pCtx)).Finterp
	var pEval uintptr
	var pArg uintptr
	var pTmp uintptr = uintptr(0)
	var rc int32
	var ii int32

	pEval = tcl.XTcl_DuplicateObj(tls, (*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++

	pTmp = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pTmp)).FrefCount++
	for ii = 0; ii < (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FnParam; ii++ {
		var p uintptr = tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FaParam + uintptr(ii)*8)))
		tcl.XTcl_ListObjAppendElement(tls, interp, pTmp, p)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14844, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pTmp)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pTmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	pTmp = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pTmp)).FrefCount++
	for ii = 0; ii < (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FnCoord; ii++ {
		var p uintptr = tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FaCoord + uintptr(ii)*8)))
		tcl.XTcl_ListObjAppendElement(tls, interp, pTmp, p)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14851, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pTmp)
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pTmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	pTmp = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pTmp)).FrefCount++
	for ii = 0; ii <= (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FmxLevel; ii++ {
		var p uintptr = tcl.XTcl_NewIntObj(tls, int32(*(*uint32)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FanQueue + uintptr(ii)*4))))
		tcl.XTcl_ListObjAppendElement(tls, interp, pTmp, p)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14858, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pTmp)
	for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
		var _objPtr uintptr = pTmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14866, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewIntObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FiLevel))

	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14873, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewIntObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FmxLevel))

	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14881, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewWideIntObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FiRowid))

	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14888, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewDoubleObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FrParentScore))

	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+14901, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg,
		tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + uintptr((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FeParentWithin)*4)), -1))

	tcl.XTcl_ListObjAppendElement(tls, interp, pEval, pArg)
	if tcl.XTcl_EvalObjEx(tls, interp, pEval, 0) != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = SQLITE_OK
	}

	if rc == SQLITE_OK {
		*(*float64)(unsafe.Pointer(bp + 24)) = 0.0
		*(*int32)(unsafe.Pointer(bp + 16)) = 0
		*(*int32)(unsafe.Pointer(bp + 32)) = 0
		*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)

		if tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+16, bp+20) != 0 ||
			*(*int32)(unsafe.Pointer(bp + 16)) != 2 ||
			tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20)) + 1*4)), bp+24) != 0 ||
			tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20)))), bp, int32(unsafe.Sizeof(uintptr(0))), ts+14915, 0, bp+32) != 0 {
			rc = SQLITE_ERROR
		} else {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FrScore = *(*float64)(unsafe.Pointer(bp + 24))
			(*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FeParentWithin = *(*int32)(unsafe.Pointer(bp + 32))
		}
	}

	for __ccgo3 := true; __ccgo3; __ccgo3 = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for __ccgo4 := true; __ccgo4; __ccgo4 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return rc
}

func box_query_destroy(tls *libc.TLS, p uintptr) {
	var pCtx uintptr = p
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pCtx)
}

func register_box_query(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCtx uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+14821)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}

	pCtx = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(BoxQueryCtx{})))
	(*BoxQueryCtx)(unsafe.Pointer(pCtx)).Finterp = interp
	(*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	(*Tcl_Obj)(unsafe.Pointer((*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript)).FrefCount++

	sqlite3.Xsqlite3_rtree_query_callback(tls,
		*(*uintptr)(unsafe.Pointer(bp)), ts+14921, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{box_query})), pCtx, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{box_query_destroy})))

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func Sqlitetestrtreedoc_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+14926, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_box_geom})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+14944, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_box_query})), uintptr(0), uintptr(0))
	return TCL_OK
}

type TestSession1 = struct {
	FpSession      uintptr
	Finterp        uintptr
	FpFilterScript uintptr
}

type TestSession = TestSession1

type TestStreamInput1 = struct {
	FnStream int32
	FaData   uintptr
	FnData   int32
	FiData   int32
}

type TestStreamInput = TestStreamInput1

func dbHandleFromObj1(tls *libc.TLS, interp uintptr, pObj uintptr, pDb uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, pObj), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930, tcl.XTcl_GetString(tls, pObj), 0))
		return TCL_ERROR
	}

	*(*uintptr)(unsafe.Pointer(pDb)) = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24)).FobjClientData))
	return TCL_OK
}

func sql_exec_changeset(tls *libc.TLS, db uintptr, zSql uintptr, pnChangeset uintptr, ppChangeset uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	var rc int32

	rc = sqlite3.Xsqlite3session_create(tls, db, ts+85, bp)

	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3session_attach(tls, *(*uintptr)(unsafe.Pointer(bp)), uintptr(0))
	}

	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
	}

	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3session_changeset(tls, *(*uintptr)(unsafe.Pointer(bp)), pnChangeset, ppChangeset)
	}

	sqlite3.Xsqlite3session_delete(tls, *(*uintptr)(unsafe.Pointer(bp)))

	return rc
}

func test_sql_exec_changeset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var zSql uintptr

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+14963)
		return TCL_ERROR
	}
	if dbHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))

	rc = sql_exec_changeset(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), zSql, bp+20, bp+24)
	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+14970, 0))
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), *(*int32)(unsafe.Pointer(bp + 20))))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
	return TCL_OK
}

func test_tcl_integer(tls *libc.TLS, interp uintptr, zVar uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pObj uintptr
	*(*int32)(unsafe.Pointer(bp)) = 0
	var pName uintptr = tcl.XTcl_NewStringObj(tls, zVar, -1)
	(*Tcl_Obj)(unsafe.Pointer(pName)).FrefCount++
	pObj = tcl.XTcl_ObjGetVar2(tls, interp, pName, uintptr(0), TCL_GLOBAL_ONLY)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pName
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if pObj != 0 {
		tcl.XTcl_GetIntFromObj(tls, uintptr(0), pObj, bp)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func test_session_error(tls *libc.TLS, interp uintptr, rc int32, zErr uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	if zErr != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10022, zErr, 0))
		sqlite3.Xsqlite3_free(tls, zErr)
	}
	return TCL_ERROR
}

func test_table_filter(tls *libc.TLS, pCtx uintptr, zTbl uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pEval uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp)) = 0

	pEval = tcl.XTcl_DuplicateObj(tls, (*TestSession)(unsafe.Pointer(p)).FpFilterScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	rc = tcl.XTcl_ListObjAppendElement(tls, (*TestSession)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	if rc == TCL_OK {
		rc = tcl.XTcl_EvalObjEx(tls, (*TestSession)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	}
	if rc == TCL_OK {
		rc = tcl.XTcl_GetBooleanFromObj(tls, (*TestSession)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*TestSession)(unsafe.Pointer(p)).Finterp), bp)
	}
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*TestSession)(unsafe.Pointer(p)).Finterp)
	}
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp))
}

type TestSessionsBlob1 = struct {
	Fp uintptr
	Fn int32
}

type TestSessionsBlob = TestSessionsBlob1

func testStreamOutput(tls *libc.TLS, pCtx uintptr, pData uintptr, nData int32) int32 {
	var pBlob uintptr = pCtx
	var pNew uintptr

	pNew = sqlite3.Xsqlite3_realloc(tls, (*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fp, (*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fn+nData)
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	(*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fp = pNew
	libc.Xmemcpy(tls, pNew+uintptr((*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fn), pData, uint32(nData))
	*(*int32)(unsafe.Pointer(pBlob + 4)) += nData
	return SQLITE_OK
}

func test_session_cmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var p uintptr = clientData
	var pSession uintptr = (*TestSession)(unsafe.Pointer(p)).FpSession

	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&aSub1)), int32(unsafe.Sizeof(SessionSubcmd{})), ts+2014, 0, bp)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+aSub1[*(*int32)(unsafe.Pointer(bp))].FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, aSub1[*(*int32)(unsafe.Pointer(bp))].FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp)) {
	case 0:
		{
			var zArg uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			if int32(*(*int8)(unsafe.Pointer(zArg))) == '*' && int32(*(*int8)(unsafe.Pointer(zArg + 1))) == 0 {
				zArg = uintptr(0)
			}
			rc = sqlite3.Xsqlite3session_attach(tls, pSession, zArg)
			if rc != SQLITE_OK {
				return test_session_error(tls, interp, rc, uintptr(0))
			}
			break

		}

	case 7:
		fallthrough
	case 1:
		{
			*(*TestSessionsBlob)(unsafe.Pointer(bp + 4)) = TestSessionsBlob{}
			if test_tcl_integer(tls, interp, ts+15000) != 0 {
				var pCtx uintptr = bp + 4
				if *(*int32)(unsafe.Pointer(bp)) == 7 {
					rc = sqlite3.Xsqlite3session_patchset_strm(tls, pSession, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					}{testStreamOutput})), pCtx)
				} else {
					rc = sqlite3.Xsqlite3session_changeset_strm(tls, pSession, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					}{testStreamOutput})), pCtx)
				}
			} else {
				if *(*int32)(unsafe.Pointer(bp)) == 7 {
					rc = sqlite3.Xsqlite3session_patchset(tls, pSession, bp+4+4, bp+4)
				} else {
					rc = sqlite3.Xsqlite3session_changeset(tls, pSession, bp+4+4, bp+4)
				}
			}
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+4)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+4)).Fn))
			}
			sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+4)).Fp)
			if rc != SQLITE_OK {
				return test_session_error(tls, interp, rc, uintptr(0))
			}
			break

		}

	case 2:
		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
		break

	case 3:
		{
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+12) != 0 {
				return TCL_ERROR
			}
			*(*int32)(unsafe.Pointer(bp + 12)) = sqlite3.Xsqlite3session_enable(tls, pSession, *(*int32)(unsafe.Pointer(bp + 12)))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 12)) != 0)))
			break

		}

	case 4:
		{
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16) != 0 {
				return TCL_ERROR
			}
			*(*int32)(unsafe.Pointer(bp + 16)) = sqlite3.Xsqlite3session_indirect(tls, pSession, *(*int32)(unsafe.Pointer(bp + 16)))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 16)) != 0)))
			break

		}

	case 5:
		{
			var val int32
			val = sqlite3.Xsqlite3session_isempty(tls, pSession)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(val != 0)))
			break

		}

	case 6:
		{
			if (*TestSession)(unsafe.Pointer(p)).FpFilterScript != 0 {
				for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
					var _objPtr uintptr = (*TestSession)(unsafe.Pointer(p)).FpFilterScript
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestSession)(unsafe.Pointer(p)).Finterp = interp
			(*TestSession)(unsafe.Pointer(p)).FpFilterScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			(*Tcl_Obj)(unsafe.Pointer((*TestSession)(unsafe.Pointer(p)).FpFilterScript)).FrefCount++
			sqlite3.Xsqlite3session_table_filter(tls, pSession, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			}{test_table_filter})), clientData)
			break

		}

	case 8:
		{
			*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
			rc = sqlite3.Xsqlite3session_diff(tls, pSession,
				tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))),
				tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4))),
				bp+20)

			if rc != 0 {
				return test_session_error(tls, interp, rc, *(*uintptr)(unsafe.Pointer(bp + 20)))
			}
			break

		}

	case 9:
		{
			var nMalloc sqlite3_int64 = sqlite3.Xsqlite3session_memory_used(tls, pSession)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, nMalloc))
			break

		}

	case 10:
		{
			var nSize sqlite3_int64 = sqlite3.Xsqlite3session_changeset_size(tls, pSession)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, nSize))
			break

		}
	case 11:
		{
			var rc int32

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+24) != 0 {
				return TCL_ERROR
			}
			rc = sqlite3.Xsqlite3session_object_config(tls,
				pSession, SQLITE_SESSION_OBJCONFIG_SIZE, bp+24)
			if rc != SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			} else {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 24))))
			}
			break

		}
	}

	return TCL_OK
}

type SessionSubcmd = struct {
	FzSub uintptr
	FnArg int32
	FzMsg uintptr
	FiSub int32
}

var aSub1 = [13]SessionSubcmd{
	{FzSub: ts + 15023, FnArg: 1, FzMsg: ts + 1951},
	{FzSub: ts + 15030, FzMsg: ts + 584},
	{FzSub: ts + 15040, FzMsg: ts + 584},
	{FzSub: ts + 15047, FnArg: 1, FzMsg: ts + 15054},
	{FzSub: ts + 15059, FnArg: 1, FzMsg: ts + 15054},
	{FzSub: ts + 15068, FzMsg: ts + 584},
	{FzSub: ts + 15076, FnArg: 1, FzMsg: ts + 10001},
	{FzSub: ts + 15089, FzMsg: ts + 584},
	{FzSub: ts + 15098, FnArg: 2, FzMsg: ts + 15103},
	{FzSub: ts + 15114, FzMsg: ts + 584},
	{FzSub: ts + 15126, FzMsg: ts + 584},
	{FzSub: ts + 15141, FnArg: 1, FzMsg: ts + 2413},
	{},
}

func test_session_del(tls *libc.TLS, clientData uintptr) {
	var p uintptr = clientData
	if (*TestSession)(unsafe.Pointer(p)).FpFilterScript != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*TestSession)(unsafe.Pointer(p)).FpFilterScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3session_delete(tls, (*TestSession)(unsafe.Pointer(p)).FpSession)
	tcl.XTcl_Free(tls, p)
}

func test_sqlite3session(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var db uintptr

	var rc int32
	var p uintptr
	*(*int32)(unsafe.Pointer(bp + 56)) = -1

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15160)
		return TCL_ERROR
	}

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
		return TCL_ERROR
	}
	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24)).FobjClientData))

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestSession{})))
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(TestSession{})))
	rc = sqlite3.Xsqlite3session_create(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4))), p)
	if rc != SQLITE_OK {
		tcl.XTcl_Free(tls, p)
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	sqlite3.Xsqlite3session_object_config(tls, (*TestSession)(unsafe.Pointer(p)).FpSession, SQLITE_SESSION_OBJCONFIG_SIZE, bp+56)

	*(*int32)(unsafe.Pointer(bp + 56)) = 1
	sqlite3.Xsqlite3session_object_config(tls, (*TestSession)(unsafe.Pointer(p)).FpSession, SQLITE_SESSION_OBJCONFIG_SIZE, bp+56)

	tcl.XTcl_CreateObjCommand(tls,
		interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_session_cmd})), p,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{test_session_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func test_append_value(tls *libc.TLS, pList uintptr, pVal uintptr) {
	if pVal == uintptr(0) {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewObj(tls))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewObj(tls))
	} else {
		var pObj uintptr
		switch sqlite3.Xsqlite3_value_type(tls, pVal) {
		case SQLITE_NULL:
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+15182, 1))
			pObj = tcl.XTcl_NewObj(tls)
			break
			fallthrough
		case SQLITE_INTEGER:
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+15184, 1))
			pObj = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, pVal))
			break
			fallthrough
		case SQLITE_FLOAT:
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+15186, 1))
			pObj = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, pVal))
			break
			fallthrough
		case SQLITE_TEXT:
			{
				var z uintptr = sqlite3.Xsqlite3_value_blob(tls, pVal)
				var n int32 = sqlite3.Xsqlite3_value_bytes(tls, pVal)
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+15188, 1))
				pObj = tcl.XTcl_NewStringObj(tls, z, n)
				break

			}
			fallthrough
		default:
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+6563, 1))
			pObj = tcl.XTcl_NewByteArrayObj(tls,
				sqlite3.Xsqlite3_value_blob(tls, pVal),
				sqlite3.Xsqlite3_value_bytes(tls, pVal))
			break
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, pObj)
	}
}

type TestConflictHandler1 = struct {
	Finterp          uintptr
	FpConflictScript uintptr
	FpFilterScript   uintptr
}

type TestConflictHandler = TestConflictHandler1

func test_obj_eq_string(tls *libc.TLS, p uintptr, z uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var n int32

	var zObj uintptr

	n = int32(libc.Xstrlen(tls, z))
	zObj = tcl.XTcl_GetStringFromObj(tls, p, bp)

	return libc.Bool32(*(*int32)(unsafe.Pointer(bp)) == n && (n == 0 || 0 == libc.Xmemcmp(tls, zObj, z, uint32(n))))
}

func test_filter_handler(tls *libc.TLS, pCtx uintptr, zTab uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	*(*int32)(unsafe.Pointer(bp)) = 1
	var pEval uintptr
	var interp uintptr = (*TestConflictHandler)(unsafe.Pointer(p)).Finterp

	pEval = tcl.XTcl_DuplicateObj(tls, (*TestConflictHandler)(unsafe.Pointer(p)).FpFilterScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++

	if TCL_OK != tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, zTab, -1)) ||
		TCL_OK != tcl.XTcl_EvalObjEx(tls, interp, pEval, TCL_EVAL_GLOBAL) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, tcl.XTcl_GetObjResult(tls, interp), bp) {
		tcl.XTcl_BackgroundError(tls, interp)
	}

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func test_conflict_handler(tls *libc.TLS, pCtx uintptr, eConf int32, pIter uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var p uintptr = pCtx
	var pEval uintptr
	var interp uintptr = (*TestConflictHandler)(unsafe.Pointer(p)).Finterp
	*(*int32)(unsafe.Pointer(bp + 56)) = 0

	pEval = tcl.XTcl_DuplicateObj(tls, (*TestConflictHandler)(unsafe.Pointer(p)).FpConflictScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++

	sqlite3.Xsqlite3changeset_op(tls, pIter, bp, bp+4, bp+8, uintptr(0))

	if eConf == SQLITE_CHANGESET_FOREIGN_KEY {
		sqlite3.Xsqlite3changeset_fk_conflicts(tls, pIter, bp+12)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, ts+15190, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12))))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls,
			func() uintptr {
				if *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_INSERT {
					return ts + 15202
				}
				return func() uintptr {
					if *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_UPDATE {
						return ts + 15209
					}
					return ts + 15216
				}()
			}(), -1))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp)), -1))

		switch eConf {
		case SQLITE_CHANGESET_DATA:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+15223, -1))
			break
			fallthrough
		case SQLITE_CHANGESET_NOTFOUND:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+15228, -1))
			break
			fallthrough
		case SQLITE_CHANGESET_CONFLICT:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+15237, -1))
			break
			fallthrough
		case SQLITE_CHANGESET_CONSTRAINT:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+15246, -1))
			break
		}

		if *(*int32)(unsafe.Pointer(bp + 8)) != SQLITE_INSERT {
			var i int32
			var pOld uintptr = tcl.XTcl_NewObj(tls)
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 4)); i++ {
				sqlite3.Xsqlite3changeset_old(tls, pIter, i, bp+16)
				test_append_value(tls, pOld, *(*uintptr)(unsafe.Pointer(bp + 16)))
			}
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pOld)
		}

		if *(*int32)(unsafe.Pointer(bp + 8)) != SQLITE_DELETE {
			var i int32
			var pNew uintptr = tcl.XTcl_NewObj(tls)
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 4)); i++ {
				sqlite3.Xsqlite3changeset_new(tls, pIter, i, bp+20)
				test_append_value(tls, pNew, *(*uintptr)(unsafe.Pointer(bp + 20)))
			}
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pNew)
		}

		if eConf == SQLITE_CHANGESET_DATA || eConf == SQLITE_CHANGESET_CONFLICT {
			var i int32
			var pConflict uintptr = tcl.XTcl_NewObj(tls)
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 4)); i++ {
				var rc int32
				_ = rc

				rc = sqlite3.Xsqlite3changeset_conflict(tls, pIter, i, bp+24)

				test_append_value(tls, pConflict, *(*uintptr)(unsafe.Pointer(bp + 24)))
			}
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pConflict)
		}

		if eConf == SQLITE_CHANGESET_CONSTRAINT ||
			eConf == SQLITE_CHANGESET_NOTFOUND {
			var rc int32 = sqlite3.Xsqlite3changeset_conflict(tls, pIter, 0, bp+28)
			_ = rc

		} else {
			var rc int32 = sqlite3.Xsqlite3changeset_conflict(tls, pIter, -1, bp+32)
			_ = rc

			rc = sqlite3.Xsqlite3changeset_conflict(tls, pIter, *(*int32)(unsafe.Pointer(bp + 4)), bp+32)

		}
		if *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_DELETE {
			var rc int32 = sqlite3.Xsqlite3changeset_new(tls, pIter, 0, bp+36)
			_ = rc

		} else {
			var rc int32 = sqlite3.Xsqlite3changeset_new(tls, pIter, -1, bp+40)
			_ = rc

			rc = sqlite3.Xsqlite3changeset_new(tls, pIter, *(*int32)(unsafe.Pointer(bp + 4)), bp+40)

		}
		if *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_INSERT {
			var rc int32 = sqlite3.Xsqlite3changeset_old(tls, pIter, 0, bp+44)
			_ = rc

		} else {
			var rc int32 = sqlite3.Xsqlite3changeset_old(tls, pIter, -1, bp+48)
			_ = rc

			rc = sqlite3.Xsqlite3changeset_old(tls, pIter, *(*int32)(unsafe.Pointer(bp + 4)), bp+48)

		}
		if eConf != SQLITE_CHANGESET_FOREIGN_KEY {
			var rc int32 = sqlite3.Xsqlite3changeset_fk_conflicts(tls, pIter, bp+52)
			_ = rc

		}

	}

	if TCL_OK != tcl.XTcl_EvalObjEx(tls, interp, pEval, TCL_EVAL_GLOBAL) {
		tcl.XTcl_BackgroundError(tls, interp)
	} else {
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		if test_obj_eq_string(tls, pRes, ts+15257) != 0 || test_obj_eq_string(tls, pRes, ts+584) != 0 {
			*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_CHANGESET_OMIT
		} else if test_obj_eq_string(tls, pRes, ts+8201) != 0 {
			*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_CHANGESET_REPLACE
		} else if test_obj_eq_string(tls, pRes, ts+8195) != 0 {
			*(*int32)(unsafe.Pointer(bp + 56)) = SQLITE_CHANGESET_ABORT
		} else {
			tcl.XTcl_GetIntFromObj(tls, uintptr(0), pRes, bp+56)
		}
	}

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return *(*int32)(unsafe.Pointer(bp + 56))
}

func replace_handler(tls *libc.TLS, pCtx uintptr, eConf int32, pIter uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var i int32
	var x int32 = 0

	sqlite3.Xsqlite3changeset_op(tls, pIter, bp, bp+4, bp+8, uintptr(0))

	if *(*int32)(unsafe.Pointer(bp + 8)) != SQLITE_INSERT {
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 4)); i++ {
			sqlite3.Xsqlite3changeset_old(tls, pIter, i, bp+12)
			sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(bp + 12)))
			x++
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 8)) != SQLITE_DELETE {
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 4)); i++ {
			sqlite3.Xsqlite3changeset_new(tls, pIter, i, bp+16)
			sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
			x++
		}
	}

	if eConf == SQLITE_CHANGESET_DATA {
		return SQLITE_CHANGESET_REPLACE
	}
	return SQLITE_CHANGESET_OMIT
}

func testStreamInput(tls *libc.TLS, pCtx uintptr, pData uintptr, pnData uintptr) int32 {
	var p uintptr = pCtx
	var nReq int32 = *(*int32)(unsafe.Pointer(pnData))
	var nRem int32 = (*TestStreamInput)(unsafe.Pointer(p)).FnData - (*TestStreamInput)(unsafe.Pointer(p)).FiData
	var nRet int32 = (*TestStreamInput)(unsafe.Pointer(p)).FnStream

	var pAlloc uintptr = sqlite3.Xsqlite3_malloc(tls, 10)
	if pAlloc == uintptr(0) {
		return SQLITE_NOMEM
	}
	sqlite3.Xsqlite3_free(tls, pAlloc)

	if nRet > nReq {
		nRet = nReq
	}
	if nRet > nRem {
		nRet = nRem
	}

	if nRet > 0 {
		libc.Xmemcpy(tls, pData, (*TestStreamInput)(unsafe.Pointer(p)).FaData+uintptr((*TestStreamInput)(unsafe.Pointer(p)).FiData), uint32(nRet))
		*(*int32)(unsafe.Pointer(p + 12)) += nRet
	}

	*(*int32)(unsafe.Pointer(pnData)) = nRet
	return SQLITE_OK
}

func testSqlite3changesetApply(tls *libc.TLS, bV2 int32, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var db uintptr

	var rc int32
	var pChangeset uintptr

	*(*uintptr)(unsafe.Pointer(bp + 88)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 92)) = 0
	var flags int32 = 0

	libc.Xmemset(tls, bp+24, 0, uint32(unsafe.Sizeof(TestStreamInput{})))
	(*TestStreamInput)(unsafe.Pointer(bp + 24)).FnStream = test_tcl_integer(tls, interp, ts+15000)

	if bV2 != 0 {
		if objc > 1 {
			var z1 uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
			var n int32 = int32(libc.Xstrlen(tls, z1))
			if n > 1 && n <= 12 && 0 == sqlite3.Xsqlite3_strnicmp(tls, ts+15262, z1, n) {
				flags = flags | SQLITE_CHANGESETAPPLY_NOSAVEPOINT
				objc--
				objv += 4
			}
		}
		if objc > 1 {
			var z1 uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
			var n int32 = int32(libc.Xstrlen(tls, z1))
			if n > 1 && n <= 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, ts+15275, z1, n) {
				flags = flags | SQLITE_CHANGESETAPPLY_INVERT
				objc--
				objv += 4
			}
		}
	}

	if objc != 4 && objc != 5 {
		var zMsg uintptr
		if bV2 != 0 {
			zMsg = ts + 15283
		} else {
			zMsg = ts + 15354
		}
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, zMsg)
		return TCL_ERROR
	}
	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+40) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), 0))
		return TCL_ERROR
	}
	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 40)).FobjClientData))
	pChangeset = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+72)
	(*TestConflictHandler)(unsafe.Pointer(bp + 76)).FpConflictScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
	(*TestConflictHandler)(unsafe.Pointer(bp + 76)).FpFilterScript = func() uintptr {
		if objc == 5 {
			return *(*uintptr)(unsafe.Pointer(objv + 4*4))
		}
		return uintptr(0)
	}()
	(*TestConflictHandler)(unsafe.Pointer(bp + 76)).Finterp = interp

	if (*TestStreamInput)(unsafe.Pointer(bp+24)).FnStream == 0 {
		if bV2 == 0 {
			rc = sqlite3.Xsqlite3changeset_apply(tls, db, *(*int32)(unsafe.Pointer(bp + 72)), pChangeset,
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(), *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+76)
		} else {
			rc = sqlite3.Xsqlite3changeset_apply_v2(tls, db, *(*int32)(unsafe.Pointer(bp + 72)), pChangeset,
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(), *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+76,
				bp+88, bp+92, flags)
		}
	} else {
		(*TestStreamInput)(unsafe.Pointer(bp + 24)).FaData = pChangeset
		(*TestStreamInput)(unsafe.Pointer(bp + 24)).FnData = *(*int32)(unsafe.Pointer(bp + 72))
		if bV2 == 0 {
			rc = sqlite3.Xsqlite3changeset_apply_strm(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp+24,
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+76)
		} else {
			rc = sqlite3.Xsqlite3changeset_apply_v2_strm(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp+24,
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+76,
				bp+88, bp+92, flags)
		}
	}

	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	} else {
		tcl.XTcl_ResetResult(tls, interp)
		if bV2 != 0 && *(*uintptr)(unsafe.Pointer(bp + 88)) != 0 {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 88)), *(*int32)(unsafe.Pointer(bp + 92))))
		}
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 88)))
	return TCL_OK
}

func test_sqlite3changeset_apply(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	return testSqlite3changesetApply(tls, 0, clientData, interp, objc, objv)
}

func test_sqlite3changeset_apply_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	return testSqlite3changesetApply(tls, 1, clientData, interp, objc, objv)
}

func test_sqlite3changeset_apply_replace_all(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var db uintptr

	var rc int32
	var pChangeset uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15399)
		return TCL_ERROR
	}
	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
		return TCL_ERROR
	}
	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24)).FobjClientData))
	pChangeset = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+56)

	rc = sqlite3.Xsqlite3changeset_apply(tls, db, *(*int32)(unsafe.Pointer(bp + 56)), pChangeset, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{replace_handler})), uintptr(0))
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}
	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func test_sqlite3changeset_invert(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15412)
		return TCL_ERROR
	}

	libc.Xmemset(tls, bp, 0, uint32(unsafe.Sizeof(TestStreamInput{})))
	libc.Xmemset(tls, bp+16, 0, uint32(unsafe.Sizeof(TestSessionsBlob{})))
	(*TestStreamInput)(unsafe.Pointer(bp)).FnStream = test_tcl_integer(tls, interp, ts+15000)
	(*TestStreamInput)(unsafe.Pointer(bp)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8)

	if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream != 0 {
		rc = sqlite3.Xsqlite3changeset_invert_strm(tls,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			}{testStreamOutput})), bp+16)
	} else {
		rc = sqlite3.Xsqlite3changeset_invert(tls, (*TestStreamInput)(unsafe.Pointer(bp)).FnData, (*TestStreamInput)(unsafe.Pointer(bp)).FaData, bp+16+4, bp+16)
	}
	if rc != SQLITE_OK {
		rc = test_session_error(tls, interp, rc, uintptr(0))
	} else {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+16)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+16)).Fn))
	}
	sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+16)).Fp)
	return rc
}

func test_sqlite3changeset_concat(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32

	*(*TestSessionsBlob)(unsafe.Pointer(bp + 32)) = TestSessionsBlob{}

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15422)
		return TCL_ERROR
	}

	libc.Xmemset(tls, bp, 0, uint32(unsafe.Sizeof(TestStreamInput{})))
	libc.Xmemset(tls, bp+16, 0, uint32(unsafe.Sizeof(TestStreamInput{})))
	(*TestStreamInput)(unsafe.Pointer(bp)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8)
	(*TestStreamInput)(unsafe.Pointer(bp + 16)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16+8)
	(*TestStreamInput)(unsafe.Pointer(bp)).FnStream = test_tcl_integer(tls, interp, ts+15000)
	(*TestStreamInput)(unsafe.Pointer(bp + 16)).FnStream = (*TestStreamInput)(unsafe.Pointer(bp)).FnStream

	if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream > 0 {
		rc = sqlite3.Xsqlite3changeset_concat_strm(tls,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp+16,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			}{testStreamOutput})), bp+32)
	} else {
		rc = sqlite3.Xsqlite3changeset_concat(tls,
			(*TestStreamInput)(unsafe.Pointer(bp)).FnData, (*TestStreamInput)(unsafe.Pointer(bp)).FaData, (*TestStreamInput)(unsafe.Pointer(bp+16)).FnData, (*TestStreamInput)(unsafe.Pointer(bp+16)).FaData, bp+32+4, bp+32)
	}

	if rc != SQLITE_OK {
		rc = test_session_error(tls, interp, rc, uintptr(0))
	} else {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+32)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+32)).Fn))
	}
	sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+32)).Fp)
	return rc
}

func test_sqlite3session_foreach(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var pChangeset uintptr

	var rc int32
	var pVarname uintptr
	var pCS uintptr
	var pScript uintptr
	var isCheckNext int32 = 0
	var isInvert int32 = 0

	libc.Xmemset(tls, bp, 0, uint32(unsafe.Sizeof(TestStreamInput{})))

	for objc > 1 {
		var zOpt uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
		var nOpt int32 = int32(libc.Xstrlen(tls, zOpt))
		if int32(*(*int8)(unsafe.Pointer(zOpt))) != '-' {
			break
		}
		if nOpt <= 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+15275, nOpt) {
			isInvert = 1
		} else if nOpt <= 5 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+15433, nOpt) {
			isCheckNext = 1
		} else {
			break
		}
		objv += 4
		objc--
	}
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+15439)
		return TCL_ERROR
	}

	pVarname = *(*uintptr)(unsafe.Pointer(objv + 1*4))
	pCS = *(*uintptr)(unsafe.Pointer(objv + 2*4))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))

	pChangeset = tcl.XTcl_GetByteArrayFromObj(tls, pCS, bp+16)
	(*TestStreamInput)(unsafe.Pointer(bp)).FnStream = test_tcl_integer(tls, interp, ts+15000)
	if isInvert != 0 {
		var f int32 = SQLITE_CHANGESETSTART_INVERT
		if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream == 0 {
			rc = sqlite3.Xsqlite3changeset_start_v2(tls, bp+20, *(*int32)(unsafe.Pointer(bp + 16)), pChangeset, f)
		} else {
			var pCtx uintptr = bp
			(*TestStreamInput)(unsafe.Pointer(bp)).FaData = pChangeset
			(*TestStreamInput)(unsafe.Pointer(bp)).FnData = *(*int32)(unsafe.Pointer(bp + 16))
			rc = sqlite3.Xsqlite3changeset_start_v2_strm(tls, bp+20, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), pCtx, f)
		}
	} else {
		if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream == 0 {
			rc = sqlite3.Xsqlite3changeset_start(tls, bp+20, *(*int32)(unsafe.Pointer(bp + 16)), pChangeset)
		} else {
			(*TestStreamInput)(unsafe.Pointer(bp)).FaData = pChangeset
			(*TestStreamInput)(unsafe.Pointer(bp)).FnData = *(*int32)(unsafe.Pointer(bp + 16))
			rc = sqlite3.Xsqlite3changeset_start_strm(tls, bp+20, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp)
		}
	}
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	for SQLITE_ROW == sqlite3.Xsqlite3changeset_next(tls, *(*uintptr)(unsafe.Pointer(bp + 20))) {
		var pVar uintptr
		var pOld uintptr
		var pNew uintptr

		var zPK uintptr

		var i int32

		if SQLITE_MISUSE != sqlite3.Xsqlite3changeset_fk_conflicts(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), bp+24) {
			sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))
			return TCL_ERROR
		}

		sqlite3.Xsqlite3changeset_op(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), bp+28, bp+32, bp+36, bp+40)
		pVar = tcl.XTcl_NewObj(tls)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewStringObj(tls,
			func() uintptr {
				if *(*int32)(unsafe.Pointer(bp + 36)) == SQLITE_INSERT {
					return ts + 15202
				}
				return func() uintptr {
					if *(*int32)(unsafe.Pointer(bp + 36)) == SQLITE_UPDATE {
						return ts + 15209
					}
					return ts + 15216
				}()
			}(), -1))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 28)), -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewIntObj(tls, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 40)) != 0)))

		zPK = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 32))+1))
		libc.Xmemset(tls, zPK, 0, uint32(*(*int32)(unsafe.Pointer(bp + 32))+1))
		sqlite3.Xsqlite3changeset_pk(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), bp+44, bp+48)

		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 32)); i++ {
			*(*int8)(unsafe.Pointer(zPK + uintptr(i))) = func() int8 {
				if *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44)) + uintptr(i))) != 0 {
					return int8('X')
				}
				return int8('.')
			}()
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewStringObj(tls, zPK, -1))
		tcl.XTcl_Free(tls, zPK)

		pOld = tcl.XTcl_NewObj(tls)
		if *(*int32)(unsafe.Pointer(bp + 36)) != SQLITE_INSERT {
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 32)); i++ {
				sqlite3.Xsqlite3changeset_old(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), i, bp+52)
				test_append_value(tls, pOld, *(*uintptr)(unsafe.Pointer(bp + 52)))
			}
		}
		pNew = tcl.XTcl_NewObj(tls)
		if *(*int32)(unsafe.Pointer(bp + 36)) != SQLITE_DELETE {
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 32)); i++ {
				sqlite3.Xsqlite3changeset_new(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), i, bp+56)
				test_append_value(tls, pNew, *(*uintptr)(unsafe.Pointer(bp + 56)))
			}
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, pOld)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, pNew)

		tcl.XTcl_ObjSetVar2(tls, interp, pVarname, uintptr(0), pVar, 0)
		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		if rc != TCL_OK && rc != TCL_CONTINUE {
			sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))
			if rc == TCL_BREAK {
				return TCL_OK
			}
			return rc
		}
	}

	if isCheckNext != 0 {
		var rc2 int32 = sqlite3.Xsqlite3changeset_next(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))
		_ = rc2
		rc = sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))

	} else {
		rc = sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))
	}
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	return TCL_OK
}

func test_rebaser_cmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr = clientData

	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&aSub2)), int32(unsafe.Sizeof(RebaseSubcmd{})), ts+2014, 0, bp)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+aSub2[*(*int32)(unsafe.Pointer(bp))].FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, aSub2[*(*int32)(unsafe.Pointer(bp))].FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp)) {
	case 0:
		{
			*(*int32)(unsafe.Pointer(bp + 4)) = 0
			var pRebase uintptr = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4)
			rc = sqlite3.Xsqlite3rebaser_configure(tls, p, *(*int32)(unsafe.Pointer(bp + 4)), pRebase)
			break

		}

	case 1:
		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
		break

	default:
		{
			libc.Xmemset(tls, bp+8, 0, uint32(unsafe.Sizeof(TestStreamInput{})))
			libc.Xmemset(tls, bp+24, 0, uint32(unsafe.Sizeof(TestSessionsBlob{})))
			(*TestStreamInput)(unsafe.Pointer(bp + 8)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+8+8)
			(*TestStreamInput)(unsafe.Pointer(bp + 8)).FnStream = test_tcl_integer(tls, interp, ts+15000)

			if (*TestStreamInput)(unsafe.Pointer(bp+8)).FnStream != 0 {
				rc = sqlite3.Xsqlite3rebaser_rebase_strm(tls, p,
					*(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, uintptr) int32
					}{testStreamInput})), bp+8,
					*(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					}{testStreamOutput})), bp+24)
			} else {
				rc = sqlite3.Xsqlite3rebaser_rebase(tls, p, (*TestStreamInput)(unsafe.Pointer(bp+8)).FnData, (*TestStreamInput)(unsafe.Pointer(bp+8)).FaData, bp+24+4, bp+24)
			}

			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+24)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+24)).Fn))
			}
			sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+24)).Fp)
			break

		}
	}

	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}
	return TCL_OK
}

type RebaseSubcmd = struct {
	FzSub uintptr
	FnArg int32
	FzMsg uintptr
	FiSub int32
}

var aSub2 = [4]RebaseSubcmd{
	{FzSub: ts + 15482, FnArg: 1, FzMsg: ts + 15492},
	{FzSub: ts + 15040, FzMsg: ts + 584},
	{FzSub: ts + 15504, FnArg: 1, FzMsg: ts + 15412},
	{},
}

func test_rebaser_del(tls *libc.TLS, clientData uintptr) {
	var p uintptr = clientData
	sqlite3.Xsqlite3rebaser_delete(tls, p)
}

func test_sqlite3rebaser_create(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10139)
		return SQLITE_ERROR
	}

	rc = sqlite3.Xsqlite3rebaser_create(tls, bp)
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	tcl.XTcl_CreateObjCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_rebaser_cmd})),
		*(*uintptr)(unsafe.Pointer(bp)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{test_rebaser_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func sqlite3_test_changeset(tls *libc.TLS, nChangeset int32, pChangeset uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	*(*uintptr)(unsafe.Pointer(bp + 32)) = uintptr(0)
	var zErr uintptr = uintptr(0)
	var rc int32 = SQLITE_OK
	var bPatch int32 = libc.Bool32(nChangeset > 0 && int32(*(*int8)(unsafe.Pointer(pChangeset))) == 'P')

	rc = sqlite3.Xsqlite3changeset_start(tls, bp+32, nChangeset, pChangeset)
	if rc == SQLITE_OK {
		var rc2 int32
		for rc == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3changeset_next(tls, *(*uintptr)(unsafe.Pointer(bp + 32))) {
			*(*uintptr)(unsafe.Pointer(bp + 36)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 40)) = 0
			*(*int32)(unsafe.Pointer(bp + 48)) = 0
			*(*uintptr)(unsafe.Pointer(bp + 44)) = uintptr(0)

			sqlite3.Xsqlite3changeset_pk(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), bp+36, bp+40)
			sqlite3.Xsqlite3changeset_op(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), bp+44, bp+40, bp+48, uintptr(0))

			if *(*int32)(unsafe.Pointer(bp + 48)) == SQLITE_UPDATE {
				var iCol int32
				for iCol = 0; iCol < *(*int32)(unsafe.Pointer(bp + 40)); iCol++ {
					*(*uintptr)(unsafe.Pointer(bp + 52)) = uintptr(0)
					*(*uintptr)(unsafe.Pointer(bp + 56)) = uintptr(0)
					sqlite3.Xsqlite3changeset_new(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), iCol, bp+52)
					sqlite3.Xsqlite3changeset_old(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), iCol, bp+56)

					if *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 36)) + uintptr(iCol))) != 0 {
						if *(*uintptr)(unsafe.Pointer(bp + 56)) == uintptr(0) {
							rc = SQLITE_ERROR
						}
					} else if bPatch != 0 {
						if *(*uintptr)(unsafe.Pointer(bp + 56)) != 0 {
							rc = SQLITE_ERROR
						}
					} else {
						if libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 56)) == uintptr(0)) != libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 52)) == uintptr(0)) {
							rc = SQLITE_ERROR
						}
					}

					if rc != SQLITE_OK {
						zErr = sqlite3.Xsqlite3_mprintf(tls,
							ts+15511,
							libc.VaList(bp, bPatch, int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 36)) + uintptr(iCol)))), libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 56)) != uintptr(0)), libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 52)) != uintptr(0))))
						break
					}
				}
			}
		}
		rc2 = sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}

	*(*uintptr)(unsafe.Pointer(pzErr)) = zErr
	return rc
}

func test_changeset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pChangeset uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 16)) = 0
	var rc int32 = SQLITE_OK
	*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15412)
		return TCL_ERROR
	}
	pChangeset = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16)

	tcl.XTcl_ResetResult(tls, interp)
	rc = sqlite3_test_changeset(tls, *(*int32)(unsafe.Pointer(bp + 16)), pChangeset, bp+20)
	if rc != SQLITE_OK {
		var zErr uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+15570, libc.VaList(bp, rc, *(*uintptr)(unsafe.Pointer(bp + 20))))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErr, -1))
		sqlite3.Xsqlite3_free(tls, zErr)
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))

	if rc != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_sqlite3session_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15582)
		return SQLITE_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&aSub3)), int32(unsafe.Sizeof(ConfigOpt{})), ts+2014, 0, bp)
	if rc != TCL_OK {
		return rc
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3session_config(tls, aSub3[*(*int32)(unsafe.Pointer(bp))].Fop, bp+4)
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4))))
	return TCL_OK
}

type ConfigOpt = struct {
	FzSub uintptr
	Fop   int32
}

var aSub3 = [3]ConfigOpt{
	{FzSub: ts + 15591, Fop: SQLITE_SESSION_CONFIG_STRMSIZE},
	{FzSub: ts + 2758},
	{},
}

func TestSession_Init(tls *libc.TLS, interp uintptr) int32 {
	bp := tls.Alloc(88)
	defer tls.Free(88)

	*(*[11]struct {
		FzCmd  uintptr
		FxProc uintptr
	})(unsafe.Pointer(bp)) = [11]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{
		{FzCmd: ts + 15601, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3session}))},
		{FzCmd: ts + 15616, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3session_foreach}))},
		{FzCmd: ts + 15639, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_invert}))},
		{FzCmd: ts + 15663, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_concat}))},
		{FzCmd: ts + 15687, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_apply}))},
		{FzCmd: ts + 15710, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_apply_v2}))},
		{FzCmd: ts + 15736,
			FxProc: *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			}{test_sqlite3changeset_apply_replace_all}))},
		{FzCmd: ts + 15771, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sql_exec_changeset}))},
		{FzCmd: ts + 15790, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3rebaser_create}))},
		{FzCmd: ts + 15812, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3session_config}))},
		{FzCmd: ts + 15834, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_changeset}))},
	}
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof([11]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{}))/uint32(unsafe.Sizeof(struct {
		FzCmd  uintptr
		FxProc uintptr
	}{})); i++ {
		var p uintptr = bp + uintptr(i)*8
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FzCmd, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

type sig_atomic_t = int32

type sigcontext = struct {
	Fsc_mask          struct{ F__bits [4]uint32 }
	Fsc_onstack       int32
	Fsc_gs            int32
	Fsc_fs            int32
	Fsc_es            int32
	Fsc_ds            int32
	Fsc_edi           int32
	Fsc_esi           int32
	Fsc_ebp           int32
	Fsc_isp           int32
	Fsc_ebx           int32
	Fsc_edx           int32
	Fsc_ecx           int32
	Fsc_eax           int32
	Fsc_trapno        int32
	Fsc_err           int32
	Fsc_eip           int32
	Fsc_cs            int32
	Fsc_efl           int32
	Fsc_esp           int32
	Fsc_ss            int32
	Fsc_len           int32
	Fsc_fpformat      int32
	Fsc_ownedfp       int32
	Fsc_flags         int32
	Fsc_fpstate       [128]int32
	Fsc_fsbase        int32
	Fsc_gsbase        int32
	Fsc_xfpustate     int32
	Fsc_xfpustate_len int32
	Fsc_spare2        [4]int32
}

type sigval = struct{ Fsival_int int32 }

type __siginfo = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	Fsi_pid    int32
	Fsi_uid    uint32
	Fsi_status int32
	Fsi_addr   uintptr
	Fsi_value  struct{ Fsival_int int32 }
	F_reason   struct {
		F_fault      struct{ F_trapno int32 }
		F__ccgo_pad1 [28]byte
	}
}

type siginfo_t = __siginfo

type sigaction = struct {
	F__sigaction_u struct{ F__sa_handler uintptr }
	Fsa_flags      int32
	Fsa_mask       sigset_t
}

type sig_t = uintptr

type sigaltstack = struct {
	Fss_sp    uintptr
	Fss_size  uint32
	Fss_flags int32
}

type stack_t = sigaltstack

type sigvec = struct {
	Fsv_handler uintptr
	Fsv_mask    int32
	Fsv_flags   int32
}

type sigstack = struct {
	Fss_sp      uintptr
	Fss_onstack int32
}

type __mcontext = struct {
	Fmc_onstack       int32
	Fmc_gs            int32
	Fmc_fs            int32
	Fmc_es            int32
	Fmc_ds            int32
	Fmc_edi           int32
	Fmc_esi           int32
	Fmc_ebp           int32
	Fmc_isp           int32
	Fmc_ebx           int32
	Fmc_edx           int32
	Fmc_ecx           int32
	Fmc_eax           int32
	Fmc_trapno        int32
	Fmc_err           int32
	Fmc_eip           int32
	Fmc_cs            int32
	Fmc_eflags        int32
	Fmc_esp           int32
	Fmc_ss            int32
	Fmc_len           int32
	Fmc_fpformat      int32
	Fmc_ownedfp       int32
	Fmc_flags         int32
	Fmc_fpstate       [128]int32
	Fmc_fsbase        int32
	Fmc_gsbase        int32
	Fmc_xfpustate     int32
	Fmc_xfpustate_len int32
	Fmc_spare2        [4]int32
}

type mcontext_t = __mcontext

type __ucontext = struct {
	Fuc_sigmask  struct{ F__bits [4]uint32 }
	Fuc_mcontext mcontext_t
	Fuc_link     uintptr
	Fuc_stack    struct {
		Fss_sp    uintptr
		Fss_size  uint32
		Fss_flags int32
	}
	Fuc_flags  int32
	F__spare__ [4]int32
}

type ucontext_t = __ucontext

type SqliteDb = struct {
	Fdb             uintptr
	Finterp         uintptr
	FzBusy          uintptr
	FzCommit        uintptr
	FzTrace         uintptr
	FzTraceV2       uintptr
	FzProfile       uintptr
	FzProgress      uintptr
	FzBindFallback  uintptr
	FzAuth          uintptr
	FdisableAuth    int32
	FzNull          uintptr
	FpFunc          uintptr
	FpUpdateHook    uintptr
	FpPreUpdateHook uintptr
	FpRollbackHook  uintptr
	FpWalHook       uintptr
	FpUnlockNotify  uintptr
	FpCollate       uintptr
	Frc             int32
	FpCollateNeeded uintptr
	FstmtList       uintptr
	FstmtLast       uintptr
	FmaxStmt        int32
	FnStmt          int32
	FpIncrblob      uintptr
	FnStep          int32
	FnSort          int32
	FnIndex         int32
	FnVMStep        int32
	FnTransaction   int32
	FopenFlags      int32
	FnRef           int32
	FbLegacyPrepare int32
}

type SqlFunc1 = struct {
	Finterp      uintptr
	FpScript     uintptr
	FpDb         uintptr
	FuseEvalObjv int32
	FeType       int32
	FzName       uintptr
	FpNext       uintptr
}

type SqlFunc = SqlFunc1

type SqlCollate1 = struct {
	Finterp  uintptr
	FzScript uintptr
	FpNext   uintptr
}

type SqlCollate = SqlCollate1

type SqlPreparedStmt1 = struct {
	FpNext  uintptr
	FpPrev  uintptr
	FpStmt  uintptr
	FnSql   int32
	FzSql   uintptr
	FnParm  int32
	FapParm uintptr
}

type SqlPreparedStmt = SqlPreparedStmt1

type IncrblobChannel1 = struct {
	FpBlob   uintptr
	FpDb     uintptr
	FiSeek   int32
	Fchannel Tcl_Channel
	FpNext   uintptr
	FpPrev   uintptr
}

type IncrblobChannel = IncrblobChannel1

func strlen30(tls *libc.TLS, z uintptr) int32 {
	var z2 uintptr = z
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return 0x3fffffff & ((int32(z2) - int32(z)) / 1)
}

func closeIncrblobChannels(tls *libc.TLS, pDb uintptr) {
	var p uintptr
	var pNext uintptr

	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob; p != 0; p = pNext {
		pNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext

		tcl.XTcl_UnregisterChannel(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)
	}
}

func incrblobClose(tls *libc.TLS, instanceData ClientData, interp uintptr) int32 {
	var p uintptr = instanceData
	var rc int32 = sqlite3.Xsqlite3_blob_close(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	var db uintptr = (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).Fdb

	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev
	}
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpPrev)).FpNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}
	if (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob == p {
		(*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}

	tcl.XTcl_Free(tls, p)

	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, db), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

func incrblobInput(tls *libc.TLS, instanceData ClientData, buf uintptr, bufSize int32, errorCodePtr uintptr) int32 {
	var p uintptr = instanceData
	var nRead int32 = bufSize
	var nBlob int32
	var rc int32

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek+nRead > nBlob {
		nRead = nBlob - (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek
	}
	if nRead <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_read(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nRead, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != SQLITE_OK {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = rc
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 8)) += nRead
	return nRead
}

func incrblobOutput(tls *libc.TLS, instanceData ClientData, buf uintptr, toWrite int32, errorCodePtr uintptr) int32 {
	var p uintptr = instanceData
	var nWrite int32 = toWrite
	var nBlob int32
	var rc int32

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek+nWrite > nBlob {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = EINVAL
		return -1
	}
	if nWrite <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_write(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nWrite, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != SQLITE_OK {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = EIO
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 8)) += nWrite
	return nWrite
}

func incrblobSeek(tls *libc.TLS, instanceData ClientData, offset int32, seekMode int32, errorCodePtr uintptr) int32 {
	var p uintptr = instanceData

	switch seekMode {
	case SEEK_SET:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = offset
		break
	case SEEK_CUR:
		*(*int32)(unsafe.Pointer(p + 8)) += offset
		break
	case SEEK_END:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob) + offset
		break

	default:
	}

	return (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek
}

func incrblobWatch(tls *libc.TLS, instanceData ClientData, mode int32) {
}

func incrblobHandle(tls *libc.TLS, instanceData ClientData, dir int32, hPtr uintptr) int32 {
	return TCL_ERROR
}

var IncrblobChannelType = Tcl_ChannelType{
	FtypeName:      ts + 15849,
	Fversion:       uintptr(0x2),
	FcloseProc:     0,
	FinputProc:     0,
	FoutputProc:    0,
	FseekProc:      0,
	FwatchProc:     0,
	FgetHandleProc: 0,
}

func createIncrblobChannel(tls *libc.TLS, interp uintptr, pDb uintptr, zDb uintptr, zTable uintptr, zColumn uintptr, iRow sqlite_int64, isReadonly int32) int32 {
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var p uintptr
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb

	var rc int32
	var flags int32 = int32(1)<<1 | func() int32 {
		if isReadonly != 0 {
			return 0
		}
		return int32(1) << 2
	}()

	rc = sqlite3.Xsqlite3_blob_open(tls, db, zDb, zTable, zColumn, iRow, libc.BoolInt32(!(isReadonly != 0)), bp+8)
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
		return TCL_ERROR
	}

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(IncrblobChannel{})))
	(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = 0
	(*IncrblobChannel)(unsafe.Pointer(p)).FpBlob = *(*uintptr)(unsafe.Pointer(bp + 8))

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+12, ts+15858, libc.VaList(bp, libc.PreIncInt32(&count, 1)))
	(*IncrblobChannel)(unsafe.Pointer(p)).Fchannel = tcl.XTcl_CreateChannel(tls, uintptr(unsafe.Pointer(&IncrblobChannelType)), bp+12, p, flags)
	tcl.XTcl_RegisterChannel(tls, interp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)

	(*IncrblobChannel)(unsafe.Pointer(p)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob
	(*IncrblobChannel)(unsafe.Pointer(p)).FpPrev = uintptr(0)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = p
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob = p
	(*IncrblobChannel)(unsafe.Pointer(p)).FpDb = pDb

	tcl.XTcl_SetResult(tls, interp, tcl.XTcl_GetChannelName(tls, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel), uintptr(1))
	return TCL_OK
}

var count int32 = 0

func safeToUseEvalObjv(tls *libc.TLS, interp uintptr, pCmd uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var z uintptr

	z = tcl.XTcl_GetStringFromObj(tls, pCmd, bp)
	for libc.PostDecInt32(&*(*int32)(unsafe.Pointer(bp)), 1) > 0 {
		var c int32 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
		if c == '$' || c == '[' || c == ';' {
			return 0
		}
	}
	return 1
}

func findSqlFunc(tls *libc.TLS, pDb uintptr, zName uintptr) uintptr {
	var p uintptr
	var pNew uintptr
	var nName int32 = strlen30(tls, zName)
	pNew = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(SqlFunc{}))+uint32(nName)+uint32(1))
	(*SqlFunc)(unsafe.Pointer(pNew)).FzName = pNew + 1*28
	libc.Xmemcpy(tls, (*SqlFunc)(unsafe.Pointer(pNew)).FzName, zName, uint32(nName+1))
	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc; p != 0; p = (*SqlFunc)(unsafe.Pointer(p)).FpNext {
		if sqlite3.Xsqlite3_stricmp(tls, (*SqlFunc)(unsafe.Pointer(p)).FzName, (*SqlFunc)(unsafe.Pointer(pNew)).FzName) == 0 {
			tcl.XTcl_Free(tls, pNew)
			return p
		}
	}
	(*SqlFunc)(unsafe.Pointer(pNew)).Finterp = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp
	(*SqlFunc)(unsafe.Pointer(pNew)).FpDb = pDb
	(*SqlFunc)(unsafe.Pointer(pNew)).FpScript = uintptr(0)
	(*SqlFunc)(unsafe.Pointer(pNew)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
	(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = pNew
	return pNew
}

func dbFreeStmt(tls *libc.TLS, pStmt uintptr) {
	if sqlite3.Xsqlite3_sql(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt) == uintptr(0) {
		tcl.XTcl_Free(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FzSql)
	}
	sqlite3.Xsqlite3_finalize(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt)
	tcl.XTcl_Free(tls, pStmt)
}

func flushStmtCache(tls *libc.TLS, pDb uintptr) {
	var pPreStmt uintptr
	var pNext uintptr

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = pNext {
		pNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
		dbFreeStmt(tls, pPreStmt)
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt = 0
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = uintptr(0)
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = uintptr(0)
}

func addDatabaseRef(tls *libc.TLS, pDb uintptr) {
	(*SqliteDb)(unsafe.Pointer(pDb)).FnRef++
}

func delDatabaseRef(tls *libc.TLS, pDb uintptr) {
	(*SqliteDb)(unsafe.Pointer(pDb)).FnRef--
	if (*SqliteDb)(unsafe.Pointer(pDb)).FnRef == 0 {
		flushStmtCache(tls, pDb)
		closeIncrblobChannels(tls, pDb)
		sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
		for (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc != 0 {
			var pFunc uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
			(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = (*SqlFunc)(unsafe.Pointer(pFunc)).FpNext

			for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
				var _objPtr uintptr = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_Free(tls, pFunc)
		}
		for (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate != 0 {
			var pCollate uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
			(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = (*SqlCollate)(unsafe.Pointer(pCollate)).FpNext
			tcl.XTcl_Free(tls, pCollate)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
			for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook != 0 {
			for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
			for __ccgo3 := true; __ccgo3; __ccgo3 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
			for __ccgo4 := true; __ccgo4; __ccgo4 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0 {
			for __ccgo5 := true; __ccgo5; __ccgo5 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		tcl.XTcl_Free(tls, pDb)
	}
}

func DbDeleteCmd(tls *libc.TLS, db uintptr) {
	var pDb uintptr = db
	delDatabaseRef(tls, pDb)
}

func DbBusyHandler(tls *libc.TLS, cd uintptr, nTries int32) int32 {
	bp := tls.Alloc(70)
	defer tls.Free(70)

	var pDb uintptr = cd
	var rc int32

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+40, ts+1333, libc.VaList(bp, nTries))
	rc = tcl.XTcl_VarEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, libc.VaList(bp+8, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, ts+5251, bp+40, uintptr(0)))
	if rc != TCL_OK || libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0 {
		return 0
	}
	return 1
}

func DbProgressHandler(tls *libc.TLS, cd uintptr) int32 {
	var pDb uintptr = cd
	var rc int32

	rc = tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress)
	if rc != TCL_OK || libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0 {
		return 1
	}
	return 0
}

func DbTraceHandler(tls *libc.TLS, cd uintptr, zSql uintptr) {
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var pDb uintptr = cd

	tcl.XTcl_DStringInit(tls, bp)
	tcl.XTcl_DStringAppend(tls, bp, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, -1)
	tcl.XTcl_DStringAppendElement(tls, bp, zSql)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp)).Fstring)
	tcl.XTcl_DStringFree(tls, bp)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

func DbTraceV2Handler(tls *libc.TLS, type1 uint32, cd uintptr, pd uintptr, xd uintptr) int32 {
	var pDb uintptr = cd
	var pCmd uintptr

	switch type1 {
	case uint32(SQLITE_TRACE_STMT):
		{
			var pStmt uintptr = pd
			var zSql uintptr = xd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewStringObj(tls, zSql, -1))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_PROFILE):
		{
			var pStmt uintptr = pd
			var ns sqlite3_int64 = *(*sqlite3_int64)(unsafe.Pointer(xd))

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, ns))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_ROW):
		{
			var pStmt uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_CLOSE):
		{
			var db uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(db)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for __ccgo3 := true; __ccgo3; __ccgo3 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	}
	return SQLITE_OK
}

func DbProfileHandler(tls *libc.TLS, cd uintptr, zSql uintptr, tm1 sqlite_uint64) {
	bp := tls.Alloc(320)
	defer tls.Free(320)

	var pDb uintptr = cd

	sqlite3.Xsqlite3_snprintf(tls, int32(uint32(unsafe.Sizeof([100]int8{}))-uint32(1)), bp+8, ts+6682, libc.VaList(bp, tm1))
	tcl.XTcl_DStringInit(tls, bp+108)
	tcl.XTcl_DStringAppend(tls, bp+108, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, -1)
	tcl.XTcl_DStringAppendElement(tls, bp+108, zSql)
	tcl.XTcl_DStringAppendElement(tls, bp+108, bp+8)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp+108)).Fstring)
	tcl.XTcl_DStringFree(tls, bp+108)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

func DbCommitHandler(tls *libc.TLS, cd uintptr) int32 {
	var pDb uintptr = cd
	var rc int32

	rc = tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
	if rc != TCL_OK || libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0 {
		return 1
	}
	return 0
}

func DbRollbackHandler(tls *libc.TLS, clientData uintptr) {
	var pDb uintptr = clientData

	if TCL_OK != tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook, 0) {
		tcl.XTcl_BackgroundError(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}
}

func DbWalHandler(tls *libc.TLS, clientData uintptr, db uintptr, zDb uintptr, nEntry int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var p uintptr
	var pDb uintptr = clientData
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp

	p = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook)
	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewIntObj(tls, nEntry))
	if TCL_OK != tcl.XTcl_EvalObjEx(tls, interp, p, 0) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, tcl.XTcl_GetObjResult(tls, interp), bp) {
		tcl.XTcl_BackgroundError(tls, interp)
	}
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = p
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func setTestUnlockNotifyVars(tls *libc.TLS, interp uintptr, iArg int32, nArg int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16, ts+1333, libc.VaList(bp, iArg))
	tcl.XTcl_SetVar2(tls, interp, ts+15870, uintptr(0), bp+16, TCL_GLOBAL_ONLY)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16, ts+1333, libc.VaList(bp+8, nArg))
	tcl.XTcl_SetVar2(tls, interp, ts+15895, uintptr(0), bp+16, TCL_GLOBAL_ONLY)
}

func DbUnlockNotify(tls *libc.TLS, apArg uintptr, nArg int32) {
	var i int32
	for i = 0; i < nArg; i++ {
		var flags int32 = TCL_EVAL_GLOBAL | TCL_EVAL_DIRECT
		var pDb uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))
		setTestUnlockNotifyVars(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, i, nArg)

		tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify, flags)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
	}
}

func DbPreUpdateHandler(tls *libc.TLS, p uintptr, db uintptr, op int32, zDb uintptr, zTbl uintptr, iKey1 sqlite_int64, iKey2 sqlite_int64) {
	var pDb uintptr = p
	var pCmd uintptr

	pCmd = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, azStr[(op-1)/9], -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, iKey1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, iKey2))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

var azStr = [3]uintptr{ts + 15216, ts + 15202, ts + 15209}

func DbUpdateHandler(tls *libc.TLS, p uintptr, op int32, zDb uintptr, zTbl uintptr, rowid sqlite_int64) {
	var pDb uintptr = p
	var pCmd uintptr

	pCmd = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, azStr1[(op-1)/9], -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, rowid))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

var azStr1 = [3]uintptr{ts + 15216, ts + 15202, ts + 15209}

func tclCollateNeeded(tls *libc.TLS, pCtx uintptr, db uintptr, enc int32, zName uintptr) {
	var pDb uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zName, -1))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pScript, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func tclSqlCollate(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 {
	var p uintptr = pCtx
	var pCmd uintptr

	pCmd = tcl.XTcl_NewStringObj(tls, (*SqlCollate)(unsafe.Pointer(p)).FzScript, -1)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zA, nA))
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zB, nB))
	tcl.XTcl_EvalObjEx(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp))
}

func tclSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var pCmd uintptr
	var i int32
	var rc int32

	if argc == 0 {
		pCmd = (*SqlFunc)(unsafe.Pointer(p)).FpScript
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, 0)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pCmd
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	} else {
		if tcl.XTcl_ListObjGetElements(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, (*SqlFunc)(unsafe.Pointer(p)).FpScript, bp, bp+4) != 0 {
			sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
			return
		}
		pCmd = tcl.XTcl_NewListObj(tls, *(*int32)(unsafe.Pointer(bp)), *(*uintptr)(unsafe.Pointer(bp + 4)))
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		for i = 0; i < argc; i++ {
			var pIn uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
			var pVal uintptr

			switch sqlite3.Xsqlite3_value_type(tls, pIn) {
			case SQLITE_BLOB:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewByteArrayObj(tls, sqlite3.Xsqlite3_value_blob(tls, pIn), bytes)
					break

				}
				fallthrough
			case SQLITE_INTEGER:
				{
					var v sqlite_int64 = sqlite3.Xsqlite3_value_int64(tls, pIn)
					if v >= int64(-2147483647) && v <= int64(2147483647) {
						pVal = tcl.XTcl_NewIntObj(tls, int32(v))
					} else {
						pVal = tcl.XTcl_NewWideIntObj(tls, v)
					}
					break

				}
				fallthrough
			case SQLITE_FLOAT:
				{
					var r float64 = sqlite3.Xsqlite3_value_double(tls, pIn)
					pVal = tcl.XTcl_NewDoubleObj(tls, r)
					break

				}
				fallthrough
			case SQLITE_NULL:
				{
					pVal = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*SqlFunc)(unsafe.Pointer(p)).FpDb)).FzNull, -1)
					break

				}
				fallthrough
			default:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pIn), bytes)
					break

				}
			}
			rc = tcl.XTcl_ListObjAppendElement(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, pVal)
			if rc != 0 {
				for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
					var _objPtr uintptr = pCmd
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
				return
			}
		}
		if !((*SqlFunc)(unsafe.Pointer(p)).FuseEvalObjv != 0) {
			tcl.XTcl_GetString(tls, pCmd)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, TCL_EVAL_DIRECT)
		for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
			var _objPtr uintptr = pCmd
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if rc != 0 && rc != TCL_RETURN {
		sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
	} else {
		var pVar uintptr = tcl.XTcl_GetObjResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp)

		var data uintptr
		var zType uintptr = func() uintptr {
			if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
				return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
			}
			return ts + 584
		}()
		var c int8 = *(*int8)(unsafe.Pointer(zType))
		var eType int32 = (*SqlFunc)(unsafe.Pointer(p)).FeType

		if eType == SQLITE_NULL {
			if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2544) == 0 && (*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0) {
				eType = SQLITE_BLOB
			} else if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2554) == 0 ||
				int32(c) == 'w' && libc.Xstrcmp(tls, zType, ts+2569) == 0 ||
				int32(c) == 'i' && libc.Xstrcmp(tls, zType, ts+2577) == 0 {
				eType = SQLITE_INTEGER
			} else if int32(c) == 'd' && libc.Xstrcmp(tls, zType, ts+2562) == 0 {
				eType = SQLITE_FLOAT
			} else {
				eType = SQLITE_TEXT
			}
		}

		switch eType {
		case SQLITE_BLOB:
			{
				data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+8)
				sqlite3.Xsqlite3_result_blob(tls, context, data, *(*int32)(unsafe.Pointer(bp + 8)), libc.UintptrFromInt32(-1))
				break

			}
			fallthrough
		case SQLITE_INTEGER:
			{
				if TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), pVar, bp+12) {
					sqlite3.Xsqlite3_result_int64(tls, context, *(*Tcl_WideInt)(unsafe.Pointer(bp + 12)))
					break
				}

			}
			fallthrough
		case SQLITE_FLOAT:
			{
				if TCL_OK == tcl.XTcl_GetDoubleFromObj(tls, uintptr(0), pVar, bp+20) {
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 20)))
					break
				}

			}
			fallthrough
		default:
			{
				data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+8)
				sqlite3.Xsqlite3_result_text(tls, context, data, *(*int32)(unsafe.Pointer(bp + 8)), libc.UintptrFromInt32(-1))
				break

			}
		}

	}
}

func auth_callback(tls *libc.TLS, pArg uintptr, code int32, zArg1 uintptr, zArg2 uintptr, zArg3 uintptr, zArg4 uintptr) int32 {
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var zCode uintptr

	var rc int32
	var zReply uintptr

	var pDb uintptr = pArg
	if (*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth != 0 {
		return SQLITE_OK
	}

	switch code {
	case SQLITE_COPY:
		zCode = ts + 15925
		break
	case SQLITE_CREATE_INDEX:
		zCode = ts + 15937
		break
	case SQLITE_CREATE_TABLE:
		zCode = ts + 15957
		break
	case SQLITE_CREATE_TEMP_INDEX:
		zCode = ts + 15977
		break
	case SQLITE_CREATE_TEMP_TABLE:
		zCode = ts + 16002
		break
	case SQLITE_CREATE_TEMP_TRIGGER:
		zCode = ts + 16027
		break
	case SQLITE_CREATE_TEMP_VIEW:
		zCode = ts + 16054
		break
	case SQLITE_CREATE_TRIGGER:
		zCode = ts + 16078
		break
	case SQLITE_CREATE_VIEW:
		zCode = ts + 16100
		break
	case SQLITE_DELETE:
		zCode = ts + 16119
		break
	case SQLITE_DROP_INDEX:
		zCode = ts + 16133
		break
	case SQLITE_DROP_TABLE:
		zCode = ts + 16151
		break
	case SQLITE_DROP_TEMP_INDEX:
		zCode = ts + 16169
		break
	case SQLITE_DROP_TEMP_TABLE:
		zCode = ts + 16192
		break
	case SQLITE_DROP_TEMP_TRIGGER:
		zCode = ts + 16215
		break
	case SQLITE_DROP_TEMP_VIEW:
		zCode = ts + 16240
		break
	case SQLITE_DROP_TRIGGER:
		zCode = ts + 16262
		break
	case SQLITE_DROP_VIEW:
		zCode = ts + 16282
		break
	case SQLITE_INSERT:
		zCode = ts + 16299
		break
	case SQLITE_PRAGMA:
		zCode = ts + 16313
		break
	case SQLITE_READ:
		zCode = ts + 16327
		break
	case SQLITE_SELECT:
		zCode = ts + 16339
		break
	case SQLITE_TRANSACTION:
		zCode = ts + 16353
		break
	case SQLITE_UPDATE:
		zCode = ts + 16372
		break
	case SQLITE_ATTACH:
		zCode = ts + 16386
		break
	case SQLITE_DETACH:
		zCode = ts + 16400
		break
	case SQLITE_ALTER_TABLE:
		zCode = ts + 16414
		break
	case SQLITE_REINDEX:
		zCode = ts + 16433
		break
	case SQLITE_ANALYZE:
		zCode = ts + 16448
		break
	case SQLITE_CREATE_VTABLE:
		zCode = ts + 16463
		break
	case SQLITE_DROP_VTABLE:
		zCode = ts + 16484
		break
	case SQLITE_FUNCTION:
		zCode = ts + 16503
		break
	case SQLITE_SAVEPOINT:
		zCode = ts + 16519
		break
	case SQLITE_RECURSIVE:
		zCode = ts + 16536
		break
	default:
		zCode = ts + 16553
		break
	}
	tcl.XTcl_DStringInit(tls, bp)
	tcl.XTcl_DStringAppend(tls, bp, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, -1)
	tcl.XTcl_DStringAppendElement(tls, bp, zCode)
	tcl.XTcl_DStringAppendElement(tls, bp, func() uintptr {
		if zArg1 != 0 {
			return zArg1
		}
		return ts + 584
	}())
	tcl.XTcl_DStringAppendElement(tls, bp, func() uintptr {
		if zArg2 != 0 {
			return zArg2
		}
		return ts + 584
	}())
	tcl.XTcl_DStringAppendElement(tls, bp, func() uintptr {
		if zArg3 != 0 {
			return zArg3
		}
		return ts + 584
	}())
	tcl.XTcl_DStringAppendElement(tls, bp, func() uintptr {
		if zArg4 != 0 {
			return zArg4
		}
		return ts + 584
	}())
	rc = tcl.XTcl_GlobalEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp)).Fstring)
	tcl.XTcl_DStringFree(tls, bp)
	if rc == TCL_OK {
		zReply = tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	} else {
		zReply = ts + 16558
	}
	if libc.Xstrcmp(tls, zReply, ts+2127) == 0 {
		rc = SQLITE_OK
	} else if libc.Xstrcmp(tls, zReply, ts+16558) == 0 {
		rc = SQLITE_DENY
	} else if libc.Xstrcmp(tls, zReply, ts+16570) == 0 {
		rc = SQLITE_IGNORE
	} else {
		rc = 999
	}
	return rc
}

func local_getline(tls *libc.TLS, zPrompt uintptr, in uintptr) uintptr {
	var zLine uintptr
	var nLine int32
	var n int32

	nLine = 100
	zLine = libc.Xmalloc(tls, uint32(nLine))
	if zLine == uintptr(0) {
		return uintptr(0)
	}
	n = 0
	for 1 != 0 {
		if n+100 > nLine {
			nLine = nLine*2 + 100
			zLine = libc.Xrealloc(tls, zLine, uint32(nLine))
			if zLine == uintptr(0) {
				return uintptr(0)
			}
		}
		if libc.Xfgets(tls, zLine+uintptr(n), nLine-n, in) == uintptr(0) {
			if n == 0 {
				libc.Xfree(tls, zLine)
				return uintptr(0)
			}
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
		for *(*int8)(unsafe.Pointer(zLine + uintptr(n))) != 0 {
			n++
		}
		if n > 0 && int32(*(*int8)(unsafe.Pointer(zLine + uintptr(n-1)))) == '\n' {
			n--
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
	}
	zLine = libc.Xrealloc(tls, zLine, uint32(n+1))
	return zLine
}

func DbTransPostCmd(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pDb uintptr = *(*ClientData)(unsafe.Pointer(data))
	var rc int32 = result
	var zEnd uintptr

	(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction--
	zEnd = azEnd[libc.Bool32(rc == TCL_ERROR)*2+libc.Bool32((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0)]

	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
	if sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zEnd, uintptr(0), uintptr(0), uintptr(0)) != 0 {
		if rc != TCL_ERROR {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
			rc = TCL_ERROR
		}
		sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+8179, uintptr(0), uintptr(0), uintptr(0))
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--

	delDatabaseRef(tls, pDb)
	return rc
}

var azEnd = [4]uintptr{
	ts + 16584,
	ts + 14542,
	ts + 16609,
	ts + 8179,
}

func dbPrepare(tls *libc.TLS, pDb uintptr, zSql uintptr, ppStmt uintptr, pzOut uintptr) int32 {
	var prepFlags uint32 = uint32(0)
	if (*SqliteDb)(unsafe.Pointer(pDb)).FbLegacyPrepare != 0 {
		return sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, ppStmt, pzOut)
	}

	if (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt > 5 {
		prepFlags = uint32(SQLITE_PREPARE_PERSISTENT)
	}

	return sqlite3.Xsqlite3_prepare_v3(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, prepFlags, ppStmt, pzOut)
}

func dbPrepareAndBind(tls *libc.TLS, pDb uintptr, zIn uintptr, pzOut uintptr, ppPreStmt uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zSql uintptr = zIn
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	var pPreStmt uintptr
	var nSql int32
	var nVar int32 = 0
	var iParm int32 = 0
	var c int8
	var i int32
	var needResultReset int32 = 0
	var rc int32 = SQLITE_OK
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp

	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = uintptr(0)

	for int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(zSql)))) == ' ' || int32(c) == '\t' || int32(c) == '\r' || int32(c) == '\n' {
		zSql++
	}
	nSql = strlen30(tls, zSql)

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext {
		var n int32 = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql
		if nSql >= n &&
			libc.Xmemcmp(tls, (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql, zSql, uint32(n)) == 0 &&
			(int32(*(*int8)(unsafe.Pointer(zSql + uintptr(n)))) == 0 || int32(*(*int8)(unsafe.Pointer(zSql + uintptr(n-1)))) == ';') {
			*(*uintptr)(unsafe.Pointer(bp)) = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt
			*(*uintptr)(unsafe.Pointer(pzOut)) = zSql + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql)

			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev)).FpNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			}
			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext)).FpPrev = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			}
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp)))
			break
		}
	}

	if pPreStmt == uintptr(0) {
		var nByte int32

		if SQLITE_OK != dbPrepare(tls, pDb, zSql, bp, pzOut) {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
			return TCL_ERROR
		}
		if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) {
			if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb) {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return TCL_ERROR
			} else {
				return TCL_OK
			}
		}

		nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp)))
		nByte = int32(uint32(unsafe.Sizeof(SqlPreparedStmt{})) + uint32(nVar)*uint32(unsafe.Sizeof(uintptr(0))))
		pPreStmt = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemset(tls, pPreStmt, 0, uint32(nByte))

		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt = *(*uintptr)(unsafe.Pointer(bp))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql = (int32(*(*uintptr)(unsafe.Pointer(pzOut))) - int32(zSql)) / 1
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp)))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm = pPreStmt + 1*28
		if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql == uintptr(0) {
			var zCopy uintptr = tcl.XTcl_Alloc(tls, uint32((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql+1))
			libc.Xmemcpy(tls, zCopy, zSql, uint32((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))
			*(*int8)(unsafe.Pointer(zCopy + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))) = int8(0)
			(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = zCopy
		}
	}

	for i = 1; i <= nVar; i++ {
		var zVar uintptr = sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp)), i)
		if zVar != uintptr(0) && (int32(*(*int8)(unsafe.Pointer(zVar))) == '$' || int32(*(*int8)(unsafe.Pointer(zVar))) == ':' || int32(*(*int8)(unsafe.Pointer(zVar))) == '@') {
			var pVar uintptr = tcl.XTcl_GetVar2Ex(tls, interp, zVar+1, uintptr(0), 0)
			if pVar == uintptr(0) && (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != uintptr(0) {
				var pCmd uintptr
				var rx int32
				pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, -1)
				(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
				tcl.XTcl_ListObjAppendElement(tls, interp, pCmd, tcl.XTcl_NewStringObj(tls, zVar, -1))
				if needResultReset != 0 {
					tcl.XTcl_ResetResult(tls, interp)
				}
				needResultReset = 1
				rx = tcl.XTcl_EvalObjEx(tls, interp, pCmd, TCL_EVAL_DIRECT)
				for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
					var _objPtr uintptr = pCmd
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rx == TCL_OK {
					pVar = tcl.XTcl_GetObjResult(tls, interp)
				} else if rx == TCL_ERROR {
					rc = TCL_ERROR
					break
				} else {
					pVar = uintptr(0)
				}
			}
			if pVar != 0 {
				var data uintptr
				var zType uintptr = func() uintptr {
					if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
						return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
					}
					return ts + 584
				}()
				c = *(*int8)(unsafe.Pointer(zType))
				if int32(*(*int8)(unsafe.Pointer(zVar))) == '@' || int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2544) == 0 && (*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0) {
					data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+4)
					sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp)), i, data, *(*int32)(unsafe.Pointer(bp + 4)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(libc.PostIncInt32(&iParm, 1))*4)) = pVar
				} else if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2554) == 0 {
					tcl.XTcl_GetIntFromObj(tls, interp, pVar, bp+4)
					sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp)), i, *(*int32)(unsafe.Pointer(bp + 4)))
				} else if int32(c) == 'd' && libc.Xstrcmp(tls, zType, ts+2562) == 0 {
					tcl.XTcl_GetDoubleFromObj(tls, interp, pVar, bp+8)
					sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp)), i, *(*float64)(unsafe.Pointer(bp + 8)))
				} else if int32(c) == 'w' && libc.Xstrcmp(tls, zType, ts+2569) == 0 || int32(c) == 'i' && libc.Xstrcmp(tls, zType, ts+2577) == 0 {
					tcl.XTcl_GetWideIntFromObj(tls, interp, pVar, bp+16)
					sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp)), i, *(*Tcl_WideInt)(unsafe.Pointer(bp + 16)))
				} else {
					data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+4)
					sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp)), i, data, *(*int32)(unsafe.Pointer(bp + 4)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(libc.PostIncInt32(&iParm, 1))*4)) = pVar
				}
			} else {
				sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp)), i)
			}
			if needResultReset != 0 {
				tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = iParm
	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = pPreStmt
	if needResultReset != 0 && rc == TCL_OK {
		tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}

	return rc
}

func dbReleaseStmt(tls *libc.TLS, pDb uintptr, pPreStmt uintptr, discard int32) {
	var i int32

	for i = 0; i < (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm; i++ {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(i)*4))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = 0

	if (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt <= 0 || discard != 0 {
		dbFreeStmt(tls, pPreStmt)
	} else {
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev = uintptr(0)
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpPrev = pPreStmt
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = pPreStmt
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast == uintptr(0) {
			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = pPreStmt
		} else {
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt++

		for (*SqliteDb)(unsafe.Pointer(pDb)).FnStmt > (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt {
			var pLast uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast
			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pLast)).FpPrev
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast)).FpNext = uintptr(0)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			dbFreeStmt(tls, pLast)
		}
	}
}

type DbEvalContext1 = struct {
	FpDb       uintptr
	FpSql      uintptr
	FzSql      uintptr
	FpPreStmt  uintptr
	FnCol      int32
	FevalFlags int32
	FpArray    uintptr
	FapColName uintptr
}

type DbEvalContext = DbEvalContext1

func dbReleaseColumnNames(tls *libc.TLS, p uintptr) {
	if (*DbEvalContext)(unsafe.Pointer(p)).FapColName != 0 {
		var i int32
		for i = 0; i < (*DbEvalContext)(unsafe.Pointer(p)).FnCol; i++ {
			for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FapColName + uintptr(i)*4))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		tcl.XTcl_Free(tls, (*DbEvalContext)(unsafe.Pointer(p)).FapColName)
		(*DbEvalContext)(unsafe.Pointer(p)).FapColName = uintptr(0)
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FnCol = 0
}

func dbEvalInit(tls *libc.TLS, p uintptr, pDb uintptr, pSql uintptr, pArray uintptr, evalFlags int32) {
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(DbEvalContext{})))
	(*DbEvalContext)(unsafe.Pointer(p)).FpDb = pDb
	(*DbEvalContext)(unsafe.Pointer(p)).FzSql = tcl.XTcl_GetString(tls, pSql)
	(*DbEvalContext)(unsafe.Pointer(p)).FpSql = pSql
	(*Tcl_Obj)(unsafe.Pointer(pSql)).FrefCount++
	if pArray != 0 {
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = pArray
		(*Tcl_Obj)(unsafe.Pointer(pArray)).FrefCount++
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FevalFlags = evalFlags
	addDatabaseRef(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb)
}

func dbEvalRowInfo(tls *libc.TLS, p uintptr, pnCol uintptr, papColName uintptr) {
	if uintptr(0) == (*DbEvalContext)(unsafe.Pointer(p)).FapColName {
		var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
		var i int32
		var nCol int32
		var apColName uintptr = uintptr(0)

		(*DbEvalContext)(unsafe.Pointer(p)).FnCol = libc.AssignInt32(&nCol, sqlite3.Xsqlite3_column_count(tls, pStmt))
		if nCol > 0 && (papColName != 0 || (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0) {
			apColName = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(uintptr(0)))*uint32(nCol))
			for i = 0; i < nCol; i++ {
				*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*4)) = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_name(tls, pStmt, i), -1)
				(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*4)))).FrefCount++
			}
			(*DbEvalContext)(unsafe.Pointer(p)).FapColName = apColName
		}

		if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
			var interp uintptr = (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).Finterp
			var pColList uintptr = tcl.XTcl_NewObj(tls)
			var pStar uintptr = tcl.XTcl_NewStringObj(tls, ts+3784, -1)

			for i = 0; i < nCol; i++ {
				tcl.XTcl_ListObjAppendElement(tls, interp, pColList, *(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*4)))
			}
			(*Tcl_Obj)(unsafe.Pointer(pStar)).FrefCount++
			tcl.XTcl_ObjSetVar2(tls, interp, (*DbEvalContext)(unsafe.Pointer(p)).FpArray, pStar, pColList, 0)
			for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
				var _objPtr uintptr = pStar
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
	}

	if papColName != 0 {
		*(*uintptr)(unsafe.Pointer(papColName)) = (*DbEvalContext)(unsafe.Pointer(p)).FapColName
	}
	if pnCol != 0 {
		*(*int32)(unsafe.Pointer(pnCol)) = (*DbEvalContext)(unsafe.Pointer(p)).FnCol
	}
}

func dbEvalStep(tls *libc.TLS, p uintptr) int32 {
	var zPrevSql uintptr = uintptr(0)

	for *(*int8)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FzSql)) != 0 || (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0 {
		var rc int32
		if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt == uintptr(0) {
			zPrevSql = func() uintptr {
				if (*DbEvalContext)(unsafe.Pointer(p)).FzSql == zPrevSql {
					return uintptr(0)
				}
				return (*DbEvalContext)(unsafe.Pointer(p)).FzSql
			}()
			rc = dbPrepareAndBind(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FzSql, p+8, p+12)
			if rc != TCL_OK {
				return rc
			}
		} else {
			var rcs int32
			var pDb uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpDb
			var pPreStmt uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt
			var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt

			rcs = sqlite3.Xsqlite3_step(tls, pStmt)
			if rcs == SQLITE_ROW {
				return TCL_OK
			}
			if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
				dbEvalRowInfo(tls, p, uintptr(0), uintptr(0))
			}
			rcs = sqlite3.Xsqlite3_reset(tls, pStmt)

			(*SqliteDb)(unsafe.Pointer(pDb)).FnStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnSort = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_SORT, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnIndex = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_AUTOINDEX, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_VM_STEP, 1)
			dbReleaseColumnNames(tls, p)
			(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)

			if rcs != SQLITE_OK {
				dbReleaseStmt(tls, pDb, pPreStmt, 1)
				if (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FbLegacyPrepare != 0 && rcs == SQLITE_SCHEMA && zPrevSql != 0 {
					(*DbEvalContext)(unsafe.Pointer(p)).FzSql = zPrevSql
					continue
				}
				tcl.XTcl_SetObjResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp,
					tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return TCL_ERROR
			} else {
				dbReleaseStmt(tls, pDb, pPreStmt, 0)
			}
		}
	}

	return TCL_BREAK
}

func dbEvalFinalize(tls *libc.TLS, p uintptr) {
	if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0 {
		sqlite3.Xsqlite3_reset(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt)
		dbReleaseStmt(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt, 0)
		(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)
	}
	if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = uintptr(0)
	}
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpSql
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbReleaseColumnNames(tls, p)
	delDatabaseRef(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb)
}

func dbEvalColumnValue(tls *libc.TLS, p uintptr, iCol int32) uintptr {
	var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
	switch sqlite3.Xsqlite3_column_type(tls, pStmt, iCol) {
	case SQLITE_BLOB:
		{
			var bytes int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, iCol)
			var zBlob uintptr = sqlite3.Xsqlite3_column_blob(tls, pStmt, iCol)
			if !(zBlob != 0) {
				bytes = 0
			}
			return tcl.XTcl_NewByteArrayObj(tls, zBlob, bytes)

		}
	case SQLITE_INTEGER:
		{
			var v sqlite_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, iCol)
			if v >= int64(-2147483647) && v <= int64(2147483647) {
				return tcl.XTcl_NewIntObj(tls, int32(v))
			} else {
				return tcl.XTcl_NewWideIntObj(tls, v)
			}

		}
		fallthrough
	case SQLITE_FLOAT:
		{
			return tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_column_double(tls, pStmt, iCol))

		}
	case SQLITE_NULL:
		{
			return tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FzNull, -1)

		}
	}

	return tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_text(tls, pStmt, iCol), -1)
}

func DbUseNre(tls *libc.TLS) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	tcl.XTcl_GetVersion(tls, bp, bp+4, uintptr(0), uintptr(0))
	return libc.Bool32(*(*int32)(unsafe.Pointer(bp)) == 8 && *(*int32)(unsafe.Pointer(bp + 4)) >= 6 || *(*int32)(unsafe.Pointer(bp)) > 8)
}

func DbEvalNextCmd(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = result

	var p uintptr = *(*ClientData)(unsafe.Pointer(data))
	var pScript uintptr = *(*ClientData)(unsafe.Pointer(data + 1*4))
	var pArray uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray

	for (rc == TCL_OK || rc == TCL_CONTINUE) && TCL_OK == libc.AssignInt32(&rc, dbEvalStep(tls, p)) {
		var i int32

		dbEvalRowInfo(tls, p, bp, bp+4)
		for i = 0; i < *(*int32)(unsafe.Pointer(bp)); i++ {
			if pArray == uintptr(0) {
				tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4)) + uintptr(i)*4)), uintptr(0), dbEvalColumnValue(tls, p, i), 0)
			} else if (*DbEvalContext)(unsafe.Pointer(p)).FevalFlags&SQLITE_EVAL_WITHOUTNULLS != 0 &&
				sqlite3.Xsqlite3_column_type(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt, i) == SQLITE_NULL {
				tcl.XTcl_UnsetVar2(tls, interp, tcl.XTcl_GetString(tls, pArray),
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4)) + uintptr(i)*4))), 0)
			} else {
				tcl.XTcl_ObjSetVar2(tls, interp, pArray, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4)) + uintptr(i)*4)), dbEvalColumnValue(tls, p, i), 0)
			}
		}

		if DbUseNre(tls) != 0 {
			tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			}{DbEvalNextCmd})), p, pScript, uintptr(0), uintptr(0))
			return tcl.XTcl_NREvalObj(tls, interp, pScript, 0)
		} else {
			rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		}
	}

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbEvalFinalize(tls, p)
	tcl.XTcl_Free(tls, p)

	if rc == TCL_OK || rc == TCL_BREAK {
		tcl.XTcl_ResetResult(tls, interp)
		rc = TCL_OK
	}
	return rc
}

func DbHookCmd(tls *libc.TLS, interp uintptr, pDb uintptr, pArg uintptr, ppHook uintptr) {
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb

	if *(*uintptr)(unsafe.Pointer(ppHook)) != 0 {
		tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(ppHook)))
		if pArg != 0 {
			for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(ppHook))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			*(*uintptr)(unsafe.Pointer(ppHook)) = uintptr(0)
		}
	}
	if pArg != 0 {
		if tcl.XTcl_GetCharLength(tls, pArg) > 0 {
			*(*uintptr)(unsafe.Pointer(ppHook)) = pArg
			(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppHook)))).FrefCount++
		}
	}

	sqlite3.Xsqlite3_preupdate_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, sqlite_int64, sqlite_int64)
			}{DbPreUpdateHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_update_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr, sqlite_int64)
			}{DbUpdateHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_rollback_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbRollbackHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_wal_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
			}{DbWalHandler}))
		}
		return uintptr(0)
	}(), pDb)
}

func DbObjCmd(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(1460)
	defer tls.Free(1460)
	*(*uintptr)(unsafe.Pointer(bp + 1344)) = cd

	var pDb uintptr

	var rc int32
	var zAuth uintptr

	var zDestFile uintptr
	var zSrcDb uintptr

	var pBackup uintptr
	var zCallback uintptr

	var zBusy uintptr

	var subCmd uintptr

	var pResult uintptr
	var pCollate uintptr
	var zName uintptr
	var zScript uintptr

	var _objPtr uintptr
	var zCommit uintptr

	var pResult1 uintptr
	var isComplete int32

	var zOpt uintptr

	var pResult2 uintptr
	var ii int32
	var zErr uintptr
	var nErr int32
	var z uintptr
	var zTable uintptr
	var zFile uintptr
	var zConflict uintptr

	var nCol int32
	var nByte int32
	var i int32
	var j int32
	var nSep int32
	var nNull int32
	var zSql uintptr
	var zLine uintptr
	var azCol uintptr
	var zCommit1 uintptr
	var in uintptr
	var lineno int32

	var pResult3 uintptr

	var zSep uintptr
	var zNull uintptr

	var z1 uintptr
	var flags int32
	var zSchema uintptr
	var pValue uintptr
	var pBA uintptr
	var pData uintptr

	var xrc int32

	var i1 int32

	var pResult4 uintptr

	var i2 int32

	var _objPtr1 uintptr

	var pRet uintptr

	var p uintptr
	var pArray uintptr
	var pScript uintptr
	var evalFlags int32
	var zOpt1 uintptr

	var z2 uintptr
	var n1 int32
	var _objPtr2 uintptr
	var flags1 int32
	var pFunc uintptr
	var pScript1 uintptr
	var zName1 uintptr

	var i3 int32

	var isReadonly1 int32
	var zDb uintptr
	var zTable1 uintptr
	var zColumn uintptr

	var zNull1 uintptr
	var pResult5 uintptr
	var rowid Tcl_WideInt
	var zProgress uintptr

	var zProfile uintptr

	var zSrcFile uintptr
	var zDestDb uintptr

	var pBackup1 uintptr
	var nTimeout int32
	var needFree int32
	var zSchema1 uintptr

	var pData1 uintptr
	var v2 int32
	var zOp uintptr

	var pResult6 uintptr
	var zTrace uintptr

	var _objPtr3 uintptr
	var _objPtr4 uintptr

	var pError uintptr

	var i4 int32
	var zTraceV2 uintptr

	var wMask Tcl_WideInt

	var pScript2 uintptr
	var zBegin uintptr
	var _objPtr5 uintptr
	var xNotify uintptr
	var pNotifyArg uintptr
	var nCol2 int32
	var pRet1 uintptr
	var pObj1 uintptr

	var ppHook uintptr

	var zArg uintptr
	var i5 int32
	pDb = *(*uintptr)(unsafe.Pointer(bp + 1344))
	rc = TCL_OK

	if !(objc < 2) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999)
	return TCL_ERROR
__1:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&DB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+14633, 0, bp+1016) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1016))) {
	case uint32(0):
		goto __4

	case uint32(1):
		goto __5

	case uint32(2):
		goto __6

	case uint32(3):
		goto __7

	case uint32(4):
		goto __8

	case uint32(5):
		goto __9

	case uint32(6):
		goto __10

	case uint32(7):
		goto __11

	case uint32(8):
		goto __12

	case uint32(9):
		goto __13

	case uint32(10):
		goto __14

	case uint32(11):
		goto __15

	case uint32(12):
		goto __16

	case uint32(13):
		goto __17

	case uint32(14):
		goto __18

	case uint32(15):
		goto __19

	case uint32(16):
		goto __20

	case uint32(18):
		goto __21
	case uint32(24):
		goto __22

	case uint32(17):
		goto __23

	case uint32(19):
		goto __24

	case uint32(20):
		goto __25

	case uint32(21):
		goto __26

	case uint32(23):
		goto __27

	case uint32(22):
		goto __28

	case uint32(27):
		goto __29

	case uint32(26):
		goto __30

	case uint32(28):
		goto __31

	case uint32(29):
		goto __32

	case uint32(31):
		goto __33

	case uint32(32):
		goto __34

	case uint32(33):
		goto __35

	case uint32(34):
		goto __36

	case uint32(35):
		goto __37

	case uint32(36):
		goto __38

	case uint32(37):
		goto __39

	case uint32(38):
		goto __40

	case uint32(25):
		goto __41

	case uint32(41):
		goto __42
	case uint32(39):
		goto __43
	case uint32(30):
		goto __44

	case uint32(40):
		goto __45
	}
	goto __3

__4:
	if !(objc > 3) {
		goto __46
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16665)
	return TCL_ERROR
	goto __47
__46:
	if !(objc == 2) {
		goto __48
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __50
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, uintptr(0)))
__50:
	;
	goto __49
__48:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __51
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
__51:
	;
	zAuth = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1020)
	if !(zAuth != 0 && *(*int32)(unsafe.Pointer(bp + 1020)) > 0) {
		goto __52
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1020))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, zAuth, uint32(*(*int32)(unsafe.Pointer(bp + 1020))+1))
	goto __53
__52:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = uintptr(0)
__53:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __54
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
	}{auth_callback})), pDb)
	goto __55
__54:
	sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__55:
	;
__49:
	;
__47:
	;
	goto __3

__5:
	if !(objc == 3) {
		goto __56
	}
	zSrcDb = ts + 85
	zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	goto __57
__56:
	if !(objc == 4) {
		goto __58
	}
	zSrcDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	goto __59
__58:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16676)
	return TCL_ERROR
__59:
	;
__57:
	;
	rc = sqlite3.Xsqlite3_open_v2(tls, zDestFile, bp+1024,
		SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|(*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __60
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+16696,
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024)))
	return TCL_ERROR
__60:
	;
	pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 1024)), ts+85, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSrcDb)
	if !(pBackup == uintptr(0)) {
		goto __61
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+16726,
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024)))
	return TCL_ERROR
__61:
	;
__62:
	if !(libc.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup, 100)) == SQLITE_OK) {
		goto __63
	}
	goto __62
__63:
	;
	sqlite3.Xsqlite3_backup_finish(tls, pBackup)
	if !(rc == SQLITE_DONE) {
		goto __64
	}
	rc = TCL_OK
	goto __65
__64:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, ts+16726,
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024))), uintptr(0)))
	rc = TCL_ERROR
__65:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024)))
	goto __3

__6:
	if !(objc > 3) {
		goto __66
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16665)
	return TCL_ERROR
	goto __67
__66:
	if !(objc == 2) {
		goto __68
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0) {
		goto __70
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+88, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, uintptr(0)))
__70:
	;
	goto __69
__68:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0) {
		goto __71
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
__71:
	;
	zCallback = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1028)
	if !(zCallback != 0 && *(*int32)(unsafe.Pointer(bp + 1028)) > 0) {
		goto __72
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1028))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, zCallback, uint32(*(*int32)(unsafe.Pointer(bp + 1028))+1))
	goto __73
__72:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = uintptr(0)
__73:
	;
__69:
	;
__67:
	;
	goto __3

__7:
	if !(objc > 3) {
		goto __74
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16742)
	return TCL_ERROR
	goto __75
__74:
	if !(objc == 2) {
		goto __76
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __78
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+104, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, uintptr(0)))
__78:
	;
	goto __77
__76:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __79
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
__79:
	;
	zBusy = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1032)
	if !(zBusy != 0 && *(*int32)(unsafe.Pointer(bp + 1032)) > 0) {
		goto __80
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1032))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, zBusy, uint32(*(*int32)(unsafe.Pointer(bp + 1032))+1))
	goto __81
__80:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = uintptr(0)
__81:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __82
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{DbBusyHandler})), pDb)
	goto __83
__82:
	sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__83:
	;
__77:
	;
__75:
	;
	goto __3

__8:
	if !(objc <= 2) {
		goto __84
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16751)
	return TCL_ERROR
__84:
	;
	subCmd = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	if !(int32(*(*int8)(unsafe.Pointer(subCmd))) == 'f' && libc.Xstrcmp(tls, subCmd, ts+16770) == 0) {
		goto __85
	}
	if !(objc != 3) {
		goto __87
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16770)
	return TCL_ERROR
	goto __88
__87:
	flushStmtCache(tls, pDb)
__88:
	;
	goto __86
__85:
	if !(int32(*(*int8)(unsafe.Pointer(subCmd))) == 's' && libc.Xstrcmp(tls, subCmd, ts+16776) == 0) {
		goto __89
	}
	if !(objc != 4) {
		goto __91
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16781)
	return TCL_ERROR
	goto __92
__91:
	if !(TCL_ERROR == tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1036)) {
		goto __93
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+120, ts+16788,
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), uintptr(0)), ts+16805, uintptr(0)))
	return TCL_ERROR
	goto __94
__93:
	if !(*(*int32)(unsafe.Pointer(bp + 1036)) < 0) {
		goto __95
	}
	flushStmtCache(tls, pDb)
	*(*int32)(unsafe.Pointer(bp + 1036)) = 0
	goto __96
__95:
	if !(*(*int32)(unsafe.Pointer(bp + 1036)) > MAX_PREPARED_STMTS) {
		goto __97
	}
	*(*int32)(unsafe.Pointer(bp + 1036)) = MAX_PREPARED_STMTS
__97:
	;
__96:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt = *(*int32)(unsafe.Pointer(bp + 1036))
__94:
	;
__92:
	;
	goto __90
__89:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+152, ts+16818,
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0)), ts+16831,
		uintptr(0)))
	return TCL_ERROR
__90:
	;
__86:
	;
	goto __3

__9:
	if !(objc != 2) {
		goto __98
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
	return TCL_ERROR
__98:
	;
	pResult = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetWideIntObj(tls, pResult, sqlite3.Xsqlite3_changes64(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	goto __3

__10:
	tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)))
	goto __3

__11:
	if !(objc != 4) {
		goto __99
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16856)
	return TCL_ERROR
__99:
	;
	zName = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1040)
	pCollate = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(SqlCollate{}))+uint32(*(*int32)(unsafe.Pointer(bp + 1040)))+uint32(1))
	if !(pCollate == uintptr(0)) {
		goto __100
	}
	return TCL_ERROR
__100:
	;
	(*SqlCollate)(unsafe.Pointer(pCollate)).Finterp = interp
	(*SqlCollate)(unsafe.Pointer(pCollate)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
	(*SqlCollate)(unsafe.Pointer(pCollate)).FzScript = pCollate + 1*12
	(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = pCollate
	libc.Xmemcpy(tls, (*SqlCollate)(unsafe.Pointer(pCollate)).FzScript, zScript, uint32(*(*int32)(unsafe.Pointer(bp + 1040))+1))
	if !(sqlite3.Xsqlite3_create_collation(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName, SQLITE_UTF8,
		pCollate, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{tclSqlCollate}))) != 0) {
		goto __101
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
	return TCL_ERROR
__101:
	;
	goto __3

__12:
	if !(objc != 3) {
		goto __102
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+10001)
	return TCL_ERROR
__102:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0) {
		goto __103
	}
__104:
	_objPtr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1) {
		goto __107
	}
	tcl.XTclFreeObj(tls, _objPtr)
__107:
	;
	goto __105
__105:
	if 0 != 0 {
		goto __104
	}
	goto __106
__106:
	;
__103:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)).FrefCount++
	sqlite3.Xsqlite3_collation_needed(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, pDb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr)
	}{tclCollateNeeded})))
	goto __3

__13:
	if !(objc > 3) {
		goto __108
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16665)
	return TCL_ERROR
	goto __109
__108:
	if !(objc == 2) {
		goto __110
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __112
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+184, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, uintptr(0)))
__112:
	;
	goto __111
__110:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __113
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
__113:
	;
	zCommit = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1044)
	if !(zCommit != 0 && *(*int32)(unsafe.Pointer(bp + 1044)) > 0) {
		goto __114
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1044))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, zCommit, uint32(*(*int32)(unsafe.Pointer(bp + 1044))+1))
	goto __115
__114:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = uintptr(0)
__115:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __116
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{DbCommitHandler})), pDb)
	goto __117
__116:
	sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__117:
	;
__111:
	;
__109:
	;
	goto __3

__14:
	if !(objc != 3) {
		goto __118
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+9890)
	return TCL_ERROR
__118:
	;
	isComplete = sqlite3.Xsqlite3_complete(tls, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0)))
	pResult1 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult1, libc.Bool32(isComplete != 0))
	goto __3

__15:
	if !(objc > 4) {
		goto __119
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16868)
	return TCL_ERROR
__119:
	;
	if !(objc == 2) {
		goto __120
	}

	pResult2 = tcl.XTcl_NewListObj(tls, 0, uintptr(0))
	ii = 0
__122:
	if !(uint32(ii) < uint32(unsafe.Sizeof(aDbConfig))/uint32(unsafe.Sizeof(DbConfigChoices{}))) {
		goto __124
	}
	*(*int32)(unsafe.Pointer(bp + 1048)) = 0
	sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, libc.VaList(bp+200, -1, bp+1048))
	tcl.XTcl_ListObjAppendElement(tls, interp, pResult2,
		tcl.XTcl_NewStringObj(tls, aDbConfig[ii].FzName, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pResult2,
		tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1048))))
	goto __123
__123:
	ii++
	goto __122
	goto __124
__124:
	;
	goto __121
__120:
	zOpt = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	*(*int32)(unsafe.Pointer(bp + 1052)) = -1
	*(*int32)(unsafe.Pointer(bp + 1056)) = 0
	if !(int32(*(*int8)(unsafe.Pointer(zOpt))) == '-') {
		goto __125
	}
	zOpt++
__125:
	;
	ii = 0
__126:
	if !(uint32(ii) < uint32(unsafe.Sizeof(aDbConfig))/uint32(unsafe.Sizeof(DbConfigChoices{}))) {
		goto __128
	}
	if !(libc.Xstrcmp(tls, aDbConfig[ii].FzName, zOpt) == 0) {
		goto __129
	}
	goto __128
__129:
	;
	goto __127
__127:
	ii++
	goto __126
	goto __128
__128:
	;
	if !(uint32(ii) >= uint32(unsafe.Sizeof(aDbConfig))/uint32(unsafe.Sizeof(DbConfigChoices{}))) {
		goto __130
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+216, ts+16887, zOpt,
		ts+16912, uintptr(0)))
	return TCL_ERROR
__130:
	;
	if !(objc == 4) {
		goto __131
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1052) != 0) {
		goto __132
	}
	return TCL_ERROR
__132:
	;
__131:
	;
	sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, libc.VaList(bp+248, *(*int32)(unsafe.Pointer(bp + 1052)), bp+1056))
	pResult2 = tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1056)))
__121:
	;
	tcl.XTcl_SetObjResult(tls, interp, pResult2)
	goto __3

__16:
	lineno = 0
	if !(objc < 5 || objc > 7) {
		goto __133
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
		ts+16914)
	return TCL_ERROR
__133:
	;
	if !(objc >= 6) {
		goto __134
	}
	zSep = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 5*4)), uintptr(0))
	goto __135
__134:
	zSep = ts + 16976
__135:
	;
	if !(objc >= 7) {
		goto __136
	}
	zNull = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 6*4)), uintptr(0))
	goto __137
__136:
	zNull = ts + 584
__137:
	;
	zConflict = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	zTable = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), uintptr(0))
	zFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0))
	nSep = strlen30(tls, zSep)
	nNull = strlen30(tls, zNull)
	if !(nSep == 0) {
		goto __138
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+264, ts+16978,
		uintptr(0)))
	return TCL_ERROR
__138:
	;
	if !(libc.Xstrcmp(tls, zConflict, ts+17022) != 0 && libc.Xstrcmp(tls, zConflict, ts+17031) != 0 && libc.Xstrcmp(tls, zConflict, ts+17037) != 0 && libc.Xstrcmp(tls, zConflict, ts+17042) != 0 && libc.Xstrcmp(tls, zConflict, ts+17049) != 0) {
		goto __139
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+280, ts+17057, zConflict,
		ts+17066, uintptr(0)))
	return TCL_ERROR
__139:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+17146, libc.VaList(bp+312, zTable))
	if !(zSql == uintptr(0)) {
		goto __140
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+320, ts+17165, zTable, uintptr(0)))
	return TCL_ERROR
__140:
	;
	nByte = strlen30(tls, zSql)
	rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1060, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != 0) {
		goto __141
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+344, ts+17188, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	nCol = 0
	goto __142
__141:
	nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)))
__142:
	;
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)))
	if !(nCol == 0) {
		goto __143
	}
	return TCL_ERROR
__143:
	;
	zSql = libc.Xmalloc(tls, uint32(nByte+50+nCol*2))
	if !(zSql == uintptr(0)) {
		goto __144
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+368, ts+17196, uintptr(0)))
	return TCL_ERROR
__144:
	;
	sqlite3.Xsqlite3_snprintf(tls, nByte+50, zSql, ts+17218,
		libc.VaList(bp+384, zConflict, zTable))
	j = strlen30(tls, zSql)
	i = 1
__145:
	if !(i < nCol) {
		goto __147
	}
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(',')
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
	goto __146
__146:
	i++
	goto __145
	goto __147
__147:
	;
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(')')
	*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
	rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1060, uintptr(0))
	libc.Xfree(tls, zSql)
	if !(rc != 0) {
		goto __148
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+400, ts+17188, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)))
	return TCL_ERROR
__148:
	;
	in = libc.Xfopen(tls, zFile, ts+4759)
	if !(in == uintptr(0)) {
		goto __149
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+424, ts+17250, zFile, uintptr(0)))
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)))
	return TCL_ERROR
__149:
	;
	azCol = libc.Xmalloc(tls, uint32(unsafe.Sizeof(uintptr(0)))*uint32(nCol+1))
	if !(azCol == uintptr(0)) {
		goto __150
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+448, ts+17196, uintptr(0)))
	libc.Xfclose(tls, in)
	return TCL_ERROR
__150:
	;
	sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+14480, uintptr(0), uintptr(0), uintptr(0))
	zCommit1 = ts + 14542
__151:
	if !(libc.AssignUintptr(&zLine, local_getline(tls, uintptr(0), in)) != uintptr(0)) {
		goto __152
	}
	lineno++
	*(*uintptr)(unsafe.Pointer(azCol)) = zLine
	i = 0
	z = zLine
__153:
	if !(*(*int8)(unsafe.Pointer(z)) != 0) {
		goto __155
	}
	if !(int32(*(*int8)(unsafe.Pointer(z))) == int32(*(*int8)(unsafe.Pointer(zSep))) && libc.Xstrncmp(tls, z, zSep, uint32(nSep)) == 0) {
		goto __156
	}
	*(*int8)(unsafe.Pointer(z)) = int8(0)
	i++
	if !(i < nCol) {
		goto __157
	}
	*(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4)) = z + uintptr(nSep)
	z += uintptr(nSep - 1)
__157:
	;
__156:
	;
	goto __154
__154:
	z++
	goto __153
	goto __155
__155:
	;
	if !(i+1 != nCol) {
		goto __158
	}
	nErr = strlen30(tls, zFile) + 200
	zErr = libc.Xmalloc(tls, uint32(nErr))
	if !(zErr != 0) {
		goto __159
	}
	sqlite3.Xsqlite3_snprintf(tls, nErr, zErr,
		ts+17276,
		libc.VaList(bp+464, zFile, lineno, nCol, i+1))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+496, zErr, uintptr(0)))
	libc.Xfree(tls, zErr)
__159:
	;
	zCommit1 = ts + 8179
	goto __152
__158:
	;
	i = 0
__160:
	if !(i < nCol) {
		goto __162
	}

	if !(nNull > 0 && libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4)), zNull) == 0 ||
		strlen30(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4))) == 0) {
		goto __163
	}
	sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)), i+1)
	goto __164
__163:
	sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)), i+1, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*4)), -1, uintptr(0))
__164:
	;
	goto __161
__161:
	i++
	goto __160
	goto __162
__162:
	;
	sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)))
	rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)))
	libc.Xfree(tls, zLine)
	if !(rc != SQLITE_OK) {
		goto __165
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+512, ts+17188, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	zCommit1 = ts + 8179
	goto __152
__165:
	;
	goto __151
__152:
	;
	libc.Xfree(tls, azCol)
	libc.Xfclose(tls, in)
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1060)))
	sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zCommit1, uintptr(0), uintptr(0), uintptr(0))

	if !(int32(*(*int8)(unsafe.Pointer(zCommit1))) == 'C') {
		goto __166
	}

	pResult3 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult3, lineno)
	rc = TCL_OK
	goto __167
__166:
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+1064, ts+1333, libc.VaList(bp+536, lineno))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+544, ts+17336, bp+1064,
		uintptr(0)))
	rc = TCL_ERROR
__167:
	;
	goto __3

__17:
	zSchema = uintptr(0)
	pValue = uintptr(0)
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1160)) = int64(0)
	*(*int32)(unsafe.Pointer(bp + 1152)) = 0

	if !(objc < 3) {
		goto __168
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17369)
	rc = TCL_ERROR
	goto __3
__168:
	;
	i1 = 2
__169:
	if !(i1 < objc-1) {
		goto __171
	}
	z1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i1)*4)))
	if !(libc.Xstrcmp(tls, z1, ts+17386) == 0 && i1 < objc-2) {
		goto __172
	}
	rc = tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(libc.PreIncInt32(&i1, 1))*4)), bp+1144)
	if !(rc != 0) {
		goto __173
	}
	goto deserialize_error
__173:
	;
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1160)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 1144))
	goto __170
__172:
	;
	if !(libc.Xstrcmp(tls, z1, ts+17395) == 0 && i1 < objc-2) {
		goto __174
	}
	rc = tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(libc.PreIncInt32(&i1, 1))*4)), bp+1152)
	if !(rc != 0) {
		goto __175
	}
	goto deserialize_error
__175:
	;
	goto __170
__174:
	;
	if !(zSchema == uintptr(0) && i1 == objc-2 && int32(*(*int8)(unsafe.Pointer(z1))) != '-') {
		goto __176
	}
	zSchema = z1
	goto __170
__176:
	;
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+568, ts+17405, z1, uintptr(0)))
	rc = TCL_ERROR
	goto deserialize_error
	goto __170
__170:
	i1++
	goto __169
	goto __171
__171:
	;
	pValue = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4))
	pBA = tcl.XTcl_GetByteArrayFromObj(tls, pValue, bp+1156)
	pData = sqlite3.Xsqlite3_malloc64(tls, uint64(*(*int32)(unsafe.Pointer(bp + 1156))))
	if !(pData == uintptr(0) && *(*int32)(unsafe.Pointer(bp + 1156)) > 0) {
		goto __177
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+592, ts+2069, uintptr(0)))
	rc = TCL_ERROR
	goto __178
__177:
	if !(*(*int32)(unsafe.Pointer(bp + 1156)) > 0) {
		goto __179
	}
	libc.Xmemcpy(tls, pData, pBA, uint32(*(*int32)(unsafe.Pointer(bp + 1156))))
__179:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1152)) != 0) {
		goto __180
	}
	flags = SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_READONLY
	goto __181
__180:
	flags = SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_RESIZEABLE
__181:
	;
	xrc = sqlite3.Xsqlite3_deserialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema, pData, int64(*(*int32)(unsafe.Pointer(bp + 1156))), int64(*(*int32)(unsafe.Pointer(bp + 1156))), uint32(flags))
	if !(xrc != 0) {
		goto __182
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+608, ts+17422, uintptr(0)))
	rc = TCL_ERROR
__182:
	;
	if !(*(*sqlite3_int64)(unsafe.Pointer(bp + 1160)) > int64(0)) {
		goto __183
	}
	sqlite3.Xsqlite3_file_control(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema, SQLITE_FCNTL_SIZE_LIMIT, bp+1160)
__183:
	;
__178:
	;
deserialize_error:
	goto __3

__18:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+624, ts+17450,
		uintptr(0)))
	return TCL_ERROR

__19:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)))
	goto __3

__20:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_error_offset(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)))
	goto __3

__21:
__22:
	pResult4 = uintptr(0)
	if !(objc != 3) {
		goto __184
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+9890)
	return TCL_ERROR
__184:
	;
	dbEvalInit(tls, bp+1168, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0), 0)
	rc = dbEvalStep(tls, bp+1168)
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 24) {
		goto __185
	}
	if !(rc == TCL_OK) {
		goto __187
	}
	pResult4 = dbEvalColumnValue(tls, bp+1168, 0)
	goto __188
__187:
	if !(rc == TCL_BREAK) {
		goto __189
	}
	tcl.XTcl_ResetResult(tls, interp)
__189:
	;
__188:
	;
	goto __186
__185:
	if !(rc == TCL_BREAK || rc == TCL_OK) {
		goto __190
	}
	pResult4 = tcl.XTcl_NewIntObj(tls, libc.Bool32(libc.Bool32(rc == TCL_OK) != 0))
__190:
	;
__186:
	;
	dbEvalFinalize(tls, bp+1168)
	if !(pResult4 != 0) {
		goto __191
	}
	tcl.XTcl_SetObjResult(tls, interp, pResult4)
__191:
	;
	if !(rc == TCL_BREAK) {
		goto __192
	}
	rc = TCL_OK
__192:
	;
	goto __3

__23:
	evalFlags = 0
__193:
	if !(objc > 3 && libc.AssignUintptr(&zOpt1, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))) != uintptr(0) && int32(*(*int8)(unsafe.Pointer(zOpt1))) == '-') {
		goto __194
	}
	if !(libc.Xstrcmp(tls, zOpt1, ts+17498) == 0) {
		goto __195
	}
	evalFlags = evalFlags | SQLITE_EVAL_WITHOUTNULLS
	goto __196
__195:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+640, ts+17512, zOpt1, ts+16912, uintptr(0)))
	return TCL_ERROR
__196:
	;
	objc--
	objv += 4
	goto __193
__194:
	;
	if !(objc < 3 || objc > 5) {
		goto __197
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
		ts+17530)
	return TCL_ERROR
__197:
	;
	if !(objc == 3) {
		goto __198
	}
	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	dbEvalInit(tls, bp+1200, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0), 0)
__200:
	if !(TCL_OK == libc.AssignInt32(&rc, dbEvalStep(tls, bp+1200))) {
		goto __201
	}
	dbEvalRowInfo(tls, bp+1200, bp+1232, uintptr(0))
	i2 = 0
__202:
	if !(i2 < *(*int32)(unsafe.Pointer(bp + 1232))) {
		goto __204
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, dbEvalColumnValue(tls, bp+1200, i2))
	goto __203
__203:
	i2++
	goto __202
	goto __204
__204:
	;
	goto __200
__201:
	;
	dbEvalFinalize(tls, bp+1200)
	if !(rc == TCL_BREAK) {
		goto __205
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	rc = TCL_OK
__205:
	;
__206:
	_objPtr1 = pRet
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr1)).FrefCount, 1) <= 1) {
		goto __209
	}
	tcl.XTclFreeObj(tls, _objPtr1)
__209:
	;
	goto __207
__207:
	if 0 != 0 {
		goto __206
	}
	goto __208
__208:
	;
	goto __199
__198:
	pArray = uintptr(0)

	if !(objc >= 5 && *(*int8)(unsafe.Pointer(tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4))))) != 0) {
		goto __210
	}
	pArray = *(*uintptr)(unsafe.Pointer(objv + 3*4))
__210:
	;
	pScript = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4))
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(DbEvalContext{})))
	dbEvalInit(tls, p, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*4)), pArray, evalFlags)

	*(*ClientData)(unsafe.Pointer(bp + 1236)) = p
	*(*ClientData)(unsafe.Pointer(bp + 1236 + 1*4)) = pScript
	rc = DbEvalNextCmd(tls, bp+1236, interp, TCL_OK)
__199:
	;
	goto __3

__24:
	flags1 = SQLITE_UTF8
	*(*int32)(unsafe.Pointer(bp + 1244)) = -1
	*(*int32)(unsafe.Pointer(bp + 1272)) = SQLITE_NULL
	if !(objc < 4) {
		goto __211
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17566)
	return TCL_ERROR
__211:
	;
	i3 = 3
__212:
	if !(i3 < objc-1) {
		goto __214
	}
	z2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3)*4)))
	n1 = strlen30(tls, z2)
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+17589, uint32(n1)) == 0) {
		goto __215
	}
	if !(i3 == objc-2) {
		goto __217
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+672, ts+17599, z2, uintptr(0)))
	return TCL_ERROR
__217:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3+1)*4)), bp+1244) != 0) {
		goto __218
	}
	return TCL_ERROR
__218:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1244)) < 0) {
		goto __219
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+696, ts+17629,
		uintptr(0)))
	return TCL_ERROR
__219:
	;
	i3++
	goto __216
__215:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+17670, uint32(n1)) == 0) {
		goto __220
	}
	flags1 = flags1 | SQLITE_DETERMINISTIC
	goto __221
__220:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+17685, uint32(n1)) == 0) {
		goto __222
	}
	flags1 = flags1 | SQLITE_DIRECTONLY
	goto __223
__222:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+17697, uint32(n1)) == 0) {
		goto __224
	}
	flags1 = flags1 | SQLITE_INNOCUOUS
	goto __225
__224:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+17708, uint32(n1)) == 0) {
		goto __226
	}
	*(*[6]uintptr)(unsafe.Pointer(bp + 1248)) = [6]uintptr{ts + 8825, ts + 17720, ts + 17725, ts + 17730, ts + 17735, uintptr(0)}

	if !(i3 == objc-2) {
		goto __228
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+712, ts+17599, z2, uintptr(0)))
	return TCL_ERROR
__228:
	;
	i3++
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3)*4)), bp+1248, int32(unsafe.Sizeof(uintptr(0))), ts+17739, 0, bp+1272) != 0) {
		goto __229
	}
	return TCL_ERROR
__229:
	;
	*(*int32)(unsafe.Pointer(bp + 1272))++
	goto __227
__226:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+736, ts+16818, z2,
		ts+17744, uintptr(0)))
	return TCL_ERROR
__227:
	;
__225:
	;
__223:
	;
__221:
	;
__216:
	;
	goto __213
__213:
	i3++
	goto __212
	goto __214
__214:
	;
	pScript1 = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4))
	zName1 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0))
	pFunc = findSqlFunc(tls, pDb, zName1)
	if !(pFunc == uintptr(0)) {
		goto __230
	}
	return TCL_ERROR
__230:
	;
	if !((*SqlFunc)(unsafe.Pointer(pFunc)).FpScript != 0) {
		goto __231
	}
__232:
	_objPtr2 = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr2)).FrefCount, 1) <= 1) {
		goto __235
	}
	tcl.XTclFreeObj(tls, _objPtr2)
__235:
	;
	goto __233
__233:
	if 0 != 0 {
		goto __232
	}
	goto __234
__234:
	;
__231:
	;
	(*SqlFunc)(unsafe.Pointer(pFunc)).FpScript = pScript1
	(*Tcl_Obj)(unsafe.Pointer(pScript1)).FrefCount++
	(*SqlFunc)(unsafe.Pointer(pFunc)).FuseEvalObjv = safeToUseEvalObjv(tls, interp, pScript1)
	(*SqlFunc)(unsafe.Pointer(pFunc)).FeType = *(*int32)(unsafe.Pointer(bp + 1272))
	rc = sqlite3.Xsqlite3_create_function(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName1, *(*int32)(unsafe.Pointer(bp + 1244)), flags1,
		pFunc, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tclSqlFunc})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __236
	}
	rc = TCL_ERROR
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
__236:
	;
	goto __3

__25:
	isReadonly1 = 0
	zDb = ts + 85

	if !(objc > 3 && libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), ts+17395) == 0) {
		goto __237
	}
	isReadonly1 = 1
__237:
	;
	if !(objc != 5+isReadonly1 && objc != 6+isReadonly1) {
		goto __238
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17822)
	return TCL_ERROR
__238:
	;
	if !(objc == 6+isReadonly1) {
		goto __239
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2+isReadonly1)*4)))
__239:
	;
	zTable1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*4)))
	zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*4)))
	rc = tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4)), bp+1276)

	if !(rc == TCL_OK) {
		goto __240
	}
	rc = createIncrblobChannel(tls,
		interp, pDb, zDb, zTable1, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 1276)), isReadonly1)
__240:
	;
	goto __3

__26:
	sqlite3.Xsqlite3_interrupt(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	goto __3

__27:
	if !(objc != 2 && objc != 3) {
		goto __241
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17858)
	return TCL_ERROR
__241:
	;
	if !(objc == 3) {
		goto __242
	}
	zNull1 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1284)
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0) {
		goto __243
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
__243:
	;
	if !(zNull1 != 0 && *(*int32)(unsafe.Pointer(bp + 1284)) > 0) {
		goto __244
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1284))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, zNull1, uint32(*(*int32)(unsafe.Pointer(bp + 1284))))
	*(*int8)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FzNull + uintptr(*(*int32)(unsafe.Pointer(bp + 1284))))) = int8(0)
	goto __245
__244:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = uintptr(0)
__245:
	;
__242:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, -1))
	goto __3

__28:
	if !(objc != 2) {
		goto __246
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
	return TCL_ERROR
__246:
	;
	rowid = sqlite3.Xsqlite3_last_insert_rowid(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	pResult5 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetWideIntObj(tls, pResult5, rowid)
	goto __3

__29:
	if !(objc == 2) {
		goto __247
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __249
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+768, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, uintptr(0)))
__249:
	;
	sqlite3.Xsqlite3_progress_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, 0, uintptr(0), uintptr(0))
	goto __248
__247:
	if !(objc == 4) {
		goto __250
	}
	if !(TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1288)) {
		goto __252
	}
	return TCL_ERROR
__252:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __253
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress)
__253:
	;
	zProgress = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1292)
	if !(zProgress != 0 && *(*int32)(unsafe.Pointer(bp + 1292)) > 0) {
		goto __254
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1292))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, zProgress, uint32(*(*int32)(unsafe.Pointer(bp + 1292))+1))
	goto __255
__254:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = uintptr(0)
__255:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __256
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_progress_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1288)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{DbProgressHandler})), pDb)
	goto __257
__256:
	sqlite3.Xsqlite3_progress_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, 0, uintptr(0), uintptr(0))
__257:
	;
	goto __251
__250:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17868)
	return TCL_ERROR
__251:
	;
__248:
	;
	goto __3

__30:
	if !(objc > 3) {
		goto __258
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16665)
	return TCL_ERROR
	goto __259
__258:
	if !(objc == 2) {
		goto __260
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __262
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+784, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, uintptr(0)))
__262:
	;
	goto __261
__260:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __263
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
__263:
	;
	zProfile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1296)
	if !(zProfile != 0 && *(*int32)(unsafe.Pointer(bp + 1296)) > 0) {
		goto __264
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1296))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, zProfile, uint32(*(*int32)(unsafe.Pointer(bp + 1296))+1))
	goto __265
__264:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = uintptr(0)
__265:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __266
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, sqlite_uint64)
	}{DbProfileHandler})), pDb)
	goto __267
__266:
	sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__267:
	;
__261:
	;
__259:
	;
	goto __3

__31:
	if !(objc != 3) {
		goto __268
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17879)
	return TCL_ERROR
__268:
	;
	goto __3

__32:
	nTimeout = 0

	if !(objc == 3) {
		goto __269
	}
	zDestDb = ts + 85
	zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	goto __270
__269:
	if !(objc == 4) {
		goto __271
	}
	zDestDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	goto __272
__271:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16676)
	return TCL_ERROR
__272:
	;
__270:
	;
	rc = sqlite3.Xsqlite3_open_v2(tls, zSrcFile, bp+1300,
		SQLITE_OPEN_READONLY|(*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __273
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+800, ts+17883,
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1300))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1300)))
	return TCL_ERROR
__273:
	;
	pBackup1 = sqlite3.Xsqlite3_backup_init(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zDestDb, *(*uintptr)(unsafe.Pointer(bp + 1300)), ts+85)
	if !(pBackup1 == uintptr(0)) {
		goto __274
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+824, ts+17913,
		sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1300)))
	return TCL_ERROR
__274:
	;
__275:
	if !(libc.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup1, 100)) == SQLITE_OK ||
		rc == SQLITE_BUSY) {
		goto __276
	}
	if !(rc == SQLITE_BUSY) {
		goto __277
	}
	if !(libc.PostIncInt32(&nTimeout, 1) >= 3) {
		goto __278
	}
	goto __276
__278:
	;
	sqlite3.Xsqlite3_sleep(tls, 100)
__277:
	;
	goto __275
__276:
	;
	sqlite3.Xsqlite3_backup_finish(tls, pBackup1)
	if !(rc == SQLITE_DONE) {
		goto __279
	}
	rc = TCL_OK
	goto __280
__279:
	if !(rc == SQLITE_BUSY || rc == SQLITE_LOCKED) {
		goto __281
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+848, ts+17930,
		uintptr(0)))
	rc = TCL_ERROR
	goto __282
__281:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+864, ts+17913,
		sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	rc = TCL_ERROR
__282:
	;
__280:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1300)))
	goto __3

__33:
	if objc >= 3 {
		zSchema1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	} else {
		zSchema1 = ts + 85
	}
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1304)) = int64(0)
	if !(objc != 2 && objc != 3) {
		goto __283
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17967)
	rc = TCL_ERROR
	goto __284
__283:
	pData1 = sqlite3.Xsqlite3_serialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema1, bp+1304, uint32(SQLITE_SERIALIZE_NOCOPY))
	if !(pData1 != 0) {
		goto __285
	}
	needFree = 0
	goto __286
__285:
	pData1 = sqlite3.Xsqlite3_serialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema1, bp+1304, uint32(0))
	needFree = 1
__286:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, pData1, int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 1304)))))
	if !(needFree != 0) {
		goto __287
	}
	sqlite3.Xsqlite3_free(tls, pData1)
__287:
	;
__284:
	;
	goto __3

__34:
	if !(objc != 3) {
		goto __288
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+17978)
	return TCL_ERROR
__288:
	;
	zOp = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if !(libc.Xstrcmp(tls, zOp, ts+9840) == 0) {
		goto __289
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnStep
	goto __290
__289:
	if !(libc.Xstrcmp(tls, zOp, ts+18000) == 0) {
		goto __291
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnSort
	goto __292
__291:
	if !(libc.Xstrcmp(tls, zOp, ts+18005) == 0) {
		goto __293
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnIndex
	goto __294
__293:
	if !(libc.Xstrcmp(tls, zOp, ts+18015) == 0) {
		goto __295
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep
	goto __296
__295:
	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp+888, ts+18022,
			uintptr(0)))
	return TCL_ERROR
__296:
	;
__294:
	;
__292:
	;
__290:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, v2))
	goto __3

__35:
	if !(objc != 3) {
		goto __297
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18078)
	return TCL_ERROR
__297:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1312) != 0) {
		goto __298
	}
	return TCL_ERROR
__298:
	;
	sqlite3.Xsqlite3_busy_timeout(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1312)))
	goto __3

__36:
	if !(objc != 2) {
		goto __299
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
	return TCL_ERROR
__299:
	;
	pResult6 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetWideIntObj(tls, pResult6, sqlite3.Xsqlite3_total_changes64(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	goto __3

__37:
	if !(objc > 3) {
		goto __300
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16665)
	return TCL_ERROR
	goto __301
__300:
	if !(objc == 2) {
		goto __302
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __304
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+904, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, uintptr(0)))
__304:
	;
	goto __303
__302:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __305
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
__305:
	;
	zTrace = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1316)
	if !(zTrace != 0 && *(*int32)(unsafe.Pointer(bp + 1316)) > 0) {
		goto __306
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1316))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, zTrace, uint32(*(*int32)(unsafe.Pointer(bp + 1316))+1))
	goto __307
__306:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = uintptr(0)
__307:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __308
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{DbTraceHandler})), pDb)
	goto __309
__308:
	sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__309:
	;
__303:
	;
__301:
	;
	goto __3

__38:
	if !(objc > 4) {
		goto __310
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18091)
	return TCL_ERROR
	goto __311
__310:
	if !(objc == 2) {
		goto __312
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __314
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+920, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, uintptr(0)))
__314:
	;
	goto __313
__312:
	wMask = int64(0)
	if !(objc == 4) {
		goto __315
	}
	if !(TCL_OK != tcl.XTcl_ListObjLength(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1320)) {
		goto __317
	}
	return TCL_ERROR
__317:
	;
	i4 = 0
__318:
	if !(i4 < *(*int32)(unsafe.Pointer(bp + 1320))) {
		goto __320
	}
	if !(TCL_OK != tcl.XTcl_ListObjIndex(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), i4, bp+1324)) {
		goto __321
	}
	return TCL_ERROR
__321:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1324)), uintptr(unsafe.Pointer(&TTYPE_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+18109, 0, bp+1328) != TCL_OK) {
		goto __322
	}
	pError = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, interp))
	(*Tcl_Obj)(unsafe.Pointer(pError)).FrefCount++
	if !(TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1324)), bp+1332)) {
		goto __324
	}
__326:
	_objPtr3 = pError
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr3)).FrefCount, 1) <= 1) {
		goto __329
	}
	tcl.XTclFreeObj(tls, _objPtr3)
__329:
	;
	goto __327
__327:
	if 0 != 0 {
		goto __326
	}
	goto __328
__328:
	;
	wMask = wMask | *(*Tcl_WideInt)(unsafe.Pointer(bp + 1332))
	goto __325
__324:
	tcl.XTcl_SetObjResult(tls, interp, pError)
__330:
	_objPtr4 = pError
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr4)).FrefCount, 1) <= 1) {
		goto __333
	}
	tcl.XTclFreeObj(tls, _objPtr4)
__333:
	;
	goto __331
__331:
	if 0 != 0 {
		goto __330
	}
	goto __332
__332:
	;
	return TCL_ERROR
__325:
	;
	goto __323
__322:
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1328))) {
	case uint32(0):
		goto __335
	case uint32(1):
		goto __336
	case uint32(2):
		goto __337
	case uint32(3):
		goto __338
	}
	goto __334
__335:
	wMask = wMask | int64(SQLITE_TRACE_STMT)
	goto __334
__336:
	wMask = wMask | int64(SQLITE_TRACE_PROFILE)
	goto __334
__337:
	wMask = wMask | int64(SQLITE_TRACE_ROW)
	goto __334
__338:
	wMask = wMask | int64(SQLITE_TRACE_CLOSE)
	goto __334
__334:
	;
__323:
	;
	goto __319
__319:
	i4++
	goto __318
	goto __320
__320:
	;
	goto __316
__315:
	wMask = int64(SQLITE_TRACE_STMT)
__316:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __339
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
__339:
	;
	zTraceV2 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+1320)
	if !(zTraceV2 != 0 && *(*int32)(unsafe.Pointer(bp + 1320)) > 0) {
		goto __340
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1320))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, zTraceV2, uint32(*(*int32)(unsafe.Pointer(bp + 1320))+1))
	goto __341
__340:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = uintptr(0)
__341:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __342
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(wMask), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uint32, uintptr, uintptr, uintptr) int32
	}{DbTraceV2Handler})), pDb)
	goto __343
__342:
	sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(0), uintptr(0), uintptr(0))
__343:
	;
__313:
	;
__311:
	;
	goto __3

__39:
	zBegin = ts + 18120
	if !(objc != 3 && objc != 4) {
		goto __344
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18147)
	return TCL_ERROR
__344:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0 && objc == 4) {
		goto __345
	}
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(unsafe.Pointer(&TTYPE_strs1)), int32(unsafe.Sizeof(uintptr(0))), ts+18161, 0, bp+1340) != 0) {
		goto __346
	}
	return TCL_ERROR
__346:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1340))) {
	case uint32(0):
		goto __348
	case uint32(1):
		goto __349
	case uint32(2):
		goto __350
	}
	goto __347
__348:
	;
	goto __347
__349:
	zBegin = ts + 18178
	goto __347
__350:
	zBegin = ts + 18194
	goto __347
__347:
	;
__345:
	;
	pScript2 = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4))

	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
	rc = sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zBegin, uintptr(0), uintptr(0), uintptr(0))
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--
	if !(rc != SQLITE_OK) {
		goto __351
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+936, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	return TCL_ERROR
__351:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction++

	addDatabaseRef(tls, pDb)
	if !(DbUseNre(tls) != 0) {
		goto __352
	}
	tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{DbTransPostCmd})), *(*uintptr)(unsafe.Pointer(bp + 1344)), uintptr(0), uintptr(0), uintptr(0))
	tcl.XTcl_NREvalObj(tls, interp, pScript2, 0)
	goto __353
__352:
	rc = DbTransPostCmd(tls, bp+1344, interp, tcl.XTcl_EvalObjEx(tls, interp, pScript2, 0))
__353:
	;
	goto __3

__40:
	if !(objc != 2 && objc != 3) {
		goto __354
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18210)
	rc = TCL_ERROR
	goto __355
__354:
	xNotify = uintptr(0)
	pNotifyArg = uintptr(0)

	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify != 0) {
		goto __356
	}
__357:
	_objPtr5 = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr5)).FrefCount, 1) <= 1) {
		goto __360
	}
	tcl.XTclFreeObj(tls, _objPtr5)
__360:
	;
	goto __358
__358:
	if 0 != 0 {
		goto __357
	}
	goto __359
__359:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
__356:
	;
	if !(objc == 3) {
		goto __361
	}
	xNotify = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{DbUnlockNotify}))
	pNotifyArg = pDb
	(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = *(*uintptr)(unsafe.Pointer(objv + 2*4))
	(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify)).FrefCount++
__361:
	;
	if !(sqlite3.Xsqlite3_unlock_notify(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, xNotify, pNotifyArg) != 0) {
		goto __362
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+952, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	rc = TCL_ERROR
__362:
	;
__355:
	;
	goto __3

__41:
	if !(objc < 3) {
		goto __363
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18219)
__363:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(unsafe.Pointer(&azSub)), int32(unsafe.Sizeof(uintptr(0))), ts+2014, 0, bp+1348) != 0) {
		goto __364
	}
	return TCL_ERROR
__364:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1348))) {
	case uint32(0):
		goto __366

	case uint32(2):
		goto __367

	case uint32(1):
		goto __368

	case uint32(3):
		goto __369
	case uint32(4):
		goto __370
	}
	goto __365
__366:
	nCol2 = sqlite3.Xsqlite3_preupdate_count(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nCol2))
	goto __365

__367:
	if !(objc > 4) {
		goto __371
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18238)
	return TCL_ERROR
__371:
	;
	DbHookCmd(tls, interp, pDb, func() uintptr {
		if objc == 4 {
			return *(*uintptr)(unsafe.Pointer(objv + 3*4))
		}
		return uintptr(0)
	}(), pDb+56)
	goto __365

__368:
	if !(objc != 3) {
		goto __372
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+584)
	return TCL_ERROR
__372:
	;
	pRet1 = tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_preupdate_depth(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	tcl.XTcl_SetObjResult(tls, interp, pRet1)
	goto __365

__369:
__370:
	if !(objc != 4) {
		goto __373
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+18252)
	return TCL_ERROR
__373:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+1352) != 0) {
		goto __374
	}
	return TCL_ERROR
__374:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1348)) == 4) {
		goto __375
	}
	rc = sqlite3.Xsqlite3_preupdate_old(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1352)), bp+1356)
	goto __376
__375:
	;
	rc = sqlite3.Xsqlite3_preupdate_new(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1352)), bp+1356)
__376:
	;
	if !(rc == SQLITE_OK) {
		goto __377
	}
	pObj1 = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(bp + 1356))), -1)
	tcl.XTcl_SetObjResult(tls, interp, pObj1)
	goto __378
__377:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+968, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	return TCL_ERROR
__378:
	;
__365:
	;
	goto __3

__42:
__43:
__44:
	ppHook = uintptr(0)
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 41) {
		goto __379
	}
	ppHook = pDb + 64
__379:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 39) {
		goto __380
	}
	ppHook = pDb + 52
__380:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 30) {
		goto __381
	}
	ppHook = pDb + 60
__381:
	;
	if !(objc > 3) {
		goto __382
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18210)
	return TCL_ERROR
__382:
	;
	DbHookCmd(tls, interp, pDb, func() uintptr {
		if objc == 3 {
			return *(*uintptr)(unsafe.Pointer(objv + 2*4))
		}
		return uintptr(0)
	}(), ppHook)
	goto __3

__45:
	i5 = 2
__383:
	if !(i5 < objc) {
		goto __385
	}
	zArg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i5)*4)))

	if !(libc.Xstrcmp(tls, zArg, ts+18258) == 0 && i5+1 < objc) {
		goto __386
	}
	i5++
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i5)*4)), pDb+132) != 0) {
		goto __388
	}
	return TCL_ERROR
__388:
	;
	goto __387
__386:
	if !(libc.Xstrcmp(tls, zArg, ts+18278) == 0) {
		goto __389
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+1360, ts+14791,
		libc.VaList(bp+984, func() uintptr {
			if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
				return (*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpStmt
			}
			return uintptr(0)
		}()))
	tcl.XTcl_SetResult(tls, interp, bp+1360, uintptr(1))
	goto __390
__389:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+992, ts+18293, zArg, uintptr(0)))
	return TCL_ERROR
__390:
	;
__387:
	;
	goto __384
__384:
	i5++
	goto __383
	goto __385
__385:
	;
	if !(i5 == 2) {
		goto __391
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_libversion(tls), uintptr(0))
__391:
	;
	goto __3

__3:
	;
	return rc
}

type DbConfigChoices = struct {
	FzName uintptr
	Fop    int32
}

var DB_strs = [43]uintptr{
	ts + 18312, ts + 18323, ts + 18330,
	ts + 18344, ts + 18349, ts + 18355,
	ts + 9845, ts + 18363, ts + 18371,
	ts + 18388, ts + 18400, ts + 14640,
	ts + 18409, ts + 18414, ts + 18426,
	ts + 18448, ts + 18458, ts + 5253,
	ts + 18470, ts + 18477, ts + 15849,
	ts + 18486, ts + 18496, ts + 18514,
	ts + 18524, ts + 18534, ts + 18544,
	ts + 9919, ts + 18552, ts + 18558,
	ts + 18566, ts + 18580, ts + 18590,
	ts + 18597, ts + 18605, ts + 18619,
	ts + 18625, ts + 18634, ts + 18646,
	ts + 18660, ts + 18672, ts + 18680,
	uintptr(0),
}
var aDbConfig = [16]DbConfigChoices{
	{FzName: ts + 18689, Fop: SQLITE_DBCONFIG_DEFENSIVE},
	{FzName: ts + 18699, Fop: SQLITE_DBCONFIG_DQS_DDL},
	{FzName: ts + 18707, Fop: SQLITE_DBCONFIG_DQS_DML},
	{FzName: ts + 18715, Fop: SQLITE_DBCONFIG_ENABLE_FKEY},
	{FzName: ts + 18727, Fop: SQLITE_DBCONFIG_ENABLE_QPSG},
	{FzName: ts + 18739, Fop: SQLITE_DBCONFIG_ENABLE_TRIGGER},
	{FzName: ts + 18754, Fop: SQLITE_DBCONFIG_ENABLE_VIEW},
	{FzName: ts + 18766, Fop: SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER},
	{FzName: ts + 18781, Fop: SQLITE_DBCONFIG_LEGACY_ALTER_TABLE},
	{FzName: ts + 18800, Fop: SQLITE_DBCONFIG_LEGACY_FILE_FORMAT},
	{FzName: ts + 18819, Fop: SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION},
	{FzName: ts + 18834, Fop: SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE},
	{FzName: ts + 18851, Fop: SQLITE_DBCONFIG_RESET_DATABASE},
	{FzName: ts + 18866, Fop: SQLITE_DBCONFIG_TRIGGER_EQP},
	{FzName: ts + 18878, Fop: SQLITE_DBCONFIG_TRUSTED_SCHEMA},
	{FzName: ts + 18893, Fop: SQLITE_DBCONFIG_WRITABLE_SCHEMA},
}
var TTYPE_strs = [5]uintptr{
	ts + 18909, ts + 18544, ts + 18919, ts + 9845, uintptr(0),
}
var TTYPE_strs1 = [4]uintptr{
	ts + 18923, ts + 18932, ts + 18942, uintptr(0),
}
var azSub = [6]uintptr{ts + 1965, ts + 18952, ts + 18958, ts + 18963, ts + 18967, uintptr(0)}

func DbObjCmdAdaptor(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	return tcl.XTcl_NRCallObjProc(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{DbObjCmd})), cd, objc, objv)
}

func sqliteCmdUsage(tls *libc.TLS, interp uintptr, objv uintptr) int32 {
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
		ts+18971)
	return TCL_ERROR
}

func DbMain(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(328)
	defer tls.Free(328)

	var p uintptr
	var zArg uintptr
	var zErrMsg uintptr
	var i int32
	var zFile uintptr = uintptr(0)
	var zVfs uintptr = uintptr(0)
	var flags int32
	*(*int32)(unsafe.Pointer(bp + 112)) = 1

	var rc int32

	flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_NOMUTEX

	if objc == 1 {
		return sqliteCmdUsage(tls, interp, objv)
	}
	if objc == 2 {
		zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
		if libc.Xstrcmp(tls, zArg, ts+19117) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_libversion(tls), uintptr(0)))
			return TCL_OK
		}
		if libc.Xstrcmp(tls, zArg, ts+19126) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3_sourceid(tls), uintptr(0)))
			return TCL_OK
		}
		if libc.Xstrcmp(tls, zArg, ts+19136) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+19147, uintptr(0)))
			return TCL_OK
		}
		if int32(*(*int8)(unsafe.Pointer(zArg))) == '-' {
			return sqliteCmdUsage(tls, interp, objv)
		}
	}
	for i = 2; i < objc; i++ {
		zArg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
		if int32(*(*int8)(unsafe.Pointer(zArg))) != '-' {
			if zFile != uintptr(0) {
				return sqliteCmdUsage(tls, interp, objv)
			}
			zFile = zArg
			continue
		}
		if i == objc-1 {
			return sqliteCmdUsage(tls, interp, objv)
		}
		i++
		if libc.Xstrcmp(tls, zArg, ts+19149) == 0 {
		} else if libc.Xstrcmp(tls, zArg, ts+19154) == 0 {
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
		} else if libc.Xstrcmp(tls, zArg, ts+17395) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+88) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 88)) != 0 {
				flags = flags & libc.CplInt32(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE)
				flags = flags | SQLITE_OPEN_READONLY
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_READONLY)
				flags = flags | SQLITE_OPEN_READWRITE
			}
		} else if libc.Xstrcmp(tls, zArg, ts+19159) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+92) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 92)) != 0 && flags&SQLITE_OPEN_READONLY == 0 {
				flags = flags | SQLITE_OPEN_CREATE
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_CREATE)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+19167) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+96) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 96)) != 0 {
				flags = flags | SQLITE_OPEN_NOFOLLOW
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_NOFOLLOW)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+19177) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+100) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 100)) != 0 {
				flags = flags | SQLITE_OPEN_NOMUTEX
				flags = flags & libc.CplInt32(SQLITE_OPEN_FULLMUTEX)
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_NOMUTEX)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+19186) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+104) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 104)) != 0 {
				flags = flags | SQLITE_OPEN_FULLMUTEX
				flags = flags & libc.CplInt32(SQLITE_OPEN_NOMUTEX)
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_FULLMUTEX)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+19197) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+108) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 108)) != 0 {
				flags = flags | SQLITE_OPEN_URI
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_URI)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+19202) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+112) != 0 {
				return TCL_ERROR
			}
		} else {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+17405, zArg, uintptr(0)))
			return TCL_ERROR
		}
	}
	zErrMsg = uintptr(0)
	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(SqliteDb{})))
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(SqliteDb{})))
	if zFile == uintptr(0) {
		zFile = ts + 584
	}
	if *(*int32)(unsafe.Pointer(bp + 112)) != 0 {
		zFile = tcl.XTcl_TranslateFileName(tls, interp, zFile, bp+116)
	}
	rc = sqlite3.Xsqlite3_open_v2(tls, zFile, p, flags, zVfs)
	if *(*int32)(unsafe.Pointer(bp + 112)) != 0 {
		tcl.XTcl_DStringFree(tls, bp+116)
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb != 0 {
		if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb) {
			zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+72, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)))
			sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)
			(*SqliteDb)(unsafe.Pointer(p)).Fdb = uintptr(0)
		}
	} else {
		zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+80, sqlite3.Xsqlite3_errstr(tls, rc)))
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, zErrMsg, uintptr(1))
		tcl.XTcl_Free(tls, p)
		sqlite3.Xsqlite3_free(tls, zErrMsg)
		return TCL_ERROR
	}
	(*SqliteDb)(unsafe.Pointer(p)).FmaxStmt = NUM_PREPARED_STMTS
	(*SqliteDb)(unsafe.Pointer(p)).FopenFlags = flags & SQLITE_OPEN_URI
	(*SqliteDb)(unsafe.Pointer(p)).Finterp = interp
	zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
	if DbUseNre(tls) != 0 {
		tcl.XTcl_NRCreateCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmdAdaptor})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})),
			p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbDeleteCmd})))
	} else {
		tcl.XTcl_CreateObjCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbDeleteCmd})))
	}
	(*SqliteDb)(unsafe.Pointer(p)).FnRef = 1
	return TCL_OK
}

func Sqlite3_Init(tls *libc.TLS, interp uintptr) int32 {
	var rc int32
	if 1 != 0 {
		rc = TCL_OK
	} else {
		rc = TCL_ERROR
	}
	if rc == TCL_OK {
		tcl.XTcl_CreateObjCommand(tls, interp, ts+19221, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))

		tcl.XTcl_CreateObjCommand(tls, interp, ts+19229, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))
		rc = tcl.XTcl_PkgProvideEx(tls, interp, ts+19221, ts+19236, uintptr(0))
	}
	return rc
}

func Tclsqlite3_Init(tls *libc.TLS, interp uintptr) int32 {
	return Sqlite3_Init(tls, interp)
}

func Sqlite3_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 {
	return TCL_OK
}

func Tclsqlite3_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 {
	return TCL_OK
}

func Sqlite3_SafeInit(tls *libc.TLS, interp uintptr) int32 {
	return TCL_ERROR
}

func Sqlite3_SafeUnload(tls *libc.TLS, interp uintptr, flags int32) int32 {
	return TCL_ERROR
}

func Sqlite_Init(tls *libc.TLS, interp uintptr) int32 {
	return Sqlite3_Init(tls, interp)
}

func Tclsqlite_Init(tls *libc.TLS, interp uintptr) int32 {
	return Sqlite3_Init(tls, interp)
}

func Sqlite_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 {
	return TCL_OK
}

func Tclsqlite_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 {
	return TCL_OK
}

func tclsh_main_loop(tls *libc.TLS) uintptr {
	return uintptr(unsafe.Pointer(&zMainloop))
}

var zMainloop = *(*[431]int8)(unsafe.Pointer(ts + 19243))

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var interp uintptr
	var i int32
	var zScript uintptr = uintptr(0)

	if libc.Xgetenv(tls, ts+19674) != 0 {
		if libc.Xisatty(tls, 0) != 0 && libc.Xisatty(tls, 2) != 0 {
			libc.Xfprintf(tls, libc.X__stderrp,
				ts+19693,
				libc.VaList(bp, libc.Xgetpid(tls)))
			libc.Xfgetc(tls, libc.X__stdinp)
		} else {
			libc.Xraise(tls, SIGTRAP)
		}
	}

	sqlite3.Xsqlite3_shutdown(tls)

	tcl.XTcl_FindExecutable(tls, *(*uintptr)(unsafe.Pointer(argv)))
	tcl.XTcl_SetSystemEncoding(tls, uintptr(0), ts+19755)
	interp = tcl.XTcl_CreateInterp(tls)
	Sqlite3_Init(tls, interp)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), bp+32, ts+1333, libc.VaList(bp+8, argc-1))
	tcl.XTcl_SetVar2(tls, interp, ts+19761, uintptr(0), bp+32, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+19766, uintptr(0), *(*uintptr)(unsafe.Pointer(argv)), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+19772, uintptr(0), ts+584, TCL_GLOBAL_ONLY)
	for i = 1; i < argc; i++ {
		tcl.XTcl_SetVar2(tls, interp, ts+19772, uintptr(0), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), TCL_GLOBAL_ONLY|TCL_LIST_ELEMENT|TCL_APPEND_VALUE)
	}
	zScript = sqlite3TestInit(tls, interp)
	if zScript == uintptr(0) {
		zScript = tclsh_main_loop(tls)
	}
	if tcl.XTcl_GlobalEval(tls, interp, zScript) != TCL_OK {
		var zInfo uintptr = tcl.XTcl_GetVar2(tls, interp, ts+19777, uintptr(0), TCL_GLOBAL_ONLY)
		if zInfo == uintptr(0) {
			zInfo = tcl.XTcl_GetStringResult(tls, interp)
		}
		libc.Xfprintf(tls, libc.X__stderrp, ts+19787, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv)), zInfo))
		return 1
	}
	return 0
}

type sqlite3_value = sqlite3_value1

type sqlite3_context = sqlite3_context1
type PreUpdate = PreUpdate1

type Vdbe = Vdbe1

type Mem = sqlite3_value1

type Op = VdbeOp1

type Bool = uint32

type AuxData1 = struct {
	FiAuxOp     int32
	FiAuxArg    int32
	FpAux       uintptr
	FxDeleteAux uintptr
	FpNextAux   uintptr
}

type AuxData = AuxData1

type VdbeCursor1 = struct {
	FeCurType       u8
	FiDb            i8
	FnullRow        u8
	FdeferredMoveto u8
	FisTable        u8
	F__ccgo_pad1    [3]byte
	FisEphemeral    uint8
	F__ccgo_pad2    [1]byte
	FseekHit        u16
	Fub             struct{ FpBtx uintptr }
	FseqCount       i64
	FcacheStatus    u32
	FseekResult     int32
	FpAltCursor     uintptr
	Fuc             struct{ FpCursor uintptr }
	FpKeyInfo       uintptr
	FiHdrOffset     u32
	FpgnoRoot       Pgno
	FnField         i16
	FnHdrParsed     u16
	FmovetoTarget   i64
	FaOffset        uintptr
	FaRow           uintptr
	FpayloadSize    u32
	FszRow          u32
	FaType          [1]u32
}

type VdbeCursor = VdbeCursor1

type VdbeFrame1 = struct {
	Fv         uintptr
	FpParent   uintptr
	FaOp       uintptr
	FaMem      uintptr
	FapCsr     uintptr
	FaOnce     uintptr
	Ftoken     uintptr
	FlastRowid i64
	FpAuxData  uintptr
	FnCursor   int32
	Fpc        int32
	FnOp       int32
	FnMem      int32
	FnChildMem int32
	FnChildCsr int32
	FnChange   i64
	FnDbChange i64
}

type VdbeFrame = VdbeFrame1

type MemValue = struct{ Fr float64 }

type bft = uint32

type ScanStatus1 = struct {
	FaddrExplain int32
	FaAddrRange  [6]int32
	FaddrLoop    int32
	FaddrVisit   int32
	FiSelectID   int32
	FnEst        LogEst
	F__ccgo_pad1 [2]byte
	FzName       uintptr
}

type ScanStatus = ScanStatus1

type DblquoteStr1 = struct {
	FpNextStr uintptr
	Fz        [8]int8
}

type DblquoteStr = DblquoteStr1

type ValueList1 = struct {
	FpCsr uintptr
	FpOut uintptr
}

type ValueList = ValueList1

func testHexToInt(tls *libc.TLS, h int32) int32 {
	if h >= '0' && h <= '9' {
		return h - '0'
	} else if h >= 'a' && h <= 'f' {
		return h - 'a' + 10
	} else {
		return h - 'A' + 10
	}
	return int32(0)
}

func sqlite3TestTextToPtr(tls *libc.TLS, z uintptr) uintptr {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if int32(*(*int8)(unsafe.Pointer(z))) == '0' && int32(*(*int8)(unsafe.Pointer(z + 1))) == 'x' {
		z += uintptr(2)
	}
	*(*u64)(unsafe.Pointer(bp + 4)) = uint64(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		*(*u64)(unsafe.Pointer(bp + 4)) = *(*u64)(unsafe.Pointer(bp + 4))<<4 + u64(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(z)))))
		z++
	}
	if uint32(unsafe.Sizeof(uintptr(0))) == uint32(unsafe.Sizeof(u64(0))) {
		libc.Xmemcpy(tls, bp, bp+4, uint32(unsafe.Sizeof(uintptr(0))))
	} else {
		*(*u32)(unsafe.Pointer(bp + 12)) = u32(*(*u64)(unsafe.Pointer(bp + 4)))
		libc.Xmemcpy(tls, bp, bp+12, uint32(unsafe.Sizeof(uintptr(0))))
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

func get_sqlite_pointer(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(180)
	defer tls.Free(180)

	var p uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19795)
		return TCL_ERROR
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19813,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	p = (*Tcl_CmdInfo)(unsafe.Pointer(bp + 48)).FobjClientData
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+80, ts+14791, libc.VaList(bp+24, (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+80, 0))
	return TCL_OK
}

func getDbPointer1(tls *libc.TLS, interp uintptr, zA uintptr, ppDb uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr

	if tcl.XTcl_GetCommandInfo(tls, interp, zA, bp) != 0 {
		p = (*Tcl_CmdInfo)(unsafe.Pointer(bp)).FobjClientData
		*(*uintptr)(unsafe.Pointer(ppDb)) = (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb
	} else {
		*(*uintptr)(unsafe.Pointer(ppDb)) = sqlite3TestTextToPtr(tls, zA)
	}
	return TCL_OK
}

func sqlite3TestErrCode(tls *libc.TLS, interp uintptr, db uintptr, rc int32) int32 {
	bp := tls.Alloc(248)
	defer tls.Free(248)

	if sqlite3.Xsqlite3_threadsafe(tls) == 0 && rc != SQLITE_MISUSE && rc != SQLITE_OK &&
		sqlite3.Xsqlite3_errcode(tls, db) != rc {
		var r2 int32 = sqlite3.Xsqlite3_errcode(tls, db)
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+48,
			ts+19833,
			libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), rc, sqlite3.Xsqlite3ErrName(tls, r2), r2))
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+48, 0))
		return 1
	}
	return 0
}

func getStmtPointer(tls *libc.TLS, interp uintptr, zArg uintptr, ppStmt uintptr) int32 {
	*(*uintptr)(unsafe.Pointer(ppStmt)) = sqlite3TestTextToPtr(tls, zArg)
	return TCL_OK
}

func sqlite3TestMakePointerStr(tls *libc.TLS, interp uintptr, zPtr uintptr, p uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, 100, zPtr, ts+14791, libc.VaList(bp, p))
	return TCL_OK
}

func exec_printf_cb(tls *libc.TLS, pArg uintptr, argc int32, argv uintptr, name uintptr) int32 {
	var str uintptr = pArg
	var i int32

	if (*Tcl_DString)(unsafe.Pointer(str)).Flength == 0 {
		for i = 0; i < argc; i++ {
			tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(name + uintptr(i)*4)) != 0 {
					return *(*uintptr)(unsafe.Pointer(name + uintptr(i)*4))
				}
				return ts + 6203
			}())
		}
	}
	for i = 0; i < argc; i++ {
		tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
			if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)) != 0 {
				return *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))
			}
			return ts + 6203
		}())
	}
	return 0
}

func test_io_trace(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	return TCL_OK
}

func clang_sanitize_address(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	var res int32 = 0
	if res == 0 && libc.Xgetenv(tls, ts+19891) != uintptr(0) {
		res = 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return TCL_OK
}

func test_exec_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(298)
	defer tls.Free(298)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 264)) = uintptr(0)
	var zSql uintptr

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19929, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+52)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+52, bp+264)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+268, ts+1333, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+268)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 52)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 264))
	}())
	tcl.XTcl_DStringFree(tls, bp+52)
	if *(*uintptr)(unsafe.Pointer(bp + 264)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 264)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_exec_hex(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(794)
	defer tls.Free(794)

	var rc int32
	var i int32
	var j int32
	*(*uintptr)(unsafe.Pointer(bp + 760)) = uintptr(0)
	var zHex uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19947, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+40) != 0 {
		return TCL_ERROR
	}
	zHex = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	i = libc.AssignInt32(&j, 0)
__1:
	if !(uint32(i) < uint32(unsafe.Sizeof([501]int8{}))-uint32(1) && *(*int8)(unsafe.Pointer(zHex + uintptr(j))) != 0) {
		goto __3
	}
	{
		if int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j)))) == '%' && *(*int8)(unsafe.Pointer(zHex + uintptr(j+2))) != 0 && *(*int8)(unsafe.Pointer(zHex + uintptr(j+2))) != 0 {
			*(*int8)(unsafe.Pointer(bp + 44 + uintptr(i))) = int8(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j+1)))))<<4 + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j+2))))))
			j = j + 2
		} else {
			*(*int8)(unsafe.Pointer(bp + 44 + uintptr(i))) = *(*int8)(unsafe.Pointer(zHex + uintptr(j)))
		}

	}
	goto __2
__2:
	i++
	j++
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(bp + 44 + uintptr(i))) = int8(0)
	tcl.XTcl_DStringInit(tls, bp+548)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), bp+44, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+548, bp+760)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+764, ts+1333, libc.VaList(bp+32, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+764)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 548)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 760))
	}())
	tcl.XTcl_DStringFree(tls, bp+548)
	if *(*uintptr)(unsafe.Pointer(bp + 760)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 760)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 40)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func db_enter(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fmutex)
	return TCL_OK
}

func db_leave(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fmutex)
	return TCL_OK
}

func test_exec(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(298)
	defer tls.Free(298)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 264)) = uintptr(0)
	var zSql uintptr
	var i int32
	var j int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19959, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+52)
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; {
		if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == '%' {
			*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i+1)))))<<4 + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i+2))))))
			i = i + 3
		} else {
			*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&i, 1))))
		}
	}
	*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+52, bp+264)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+268, ts+1333, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+268)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 52)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 264))
	}())
	tcl.XTcl_DStringFree(tls, bp+52)
	if *(*uintptr)(unsafe.Pointer(bp + 264)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 264)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_exec_nr(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 36)) = uintptr(0)
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19959, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), uintptr(0), uintptr(0), bp+36)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_mprintf_z(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zResult uintptr = uintptr(0)
	var i int32

	for i = 2; i < argc && (i == 2 || zResult != 0); i++ {
		zResult = sqlite3.Xsqlite3_mprintf(tls, ts+19967, libc.VaList(bp, zResult, *(*uintptr)(unsafe.Pointer(argv + 1*4)), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, zResult, 0))
	sqlite3.Xsqlite3_free(tls, zResult)
	return TCL_OK
}

func test_mprintf_n(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var zStr uintptr
	*(*int32)(unsafe.Pointer(bp + 16)) = 0
	zStr = sqlite3.Xsqlite3_mprintf(tls, ts+19974, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+16))
	sqlite3.Xsqlite3_free(tls, zStr)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16))))
	return TCL_OK
}

func test_snprintf_int(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var n int32 = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	var zFormat uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	var a1 int32 = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	if uint32(n) > uint32(unsafe.Sizeof([100]int8{})) {
		n = int32(unsafe.Sizeof([100]int8{}))
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24, ts+19979, 0)
	sqlite3.Xsqlite3_snprintf(tls, n, bp+24, zFormat, libc.VaList(bp, a1))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, bp+24, 0))
	return TCL_OK
}

func test_get_table_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(330)
	defer tls.Free(330)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 288)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 292)) = 0
	*(*int32)(unsafe.Pointer(bp + 296)) = 0

	var i int32

	var zSql uintptr
	*(*int32)(unsafe.Pointer(bp + 64)) = -1
	if argc == 5 {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*4)), bp+64) != 0 {
			return TCL_ERROR
		}
	}
	if argc != 4 && argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20006, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+68) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+72)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
	if argc == 5 {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 68)), zSql, bp+284, uintptr(0), uintptr(0), bp+288)
	} else {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 68)), zSql, bp+284, bp+292, bp+296, bp+288)
		*(*int32)(unsafe.Pointer(bp + 64)) = (*(*int32)(unsafe.Pointer(bp + 292)) + 1) * *(*int32)(unsafe.Pointer(bp + 296))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+300, ts+1333, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+300)
	if rc == SQLITE_OK {
		if argc == 4 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+300, ts+1333, libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 292))))
			tcl.XTcl_AppendElement(tls, interp, bp+300)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+300, ts+1333, libc.VaList(bp+56, *(*int32)(unsafe.Pointer(bp + 296))))
			tcl.XTcl_AppendElement(tls, interp, bp+300)
		}
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64)); i++ {
			tcl.XTcl_AppendElement(tls, interp, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 284)) + uintptr(i)*4)) != 0 {
					return *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 284)) + uintptr(i)*4))
				}
				return ts + 6203
			}())
		}
	} else {
		tcl.XTcl_AppendElement(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 288)))
	}
	sqlite3.Xsqlite3_free_table(tls, *(*uintptr)(unsafe.Pointer(bp + 284)))
	if *(*uintptr)(unsafe.Pointer(bp + 288)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 288)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 68)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_last_rowid(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(90)
	defer tls.Free(90)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)), ts+20032, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+56) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+60, ts+6682, libc.VaList(bp+32, sqlite3.Xsqlite3_last_insert_rowid(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60, 0))
	return SQLITE_OK
}

func test_key(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	return TCL_OK
}

func test_rekey(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	return TCL_OK
}

func sqlite_test_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20037, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func sqlite_test_close_v2(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20037, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_close_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func t1_ifnullFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var i int32
	for i = 0; i < argc; i++ {
		if SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) {
			var n int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))),
				n, libc.UintptrFromInt32(-1))
			break
		}
	}
}

func hex8Func(tls *libc.TLS, p uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var z uintptr
	var i int32

	z = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; uint32(i) < uint32(unsafe.Sizeof([200]int8{}))/uint32(2)-uint32(2) && *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		sqlite3.Xsqlite3_snprintf(tls, int32(uint32(unsafe.Sizeof([200]int8{}))-uint32(i*2)), bp+8+uintptr(i*2), ts+6694, libc.VaList(bp, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))))
	}
	*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i*2))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, p, bp+8, -1, libc.UintptrFromInt32(-1))
}

func hex16Func(tls *libc.TLS, p uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(408)
	defer tls.Free(408)

	var z uintptr
	var i int32

	z = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; uint32(i) < uint32(unsafe.Sizeof([400]int8{}))/uint32(4)-uint32(4) && *(*uint16)(unsafe.Pointer(z + uintptr(i)*2)) != 0; i++ {
		sqlite3.Xsqlite3_snprintf(tls, int32(uint32(unsafe.Sizeof([400]int8{}))-uint32(i*4)), bp+8+uintptr(i*4), ts+20048, libc.VaList(bp, int32(*(*uint16)(unsafe.Pointer(z + uintptr(i)*2)))&0xff))
	}
	*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i*4))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, p, bp+8, -1, libc.UintptrFromInt32(-1))
}

type dstr = struct {
	FnAlloc int32
	FnUsed  int32
	Fz      uintptr
}

func dstrAppend(tls *libc.TLS, p uintptr, z uintptr, divider int32) {
	var n int32 = int32(libc.Xstrlen(tls, z))
	if (*dstr)(unsafe.Pointer(p)).FnUsed+n+2 > (*dstr)(unsafe.Pointer(p)).FnAlloc {
		var zNew uintptr
		(*dstr)(unsafe.Pointer(p)).FnAlloc = (*dstr)(unsafe.Pointer(p)).FnAlloc*2 + n + 200
		zNew = sqlite3.Xsqlite3_realloc(tls, (*dstr)(unsafe.Pointer(p)).Fz, (*dstr)(unsafe.Pointer(p)).FnAlloc)
		if zNew == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(p)).Fz)
			libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(dstr{})))
			return
		}
		(*dstr)(unsafe.Pointer(p)).Fz = zNew
	}
	if divider != 0 && (*dstr)(unsafe.Pointer(p)).FnUsed > 0 {
		*(*int8)(unsafe.Pointer((*dstr)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*dstr)(unsafe.Pointer(p)).FnUsed, 1)))) = int8(divider)
	}
	libc.Xmemcpy(tls, (*dstr)(unsafe.Pointer(p)).Fz+uintptr((*dstr)(unsafe.Pointer(p)).FnUsed), z, uint32(n+1))
	*(*int32)(unsafe.Pointer(p + 4)) += n
}

func execFuncCallback(tls *libc.TLS, pData uintptr, argc int32, argv uintptr, NotUsed uintptr) int32 {
	var p uintptr = pData
	var i int32
	for i = 0; i < argc; i++ {
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)) == uintptr(0) {
			dstrAppend(tls, p, ts+6203, ' ')
		} else {
			dstrAppend(tls, p, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), ' ')
		}
	}
	return 0
}

func sqlite3ExecFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	libc.Xmemset(tls, bp, 0, uint32(unsafe.Sizeof(dstr{})))
	sqlite3.Xsqlite3_exec(tls, sqlite3.Xsqlite3_user_data(tls, context),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
		}{execFuncCallback})), bp, uintptr(0))
	sqlite3.Xsqlite3_result_text(tls, context, (*dstr)(unsafe.Pointer(bp)).Fz, (*dstr)(unsafe.Pointer(bp)).FnUsed, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(bp)).Fz)
}

func tkt2213Function(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var nText int32
	var zText1 uintptr
	var zText2 uintptr
	var zText3 uintptr

	nText = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText3 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))

	if zText1 != zText2 || zText2 != zText3 {
		sqlite3.Xsqlite3_result_error(tls, context, ts+20053, -1)
	} else {
		var zCopy uintptr = sqlite3.Xsqlite3_malloc(tls, nText)
		libc.Xmemcpy(tls, zCopy, zText1, uint32(nText))
		sqlite3.Xsqlite3_result_text(tls, context, zCopy, nText, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func ptrChngFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var p1 uintptr
	var p2 uintptr
	var zCmd uintptr
	if argc != 4 {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+17725) == 0 {
		p1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+20074) == 0 {
		p1 = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+17730) == 0 {
		p1 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+20081) == 0 {
		sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+20087) == 0 {
		sqlite3.Xsqlite3_value_bytes16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+20095) == 0 {
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+17725) == 0 {
		p2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+20074) == 0 {
		p2 = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+17730) == 0 {
		p2 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else {
		return
	}
	sqlite3.Xsqlite3_result_int(tls, context, libc.Bool32(p1 != p2))
}

func nondeterministicFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	sqlite3.Xsqlite3_result_int(tls, context, libc.PostIncInt32(&cnt, 1))
}

var cnt int32 = 0

func intrealFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var v sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_int64(tls, context, v)
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_RESULT_INTREAL, libc.VaList(bp, context))
}

func test_create_function(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20032, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20100, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{t1_ifnullFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20111, 1, SQLITE_UTF8|SQLITE_DETERMINISTIC,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{hex8Func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20116, 1, SQLITE_UTF16|SQLITE_DETERMINISTIC,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{hex16Func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20122, 1, SQLITE_ANY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{tkt2213Function})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20134, 4, SQLITE_ANY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{ptrChngFunction})), uintptr(0), uintptr(0))
	}

	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20149, -1, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20158, -1, SQLITE_UTF8|SQLITE_DETERMINISTIC,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}

	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20167, 1, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{intrealFunction})), uintptr(0), uintptr(0))
	}

	if rc == SQLITE_OK {
		var zUtf16 uintptr
		var pVal uintptr
		sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fmutex)
		pVal = sqlite3.Xsqlite3ValueNew(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, ts+20175, uint8(SQLITE_UTF8), uintptr(0))
		zUtf16 = sqlite3.Xsqlite3ValueText(tls, pVal, uint8(SQLITE_UTF16LE))
		if (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).FmallocFailed != 0 {
			rc = SQLITE_NOMEM
		} else {
			rc = sqlite3.Xsqlite3_create_function16(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), zUtf16,
				1, SQLITE_UTF16, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{sqlite3ExecFunc})), uintptr(0), uintptr(0))
		}
		sqlite3.Xsqlite3ValueFree(tls, pVal)
		sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fmutex)
	}

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32)), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_drop_modules(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if argc < 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20032, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_drop_modules(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), func() uintptr {
		if argc > 2 {
			return argv + uintptr(2)*4
		}
		return uintptr(0)
	}())
	return TCL_OK
}

type t1CountCtx1 = struct{ Fn int32 }

type t1CountCtx = t1CountCtx1

func t1CountStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(9)
	defer tls.Free(9)

	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if (argc == 0 || SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv)))) && p != 0 {
		(*t1CountCtx)(unsafe.Pointer(p)).Fn++
	}
	if argc > 0 {
		var v int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		if v == 40 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+20189, -1)
		} else if v == 41 {
			*(*[9]int8)(unsafe.Pointer(bp)) = [9]int8{int8(0), int8(0x61), int8(0), int8(0x62), int8(0), int8(0x63), int8(0), int8(0), int8(0)}
			sqlite3.Xsqlite3_result_error16(tls, context, bp+1, -1)
		}
	}
}

func t1CountFinalize(tls *libc.TLS, context uintptr) {
	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if p != 0 {
		if (*t1CountCtx)(unsafe.Pointer(p)).Fn == 42 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+20219, -1)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, func() int32 {
				if p != 0 {
					return (*t1CountCtx)(unsafe.Pointer(p)).Fn
				}
				return 0
			}())
		}
	}
}

func legacyCountStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
}

func legacyCountFinalize(tls *libc.TLS, context uintptr) {
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_aggregate_count(tls, context))
}

func test_create_aggregate(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20037, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20240, 0, SQLITE_UTF8, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{t1CountFinalize})))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20240, 1, SQLITE_UTF8, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{t1CountFinalize})))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+20248, 0, SQLITE_ANY, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{legacyCountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{legacyCountFinalize})))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32)), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20261, 0))
		return TCL_ERROR
	}
	libc.Xprintf(tls, ts+389, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	return TCL_OK
}

func sqlite3_mprintf_int(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20268, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72)), *(*int32)(unsafe.Pointer(bp + 72 + 1*4)), *(*int32)(unsafe.Pointer(bp + 72 + 2*4))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_mprintf_int64(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20268, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if sqlite3.Xsqlite3Atoi64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), bp+88+uintptr(i-2)*8, sqlite3.Xsqlite3Strlen30(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))), uint8(SQLITE_UTF8)) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+20289, 0))
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+48, *(*sqlite_int64)(unsafe.Pointer(bp + 88)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 + 1*8)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 + 2*8))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_mprintf_long(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var i int32

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20268, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
		*(*int32)(unsafe.Pointer(bp + 84 + uintptr(i-2)*4)) = *(*int32)(unsafe.Pointer(bp + 72 + uintptr(i-2)*4))
		*(*int32)(unsafe.Pointer(bp + 84 + uintptr(i-2)*4)) &= libc.Int32FromUint64(uint64(1)<<(uint32(unsafe.Sizeof(int32(0)))*uint32(8)) - uint64(1))
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 84)), *(*int32)(unsafe.Pointer(bp + 84 + 1*4)), *(*int32)(unsafe.Pointer(bp + 84 + 2*4))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_mprintf_str(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	var z uintptr
	if argc < 4 || argc > 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20328, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72)), *(*int32)(unsafe.Pointer(bp + 72 + 1*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + 4*4))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_snprintf_str(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var i int32

	var z uintptr
	if argc < 5 || argc > 6 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20354, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+88) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 88)) < 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+20384, 0))
		return TCL_ERROR
	}
	for i = 3; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), bp+92+uintptr(i-3)*4) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 88))+1)
	sqlite3.Xsqlite3_snprintf(tls, *(*int32)(unsafe.Pointer(bp + 88)), z, *(*uintptr)(unsafe.Pointer(argv + 2*4)), libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 92)), *(*int32)(unsafe.Pointer(bp + 92 + 1*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + 5*4))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_mprintf_double(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var i int32

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20407, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*4)), bp+84) != 0 {
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72)), *(*int32)(unsafe.Pointer(bp + 72 + 1*4)), *(*float64)(unsafe.Pointer(bp + 84))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_mprintf_scaled(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var i int32

	var z uintptr
	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20431, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)), bp+56+uintptr(i-2)*8) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*float64)(unsafe.Pointer(bp + 56))**(*float64)(unsafe.Pointer(bp + 56 + 1*8))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_mprintf_stronly(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20454, 0))
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func sqlite3_mprintf_hexdouble(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var z uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20454, 0))
		return TCL_ERROR
	}
	if libc.Xsscanf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)), ts+20470, libc.VaList(bp+32, bp+88, bp+92)) != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+20479, 0))
		return TCL_ERROR
	}
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104)) = sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 88)))
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104)) = *(*sqlite_uint64)(unsafe.Pointer(bp + 104))<<32 + sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 92)))
	libc.Xmemcpy(tls, bp+96, bp+104, uint32(unsafe.Sizeof(float64(0))))
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.VaList(bp+64, *(*float64)(unsafe.Pointer(bp + 96))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func test_enable_shared(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	var ret int32 = 0

	if objc != 2 && objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20523)
		return TCL_ERROR
	}
	ret = sqlite3.Xsqlite3Config.FsharedCacheEnabled

	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
			return TCL_ERROR
		}
		rc = sqlite3.Xsqlite3_enable_shared_cache(tls, *(*int32)(unsafe.Pointer(bp)))
		if rc != SQLITE_OK {
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
			return TCL_ERROR
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(ret != 0)))
	return TCL_OK
}

func test_extended_result_codes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20533)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_extended_result_codes(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))
	return TCL_OK
}

func test_libversion_number(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_libversion_number(tls)))
	return TCL_OK
}

func test_table_column_metadata(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zDb uintptr
	var zTbl uintptr
	var zCol uintptr
	var rc int32
	var pRet uintptr

	if objc != 5 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20544)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zTbl = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if objc == 5 {
		zCol = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	} else {
		zCol = uintptr(0)
	}

	if libc.Xstrlen(tls, zDb) == size_t(0) {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_table_column_metadata(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), zDb, zTbl, zCol,
		bp+20, bp+24, bp+28, bp+32, bp+36)

	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16))), 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 28))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 32))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 36))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

func blobHandleFromObj(tls *libc.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp)
	if *(*int32)(unsafe.Pointer(bp)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else {
		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4)
		if !(channel != 0) {
			return TCL_ERROR
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), SEEK_SET)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	}

	return TCL_OK
}

func test_blob_reopen(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20570)
		return TCL_ERROR
	}

	if blobHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_blob_reopen(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 4)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

type TestCollationX1 = struct {
	Finterp uintptr
	FpCmp   uintptr
	FpDel   uintptr
}

type TestCollationX = TestCollationX1

func testCreateCollationDel(tls *libc.TLS, pCtx uintptr) {
	var p uintptr = pCtx

	var rc int32 = tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, (*TestCollationX)(unsafe.Pointer(p)).FpDel, TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpCmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpDel
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func testCreateCollationCmp(tls *libc.TLS, pCtx uintptr, nLeft int32, zLeft uintptr, nRight int32, zRight uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*TestCollationX)(unsafe.Pointer(p)).FpCmp)
	*(*int32)(unsafe.Pointer(bp)) = 0

	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zLeft, nLeft))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zRight, nRight))

	if TCL_OK != tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, pScript, TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp), bp) {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func test_create_collation_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr

	var rc int32

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20584)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0 {
		return TCL_ERROR
	}

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TestCollationX{})))
	(*TestCollationX)(unsafe.Pointer(p)).FpCmp = *(*uintptr)(unsafe.Pointer(objv + 3*4))
	(*TestCollationX)(unsafe.Pointer(p)).FpDel = *(*uintptr)(unsafe.Pointer(objv + 4*4))
	(*TestCollationX)(unsafe.Pointer(p)).Finterp = interp
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpCmp)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpDel)).FrefCount++

	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 16,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testCreateCollationDel})))
	if rc != SQLITE_MISUSE {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp, ts+20617, uintptr(0)))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), SQLITE_UTF8,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testCreateCollationDel})))
	return TCL_OK
}

type CreateFunctionV21 = struct {
	Finterp   uintptr
	FpFunc    uintptr
	FpStep    uintptr
	FpFinal   uintptr
	FpDestroy uintptr
}

type CreateFunctionV2 = CreateFunctionV21

func cf2Func(tls *libc.TLS, ctx uintptr, nArg int32, aArg uintptr) {
}

func cf2Step(tls *libc.TLS, ctx uintptr, nArg int32, aArg uintptr) {
}

func cf2Final(tls *libc.TLS, ctx uintptr) {
}

func cf2Destroy(tls *libc.TLS, pUser uintptr) {
	var p uintptr = pUser

	if (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp != 0 && (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		var rc int32 = tcl.XTcl_EvalObjEx(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy, 0)
		if rc != TCL_OK {
			tcl.XTcl_BackgroundError(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		for __ccgo3 := true; __ccgo3; __ccgo3 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func test_create_function_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var zFunc uintptr

	var p uintptr
	var i int32
	var rc int32

	*(*[7]EncTable)(unsafe.Pointer(bp + 24)) = [7]EncTable{
		{FzEnc: ts + 20682, Fenc: SQLITE_UTF8},
		{FzEnc: ts + 20687, Fenc: SQLITE_UTF16},
		{FzEnc: ts + 20693, Fenc: SQLITE_UTF16LE},
		{FzEnc: ts + 20701, Fenc: SQLITE_UTF16BE},
		{FzEnc: ts + 17735, Fenc: SQLITE_ANY},
		{FzEnc: ts + 19147},
		{},
	}

	if objc < 5 || objc%2 == 0 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20709)
		return TCL_ERROR
	}

	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0 {
		return TCL_ERROR
	}
	zFunc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+24, int32(unsafe.Sizeof(EncTable{})),
		ts+11199, 0, bp+80) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 80)) = (*EncTable)(unsafe.Pointer(bp + 24 + uintptr(*(*int32)(unsafe.Pointer(bp + 80)))*8)).Fenc

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CreateFunctionV2{})))

	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(CreateFunctionV2{})))
	(*CreateFunctionV2)(unsafe.Pointer(p)).Finterp = interp

	for i = 5; i < objc; i = i + 2 {
		*(*[5]uintptr)(unsafe.Pointer(bp + 84)) = [5]uintptr{ts + 20738, ts + 20744, ts + 20750, ts + 20757, uintptr(0)}
		if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+84, int32(unsafe.Sizeof(uintptr(0))), ts+20766, 0, bp+104) != 0 {
			sqlite3.Xsqlite3_free(tls, p)
			return TCL_ERROR
		}

		switch *(*int32)(unsafe.Pointer(bp + 104)) {
		case 0:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4))
			break
		case 1:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4))
			break
		case 2:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4))
			break
		case 3:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4))
			break
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)).FrefCount++
	}

	rc = sqlite3.Xsqlite3_create_function_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), zFunc, *(*int32)(unsafe.Pointer(bp + 20)), *(*int32)(unsafe.Pointer(bp + 80)), p,
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{cf2Func}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{cf2Step}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cf2Final}))
			}
			return uintptr(0)
		}(),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cf2Destroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

type EncTable = struct {
	FzEnc uintptr
	Fenc  int32
}

func test_load_extension(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var db uintptr
	_ = db
	var rc int32
	var zDb uintptr
	var zFile uintptr
	_ = zFile
	var zProc uintptr = uintptr(0)
	_ = zProc
	var zErr uintptr = uintptr(0)

	if objc != 4 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20773)
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if objc == 4 {
		zProc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	}

	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+24) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19813, zDb, uintptr(0)))
		return TCL_ERROR
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24)).FobjClientData)).Fdb

	rc = SQLITE_ERROR
	zErr = sqlite3.Xsqlite3_mprintf(tls, ts+20795, 0)
	_ = zProc
	_ = zFile
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, func() uintptr {
			if zErr != 0 {
				return zErr
			}
			return ts + 584
		}(), uintptr(1))
		rc = TCL_ERROR
	} else {
		rc = TCL_OK
	}
	sqlite3.Xsqlite3_free(tls, zErr)

	return rc
}

func test_enable_load(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var db uintptr
	_ = db
	var zDb uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20837)
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))

	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+32) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19813, zDb, uintptr(0)))
		return TCL_ERROR
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 32)).FobjClientData)).Fdb

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+64) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+20795))
	return TCL_ERROR
}

func sqlite_abort(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	libc.Xexit(tls, 255)

	return TCL_OK
}

func testFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var zArg0 uintptr
__1:
	if !(argc >= 2) {
		goto __2
	}
	zArg0 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if !(zArg0 != 0) {
		goto __3
	}
	if !(0 == sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+2577)) {
		goto __5
	}
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	goto __6
__5:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+4317) == 0) {
		goto __7
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	goto __8
__7:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+20853) == 0) {
		goto __9
	}
	sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))), -1,
		libc.UintptrFromInt32(-1))
	goto __10
__9:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+2562) == 0) {
		goto __11
	}
	sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	goto __12
__11:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+8294) == 0) {
		goto __13
	}
	sqlite3.Xsqlite3_result_null(tls, context)
	goto __14
__13:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+14915) == 0) {
		goto __15
	}
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv + uintptr(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))*4)))
	goto __16
__15:
	goto error_out
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;
__6:
	;
	goto __4
__3:
	goto error_out
__4:
	;
	argc = argc - 2
	argv += 4 * uintptr(2)
	goto __1
__2:
	;
	return

error_out:
	sqlite3.Xsqlite3_result_error(tls, context,
		ts+20860, -1)
}

func test_register_func(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20928, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testFunc})), uintptr(0), uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_finalize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32
	var db uintptr = uintptr(0)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+20946, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 32)) != 0 {
		db = sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if db != 0 && sqlite3TestErrCode(tls, interp, db, rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_stmt_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var iValue int32
	var i int32
	*(*int32)(unsafe.Pointer(bp + 4)) = 0

	var zOpName uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20954)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	for i = 0; i < int32(uint32(unsafe.Sizeof(aOp))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{}))); i++ {
		if libc.Xstrcmp(tls, aOp[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 4)) = aOp[i].Fop
			break
		}
	}
	if i >= int32(uint32(unsafe.Sizeof(aOp))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{}))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	iValue = sqlite3.Xsqlite3_stmt_status(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)), *(*int32)(unsafe.Pointer(bp + 8)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iValue))
	return TCL_OK
}

var aOp = [7]struct {
	FzName uintptr
	Fop    int32
}{
	{FzName: ts + 20979, Fop: SQLITE_STMTSTATUS_FULLSCAN_STEP},
	{FzName: ts + 21011, Fop: SQLITE_STMTSTATUS_SORT},
	{FzName: ts + 21034, Fop: SQLITE_STMTSTATUS_AUTOINDEX},
	{FzName: ts + 21062, Fop: SQLITE_STMTSTATUS_VM_STEP},
	{FzName: ts + 21088, Fop: SQLITE_STMTSTATUS_REPREPARE},
	{FzName: ts + 21116, Fop: SQLITE_STMTSTATUS_RUN},
	{FzName: ts + 21138, Fop: SQLITE_STMTSTATUS_MEMUSED},
}

func test_config_sorterref(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21164)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_SORTERREF_SIZE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8))))
	return TCL_OK
}

func vfsCurrentTimeInt64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTimeInt64})).f(tls, pVfs, bp)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*i64)(unsafe.Pointer(bp))))
	return TCL_OK
}

func test_delete_database(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32
	var zFile uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21170)
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	rc = sqlite3_delete_database(tls, zFile)

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

func test_atomic_batch_write(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zFile uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
	var bRes int32 = 0
	var dc int32 = 0
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21175)
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))

	rc = sqlite3.Xsqlite3_open(tls, zFile, bp+16)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16))), 0))
		sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+85, SQLITE_FCNTL_FILE_POINTER, bp+20)
	dc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20)))).FpMethods)).FxDeviceCharacteristics})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))
	if dc&SQLITE_IOCAP_BATCH_ATOMIC != 0 {
		bRes = 1
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, bRes))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	return TCL_OK
}

func test_next_stmt(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(106)
	defer tls.Free(106)

	*(*uintptr)(unsafe.Pointer(bp + 48)) = uintptr(0)

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21180, 0))
		return TCL_ERROR
	}

	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+52) != 0 {
		return TCL_ERROR
	}
	*(*uintptr)(unsafe.Pointer(bp + 52)) = sqlite3.Xsqlite3_next_stmt(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), *(*uintptr)(unsafe.Pointer(bp + 52)))
	if *(*uintptr)(unsafe.Pointer(bp + 52)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+56, *(*uintptr)(unsafe.Pointer(bp + 52))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+56, 0))
	}
	return TCL_OK
}

func test_stmt_readonly(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21189, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(rc != 0)))
	return TCL_OK
}

func test_stmt_isexplain(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21189, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_isexplain(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_stmt_busy(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21189, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_busy(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(rc != 0)))
	return TCL_OK
}

func uses_stmt_journal(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21189, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 144))&0x20>>5) != 0)))
	return TCL_OK
}

func test_reset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+20946, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	if *(*uintptr)(unsafe.Pointer(bp + 32)) != 0 && sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

func test_expired(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+20946, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(sqlite3.Xsqlite3_expired(tls, *(*uintptr)(unsafe.Pointer(bp + 32))) != 0)))
	return TCL_OK
}

func test_transfer_bind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21195, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+36) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_transfer_bindings(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*uintptr)(unsafe.Pointer(bp + 36)))))
	return TCL_OK
}

func test_changes(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_changes(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))))
	return TCL_OK
}

var sqlite_static_bind_value uintptr = uintptr(0)
var sqlite_static_bind_nbyte int32 = 0

func test_bind(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(138)
	defer tls.Free(138)

	var rc int32

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+21214, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+80) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+84) != 0 {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+8294) == 0 {
		rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), *(*int32)(unsafe.Pointer(bp + 84)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+21250) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), *(*int32)(unsafe.Pointer(bp + 84)), sqlite_static_bind_value, -1, uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+21257) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), *(*int32)(unsafe.Pointer(bp + 84)), sqlite_static_bind_value,
			sqlite_static_bind_nbyte, uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+21271) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), *(*int32)(unsafe.Pointer(bp + 84)), *(*uintptr)(unsafe.Pointer(argv + 3*4)), -1, libc.UintptrFromInt32(-1))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)), ts+21278) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), *(*int32)(unsafe.Pointer(bp + 84)), ts+21285, 10, uintptr(0))
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp+32, ts+21296, 0))
		return TCL_ERROR
	}
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 80))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+88, ts+21350, libc.VaList(bp+48, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+88, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

var pTestCollateInterp uintptr

func test_collate_func(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i uintptr = pTestCollateInterp
	var encin int32 = int32(pCtx)

	var n int32
	var pVal uintptr
	var pX uintptr

	pX = tcl.XTcl_NewStringObj(tls, ts+21356, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++

	switch encin {
	case SQLITE_UTF8:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+21369, -1))
		break
	case SQLITE_UTF16LE:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+21375, -1))
		break
	case SQLITE_UTF16BE:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+21384, -1))
		break
	default:
	}

	sqlite3.Xsqlite3BeginBenignMalloc(tls)
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	if pVal != 0 {
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, nA, zA, uint8(encin), uintptr(0))
		n = sqlite3.Xsqlite3_value_bytes(tls, pVal)
		tcl.XTcl_ListObjAppendElement(tls, i, pX,
			tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pVal), n))
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, nB, zB, uint8(encin), uintptr(0))
		n = sqlite3.Xsqlite3_value_bytes(tls, pVal)
		tcl.XTcl_ListObjAppendElement(tls, i, pX,
			tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pVal), n))
		sqlite3.Xsqlite3ValueFree(tls, pVal)
	}
	sqlite3.Xsqlite3EndBenignMalloc(tls)

	tcl.XTcl_EvalObjEx(tls, i, pX, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_GetIntFromObj(tls, i, tcl.XTcl_GetObjResult(tls, i), bp)
	return *(*int32)(unsafe.Pointer(bp))
}

func test_collate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var pVal uintptr
	var rc int32
	var zUtf16 uintptr

	if !(objc != 5) {
		goto __1
	}
	goto bad_args
__1:
	;
	pTestCollateInterp = interp
	if !(getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52)) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), ts+21356, SQLITE_UTF8,
		uintptr(SQLITE_UTF8), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 52)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
	if !(rc == SQLITE_OK) {
		goto __4
	}
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+52)) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), ts+21356, SQLITE_UTF16LE,
		uintptr(SQLITE_UTF16LE), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 52)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+52)) {
		goto __6
	}
	return TCL_ERROR
__6:
	;
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48)))).Fmutex)
	pVal = sqlite3.Xsqlite3ValueNew(tls, *(*uintptr)(unsafe.Pointer(bp + 48)))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, ts+21356, uint8(SQLITE_UTF8), uintptr(0))
	zUtf16 = sqlite3.Xsqlite3ValueText(tls, pVal, uint8(SQLITE_UTF16LE))
	if !((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48)))).FmallocFailed != 0) {
		goto __7
	}
	rc = SQLITE_NOMEM
	goto __8
__7:
	rc = sqlite3.Xsqlite3_create_collation16(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), zUtf16, SQLITE_UTF16BE,
		uintptr(SQLITE_UTF16BE), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 52)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
__8:
	;
	sqlite3.Xsqlite3ValueFree(tls, pVal)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48)))).Fmutex)
__4:
	;
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0) {
		goto __9
	}
	return TCL_ERROR
__9:
	;
	if !(rc != SQLITE_OK) {
		goto __10
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_ERROR
__10:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+19903,
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21393, 0))
	return TCL_ERROR
}

func test_utf16bin_collate_func(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 {
	var nCmp int32 = func() int32 {
		if nA > nB {
			return nB
		}
		return nA
	}()
	var res int32 = libc.Xmemcmp(tls, zA, zB, uint32(nCmp))
	if res == 0 {
		res = nA - nB
	}
	return res
}

func test_utf16bin_collate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+21426, SQLITE_UTF16, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{test_utf16bin_collate_func})))
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp)), rc) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
	return TCL_ERROR
}

var zNeededCollation [200]int8
var pzNeededCollation uintptr = 0

func test_collate_needed_cb(tls *libc.TLS, pCtx uintptr, db uintptr, eTextRep int32, pName uintptr) {
	var enc int32 = int32((*sqlite31)(unsafe.Pointer(db)).Fenc)
	var i int32
	var z uintptr
	z = pName
	i = 0
	for ; *(*int8)(unsafe.Pointer(z)) != 0 || *(*int8)(unsafe.Pointer(z + 1)) != 0; z++ {
		if *(*int8)(unsafe.Pointer(z)) != 0 {
			zNeededCollation[libc.PostIncInt32(&i, 1)] = *(*int8)(unsafe.Pointer(z))
		}
	}
	zNeededCollation[i] = int8(0)
	sqlite3.Xsqlite3_create_collation(tls,
		db, ts+21356, int32((*sqlite31)(unsafe.Pointer(db)).Fenc), uintptr(enc), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{test_collate_func})))
}

func test_collate_needed(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	rc = sqlite3.Xsqlite3_collation_needed16(tls, *(*uintptr)(unsafe.Pointer(bp)), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr)
	}{test_collate_needed_cb})))
	zNeededCollation[0] = int8(0)
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp)), rc) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
	return TCL_ERROR
}

var unaligned_string_counter int32 = 0

func alignmentCollFunc(tls *libc.TLS, NotUsed uintptr, nKey1 int32, pKey1 uintptr, nKey2 int32, pKey2 uintptr) int32 {
	var rc int32
	var n int32
	if nKey1 < nKey2 {
		n = nKey1
	} else {
		n = nKey2
	}
	if nKey1 > 0 && 1 == 1&int32(pKey1) {
		unaligned_string_counter++
	}
	if nKey2 > 0 && 1 == 1&int32(pKey2) {
		unaligned_string_counter++
	}
	rc = libc.Xmemcmp(tls, pKey1, pKey2, uint32(n))
	if rc == 0 {
		rc = nKey1 - nKey2
	}
	return rc
}

func add_alignment_test_collations(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc >= 2 {
		if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+21435, SQLITE_UTF16,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{alignmentCollFunc})))
		sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+21451, SQLITE_UTF16_ALIGNED,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{alignmentCollFunc})))
	}
	return SQLITE_OK
}

func test_function_utf8(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+21465, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+21369, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_result_text(tls, pCtx, tcl.XTcl_GetStringResult(tls, interp), -1, libc.UintptrFromInt32(-1))
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text16be(tls, pCtx, sqlite3.Xsqlite3_value_text16be(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function_utf16le(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+21465, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+21375, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text(tls, pCtx, sqlite3.Xsqlite3_value_text(tls, pVal), -1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function_utf16be(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+21465, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+21384, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text16(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_result_text16be(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_result_text16le(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if !(objc != 5) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36)) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 36)) != 0) {
		goto __4
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+21465, 1, SQLITE_UTF8,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf8})), uintptr(0), uintptr(0))
__4:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+36)) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 36)) != 0) {
		goto __6
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+21465, 1, SQLITE_UTF16LE,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf16le})), uintptr(0), uintptr(0))
__6:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+36)) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 36)) != 0) {
		goto __8
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+21465, 1, SQLITE_UTF16BE,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf16be})), uintptr(0), uintptr(0))
__8:
	;
	return TCL_OK
bad_args:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21393, 0))
	return TCL_ERROR
}

func test_errstr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var zCode uintptr
	var i int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21479)
	}

	zCode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	for i = 0; i < 200; i++ {
		if 0 == libc.Xstrcmp(tls, sqlite3.Xsqlite3ErrName(tls, i), zCode) {
			break
		}
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, i), uintptr(0))
	return TCL_OK
}

func test_breakpoint(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	return TCL_OK
}

func test_bind_zeroblob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21492)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)), *(*int32)(unsafe.Pointer(bp + 8)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

func test_bind_zeroblob64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21492)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+24) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob64(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20)), uint64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 24))))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 16))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func test_bind_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21503, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+40) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)), *(*int32)(unsafe.Pointer(bp + 40)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

func test_intarray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var i int32

	sqlite3.Xsqlite3_free(tls, p)
	p = uintptr(0)
	if objc > 1 {
		p = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(int32(0)))*uint32(objc-1)))
		if p == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*4)), p+uintptr(i)*4) != 0 {
				sqlite3.Xsqlite3_free(tls, p)
				p = uintptr(0)
				return TCL_ERROR
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p)))
	return TCL_OK
}

var p uintptr = uintptr(0)

func test_int64array_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	sqlite3.Xsqlite3_free(tls, p1)
	p1 = uintptr(0)
	if objc > 1 {
		p1 = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(sqlite3_int64(0)))*uint32(objc-1)))
		if p1 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*4)), bp) != 0 {
				sqlite3.Xsqlite3_free(tls, p1)
				p1 = uintptr(0)
				return TCL_ERROR
			}
			*(*sqlite3_int64)(unsafe.Pointer(p1 + uintptr(i)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp))
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p1)))
	return TCL_OK
}

var p1 uintptr = uintptr(0)

func test_doublearray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var i int32

	sqlite3.Xsqlite3_free(tls, p2)
	p2 = uintptr(0)
	if objc > 1 {
		p2 = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(float64(0)))*uint32(objc-1)))
		if p2 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			if tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*4)), p2+uintptr(i)*8) != 0 {
				sqlite3.Xsqlite3_free(tls, p2)
				p2 = uintptr(0)
				return TCL_ERROR
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p2)))
	return TCL_OK
}

var p2 uintptr = uintptr(0)

func test_textarray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	for i = 0; i < n; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*4)))
	}
	sqlite3.Xsqlite3_free(tls, p3)
	p3 = uintptr(0)
	if objc > 1 {
		p3 = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(uintptr(0)))*uint32(objc-1)))
		if p3 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			*(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*4)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*4)))))
		}
	}
	n = objc - 1
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p3)))
	return TCL_OK
}

var n int32 = 0
var p3 uintptr = uintptr(0)

func test_bind_int64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21503, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+40) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 40)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

func test_bind_double(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	*(*float64)(unsafe.Pointer(bp + 40)) = float64(0)
	var rc int32
	var zVal uintptr
	var i int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21503, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	zVal = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aSpecialFp))/uint32(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{})); i++ {
		if libc.Xstrcmp(tls, aSpecialFp[i].FzName, zVal) == 0 {
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 48)) = sqlite3_uint64(aSpecialFp[i].FiUpper)
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 48)) <<= 32
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 48)) |= sqlite3_uint64(aSpecialFp[i].FiLower)

			libc.Xmemcpy(tls, bp+40, bp+48, uint32(8))
			break
		}
	}
	if uint32(i) >= uint32(unsafe.Sizeof(aSpecialFp))/uint32(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{})) && tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+40) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)), *(*float64)(unsafe.Pointer(bp + 40)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

var aSpecialFp = [10]struct {
	FzName  uintptr
	FiUpper uint32
	FiLower uint32
}{
	{FzName: ts + 21517, FiUpper: uint32(0x7fffffff), FiLower: 0xffffffff},
	{FzName: ts + 21521, FiUpper: uint32(0x7ff7ffff), FiLower: 0xffffffff},
	{FzName: ts + 21526, FiUpper: 0xffffffff, FiLower: 0xffffffff},
	{FzName: ts + 21531, FiUpper: 0xfff7ffff, FiLower: 0xffffffff},
	{FzName: ts + 21537, FiUpper: uint32(0x7ff00000)},
	{FzName: ts + 21542, FiUpper: 0xfff00000},
	{FzName: ts + 21547, FiLower: uint32(0x00000001)},
	{FzName: ts + 21555, FiUpper: 0x80000000, FiLower: uint32(0x00000001)},
	{FzName: ts + 21564, FiUpper: uint32(0x7ff80000)},
	{FzName: ts + 21569, FiUpper: 0xfff80000},
}

func test_bind_null(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21575, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

func test_bind_text(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	*(*int32)(unsafe.Pointer(bp + 72)) = 0

	var value uintptr
	var rc int32
	var toFree uintptr = uintptr(0)

	if objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21583, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68) != 0 {
		return TCL_ERROR
	}
	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+76) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 76)) < 0 {
		toFree = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 72))+1))
		if toFree == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+2069, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xmemcpy(tls, toFree, value, uint32(*(*int32)(unsafe.Pointer(bp + 72))))
		*(*int8)(unsafe.Pointer(toFree + uintptr(*(*int32)(unsafe.Pointer(bp + 72))))) = int8(0)
		value = toFree
	}
	rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), *(*int32)(unsafe.Pointer(bp + 68)), value, *(*int32)(unsafe.Pointer(bp + 76)), libc.UintptrFromInt32(-1))
	libc.Xfree(tls, toFree)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}

	return TCL_OK
}

func test_bind_text16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var value uintptr
	var toFree uintptr = uintptr(0)
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 72)) = 0

	var xDel uintptr = func() uintptr {
		if objc == 6 {
			return uintptr(0)
		}
		return libc.UintptrFromInt32(-1)
	}()
	var oStmt uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-4)*4))
	var oN uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*4))
	var oString uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*4))
	var oBytes uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4))

	if objc != 5 && objc != 6 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21583, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, oStmt), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, oN, bp+68) != 0 {
		return TCL_ERROR
	}
	value = tcl.XTcl_GetByteArrayFromObj(tls, oString, bp+72)
	if tcl.XTcl_GetIntFromObj(tls, interp, oBytes, bp+76) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 76)) < 0 && xDel == libc.UintptrFromInt32(-1) {
		toFree = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 72))+3))
		if toFree == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+2069, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xmemcpy(tls, toFree, value, uint32(*(*int32)(unsafe.Pointer(bp + 72))))
		libc.Xmemset(tls, toFree+uintptr(*(*int32)(unsafe.Pointer(bp + 72))), 0, uint32(3))
		value = toFree
	}
	rc = sqlite3.Xsqlite3_bind_text16(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), *(*int32)(unsafe.Pointer(bp + 68)), value, *(*int32)(unsafe.Pointer(bp + 76)), xDel)
	libc.Xfree(tls, toFree)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func test_bind_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(280)
	defer tls.Free(280)

	var value uintptr
	var rc int32
	var xDestructor sqlite3_destructor_type = libc.UintptrFromInt32(-1)

	if objc != 5 && objc != 6 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+21603, 0))
		return TCL_ERROR
	}

	if objc == 6 {
		xDestructor = uintptr(0)
		objv += 4
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68) != 0 {
		return TCL_ERROR
	}

	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+76) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 76)) > *(*int32)(unsafe.Pointer(bp + 72)) {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+80,
			ts+21622, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 76)), *(*int32)(unsafe.Pointer(bp + 72))))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+80, uintptr(0)))
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), *(*int32)(unsafe.Pointer(bp + 68)), value, *(*int32)(unsafe.Pointer(bp + 76)), xDestructor)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

func test_bind_value_from_preupdate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var z3 uintptr = uintptr(0)
	var db uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 36)) = uintptr(0)

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21656)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+24) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+28) != 0 {
		return TCL_ERROR
	}
	z3 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	db = sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))

	if int32(*(*int8)(unsafe.Pointer(z3))) == 'n' {
		sqlite3.Xsqlite3_preupdate_new(tls, db, *(*int32)(unsafe.Pointer(bp + 32)), bp+36)
	} else if int32(*(*int8)(unsafe.Pointer(z3))) == 'o' {
		sqlite3.Xsqlite3_preupdate_old(tls, db, *(*int32)(unsafe.Pointer(bp + 32)), bp+36)
	} else {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+21675, z3, uintptr(0)))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), *(*int32)(unsafe.Pointer(bp + 28)), *(*uintptr)(unsafe.Pointer(bp + 36)))

	return TCL_OK
}

func test_bind_value_from_select(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var zSql uintptr = uintptr(0)
	var db uintptr = uintptr(0)
	var rc int32 = SQLITE_OK

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21702)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	db = sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 48)))

	rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56, uintptr(0))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+21716, sqlite3.Xsqlite3_errmsg(tls, db), uintptr(0)))
		return TCL_ERROR
	}
	if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) == SQLITE_ROW {
		var pVal uintptr = sqlite3.Xsqlite3_column_value(tls, *(*uintptr)(unsafe.Pointer(bp + 56)), 0)
		sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), *(*int32)(unsafe.Pointer(bp + 52)), pVal)
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp+24, ts+21731, sqlite3.Xsqlite3_errmsg(tls, db), uintptr(0)))
		return TCL_ERROR
	}

	return TCL_OK
}

func test_carray_bind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var eType int32
	var nData int32
	var aData uintptr
	var isTransient int32
	var isStatic int32

	var i int32
	var j int32
	var rc int32
	var xDel uintptr
	var z uintptr

	var a uintptr

	var a1 uintptr

	var a2 uintptr
	var v3 uintptr
	var a3 uintptr

	var v4 uintptr
	var a4 uintptr
	eType = 0
	nData = 0
	aData = uintptr(0)
	isTransient = 0
	isStatic = 0
	xDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))

	if !(aStaticData != 0) {
		goto __1
	}

	if !(eStaticType == 3) {
		goto __2
	}
	i = 0
__3:
	if !(i < nStaticData) {
		goto __5
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(aStaticData + uintptr(i)*4)))
	goto __4
__4:
	i++
	goto __3
	goto __5
__5:
	;
__2:
	;
	if !(eStaticType == 4) {
		goto __6
	}
	i = 0
__7:
	if !(i < nStaticData) {
		goto __9
	}
	sqlite3.Xsqlite3_free(tls, (*iovec)(unsafe.Pointer(aStaticData+uintptr(i)*8)).Fiov_base)
	goto __8
__8:
	i++
	goto __7
	goto __9
__9:
	;
__6:
	;
	sqlite3.Xsqlite3_free(tls, aStaticData)
	aStaticData = uintptr(0)
	nStaticData = 0
	eStaticType = 0
__1:
	;
	if !(objc == 1) {
		goto __10
	}
	return TCL_OK
__10:
	;
	i = 1
__11:
	if !(i < objc && int32(*(*int8)(unsafe.Pointer(tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))))) == '-') {
		goto __13
	}
	z = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
	if !(libc.Xstrcmp(tls, z, ts+21752) == 0) {
		goto __14
	}
	isTransient = 1
	xDel = libc.UintptrFromInt32(-1)
	goto __15
__14:
	if !(libc.Xstrcmp(tls, z, ts+21763) == 0) {
		goto __16
	}
	isStatic = 1
	xDel = uintptr(0)
	goto __17
__16:
	if !(libc.Xstrcmp(tls, z, ts+21771) == 0) {
		goto __18
	}
	eType = 0
	goto __19
__18:
	if !(libc.Xstrcmp(tls, z, ts+21778) == 0) {
		goto __20
	}
	eType = 1
	goto __21
__20:
	if !(libc.Xstrcmp(tls, z, ts+21785) == 0) {
		goto __22
	}
	eType = 2
	goto __23
__22:
	if !(libc.Xstrcmp(tls, z, ts+21793) == 0) {
		goto __24
	}
	eType = 3
	goto __25
__24:
	if !(libc.Xstrcmp(tls, z, ts+21799) == 0) {
		goto __26
	}
	eType = 4
	goto __27
__26:
	if !(libc.Xstrcmp(tls, z, ts+21805) == 0) {
		goto __28
	}
	goto __13
	goto __29
__28:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+17405, z, uintptr(0)))
	return TCL_ERROR
__29:
	;
__27:
	;
__25:
	;
__23:
	;
__21:
	;
__19:
	;
__17:
	;
__15:
	;
	goto __12
__12:
	i++
	goto __11
	goto __13
__13:
	;
	if !(eType == 3 && !(isStatic != 0) && !(isTransient != 0)) {
		goto __30
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+21808,
		uintptr(0)))
	return TCL_ERROR
__30:
	;
	if !(eType == 4 && !(isStatic != 0) && !(isTransient != 0)) {
		goto __31
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+21855,
		uintptr(0)))
	return TCL_ERROR
__31:
	;
	if !(isStatic != 0 && isTransient != 0) {
		goto __32
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, ts+21902,
		uintptr(0)))
	return TCL_ERROR
__32:
	;
	if !(objc-i < 2) {
		goto __33
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21940)
	return TCL_ERROR
__33:
	;
	if !(getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4))), bp+96) != 0) {
		goto __34
	}
	return TCL_ERROR
__34:
	;
	i++
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+100) != 0) {
		goto __35
	}
	return TCL_ERROR
__35:
	;
	i++
	nData = objc - i
	switch eType + 5*libc.Bool32(nData <= 0) {
	case 0:
		goto __37
	case 1:
		goto __38
	case 2:
		goto __39
	case 3:
		goto __40
	case 4:
		goto __41
	case 5:
		goto __42
	}
	goto __36
__37:
	a = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(int32(0)))*uint32(nData)))
	if !(a == uintptr(0)) {
		goto __43
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__43:
	;
	j = 0
__44:
	if !(j < nData) {
		goto __46
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*4)), bp+104) != 0) {
		goto __47
	}
	sqlite3.Xsqlite3_free(tls, a)
	return TCL_ERROR
__47:
	;
	*(*int32)(unsafe.Pointer(a + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(bp + 104))
	goto __45
__45:
	j++
	goto __44
	goto __46
__46:
	;
	aData = a
	goto __36

__38:
	a1 = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(sqlite3_int64(0)))*uint32(nData)))
	if !(a1 == uintptr(0)) {
		goto __48
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__48:
	;
	j = 0
__49:
	if !(j < nData) {
		goto __51
	}
	if !(tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*4)), bp+108) != 0) {
		goto __52
	}
	sqlite3.Xsqlite3_free(tls, a1)
	return TCL_ERROR
__52:
	;
	*(*sqlite3_int64)(unsafe.Pointer(a1 + uintptr(j)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 108))
	goto __50
__50:
	j++
	goto __49
	goto __51
__51:
	;
	aData = a1
	goto __36

__39:
	a2 = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(float64(0)))*uint32(nData)))
	if !(a2 == uintptr(0)) {
		goto __53
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__53:
	;
	j = 0
__54:
	if !(j < nData) {
		goto __56
	}
	if !(tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*4)), bp+116) != 0) {
		goto __57
	}
	sqlite3.Xsqlite3_free(tls, a2)
	return TCL_ERROR
__57:
	;
	*(*float64)(unsafe.Pointer(a2 + uintptr(j)*8)) = *(*float64)(unsafe.Pointer(bp + 116))
	goto __55
__55:
	j++
	goto __54
	goto __56
__56:
	;
	aData = a2
	goto __36

__40:
	a3 = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(uintptr(0)))*uint32(nData)))
	if !(a3 == uintptr(0)) {
		goto __58
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__58:
	;
	j = 0
__59:
	if !(j < nData) {
		goto __61
	}
	v3 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*4)))
	*(*uintptr)(unsafe.Pointer(a3 + uintptr(j)*4)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+72, v3))
	goto __60
__60:
	j++
	goto __59
	goto __61
__61:
	;
	aData = a3
	goto __36

__41:
	a4 = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(iovec{}))*uint32(nData)))
	if !(a4 == uintptr(0)) {
		goto __62
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__62:
	;
	j = 0
__63:
	if !(j < nData) {
		goto __65
	}
	*(*int32)(unsafe.Pointer(bp + 124)) = 0
	v4 = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+i)*4)), bp+124)
	(*iovec)(unsafe.Pointer(a4 + uintptr(j)*8)).Fiov_len = size_t(*(*int32)(unsafe.Pointer(bp + 124)))
	(*iovec)(unsafe.Pointer(a4 + uintptr(j)*8)).Fiov_base = sqlite3.Xsqlite3_malloc64(tls, uint64(*(*int32)(unsafe.Pointer(bp + 124))))
	if !((*iovec)(unsafe.Pointer(a4+uintptr(j)*8)).Fiov_base == uintptr(0)) {
		goto __66
	}
	(*iovec)(unsafe.Pointer(a4 + uintptr(j)*8)).Fiov_len = size_t(0)
	goto __67
__66:
	libc.Xmemcpy(tls, (*iovec)(unsafe.Pointer(a4+uintptr(j)*8)).Fiov_base, v4, uint32(*(*int32)(unsafe.Pointer(bp + 124))))
__67:
	;
	goto __64
__64:
	j++
	goto __63
	goto __65
__65:
	;
	aData = a4
	goto __36

__42:
	aData = ts + 584
	xDel = uintptr(0)
	isTransient = 0
	isStatic = 0
	goto __36

__36:
	;
	if !(isStatic != 0) {
		goto __68
	}
	aStaticData = aData
	nStaticData = nData
	eStaticType = eType
__68:
	;
	rc = sqlite3_carray_bind(tls, *(*uintptr)(unsafe.Pointer(bp + 96)), *(*int32)(unsafe.Pointer(bp + 100)), aData, nData, eType, xDel)
	if !(isTransient != 0) {
		goto __69
	}
	if !(eType == 3) {
		goto __70
	}
	i = 0
__71:
	if !(i < nData) {
		goto __73
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(aData + uintptr(i)*4)))
	goto __72
__72:
	i++
	goto __71
	goto __73
__73:
	;
__70:
	;
	if !(eType == 4) {
		goto __74
	}
	i = 0
__75:
	if !(i < nData) {
		goto __77
	}
	sqlite3.Xsqlite3_free(tls, (*iovec)(unsafe.Pointer(aData+uintptr(i)*8)).Fiov_base)
	goto __76
__76:
	i++
	goto __75
	goto __77
__77:
	;
__74:
	;
	sqlite3.Xsqlite3_free(tls, aData)
__69:
	;
carray_bind_done:
	if !(rc != 0) {
		goto __78
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+80, sqlite3.Xsqlite3_errstr(tls, rc), uintptr(0)))
	return TCL_ERROR
__78:
	;
	return TCL_OK
}

var aStaticData uintptr = uintptr(0)
var nStaticData int32 = 0
var eStaticType int32 = 0

func test_bind_parameter_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21969)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp)))))
	return TCL_OK
}

func test_bind_parameter_name(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21974)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4))), -1))
	return TCL_OK
}

func test_bind_parameter_index(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21981)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls,
			sqlite3.Xsqlite3_bind_parameter_index(tls, *(*uintptr)(unsafe.Pointer(bp)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))))
	return TCL_OK
}

func test_clear_bindings(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21969)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_clear_bindings(tls, *(*uintptr)(unsafe.Pointer(bp)))))
	return TCL_OK
}

func test_sleep(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18078)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_sleep(tls, *(*int32)(unsafe.Pointer(bp)))))
	return TCL_OK
}

func test_ex_errcode(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_extended_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

func test_errcode(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

func test_errmsg(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var zErr uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	zErr = sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErr, -1))
	return TCL_OK
}

func test_error_offset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var iByteOffset int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	iByteOffset = sqlite3.Xsqlite3_error_offset(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iByteOffset))
	return TCL_OK
}

func test_errmsg16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var zErr uintptr
	var z uintptr
	var bytes int32 = 0

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	zErr = sqlite3.Xsqlite3_errmsg16(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	if zErr != 0 {
		z = zErr
		for bytes = 0; *(*int8)(unsafe.Pointer(z + uintptr(bytes))) != 0 || *(*int8)(unsafe.Pointer(z + uintptr(bytes+1))) != 0; bytes = bytes + 2 {
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, zErr, bytes))
	return TCL_OK
}

func test_prepare(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(146)
	defer tls.Free(146)

	var zSql uintptr

	*(*uintptr)(unsafe.Pointer(bp + 92)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 88)) = uintptr(0)

	var rc int32

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+21991, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), zSql, *(*int32)(unsafe.Pointer(bp + 84)), bp+88, func() uintptr {
		if objc >= 5 {
			return bp + 92
		}
		return uintptr(0)
	}())
	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if *(*uintptr)(unsafe.Pointer(bp + 92)) != 0 && objc >= 5 {
		if *(*int32)(unsafe.Pointer(bp + 84)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84)) = *(*int32)(unsafe.Pointer(bp + 84)) - (int32(*(*uintptr)(unsafe.Pointer(bp + 92)))-int32(zSql))/1
		}
		if int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 92)))) < *(*int32)(unsafe.Pointer(bp + 84)) {
			*(*int32)(unsafe.Pointer(bp + 84)) = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 92))))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 92)), *(*int32)(unsafe.Pointer(bp + 84))), 0)
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96, ts+21350, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+96, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 88)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96, *(*uintptr)(unsafe.Pointer(bp + 88))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+96, 0))
	}
	return TCL_OK
}

func test_prepare_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(146)
	defer tls.Free(146)

	var zSql uintptr
	var zCopy uintptr = uintptr(0)

	*(*uintptr)(unsafe.Pointer(bp + 88)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 92)) = uintptr(0)

	var rc int32

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22015, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 84)) >= 0 {
		zCopy = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 84))))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(*(*int32)(unsafe.Pointer(bp + 84))))
	} else {
		var n int32 = int32(libc.Xstrlen(tls, zSql)) + 1
		zCopy = libc.Xmalloc(tls, uint32(n))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(n))
	}
	if objc >= 5 {
		pzTail = bp + 88
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), zCopy, *(*int32)(unsafe.Pointer(bp + 84)), bp+92, pzTail)
	if objc >= 5 {
		*(*uintptr)(unsafe.Pointer(bp + 88)) = zSql + uintptr((int32(*(*uintptr)(unsafe.Pointer(bp + 88)))-int32(zCopy))/1)
	}
	libc.Xfree(tls, zCopy)

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if rc == SQLITE_OK && objc >= 5 && *(*uintptr)(unsafe.Pointer(bp + 88)) != 0 {
		if *(*int32)(unsafe.Pointer(bp + 84)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84)) = *(*int32)(unsafe.Pointer(bp + 84)) - (int32(*(*uintptr)(unsafe.Pointer(bp + 88)))-int32(zSql))/1
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 88)), *(*int32)(unsafe.Pointer(bp + 84))), 0)
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96, ts+21350, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+96, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 92)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96, *(*uintptr)(unsafe.Pointer(bp + 92))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+96, 0))
	}
	return TCL_OK
}

func test_prepare_v3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(150)
	defer tls.Free(150)

	var zSql uintptr
	var zCopy uintptr = uintptr(0)

	*(*uintptr)(unsafe.Pointer(bp + 92)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)

	var rc int32

	if objc != 6 && objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22037, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+88) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 84)) >= 0 {
		zCopy = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 84))))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(*(*int32)(unsafe.Pointer(bp + 84))))
	} else {
		var n int32 = int32(libc.Xstrlen(tls, zSql)) + 1
		zCopy = libc.Xmalloc(tls, uint32(n))
		libc.Xmemcpy(tls, zCopy, zSql, uint32(n))
	}
	if objc >= 6 {
		pzTail = bp + 92
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v3(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), zCopy, *(*int32)(unsafe.Pointer(bp + 84)), uint32(*(*int32)(unsafe.Pointer(bp + 88))), bp+96, pzTail)
	libc.Xfree(tls, zCopy)
	*(*uintptr)(unsafe.Pointer(bp + 92)) = zSql + uintptr((int32(*(*uintptr)(unsafe.Pointer(bp + 92)))-int32(zCopy))/1)

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if rc == SQLITE_OK && *(*uintptr)(unsafe.Pointer(bp + 92)) != 0 && objc >= 6 {
		if *(*int32)(unsafe.Pointer(bp + 84)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84)) = *(*int32)(unsafe.Pointer(bp + 84)) - (int32(*(*uintptr)(unsafe.Pointer(bp + 92)))-int32(zSql))/1
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 92)), *(*int32)(unsafe.Pointer(bp + 84))), 0)
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+100, ts+21350, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+100, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 96)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+100, *(*uintptr)(unsafe.Pointer(bp + 96))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+100, 0))
	}
	return TCL_OK
}

func test_prepare_tkt3134(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(138)
	defer tls.Free(138)

	*(*uintptr)(unsafe.Pointer(bp + 84)) = uintptr(0)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22015, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), uintptr(unsafe.Pointer(&zSql))+1, 0, bp+84, uintptr(0))

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+88, ts+21350, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+88, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 84)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+88, *(*uintptr)(unsafe.Pointer(bp + 84))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+88, 0))
	}
	return TCL_OK
}

var zSql = *(*[10]int8)(unsafe.Pointer(ts + 22065))

func test_prepare16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(118)
	defer tls.Free(118)

	var zSql uintptr
	*(*uintptr)(unsafe.Pointer(bp + 64)) = uintptr(0)
	var pTail uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 60)) = uintptr(0)

	var rc int32

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+21991, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+56) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare16(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), zSql, *(*int32)(unsafe.Pointer(bp + 56)), bp+60, func() uintptr {
		if objc >= 5 {
			return bp + 64
		}
		return uintptr(0)
	}())
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		return TCL_ERROR
	}

	if objc >= 5 {
		if *(*uintptr)(unsafe.Pointer(bp + 64)) != 0 {
			*(*int32)(unsafe.Pointer(bp + 52)) = *(*int32)(unsafe.Pointer(bp + 52)) - (int32(*(*uintptr)(unsafe.Pointer(bp + 64)))-int32(zSql))/1
		} else {
			*(*int32)(unsafe.Pointer(bp + 52)) = 0
		}
		pTail = tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), *(*int32)(unsafe.Pointer(bp + 52)))
		(*Tcl_Obj)(unsafe.Pointer(pTail)).FrefCount++
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), pTail, 0)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pTail
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if *(*uintptr)(unsafe.Pointer(bp + 60)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+68, *(*uintptr)(unsafe.Pointer(bp + 60))) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+68, 0))
	return TCL_OK
}

func test_prepare16_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(118)
	defer tls.Free(118)

	var zSql uintptr
	*(*uintptr)(unsafe.Pointer(bp + 64)) = uintptr(0)
	var pTail uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 60)) = uintptr(0)

	var rc int32

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+21991, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+56) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare16_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), zSql, *(*int32)(unsafe.Pointer(bp + 56)), bp+60, func() uintptr {
		if objc >= 5 {
			return bp + 64
		}
		return uintptr(0)
	}())
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		return TCL_ERROR
	}

	if objc >= 5 {
		if *(*uintptr)(unsafe.Pointer(bp + 64)) != 0 {
			*(*int32)(unsafe.Pointer(bp + 52)) = *(*int32)(unsafe.Pointer(bp + 52)) - (int32(*(*uintptr)(unsafe.Pointer(bp + 64)))-int32(zSql))/1
		} else {
			*(*int32)(unsafe.Pointer(bp + 52)) = 0
		}
		pTail = tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), *(*int32)(unsafe.Pointer(bp + 52)))
		(*Tcl_Obj)(unsafe.Pointer(pTail)).FrefCount++
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), pTail, 0)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pTail
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if *(*uintptr)(unsafe.Pointer(bp + 60)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+68, *(*uintptr)(unsafe.Pointer(bp + 60))) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+68, 0))
	return TCL_OK
}

func test_open(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zFilename uintptr

	if objc != 3 && objc != 2 && objc != 1 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22075, 0))
		return TCL_ERROR
	}

	if objc > 1 {
		zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	} else {
		zFilename = uintptr(0)
	}
	sqlite3.Xsqlite3_open(tls, zFilename, bp+48)

	if sqlite3TestMakePointerStr(tls, interp, bp+52, *(*uintptr)(unsafe.Pointer(bp + 48))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+52, 0))
	return TCL_OK
}

func test_open_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(300)
	defer tls.Free(300)

	var zFilename uintptr
	var zVfs uintptr
	var flags int32 = 0

	var rc int32

	var i int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22098)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if int32(*(*int8)(unsafe.Pointer(zVfs))) == 0x00 {
		zVfs = uintptr(0)
	}

	rc = tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16, bp+20)
	if rc != TCL_OK {
		return rc
	}
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 16)); i++ {
		*(*[21]OpenFlag)(unsafe.Pointer(bp + 24)) = [21]OpenFlag{
			{FzFlag: ts + 22117, Fflag: SQLITE_OPEN_READONLY},
			{FzFlag: ts + 22138, Fflag: SQLITE_OPEN_READWRITE},
			{FzFlag: ts + 22160, Fflag: SQLITE_OPEN_CREATE},
			{FzFlag: ts + 22179, Fflag: SQLITE_OPEN_DELETEONCLOSE},
			{FzFlag: ts + 22205, Fflag: SQLITE_OPEN_EXCLUSIVE},
			{FzFlag: ts + 22227, Fflag: SQLITE_OPEN_AUTOPROXY},
			{FzFlag: ts + 22249, Fflag: SQLITE_OPEN_MAIN_DB},
			{FzFlag: ts + 22269, Fflag: SQLITE_OPEN_TEMP_DB},
			{FzFlag: ts + 22289, Fflag: SQLITE_OPEN_TRANSIENT_DB},
			{FzFlag: ts + 22314, Fflag: SQLITE_OPEN_MAIN_JOURNAL},
			{FzFlag: ts + 22339, Fflag: SQLITE_OPEN_TEMP_JOURNAL},
			{FzFlag: ts + 22364, Fflag: SQLITE_OPEN_SUBJOURNAL},
			{FzFlag: ts + 22387, Fflag: SQLITE_OPEN_SUPER_JOURNAL},
			{FzFlag: ts + 22413, Fflag: SQLITE_OPEN_NOMUTEX},
			{FzFlag: ts + 22433, Fflag: SQLITE_OPEN_FULLMUTEX},
			{FzFlag: ts + 22455, Fflag: SQLITE_OPEN_SHAREDCACHE},
			{FzFlag: ts + 22479, Fflag: SQLITE_OPEN_PRIVATECACHE},
			{FzFlag: ts + 22504, Fflag: SQLITE_OPEN_WAL},
			{FzFlag: ts + 22520, Fflag: SQLITE_OPEN_URI},
			{FzFlag: ts + 22536, Fflag: SQLITE_OPEN_EXRESCODE},
			{},
		}
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 20)) + uintptr(i)*4)), bp+24, int32(unsafe.Sizeof(OpenFlag{})),
			ts+22558, 0, bp+192)
		if rc != TCL_OK {
			return rc
		}
		flags = flags | (*OpenFlag)(unsafe.Pointer(bp+24+uintptr(*(*int32)(unsafe.Pointer(bp + 192)))*8)).Fflag
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, zFilename, bp+196, flags, zVfs)
	if sqlite3TestMakePointerStr(tls, interp, bp+200, *(*uintptr)(unsafe.Pointer(bp + 196))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+200, 0))
	return TCL_OK
}

type OpenFlag = struct {
	FzFlag uintptr
	Fflag  int32
}

func test_open16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zFilename uintptr

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22075, 0))
		return TCL_ERROR
	}

	zFilename = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
	sqlite3.Xsqlite3_open16(tls, zFilename, bp+48)

	if sqlite3TestMakePointerStr(tls, interp, bp+52, *(*uintptr)(unsafe.Pointer(bp + 48))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+52, 0))
	return TCL_OK
}

func test_complete16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var zBuf uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22563)
		return TCL_ERROR
	}

	zBuf = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_complete16(tls, zBuf)))
	return TCL_OK
}

func test_normalize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var zSql uintptr
	var zNorm uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+9890)
		return TCL_ERROR
	}

	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zNorm = sqlite3_normalize(tls, zSql)
	if zNorm != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zNorm, -1))
		sqlite3.Xsqlite3_free(tls, zNorm)
	}
	return TCL_OK
}

func test_step(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+21189, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_sql(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21969)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp))), uintptr(1))
	return TCL_OK
}

func test_ex_sql(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var z uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21969)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_expanded_sql(tls, *(*uintptr)(unsafe.Pointer(bp)))
	tcl.XTcl_SetResult(tls, interp, z, uintptr(1))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

func test_column_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))))
	return TCL_OK
}

func test_column_type(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var tp int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	tp = sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	switch tp {
	case SQLITE_INTEGER:
		tcl.XTcl_SetResult(tls, interp, ts+2413, uintptr(0))
		break
	case SQLITE_NULL:
		tcl.XTcl_SetResult(tls, interp, ts+6203, uintptr(0))
		break
	case SQLITE_FLOAT:
		tcl.XTcl_SetResult(tls, interp, ts+22589, uintptr(0))
		break
	case SQLITE_TEXT:
		tcl.XTcl_SetResult(tls, interp, ts+22595, uintptr(0))
		break
	case SQLITE_BLOB:
		tcl.XTcl_SetResult(tls, interp, ts+22600, uintptr(0))
		break
	default:
	}

	return TCL_OK
}

func test_column_int64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var iVal i64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	iVal = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, iVal))
	return TCL_OK
}

func test_column_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var len int32
	var pBlob uintptr

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	len = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	pBlob = sqlite3.Xsqlite3_column_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, pBlob, len))
	return TCL_OK
}

func test_column_double(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rVal float64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	rVal = sqlite3.Xsqlite3_column_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewDoubleObj(tls, rVal))
	return TCL_OK
}

func test_data_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_data_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))))
	return TCL_OK
}

func test_stmt_utf8(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var xFunc uintptr
	var zRet uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}
	zRet = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{xFunc})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	if zRet != 0 {
		tcl.XTcl_SetResult(tls, interp, zRet, uintptr(0))
	}
	return TCL_OK
}

func test_global_recover(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_global_recover(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_stmt_utf16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var pRet uintptr
	var zName16 uintptr
	var xFunc uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	zName16 = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{xFunc})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))
	if zName16 != 0 {
		var n int32
		var z uintptr = zName16
		for n = 0; *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 || *(*int8)(unsafe.Pointer(z + uintptr(n+1))) != 0; n = n + 2 {
		}
		pRet = tcl.XTcl_NewByteArrayObj(tls, zName16, n+2)
		tcl.XTcl_SetObjResult(tls, interp, pRet)
	}

	return TCL_OK
}

func test_stmt_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var xFunc uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22576, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{xFunc})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))))
	return TCL_OK
}

func test_interrupt(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_interrupt(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
	return TCL_OK
}

func test_is_interrupted(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_is_interrupted(tls, *(*uintptr)(unsafe.Pointer(bp + 48)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, func() uintptr {
		if rc != 0 {
			return ts + 22605
		}
		return ts + 19147
	}(), uintptr(0)))
	return TCL_OK
}

func delete_function(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+22607, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), -1, SQLITE_UTF8, uintptr(0), uintptr(0), uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func delete_collation(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+22607, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), *(*uintptr)(unsafe.Pointer(argv + 2*4)), SQLITE_UTF8, uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func get_autocommit(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(90)
	defer tls.Free(90)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+56) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+60, ts+1333, libc.VaList(bp+32, sqlite3.Xsqlite3_get_autocommit(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60, 0))
	return TCL_OK
}

func test_busy_timeout(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+52) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_busy_timeout(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), *(*int32)(unsafe.Pointer(bp + 52)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

func tcl_variable_type(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pVar uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22625)
		return TCL_ERROR
	}
	pVar = tcl.XTcl_GetVar2Ex(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0), TCL_LEAVE_ERR_MSG)
	if pVar == uintptr(0) {
		return TCL_ERROR
	}
	if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname, -1))
	}
	return TCL_OK
}

func test_release_memory(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var amt int32
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22634)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp)) = -1
	}
	amt = sqlite3.Xsqlite3_release_memory(tls, *(*int32)(unsafe.Pointer(bp)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, amt))
	return TCL_OK
}

func test_db_release_memory(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_db_release_memory(tls, *(*uintptr)(unsafe.Pointer(bp)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_db_cacheflush(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_db_cacheflush(tls, *(*uintptr)(unsafe.Pointer(bp)))
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
		return TCL_ERROR
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func test_system_errno(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var iErrno int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	iErrno = sqlite3.Xsqlite3_system_errno(tls, *(*uintptr)(unsafe.Pointer(bp)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iErrno))
	return TCL_OK
}

func test_db_filename(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22638)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0 {
		return TCL_ERROR
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_db_filename(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), zDbName), uintptr(0)))
	return TCL_OK
}

func test_db_readonly(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22638)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_db_readonly(tls, *(*uintptr)(unsafe.Pointer(bp)), zDbName)))
	return TCL_OK
}

func test_soft_heap_limit(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp)) = int64(-1)
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22634)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
			return TCL_ERROR
		}
	}
	amt = sqlite3.Xsqlite3_soft_heap_limit64(tls, *(*Tcl_WideInt)(unsafe.Pointer(bp)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, amt))
	return TCL_OK
}

func test_hard_heap_limit(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp)) = int64(-1)
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22634)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
			return TCL_ERROR
		}
	}
	amt = sqlite3.Xsqlite3_hard_heap_limit64(tls, *(*Tcl_WideInt)(unsafe.Pointer(bp)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, amt))
	return TCL_OK
}

func test_thread_cleanup(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return TCL_OK
}

func test_pager_refcounts(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var i int32
	var v int32
	var a uintptr
	var pResult uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	pResult = tcl.XTcl_NewObj(tls)
	for i = 0; i < (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).FnDb; i++ {
		if (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).FaDb+uintptr(i)*16)).FpBt == uintptr(0) {
			v = -1
		} else {
			sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fmutex)
			a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).FaDb+uintptr(i)*16)).FpBt))
			v = *(*int32)(unsafe.Pointer(a))
			sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fmutex)
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, v))
	}
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

func working_64bit_int(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var pTestObj uintptr
	var working int32 = 0

	pTestObj = tcl.XTcl_NewWideIntObj(tls, int64(1000000)*int64(1234567890))
	working = libc.Bool32(libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, pTestObj), ts+22648) == 0)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pTestObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(working != 0)))
	return TCL_OK
}

func vfs_unlink_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var i int32
	var pMain uintptr

	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(0))
	(*sqlite3_vfs)(unsafe.Pointer(bp)).FzName = ts + 22665
	(*sqlite3_vfs)(unsafe.Pointer(bp + 88)).FzName = ts + 22671

	pMain = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	sqlite3.Xsqlite3_vfs_register(tls, bp, 0)

	sqlite3.Xsqlite3_vfs_register(tls, bp+88, 0)

	sqlite3.Xsqlite3_vfs_register(tls, bp, 1)

	sqlite3.Xsqlite3_vfs_register(tls, bp+88, 1)

	if pMain != 0 {
		sqlite3.Xsqlite3_vfs_register(tls, pMain, 1)

	}

	for i = 0; uint32(i) < uint32(unsafe.Sizeof([20]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0))); i++ {
		*(*uintptr)(unsafe.Pointer(bp + 176 + uintptr(i)*4)) = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if *(*uintptr)(unsafe.Pointer(bp + 176 + uintptr(i)*4)) != 0 {
			sqlite3.Xsqlite3_vfs_unregister(tls, *(*uintptr)(unsafe.Pointer(bp + 176 + uintptr(i)*4)))

		}
	}

	sqlite3.Xsqlite3_vfs_register(tls, pMain, 0)

	sqlite3.Xsqlite3_vfs_unregister(tls, pMain)

	for i = int32(uint32(unsafe.Sizeof([20]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0))) - uint32(1)); i >= 0; i-- {
		if *(*uintptr)(unsafe.Pointer(bp + 176 + uintptr(i)*4)) != 0 {
			sqlite3.Xsqlite3_vfs_register(tls, *(*uintptr)(unsafe.Pointer(bp + 176 + uintptr(i)*4)), 1)

		}
	}

	sqlite3.Xsqlite3_vfs_unregister(tls, bp)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+88)

	sqlite3.Xsqlite3_vfs_unregister(tls, bp)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+88)

	return TCL_OK
}

func vfs_initfail_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(88)
	defer tls.Free(88)

	(*sqlite3_vfs)(unsafe.Pointer(bp)).FzName = ts + 22665

	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp, 0)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp, 1)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

var apVfs [20]uintptr
var nVfs int32 = 0

func vfs_unregister_all(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var i int32
	for i = 0; i < int32(uint32(unsafe.Sizeof(apVfs))/uint32(unsafe.Sizeof(uintptr(0)))); i++ {
		apVfs[i] = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if apVfs[i] == uintptr(0) {
			break
		}
		sqlite3.Xsqlite3_vfs_unregister(tls, apVfs[i])
	}
	nVfs = i
	return TCL_OK
}

func vfs_reregister_all(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var i int32
	for i = nVfs - 1; i >= 0; i-- {
		sqlite3.Xsqlite3_vfs_register(tls, apVfs[i], 1)
	}
	return TCL_OK
}

func file_control_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	*(*int32)(unsafe.Pointer(bp + 36)) = 0

	var rc int32
	_ = rc

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), uintptr(0), 0, bp+36)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+22677, SQLITE_FCNTL_LOCKSTATE, bp+36)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+85, -1, bp+36)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+9286, -1, bp+36)

	return TCL_OK
}

func file_control_lasterrno_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*int32)(unsafe.Pointer(bp + 68)) = 0

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+19955, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), uintptr(0), SQLITE_FCNTL_LAST_ERRNO, bp+68)
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 68)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+22690,
			tcl.XTcl_GetStringFromObj(tls, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 68))), uintptr(0)), ts+5251, 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func file_control_data_version(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var zDb uintptr

	var rc int32

	if objc != 3 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22718)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+8) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	} else {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), zDb, SQLITE_FCNTL_DATA_VERSION, bp+12)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	} else {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+16, ts+22730, libc.VaList(bp, *(*uint32)(unsafe.Pointer(bp + 12))))
		tcl.XTcl_SetResult(tls, interp, bp+16, uintptr(1))
		return TCL_OK
	}
	return int32(0)
}

func file_control_chunksize_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zDb uintptr

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22733)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if int32(*(*int8)(unsafe.Pointer(zDb))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp)), zDb, SQLITE_FCNTL_CHUNK_SIZE, bp+4)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	return TCL_OK
}

func file_control_sizehint_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var zDb uintptr

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22733)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 ||
		tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if int32(*(*int8)(unsafe.Pointer(zDb))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp)), zDb, SQLITE_FCNTL_SIZE_HINT, bp+4)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	return TCL_OK
}

func file_control_lockproxy_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+22748, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}

	return TCL_OK
}

func file_control_persist_wal(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var rc int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+22756, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), uintptr(0), SQLITE_FCNTL_PERSIST_WAL, bp+68)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72, ts+22765, libc.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 68))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+72, uintptr(0)))
	return TCL_OK
}

func file_control_powersafe_overwrite(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var rc int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+22756, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), uintptr(0), SQLITE_FCNTL_POWERSAFE_OVERWRITE, bp+68)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72, ts+22765, libc.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 68))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+72, uintptr(0)))
	return TCL_OK
}

func file_control_vfsname(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var zDbName uintptr = ts + 85
	*(*uintptr)(unsafe.Pointer(bp + 52)) = uintptr(0)

	if objc != 2 && objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+22771, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), zDbName, SQLITE_FCNTL_VFSNAME, bp+52)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 52)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 52)))
	return TCL_OK
}

func file_control_reservebytes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zDbName uintptr = ts + 85
	*(*int32)(unsafe.Pointer(bp + 4)) = 0
	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22783)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp)), zDbName, SQLITE_FCNTL_RESERVE_BYTES, bp+4)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

func file_control_tempfilename(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var zDbName uintptr = ts + 85
	*(*uintptr)(unsafe.Pointer(bp + 52)) = uintptr(0)

	if objc != 2 && objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+22771, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48)), zDbName, SQLITE_FCNTL_TEMPFILENAME, bp+52)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 52)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 52)))
	return TCL_OK
}

func file_control_external_reader(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zName uintptr = ts + 85
	*(*int32)(unsafe.Pointer(bp + 36)) = 0
	var rc int32 = SQLITE_OK

	if objc != 2 && objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+22771, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), zName, SQLITE_FCNTL_EXTERNAL_READER, bp+36)
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 36))))
	return TCL_OK
}

func vfs_list(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var pVfs uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}
	for pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)); pVfs != 0; pVfs = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpNext {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

func test_limit(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var rc int32
	var i int32
	var id int32 = 0

	var zId uintptr

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+22788, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56) != 0 {
		return TCL_ERROR
	}
	zId = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aId))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fid    int32
	}{})); i++ {
		if libc.Xstrcmp(tls, zId, aId[i].FzName) == 0 {
			id = aId[i].Fid
			break
		}
	}
	if uint32(i) >= uint32(unsafe.Sizeof(aId))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fid    int32
	}{})) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+22801, zId, uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+60) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 56)), id, *(*int32)(unsafe.Pointer(bp + 60)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

var aId = [14]struct {
	FzName uintptr
	Fid    int32
}{
	{FzName: ts + 22822},
	{FzName: ts + 22842, Fid: SQLITE_LIMIT_SQL_LENGTH},
	{FzName: ts + 22866, Fid: SQLITE_LIMIT_COLUMN},
	{FzName: ts + 22886, Fid: SQLITE_LIMIT_EXPR_DEPTH},
	{FzName: ts + 22910, Fid: SQLITE_LIMIT_COMPOUND_SELECT},
	{FzName: ts + 22939, Fid: SQLITE_LIMIT_VDBE_OP},
	{FzName: ts + 22960, Fid: SQLITE_LIMIT_FUNCTION_ARG},
	{FzName: ts + 22986, Fid: SQLITE_LIMIT_ATTACHED},
	{FzName: ts + 23008, Fid: SQLITE_LIMIT_LIKE_PATTERN_LENGTH},
	{FzName: ts + 23041, Fid: SQLITE_LIMIT_VARIABLE_NUMBER},
	{FzName: ts + 23070, Fid: SQLITE_LIMIT_TRIGGER_DEPTH},
	{FzName: ts + 23097, Fid: SQLITE_LIMIT_WORKER_THREADS},
	{FzName: ts + 23125, Fid: -1},
	{FzName: ts + 23147, Fid: SQLITE_LIMIT_WORKER_THREADS + 1},
}

func save_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32 = sqlite3.Xsqlite3_test_control(tls, 9999, 0)
	_ = rc

	rc = sqlite3.Xsqlite3_test_control(tls, -1, 0)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_SAVE, 0)
	return TCL_OK
}

func restore_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_RESTORE, 0)
	return TCL_OK
}

func reset_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	sqlite3.Xsqlite3_randomness(tls, 0, uintptr(0))
	return TCL_OK
}

func prng_seed(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*int32)(unsafe.Pointer(bp + 16)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23167)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16) != 0 {
		return TCL_ERROR
	}
	if objc == 3 && getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+20) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_SEED, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16)), *(*uintptr)(unsafe.Pointer(bp + 20))))
	return TCL_OK
}

func extra_schema_checks(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*int32)(unsafe.Pointer(bp + 8)) = 0
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23177)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8))))
	return TCL_OK
}

func database_may_be_corrupt(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_NEVER_CORRUPT, libc.VaList(bp, 0))
	return TCL_OK
}

func database_never_corrupt(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_NEVER_CORRUPT, libc.VaList(bp, 1))
	return TCL_OK
}

func test_pcache_stats(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pRet uintptr

	sqlite3.Xsqlite3PcacheStats(tls, bp, bp+4, bp+8, bp+12)

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+23185, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+23193, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+23197, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+23201, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12))))

	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

func test_unlock_notify_cb(tls *libc.TLS, aArg uintptr, nArg int32) {
	var ii int32
	for ii = 0; ii < nArg; ii++ {
		tcl.XTcl_EvalEx(tls, *(*uintptr)(unsafe.Pointer(aArg + uintptr(ii)*4)), ts+18646, -1, TCL_EVAL_GLOBAL)
	}
}

func test_unlock_notify(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}

	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_unlock_notify(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{test_unlock_notify_cb})), interp)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_wal_checkpoint(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zDb uintptr = uintptr(0)

	var rc int32

	if objc != 3 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23212)
		return TCL_ERROR
	}

	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}
	rc = sqlite3.Xsqlite3_wal_checkpoint(tls, *(*uintptr)(unsafe.Pointer(bp)), zDb)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_wal_checkpoint_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var zDb uintptr = uintptr(0)

	var rc int32

	*(*int32)(unsafe.Pointer(bp + 60)) = -555
	*(*int32)(unsafe.Pointer(bp + 64)) = -555
	var pRet uintptr

	*(*[5]uintptr)(unsafe.Pointer(bp + 40)) = [5]uintptr{ts + 23222, ts + 23230, ts + 23235, ts + 23243, uintptr(0)}

	if objc != 3 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23252)
		return TCL_ERROR
	}

	if objc == 4 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 || TCL_OK != tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) &&
		TCL_OK != tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+40, int32(unsafe.Sizeof(uintptr(0))), ts+23267, 0, bp+36) {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_wal_checkpoint_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), zDb, *(*int32)(unsafe.Pointer(bp + 36)), bp+60, bp+64)
	if rc != SQLITE_OK && rc != SQLITE_BUSY {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, zErrCode, ts+10022, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, func() int32 {
		if rc == SQLITE_BUSY {
			return 1
		}
		return 0
	}()))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 60))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 64))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

func test_wal_autocheckpoint(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23272)
		return TCL_ERROR
	}

	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_wal_autocheckpoint(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))
	tcl.XTcl_ResetResult(tls, interp)
	if rc != SQLITE_OK {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErrCode, -1))
		return TCL_ERROR
	}

	return TCL_OK
}

type LogCallback = struct {
	FpInterp uintptr
	FpObj    uintptr
}

var logcallback = LogCallback{}

func xLogcallback(tls *libc.TLS, unused uintptr, err int32, zMsg uintptr) {
	var pNew uintptr = tcl.XTcl_DuplicateObj(tls, logcallback.FpObj)
	(*Tcl_Obj)(unsafe.Pointer(pNew)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls,
		uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, err), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, zMsg, -1))
	tcl.XTcl_EvalObjEx(tls, logcallback.FpInterp, pNew, TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pNew
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func test_sqlite3_log(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10001)
		return TCL_ERROR
	}
	if logcallback.FpObj != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = logcallback.FpObj
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		logcallback.FpObj = uintptr(0)
		logcallback.FpInterp = uintptr(0)
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp, uintptr(0), uintptr(0)))
	}
	if objc > 1 {
		logcallback.FpObj = *(*uintptr)(unsafe.Pointer(objv + 1*4))
		(*Tcl_Obj)(unsafe.Pointer(logcallback.FpObj)).FrefCount++
		logcallback.FpInterp = interp
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{xLogcallback})), uintptr(0)))
	}
	return TCL_OK
}

func runAsObjProc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23281)
		return TCL_ERROR
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+48) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19813,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	if (*Tcl_CmdInfo)(unsafe.Pointer(bp+48)).FobjProc == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+23293,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	return (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_CmdInfo)(unsafe.Pointer(bp + 48)).FobjProc})).f(tls, (*Tcl_CmdInfo)(unsafe.Pointer(bp+48)).FobjClientData, interp, objc-1, objv+uintptr(1)*4)
}

func printExplainQueryPlan(tls *libc.TLS, pStmt uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var zSql uintptr
	var zExplain uintptr

	var rc int32

	zSql = sqlite3.Xsqlite3_sql(tls, pStmt)
	if zSql == uintptr(0) {
		return SQLITE_ERROR
	}

	zExplain = sqlite3.Xsqlite3_mprintf(tls, ts+330, libc.VaList(bp, zSql))
	if zExplain == uintptr(0) {
		return SQLITE_NOMEM
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt), zExplain, -1, bp+40, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zExplain)
	if rc != SQLITE_OK {
		return rc
	}

	for SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40))) {
		var iSelectid int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), 0)
		var iOrder int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), 1)
		var iFrom int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), 2)
		var zDetail uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), 3)

		libc.Xprintf(tls, ts+23318, libc.VaList(bp+8, iSelectid, iOrder, iFrom, zDetail))
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 40)))
}

func test_print_eqp(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21969)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	rc = printExplainQueryPlan(tls, *(*uintptr)(unsafe.Pointer(bp)))

	libc.Xfflush(tls, libc.X__stdoutp)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func testLocaltime(tls *libc.TLS, aliasT uintptr, aliasTM uintptr) int32 {
	var t time_t = *(*time_t)(unsafe.Pointer(aliasT))
	var pTm uintptr = aliasTM
	var altT time_t
	var iJD sqlite3_int64
	var Z int32
	var A int32
	var B int32
	var C int32
	var D int32
	var E int32
	var X1 int32
	var S int32

	if t/86400&1 != 0 {
		altT = t + 1800
	} else {
		altT = t - 1800
	}
	iJD = int64(altT) + 210866760000
	Z = int32((iJD + int64(43200)) / int64(86400))
	A = libc.Int32FromFloat64((float64(Z) - 1867216.25) / 36524.25)
	A = Z + 1 + A - A/4
	B = A + 1524
	C = libc.Int32FromFloat64((float64(B) - 122.1) / 365.25)
	D = 36525 * (C & 32767) / 100
	E = libc.Int32FromFloat64(float64(B-D) / 30.6001)
	X1 = libc.Int32FromFloat64(30.6001 * float64(E))
	(*tm)(unsafe.Pointer(pTm)).Ftm_mday = B - D - X1
	(*tm)(unsafe.Pointer(pTm)).Ftm_mon = func() int32 {
		if E < 14 {
			return E - 2
		}
		return E - 14
	}()
	(*tm)(unsafe.Pointer(pTm)).Ftm_year = func() int32 {
		if (*tm)(unsafe.Pointer(pTm)).Ftm_mon > 1 {
			return C - 4716
		}
		return C - 4715
	}() - 1900
	S = int32((iJD + int64(43200)) % int64(86400))
	(*tm)(unsafe.Pointer(pTm)).Ftm_hour = S / 3600
	(*tm)(unsafe.Pointer(pTm)).Ftm_min = S / 60 % 60
	(*tm)(unsafe.Pointer(pTm)).Ftm_sec = S % 60
	return libc.Bool32(t == 959609760)
}

func test_test_control(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(144)
	defer tls.Free(144)

	*(*[5]Verb)(unsafe.Pointer(bp + 72)) = [5]Verb{
		{FzName: ts + 23331, Fi: SQLITE_TESTCTRL_LOCALTIME_FAULT},
		{FzName: ts + 23363, Fi: SQLITE_TESTCTRL_SORTER_MMAP},
		{FzName: ts + 23391, Fi: SQLITE_TESTCTRL_IMPOSTER},
		{FzName: ts + 23416, Fi: SQLITE_TESTCTRL_INTERNAL_FUNCTIONS},
		{},
	}

	var iFlag int32
	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23451)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+72, int32(unsafe.Sizeof(Verb{})), ts+23464, 0, bp+112)
	if rc != TCL_OK {
		return rc
	}

	iFlag = (*Verb)(unsafe.Pointer(bp + 72 + uintptr(*(*int32)(unsafe.Pointer(bp + 112)))*8)).Fi
	switch iFlag {
	case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:
		{
			*(*uintptr)(unsafe.Pointer(bp + 116)) = uintptr(0)
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+2050)
				return TCL_ERROR
			}
			if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+116) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 116))))
			break

		}
	case SQLITE_TESTCTRL_LOCALTIME_FAULT:
		{
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+23469)
				return TCL_ERROR
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+120) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, iFlag, libc.VaList(bp+8, *(*int32)(unsafe.Pointer(bp + 120)), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			}{testLocaltime}))))
			break

		}

	case SQLITE_TESTCTRL_SORTER_MMAP:
		{
			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+23475)
				return TCL_ERROR
			}
			if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+124) != 0 {
				return TCL_ERROR
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+128) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_SORTER_MMAP, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(bp + 124)), *(*int32)(unsafe.Pointer(bp + 128))))
			break

		}

	case SQLITE_TESTCTRL_IMPOSTER:
		{
			var zDbName uintptr

			if objc != 6 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+23484)
				return TCL_ERROR
			}
			if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+132) != 0 {
				return TCL_ERROR
			}
			zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+136) != 0 {
				return TCL_ERROR
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), bp+140) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_IMPOSTER, libc.VaList(bp+40, *(*uintptr)(unsafe.Pointer(bp + 132)), zDbName, *(*int32)(unsafe.Pointer(bp + 136)), *(*int32)(unsafe.Pointer(bp + 140))))
			break

		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

type Verb = struct {
	FzName uintptr
	Fi     int32
}

type rusage = struct {
	Fru_utime struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
	Fru_stime struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
	Fru_maxrss   int32
	Fru_ixrss    int32
	Fru_idrss    int32
	Fru_isrss    int32
	Fru_minflt   int32
	Fru_majflt   int32
	Fru_nswap    int32
	Fru_inblock  int32
	Fru_oublock  int32
	Fru_msgsnd   int32
	Fru_msgrcv   int32
	Fru_nsignals int32
	Fru_nvcsw    int32
	Fru_nivcsw   int32
}

type __wrusage = struct {
	Fwru_self struct {
		Fru_utime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_stime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_maxrss   int32
		Fru_ixrss    int32
		Fru_idrss    int32
		Fru_isrss    int32
		Fru_minflt   int32
		Fru_majflt   int32
		Fru_nswap    int32
		Fru_inblock  int32
		Fru_oublock  int32
		Fru_msgsnd   int32
		Fru_msgrcv   int32
		Fru_nsignals int32
		Fru_nvcsw    int32
		Fru_nivcsw   int32
	}
	Fwru_children struct {
		Fru_utime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_stime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_maxrss   int32
		Fru_ixrss    int32
		Fru_idrss    int32
		Fru_isrss    int32
		Fru_minflt   int32
		Fru_majflt   int32
		Fru_nswap    int32
		Fru_inblock  int32
		Fru_oublock  int32
		Fru_msgsnd   int32
		Fru_msgrcv   int32
		Fru_nsignals int32
		Fru_nvcsw    int32
		Fru_nivcsw   int32
	}
}

type rlimit = struct {
	Frlim_cur rlim_t
	Frlim_max rlim_t
}

type orlimit = struct {
	Frlim_cur int32
	Frlim_max int32
}

type loadavg = struct {
	Fldavg  [3]uint32
	Ffscale int32
}

func test_getrusage(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(1144)
	defer tls.Free(1144)

	libc.Xmemset(tls, bp+48, 0, uint32(unsafe.Sizeof(rusage{})))
	libc.Xgetrusage(tls, RUSAGE_SELF, bp+48)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1024]int8{})), bp+120,
		ts+23505,
		libc.VaList(bp, (*rusage)(unsafe.Pointer(bp+48)).Fru_utime.Ftv_sec, (*rusage)(unsafe.Pointer(bp+48)).Fru_utime.Ftv_usec,
			(*rusage)(unsafe.Pointer(bp+48)).Fru_stime.Ftv_sec, (*rusage)(unsafe.Pointer(bp+48)).Fru_stime.Ftv_usec,
			(*rusage)(unsafe.Pointer(bp+48)).Fru_minflt, (*rusage)(unsafe.Pointer(bp+48)).Fru_majflt))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+120, -1))
	return TCL_OK
}

func optimization_control(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32

	var zOpt uintptr

	var mask int32 = 0
	var cnt int32 = 0

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23565)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+60) != 0 {
		return TCL_ERROR
	}
	zOpt = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aOpt))/uint32(unsafe.Sizeof(struct {
		FzOptName uintptr
		Fmask     int32
	}{})); i++ {
		if libc.Xstrstr(tls, zOpt, aOpt[i].FzOptName) != uintptr(0) {
			mask = mask | aOpt[i].Fmask
			cnt++
		}
	}
	if *(*int32)(unsafe.Pointer(bp + 60)) != 0 {
		mask = ^mask
	}
	if cnt == 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+23580,
			uintptr(0)))
		for i = 0; uint32(i) < uint32(unsafe.Sizeof(aOpt))/uint32(unsafe.Sizeof(struct {
			FzOptName uintptr
			Fmask     int32
		}{})); i++ {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+5251, aOpt[i].FzOptName, uintptr(0)))
		}
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_OPTIMIZATIONS, libc.VaList(bp+40, *(*uintptr)(unsafe.Pointer(bp + 56)), mask))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, mask))
	return TCL_OK
}

var aOpt = [15]struct {
	FzOptName uintptr
	Fmask     int32
}{
	{FzOptName: ts + 23621, Fmask: libc.Int32FromUint32(SQLITE_AllOpts)},
	{FzOptName: ts + 23625},
	{FzOptName: ts + 23630, Fmask: SQLITE_QueryFlattener},
	{FzOptName: ts + 23646, Fmask: SQLITE_GroupByOrder},
	{FzOptName: ts + 23660, Fmask: SQLITE_FactorOutConst},
	{FzOptName: ts + 23677, Fmask: SQLITE_DistinctOpt},
	{FzOptName: ts + 23690, Fmask: SQLITE_CoverIdxScan},
	{FzOptName: ts + 23705, Fmask: SQLITE_OrderByIdxJoin},
	{FzOptName: ts + 23723, Fmask: SQLITE_Transitive},
	{FzOptName: ts + 23734, Fmask: SQLITE_OmitNoopJoin},
	{FzOptName: ts + 23749, Fmask: SQLITE_Stat4},
	{FzOptName: ts + 23755, Fmask: SQLITE_SkipScan},
	{FzOptName: ts + 23765, Fmask: SQLITE_PushDown},
	{FzOptName: ts + 23775, Fmask: SQLITE_BalancedMerge},
	{FzOptName: ts + 23790, Fmask: SQLITE_PropagateConst},
}

func tclLoadStaticExtensionCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var zName uintptr
	var i int32
	var j int32
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 68)) = uintptr(0)
	if objc < 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23806)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64) != 0 {
		return TCL_ERROR
	}
	for j = 2; j < objc; j++ {
		zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(j)*4)))
		for i = 0; i < int32(uint32(unsafe.Sizeof(aExtension))/uint32(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{}))); i++ {
			if libc.Xstrcmp(tls, zName, aExtension[i].FzExtName) == 0 {
				break
			}
		}
		if i >= int32(uint32(unsafe.Sizeof(aExtension))/uint32(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{}))) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+23818, zName, uintptr(0)))
			return TCL_ERROR
		}
		if aExtension[i].FpInit != 0 {
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{aExtension[i].FpInit})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), bp+68, uintptr(0))
		} else {
			rc = SQLITE_OK
		}
		if rc != SQLITE_OK && rc != SQLITE_OK|int32(1)<<8 || *(*uintptr)(unsafe.Pointer(bp + 68)) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+23838, zName, ts+23857, *(*uintptr)(unsafe.Pointer(bp + 68)),
				uintptr(0)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 68)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

var aExtension = [23]struct {
	FzExtName uintptr
	FpInit    uintptr
}{
	{FzExtName: ts + 23867, FpInit: 0},
	{FzExtName: ts + 23874, FpInit: 0},
	{FzExtName: ts + 23884, FpInit: 0},
	{FzExtName: ts + 4417, FpInit: 0},
	{FzExtName: ts + 23891, FpInit: 0},
	{FzExtName: ts + 5172, FpInit: 0},
	{FzExtName: ts + 5195, FpInit: 0},
	{FzExtName: ts + 5253, FpInit: 0},
	{FzExtName: ts + 5331, FpInit: 0},
	{FzExtName: ts + 23899, FpInit: 0},
	{FzExtName: ts + 5840, FpInit: 0},
	{FzExtName: ts + 5864, FpInit: 0},
	{FzExtName: ts + 23906, FpInit: 0},
	{FzExtName: ts + 6444, FpInit: 0},
	{FzExtName: ts + 6519, FpInit: 0},
	{FzExtName: ts + 6890, FpInit: 0},
	{FzExtName: ts + 7186, FpInit: 0},
	{FzExtName: ts + 7201, FpInit: 0},
	{FzExtName: ts + 23915, FpInit: 0},
	{FzExtName: ts + 23922, FpInit: 0},
	{FzExtName: ts + 23931, FpInit: 0},
	{FzExtName: ts + 9276, FpInit: 0},
	{FzExtName: ts + 9818, FpInit: 0},
}

func sorter_test_fakeheap(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15054)
		return TCL_ERROR
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp)) != 0 {
		if sqlite3.Xsqlite3Config.FpHeap == uintptr(0) {
			sqlite3.Xsqlite3Config.FpHeap = libc.UintptrFromInt32(-1)
		}
	} else {
		if sqlite3.Xsqlite3Config.FpHeap == libc.UintptrFromInt32(-1) {
			sqlite3.Xsqlite3Config.FpHeap = uintptr(0)
		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func sorter_test_sort4_helper(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var zSql1 uintptr
	var zSql2 uintptr

	var iStep int32
	var iCksum1 uint32
	var iCksum2 uint32
	var rc int32
	var iB int32

	var a int32
	var a1 int32
	iCksum1 = uint32(0)
	iCksum2 = uint32(0)

	if !(objc != 5) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23938)
	return TCL_ERROR
__1:
	;
	if !(getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	zSql1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+60) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	zSql2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))

	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56)), zSql1, -1, bp+64, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __4
	}
	goto sql_error
__4:
	;
	iB = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 64))) - 1
	iStep = 0
__5:
	if !(iStep < *(*int32)(unsafe.Pointer(bp + 60)) && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64)))) {
		goto __7
	}
	a = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), 0)
	if !(a != sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), iB)) {
		goto __8
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+23957, 0))
	return TCL_ERROR
__8:
	;
	iCksum1 = iCksum1 + (iCksum1<<3 + uint32(a))
	goto __6
__6:
	iStep++
	goto __5
	goto __7
__7:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64)))
	if !(rc != SQLITE_OK) {
		goto __9
	}
	goto sql_error
__9:
	;
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56)), zSql2, -1, bp+64, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __10
	}
	goto sql_error
__10:
	;
	iStep = 0
__11:
	if !(SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64)))) {
		goto __13
	}
	a1 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), 0)
	iCksum2 = iCksum2 + (iCksum2<<3 + uint32(a1))
	goto __12
__12:
	iStep++
	goto __11
	goto __13
__13:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64)))
	if !(rc != SQLITE_OK) {
		goto __14
	}
	goto sql_error
__14:
	;
	if !(iCksum1 != iCksum2) {
		goto __15
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+23976, 0))
	return TCL_ERROR
__15:
	;
	return TCL_OK
sql_error:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+23994, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 56))), 0))
	return TCL_ERROR
}

func test_bad_behavior(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var xyz int32
	var i int32 = *(*int32)(unsafe.Pointer(clientData))
	var j int32

	var a uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24006)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp)) {
	case 1:
		{
			xyz = 0x7fffff00 - i
			xyz = xyz + 0x100
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, xyz))
			break

		}
	case 2:
		{
			*(*int32)(unsafe.Pointer(bp + 4 + 1*4)) = 5
			if *(*int32)(unsafe.Pointer(bp + 4 + uintptr(i)*4)) > 0 {
				*(*int32)(unsafe.Pointer(bp + 4 + 1*4))++
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 + 1*4))))
			break

		}
	case 3:
		{
			a = libc.Xmalloc(tls, uint32(unsafe.Sizeof(int32(0)))*uint32(10))
			for j = 0; j < 10; j++ {
				*(*int32)(unsafe.Pointer(a + uintptr(j)*4)) = j
			}
			libc.Xfree(tls, a)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
			break

		}
	case 4:
		{
			tcl.XTcl_Panic(tls, ts+24011, 0)
			break

		}
	}
	return TCL_OK
}

func test_register_dbstat_vtab(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zDb uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}

	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp) != 0 {
		var db uintptr = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp)).FobjClientData)).Fdb
		sqlite3.Xsqlite3DbstatRegister(tls, db)
	}
	return TCL_OK
}

func test_sqlite3_db_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var i int32
	*(*int32)(unsafe.Pointer(bp + 20)) = 0
	var zSetting uintptr

	if objc != 4 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24028)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0 {
		return TCL_ERROR
	}
	zSetting = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if sqlite3.Xsqlite3_strglob(tls, ts+24047, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+24056, zSetting) == 0 {
		zSetting += uintptr(9)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+24067, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	for i = 0; i < int32(uint32(unsafe.Sizeof(aSetting))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FeVal  int32
	}{}))); i++ {
		if libc.Xstrcmp(tls, zSetting, aSetting[i].FzName) == 0 {
			break
		}
	}
	if i >= int32(uint32(unsafe.Sizeof(aSetting))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FeVal  int32
	}{}))) {
		tcl.XTcl_SetObjResult(tls, interp,
			tcl.XTcl_NewStringObj(tls, ts+24076, -1))
		return TCL_ERROR
	}
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 20)) = -1
	}
	sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), aSetting[i].FeVal, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 20)), bp+20))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 20))))
	return TCL_OK
}

var aSetting = [14]struct {
	FzName uintptr
	FeVal  int32
}{
	{FzName: ts + 24110, FeVal: SQLITE_DBCONFIG_ENABLE_FKEY},
	{FzName: ts + 24115, FeVal: SQLITE_DBCONFIG_ENABLE_TRIGGER},
	{FzName: ts + 24123, FeVal: SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER},
	{FzName: ts + 24138, FeVal: SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION},
	{FzName: ts + 24153, FeVal: SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE},
	{FzName: ts + 24170, FeVal: SQLITE_DBCONFIG_ENABLE_QPSG},
	{FzName: ts + 24175, FeVal: SQLITE_DBCONFIG_TRIGGER_EQP},
	{FzName: ts + 24187, FeVal: SQLITE_DBCONFIG_RESET_DATABASE},
	{FzName: ts + 24196, FeVal: SQLITE_DBCONFIG_DEFENSIVE},
	{FzName: ts + 24206, FeVal: SQLITE_DBCONFIG_WRITABLE_SCHEMA},
	{FzName: ts + 24222, FeVal: SQLITE_DBCONFIG_LEGACY_ALTER_TABLE},
	{FzName: ts + 24241, FeVal: SQLITE_DBCONFIG_DQS_DML},
	{FzName: ts + 24249, FeVal: SQLITE_DBCONFIG_DQS_DDL},
	{FzName: ts + 24257, FeVal: SQLITE_DBCONFIG_LEGACY_FILE_FORMAT},
}

func test_sqlite3_txn_state(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zSchema uintptr
	var iTxn int32

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24276)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zSchema = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	} else {
		zSchema = uintptr(0)
	}
	iTxn = sqlite3.Xsqlite3_txn_state(tls, *(*uintptr)(unsafe.Pointer(bp)), zSchema)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iTxn))
	return TCL_OK
}

func test_dbconfig_maindbname_icecube(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	} else {
		if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+8) != 0 {
			return TCL_ERROR
		}
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), SQLITE_DBCONFIG_MAINDBNAME, libc.VaList(bp, ts+24288))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return TCL_OK
	}
	return int32(0)
}

func test_mmap_warm(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24296)
		return TCL_ERROR
	} else {
		var rc int32

		var zDb uintptr = uintptr(0)
		if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
			return TCL_ERROR
		}
		if objc == 3 {
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
		}
		rc = sqlite3_mmap_warm(tls, *(*uintptr)(unsafe.Pointer(bp)), zDb)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_OK
	}
	return int32(0)
}

func test_write_db(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*Tcl_WideInt)(unsafe.Pointer(bp + 4)) = int64(0)
	var aData uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 12)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24308)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	aData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+12)

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+85, SQLITE_FCNTL_FILE_POINTER, bp+16)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).FpMethods)).FxWrite})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), aData, *(*int32)(unsafe.Pointer(bp + 12)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 4)))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_register_cksumvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	} else {
		var rc int32 = sqlite3_register_cksumvfs(tls, uintptr(0))
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	return TCL_OK
}

func test_unregister_cksumvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	} else {
		var rc int32 = sqlite3_unregister_cksumvfs(tls)
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	return TCL_OK
}

func test_decode_hexdb(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(296)
	defer tls.Free(296)

	var zIn uintptr = uintptr(0)
	var a uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 216)) = 0
	var lineno int32 = 0
	var i int32
	var iNext int32
	var iOffset int32 = 0

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24323)
		return TCL_ERROR
	}
	zIn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	for i = 0; *(*int8)(unsafe.Pointer(zIn + uintptr(i))) != 0; i = iNext {
		lineno++
		for iNext = i; *(*int8)(unsafe.Pointer(zIn + uintptr(iNext))) != 0 && int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) != '\n'; iNext++ {
		}
		if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) == '\n' {
			iNext++
		}
		for int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == ' ' || int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == '\t' {
			i++
		}
		if a == uintptr(0) {
			rc = libc.Xsscanf(tls, zIn+uintptr(i), ts+24329, libc.VaList(bp, bp+216, bp+220))
			if rc != 2 {
				continue
			}
			if *(*int32)(unsafe.Pointer(bp + 220)) < 512 || *(*int32)(unsafe.Pointer(bp + 220)) > 65536 || *(*int32)(unsafe.Pointer(bp + 220))&(*(*int32)(unsafe.Pointer(bp + 220))-1) != 0 {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+24351, uintptr(0)))
				return TCL_ERROR
			}
			*(*int32)(unsafe.Pointer(bp + 216)) = (*(*int32)(unsafe.Pointer(bp + 216)) + *(*int32)(unsafe.Pointer(bp + 220)) - 1) & ^(*(*int32)(unsafe.Pointer(bp + 220)) - 1)
			if *(*int32)(unsafe.Pointer(bp + 216)) < 512 {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+24372, uintptr(0)))
				return TCL_ERROR
			}
			a = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 216))))
			if a == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+2069, uintptr(0)))
				return TCL_ERROR
			}
			libc.Xmemset(tls, a, 0, uint32(*(*int32)(unsafe.Pointer(bp + 216))))
			continue
		}
		rc = libc.Xsscanf(tls, zIn+uintptr(i), ts+24389, libc.VaList(bp+64, bp+224, bp+228))
		if rc == 2 {
			iOffset = *(*int32)(unsafe.Pointer(bp + 228))
			continue
		}
		rc = libc.Xsscanf(tls, zIn+uintptr(i), ts+24409,
			libc.VaList(bp+80, bp+224, bp+232, bp+232+1*4, bp+232+2*4, bp+232+3*4, bp+232+4*4, bp+232+5*4, bp+232+6*4, bp+232+7*4,
				bp+232+8*4, bp+232+9*4, bp+232+10*4, bp+232+11*4, bp+232+12*4, bp+232+13*4, bp+232+14*4, bp+232+15*4))
		if rc == 17 {
			*(*int32)(unsafe.Pointer(bp + 228)) = iOffset + *(*int32)(unsafe.Pointer(bp + 224))
			if *(*int32)(unsafe.Pointer(bp + 228))+16 <= *(*int32)(unsafe.Pointer(bp + 216)) {
				var ii int32
				for ii = 0; ii < 16; ii++ {
					*(*uint8)(unsafe.Pointer(a + uintptr(*(*int32)(unsafe.Pointer(bp + 228))+ii))) = uint8(*(*uint32)(unsafe.Pointer(bp + 232 + uintptr(ii)*4)) & uint32(0xff))
				}
			}
			continue
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, a, *(*int32)(unsafe.Pointer(bp + 216))))
	libc.Xfree(tls, a)
	return TCL_OK
}

type AutovacPageData1 = struct {
	Finterp  uintptr
	FzScript uintptr
}

type AutovacPageData = AutovacPageData1

func test_autovacuum_pages_callback(tls *libc.TLS, pClientData uintptr, zSchema uintptr, nFilePages uint32, nFreePages uint32, nBytePerPage uint32) uint32 {
	bp := tls.Alloc(340)
	defer tls.Free(340)

	var pData uintptr = pClientData

	tcl.XTcl_DStringInit(tls, bp+24)
	tcl.XTcl_DStringAppend(tls, bp+24, (*AutovacPageData)(unsafe.Pointer(pData)).FzScript, -1)
	tcl.XTcl_DStringAppendElement(tls, bp+24, zSchema)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+236, ts+22730, libc.VaList(bp, nFilePages))
	tcl.XTcl_DStringAppendElement(tls, bp+24, bp+236)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+236, ts+22730, libc.VaList(bp+8, nFreePages))
	tcl.XTcl_DStringAppendElement(tls, bp+24, bp+236)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+236, ts+22730, libc.VaList(bp+16, nBytePerPage))
	tcl.XTcl_DStringAppendElement(tls, bp+24, bp+236)
	tcl.XTcl_ResetResult(tls, (*AutovacPageData)(unsafe.Pointer(pData)).Finterp)
	tcl.XTcl_Eval(tls, (*AutovacPageData)(unsafe.Pointer(pData)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp+24)).Fstring)
	tcl.XTcl_DStringFree(tls, bp+24)
	*(*uint32)(unsafe.Pointer(bp + 336)) = nFreePages
	tcl.XTcl_GetIntFromObj(tls, uintptr(0), tcl.XTcl_GetObjResult(tls, (*AutovacPageData)(unsafe.Pointer(pData)).Finterp), bp+336)
	return *(*uint32)(unsafe.Pointer(bp + 336))
}

func test_autovacuum_pages(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(1044)
	defer tls.Free(1044)

	var pData uintptr

	var rc int32
	var zScript uintptr
	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24463)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+40) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zScript = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	} else {
		zScript = uintptr(0)
	}
	if zScript != 0 {
		var nScript size_t = libc.Xstrlen(tls, zScript)
		pData = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(AutovacPageData{}))+nScript+uint32(1)))
		if pData == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2069, uintptr(0)))
			return TCL_ERROR
		}
		(*AutovacPageData)(unsafe.Pointer(pData)).Finterp = interp
		(*AutovacPageData)(unsafe.Pointer(pData)).FzScript = pData + 1*8
		libc.Xmemcpy(tls, (*AutovacPageData)(unsafe.Pointer(pData)).FzScript, zScript, nScript+size_t(1))
		rc = sqlite3.Xsqlite3_autovacuum_pages(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uint32, uint32, uint32) uint32
		}{test_autovacuum_pages_callback})),
			pData, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		rc = sqlite3.Xsqlite3_autovacuum_pages(tls, *(*uintptr)(unsafe.Pointer(bp + 40)), uintptr(0), uintptr(0), uintptr(0))
	}
	if rc != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+44,
			ts+24475, libc.VaList(bp+16, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, bp+44, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

func Sqlitetest1_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd1))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd1[i].FzName, aCmd1[i].FxProc, uintptr(0), uintptr(0))
	}
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd1))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd1[i].FzName,
			aObjCmd1[i].FxProc, aObjCmd1[i].FclientData, uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+24513,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_search_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24533,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_found_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24552,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sort_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24570,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_max_blobsize)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24591,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_like_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24609,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_interrupt_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24632,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_open_file_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24655,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_current_time)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24675,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_xferopt_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24697,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_readdb_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24724,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writedb_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24752,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writej_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24779,
		uintptr(unsafe.Pointer(&unaligned_string_counter)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24804,
		uintptr(unsafe.Pointer(&pzNeededCollation)), TCL_LINK_STRING|TCL_LINK_READ_ONLY)
	{
		tcl.XTcl_LinkVar(tls, interp, ts+24833,
			uintptr(unsafe.Pointer(&query_plan)), TCL_LINK_STRING|TCL_LINK_READ_ONLY)

	}
	tcl.XTcl_LinkVar(tls, interp, ts+24851,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_opentemp_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24873,
		uintptr(unsafe.Pointer(&sqlite_static_bind_value)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+24898,
		uintptr(unsafe.Pointer(&sqlite_static_bind_nbyte)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+24923,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_temp_directory)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+24945,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_data_directory)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+24967,
		uintptr(unsafe.Pointer(&bitmask_size)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	tcl.XTcl_LinkVar(tls, interp, ts+24980,
		uintptr(unsafe.Pointer(&longdouble_size)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	tcl.XTcl_LinkVar(tls, interp, ts+24996,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sync_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+25014,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_fullsync_count)), TCL_LINK_INT)
	return TCL_OK
}

var iZero int32 = 0
var aCmd1 = [40]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 25036, FxProc: 0},
	{FzName: ts + 25045, FxProc: 0},
	{FzName: ts + 25054, FxProc: 0},
	{FzName: ts + 25074, FxProc: 0},
	{FzName: ts + 25096, FxProc: 0},
	{FzName: ts + 25117, FxProc: 0},
	{FzName: ts + 25137, FxProc: 0},
	{FzName: ts + 25158, FxProc: 0},
	{FzName: ts + 25182, FxProc: 0},
	{FzName: ts + 25205, FxProc: 0},
	{FzName: ts + 25228, FxProc: 0},
	{FzName: ts + 25254, FxProc: 0},
	{FzName: ts + 25277, FxProc: 0},
	{FzName: ts + 25300, FxProc: 0},
	{FzName: ts + 25321, FxProc: 0},
	{FzName: ts + 25347, FxProc: 0},
	{FzName: ts + 25367, FxProc: 0},
	{FzName: ts + 25384, FxProc: 0},
	{FzName: ts + 25397, FxProc: 0},
	{FzName: ts + 25413, FxProc: 0},
	{FzName: ts + 25438, FxProc: 0},
	{FzName: ts + 25452, FxProc: 0},
	{FzName: ts + 25469, FxProc: 0},
	{FzName: ts + 25493, FxProc: 0},
	{FzName: ts + 25518, FxProc: 0},
	{FzName: ts + 25539, FxProc: 0},
	{FzName: ts + 25569, FxProc: 0},
	{FzName: ts + 25582, FxProc: 0},
	{FzName: ts + 25594, FxProc: 0},
	{FzName: ts + 25605, FxProc: 0},
	{FzName: ts + 25617, FxProc: 0},
	{FzName: ts + 25631, FxProc: 0},
	{FzName: ts + 25649, FxProc: 0},
	{FzName: ts + 25672, FxProc: 0},
	{FzName: ts + 25695, FxProc: 0},
	{FzName: ts + 25719, FxProc: 0},
	{FzName: ts + 25742, FxProc: 0},
	{FzName: ts + 25763, FxProc: 0},
	{FzName: ts + 25770, FxProc: 0},
	{FzName: ts + 25785, FxProc: 0},
}
var aObjCmd1 = [157]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 25808, FxProc: 0},
	{FzName: ts + 25826, FxProc: 0},
	{FzName: ts + 25844, FxProc: 0, FclientData: 0},
	{FzName: ts + 25857, FxProc: 0},
	{FzName: ts + 25878, FxProc: 0},
	{FzName: ts + 25905, FxProc: 0},
	{FzName: ts + 25919, FxProc: 0},
	{FzName: ts + 25935, FxProc: 0},
	{FzName: ts + 25952, FxProc: 0},
	{FzName: ts + 25967, FxProc: 0},
	{FzName: ts + 25984, FxProc: 0},
	{FzName: ts + 26006, FxProc: 0},
	{FzName: ts + 26030, FxProc: 0},
	{FzName: ts + 26049, FxProc: 0},
	{FzName: ts + 26069, FxProc: 0},
	{FzName: ts + 26087, FxProc: 0},
	{FzName: ts + 26105, FxProc: 0},
	{FzName: ts + 26125, FxProc: 0},
	{FzName: ts + 26143, FxProc: 0},
	{FzName: ts + 26174, FxProc: 0},
	{FzName: ts + 26208, FxProc: 0},
	{FzName: ts + 26228, FxProc: 0},
	{FzName: ts + 26257, FxProc: 0},
	{FzName: ts + 26285, FxProc: 0},
	{FzName: ts + 26314, FxProc: 0},
	{FzName: ts + 26337, FxProc: 0},
	{FzName: ts + 26351, FxProc: 0},
	{FzName: ts + 26367, FxProc: 0},
	{FzName: ts + 26392, FxProc: 0},
	{FzName: ts + 26407, FxProc: 0},
	{FzName: ts + 26428, FxProc: 0},
	{FzName: ts + 26445, FxProc: 0},
	{FzName: ts + 26458, FxProc: 0},
	{FzName: ts + 26473, FxProc: 0},
	{FzName: ts + 26489, FxProc: 0},
	{FzName: ts + 26508, FxProc: 0},
	{FzName: ts + 26526, FxProc: 0},
	{FzName: ts + 26542, FxProc: 0},
	{FzName: ts + 26560, FxProc: 0},
	{FzName: ts + 26579, FxProc: 0},
	{FzName: ts + 26598, FxProc: 0},
	{FzName: ts + 26622, FxProc: 0},
	{FzName: ts + 26643, FxProc: 0},
	{FzName: ts + 26660, FxProc: 0},
	{FzName: ts + 26680, FxProc: 0},
	{FzName: ts + 26694, FxProc: 0},
	{FzName: ts + 26710, FxProc: 0},
	{FzName: ts + 26736, FxProc: 0},
	{FzName: ts + 26752, FxProc: 0},
	{FzName: ts + 26765, FxProc: 0},
	{FzName: ts + 26777, FxProc: 0},
	{FzName: ts + 26798, FxProc: 0},
	{FzName: ts + 26816, FxProc: 0},
	{FzName: ts + 26838, FxProc: 0},
	{FzName: ts + 26861, FxProc: 0},
	{FzName: ts + 26879, FxProc: 0},
	{FzName: ts + 26897, FxProc: 0},
	{FzName: ts + 26920, FxProc: 0},
	{FzName: ts + 26946, FxProc: 0},
	{FzName: ts + 26968, FxProc: 0},
	{FzName: ts + 26989, FxProc: 0},
	{FzName: ts + 27009, FxProc: 0},
	{FzName: ts + 27029, FxProc: 0},
	{FzName: ts + 27053, FxProc: 0},
	{FzName: ts + 27079, FxProc: 0},
	{FzName: ts + 27105, FxProc: 0},
	{FzName: ts + 27128, FxProc: 0},
	{FzName: ts + 27152, FxProc: 0},
	{FzName: ts + 27175, FxProc: 0},
	{FzName: ts + 27205, FxProc: 0},
	{FzName: ts + 27235, FxProc: 0},
	{FzName: ts + 27249, FxProc: 0},
	{FzName: ts + 27277, FxProc: 0},
	{FzName: ts + 27293, FxProc: 0},
	{FzName: ts + 27312, FxProc: 0},
	{FzName: ts + 27329, FxProc: 0},
	{FzName: ts + 27339, FxProc: 0},
	{FzName: ts + 27359, FxProc: 0},
	{FzName: ts + 27382, FxProc: 0},
	{FzName: ts + 27406, FxProc: 0},
	{FzName: ts + 27427, FxProc: 0},
	{FzName: ts + 27439, FxProc: 0},
	{FzName: ts + 27460, FxProc: 0},
	{FzName: ts + 27479, FxProc: 0},
	{FzName: ts + 27499, FxProc: 0},
	{FzName: ts + 27519, FxProc: 0},
	{FzName: ts + 27541, FxProc: 0},
	{FzName: ts + 27562, FxProc: 0, FclientData: 0},
	{FzName: ts + 27582, FxProc: 0, FclientData: 0},
	{FzName: ts + 27602, FxProc: 0, FclientData: 0},
	{FzName: ts + 27621, FxProc: 0, FclientData: 0},
	{FzName: ts + 27642, FxProc: 0, FclientData: 0},
	{FzName: ts + 27666, FxProc: 0, FclientData: 0},
	{FzName: ts + 27695, FxProc: 0, FclientData: 0},
	{FzName: ts + 27721, FxProc: 0, FclientData: 0},
	{FzName: ts + 27748, FxProc: 0, FclientData: 0},
	{FzName: ts + 27771, FxProc: 0, FclientData: 0},
	{FzName: ts + 27793, FxProc: 0, FclientData: 0},
	{FzName: ts + 27815, FxProc: 0},
	{FzName: ts + 27845, FxProc: 0, FclientData: 0},
	{FzName: ts + 27871,
		FxProc: 0, FclientData: 0},
	{FzName: ts + 27902, FxProc: 0, FclientData: 0},
	{FzName: ts + 27930, FxProc: 0, FclientData: 0},
	{FzName: ts + 27959, FxProc: 0},
	{FzName: ts + 27987, FxProc: 0},
	{FzName: ts + 28010, FxProc: 0},
	{FzName: ts + 28028, FxProc: 0},
	{FzName: ts + 28044, FxProc: 0},
	{FzName: ts + 28062, FxProc: 0},
	{FzName: ts + 28081, FxProc: 0},
	{FzName: ts + 28100, FxProc: 0},
	{FzName: ts + 28118, FxProc: 0},
	{FzName: ts + 28146, FxProc: 0},
	{FzName: ts + 28174, FxProc: 0},
	{FzName: ts + 28202, FxProc: 0},
	{FzName: ts + 28229, FxProc: 0},
	{FzName: ts + 28255, FxProc: 0},
	{FzName: ts + 28280, FxProc: 0},
	{FzName: ts + 28313, FxProc: 0},
	{FzName: ts + 28334, FxProc: 0},
	{FzName: ts + 28360, FxProc: 0},
	{FzName: ts + 28386, FxProc: 0},
	{FzName: ts + 28415, FxProc: 0},
	{FzName: ts + 28432, FxProc: 0},
	{FzName: ts + 28459, FxProc: 0},
	{FzName: ts + 28476, FxProc: 0},
	{FzName: ts + 28500, FxProc: 0},
	{FzName: ts + 28518, FxProc: 0},
	{FzName: ts + 28544, FxProc: 0},
	{FzName: ts + 28564, FxProc: 0},
	{FzName: ts + 28582, FxProc: 0},
	{FzName: ts + 28610, FxProc: 0},
	{FzName: ts + 28638, FxProc: 0},
	{FzName: ts + 28664, FxProc: 0},
	{FzName: ts + 28694, FxProc: 0},
	{FzName: ts + 28714, FxProc: 0},
	{FzName: ts + 28727, FxProc: 0},
	{FzName: ts + 28749, FxProc: 0},
	{FzName: ts + 28772, FxProc: 0},
	{FzName: ts + 28798, FxProc: 0},
	{FzName: ts + 28825, FxProc: 0},
	{FzName: ts + 28842, FxProc: 0},
	{FzName: ts + 28867, FxProc: 0},
	{FzName: ts + 28888, FxProc: 0},
	{FzName: ts + 28898, FxProc: 0},
	{FzName: ts + 28920, FxProc: 0},
	{FzName: ts + 28941, FxProc: 0},
	{FzName: ts + 28966, FxProc: 0},
	{FzName: ts + 28989, FxProc: 0},
	{FzName: ts + 29013, FxProc: 0},
	{FzName: ts + 29032, FxProc: 0},
	{FzName: ts + 29050, FxProc: 0},
	{FzName: ts + 29075, FxProc: 0},
	{FzName: ts + 29100, FxProc: 0},
	{FzName: ts + 29113, FxProc: 0},
	{FzName: ts + 29127, FxProc: 0},
	{FzName: ts + 29153, FxProc: 0},
}
var bitmask_size int32 = int32(uint32(unsafe.Sizeof(Bitmask(0))) * uint32(8))
var longdouble_size int32 = int32(unsafe.Sizeof(float64(0)))
var query_plan uintptr = ts + 29181

var test_pagesize int32 = 1024

func pager_test_reiniter(tls *libc.TLS, pNotUsed uintptr) {
	return
}

func pager_open(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(184)
	defer tls.Free(184)

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29207, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerOpen(tls, sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)), bp+76, *(*uintptr)(unsafe.Pointer(argv + 1*4)), 0, 0,
		SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_MAIN_DB,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{pager_test_reiniter})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3PagerSetCachesize(tls, *(*uintptr)(unsafe.Pointer(bp + 76)), *(*int32)(unsafe.Pointer(bp + 72)))
	*(*u32)(unsafe.Pointer(bp + 80)) = u32(test_pagesize)
	sqlite3.Xsqlite3PagerSetPagesize(tls, *(*uintptr)(unsafe.Pointer(bp + 76)), bp+80, -1)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+84, ts+14791, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 76))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+84, 0))
	return TCL_OK
}

func pager_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerClose(tls, pPager, uintptr(0))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func pager_rollback(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerRollback(tls, pPager)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func pager_commit(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerCommitPhaseOne(tls, pPager, uintptr(0), 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerCommitPhaseTwo(tls, pPager)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func pager_stmt_begin(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerOpenSavepoint(tls, pPager, 1)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func pager_stmt_rollback(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_ROLLBACK, 0)
	sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_RELEASE, 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func pager_stmt_commit(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_RELEASE, 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func pager_stats(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pPager uintptr
	var i int32
	var a uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	a = sqlite3.Xsqlite3PagerStats(tls, pPager)
	for i = 0; i < 9; i++ {
		tcl.XTcl_AppendElement(tls, interp, zName[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40, ts+1333, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40)
	}
	return TCL_OK
}

var zName = [9]uintptr{
	ts + 29230, ts + 29234, ts + 23193, ts + 16776, ts + 9913, ts + 29239,
	ts + 29243, ts + 29247, ts + 29252,
}

func pager_pagecount(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3PagerPagecount(tls, pPager, bp+56)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60, ts+1333, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 56))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60, 0))
	return TCL_OK
}

func page_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(180)
	defer tls.Free(180)

	var pPager uintptr

	*(*uintptr)(unsafe.Pointer(bp + 76)) = uintptr(0)

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29257, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerSharedLock(tls, pPager)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3PagerGet(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 72))), bp+76, 0)
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+80, ts+14791, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 76))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+80, 0))
	return TCL_OK
}

func page_lookup(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr

	var pPage uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29257, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+56) != 0 {
		return TCL_ERROR
	}
	pPage = sqlite3.Xsqlite3PagerLookup(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 56))))
	if pPage != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60, ts+14791, libc.VaList(bp+32, pPage))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60, 0))
	}
	return TCL_OK
}

func pager_truncate(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pPager uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29257, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3PagerTruncateImage(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 32))))
	return TCL_OK
}

func page_unref(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29267, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3PagerUnref(tls, pPage)
	return TCL_OK
}

func page_read(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(148)
	defer tls.Free(148)

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29267, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	libc.Xmemcpy(tls, bp+48, sqlite3.Xsqlite3PagerGetData(tls, pPage), uint32(unsafe.Sizeof([100]int8{})))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+48, 0))
	return TCL_OK
}

func page_number(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(156)
	defer tls.Free(156)

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29267, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+56, ts+1333, libc.VaList(bp+32, sqlite3.Xsqlite3PagerPagenumber(tls, pPage)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56, 0))
	return TCL_OK
}

func page_write(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPage uintptr
	var pData uintptr
	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29274, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3PagerWrite(tls, pPage)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	pData = sqlite3.Xsqlite3PagerGetData(tls, pPage)
	libc.Xstrncpy(tls, pData, *(*uintptr)(unsafe.Pointer(argv + 2*4)), uint32(test_pagesize-1))
	*(*int8)(unsafe.Pointer(pData + uintptr(test_pagesize-1))) = int8(0)
	return TCL_OK
}

func fake_big_file(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var pVfs uintptr
	*(*uintptr)(unsafe.Pointer(bp + 84)) = uintptr(0)
	var rc int32

	var offset i64
	var zFile uintptr
	var nFile int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29286, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+80) != 0 {
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nFile = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	zFile = sqlite3.Xsqlite3_malloc(tls, nFile+2)
	if zFile == uintptr(0) {
		return TCL_ERROR
	}
	libc.Xmemcpy(tls, zFile, *(*uintptr)(unsafe.Pointer(argv + 2*4)), uint32(nFile+1))
	*(*int8)(unsafe.Pointer(zFile + uintptr(nFile+1))) = int8(0)
	rc = sqlite3.Xsqlite3OsOpenMalloc(tls, pVfs, zFile, bp+84,
		SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB, uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+29305, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		sqlite3.Xsqlite3_free(tls, zFile)
		return TCL_ERROR
	}
	offset = i64(*(*int32)(unsafe.Pointer(bp + 80)))
	offset = offset * int64(1024*1024)
	rc = sqlite3.Xsqlite3OsWrite(tls, *(*uintptr)(unsafe.Pointer(bp + 84)), ts+29319, 14, offset)
	sqlite3.Xsqlite3OsCloseFree(tls, *(*uintptr)(unsafe.Pointer(bp + 84)))
	sqlite3.Xsqlite3_free(tls, zFile)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, ts+29333, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func testPendingByte(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29348, uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+40) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PENDING_BYTE, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 40))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

var faultSimInterp uintptr = uintptr(0)
var faultSimScriptSize int32 = 0
var faultSimScript uintptr

func faultSimCallback(tls *libc.TLS, x int32) int32 {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var i int32
	var isNeg int32
	var rc int32
	if x == 0 {
		libc.Xmemcpy(tls, faultSimScript+uintptr(faultSimScriptSize), ts+19147, uint32(2))
	} else {
		if x < 0 {
			isNeg = 1
			x = -x
		} else {
			isNeg = 0
		}
		*(*int8)(unsafe.Pointer(bp + 8 + 29)) = int8(0)
		i = int32(uint32(unsafe.Sizeof([30]int8{})) - uint32(2))
	__1:
		if !(i > 0 && x > 0) {
			goto __3
		}
		{
			*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i))) = int8(x%10 + '0')

		}
		goto __2
	__2:
		i--
		x = x / 10
		goto __1
		goto __3
	__3:
		;
		if isNeg != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 + uintptr(libc.PostDecInt32(&i, 1)))) = int8('-')
		}
		libc.Xmemcpy(tls, faultSimScript+uintptr(faultSimScriptSize), bp+8+uintptr(i)+uintptr(1), uint32(unsafe.Sizeof([30]int8{}))-uint32(i))
	}
	rc = tcl.XTcl_Eval(tls, faultSimInterp, faultSimScript)
	if rc != 0 {
		libc.Xfprintf(tls, libc.X__stderrp, ts+29363, libc.VaList(bp, faultSimScript))
		rc = SQLITE_ERROR
	} else {
		rc = libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, faultSimInterp))
	}
	tcl.XTcl_ResetResult(tls, faultSimInterp)
	return rc
}

func faultInstallCmd(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var zScript uintptr
	var nScript int32
	var rc int32
	if argc != 1 && argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29399, uintptr(0)))
	}
	if argc == 2 {
		zScript = *(*uintptr)(unsafe.Pointer(argv + 1*4))
	} else {
		zScript = ts + 584
	}
	nScript = int32(libc.Xstrlen(tls, zScript))
	if faultSimScript != 0 {
		libc.Xfree(tls, faultSimScript)
		faultSimScript = uintptr(0)
	}
	if nScript == 0 {
		rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_FAULT_INSTALL, libc.VaList(bp+32, 0))
	} else {
		faultSimScript = libc.Xmalloc(tls, uint32(nScript+100))
		if faultSimScript == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+2069, uintptr(0)))
			return SQLITE_ERROR
		}
		libc.Xmemcpy(tls, faultSimScript, zScript, uint32(nScript))
		*(*int8)(unsafe.Pointer(faultSimScript + uintptr(nScript))) = int8(' ')
		faultSimScriptSize = nScript + 1
		faultSimInterp = interp
		rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_FAULT_INSTALL, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{faultSimCallback}))))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return SQLITE_OK
}

func testBitvecBuiltinTest(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(452)
	defer tls.Free(452)

	var rc int32
	var nProg int32 = 0

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29408, uintptr(0)))
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+48) != 0 {
		return TCL_ERROR
	}
	z = *(*uintptr)(unsafe.Pointer(argv + 2*4))
	for nProg < 99 && *(*int8)(unsafe.Pointer(z)) != 0 {
		for *(*int8)(unsafe.Pointer(z)) != 0 && !(int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x04 != 0) {
			z++
		}
		if int32(*(*int8)(unsafe.Pointer(z))) == 0 {
			break
		}
		*(*int32)(unsafe.Pointer(bp + 52 + uintptr(libc.PostIncInt32(&nProg, 1))*4)) = libc.Xatoi(tls, z)
		for int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x04 != 0 {
			z++
		}
	}
	*(*int32)(unsafe.Pointer(bp + 52 + uintptr(nProg)*4)) = 0
	rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BITVEC_TEST, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 48)), bp+52))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func Sqlitetest2_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd2))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd2[i].FzName, aCmd2[i].FxProc, uintptr(0), uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+29423,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_pending)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+29447,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_persist)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+29471,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hit)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+29491,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hardhit)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+29515,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull_pending)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+29539,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+29555,
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3PendingByte)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	return TCL_OK
}

var aCmd2 = [20]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 29575, FxProc: 0},
	{FzName: ts + 29586, FxProc: 0},
	{FzName: ts + 29598, FxProc: 0},
	{FzName: ts + 29611, FxProc: 0},
	{FzName: ts + 29626, FxProc: 0},
	{FzName: ts + 29643, FxProc: 0},
	{FzName: ts + 29661, FxProc: 0},
	{FzName: ts + 29681, FxProc: 0},
	{FzName: ts + 29693, FxProc: 0},
	{FzName: ts + 29709, FxProc: 0},
	{FzName: ts + 29718, FxProc: 0},
	{FzName: ts + 29730, FxProc: 0},
	{FzName: ts + 29741, FxProc: 0},
	{FzName: ts + 29751, FxProc: 0},
	{FzName: ts + 29762, FxProc: 0},
	{FzName: ts + 29774, FxProc: 0},
	{FzName: ts + 29789, FxProc: 0},
	{FzName: ts + 29803, FxProc: 0},
	{FzName: ts + 29828, FxProc: 0},
	{FzName: ts + 29862, FxProc: 0},
}

type Btree = Btree1
type BtCursor = BtCursor1
type BtShared = BtShared1

type MemPage1 = struct {
	FisInit          u8
	FintKey          u8
	FintKeyLeaf      u8
	F__ccgo_pad1     [1]byte
	Fpgno            Pgno
	Fleaf            u8
	FhdrOffset       u8
	FchildPtrSize    u8
	Fmax1bytePayload u8
	FnOverflow       u8
	F__ccgo_pad2     [1]byte
	FmaxLocal        u16
	FminLocal        u16
	FcellOffset      u16
	FnFree           int32
	FnCell           u16
	FmaskPage        u16
	FaiOvfl          [4]u16
	FapOvfl          [4]uintptr
	FpBt             uintptr
	FaData           uintptr
	FaDataEnd        uintptr
	FaCellIdx        uintptr
	FaDataOfst       uintptr
	FpDbPage         uintptr
	FxCellSize       uintptr
	FxParseCell      uintptr
}

type MemPage = MemPage1
type BtLock1 = struct {
	FpBtree      uintptr
	FiTable      Pgno
	FeLock       u8
	F__ccgo_pad1 [3]byte
	FpNext       uintptr
}

type BtLock = BtLock1
type CellInfo1 = struct {
	FnKey     i64
	FpPayload uintptr
	FnPayload u32
	FnLocal   u16
	FnSize    u16
}

type CellInfo = CellInfo1

type IntegrityCk1 = struct {
	FpBt    uintptr
	FpPager uintptr
	FaPgRef uintptr
	FnPage  Pgno
	FmxErr  int32
	FnErr   int32
	Frc     int32
	FnStep  u32
	FzPfx   uintptr
	Fv1     Pgno
	Fv2     int32
	FerrMsg StrAccum
	Fheap   uintptr
	Fdb     uintptr
}

type IntegrityCk = IntegrityCk1

var sDb sqlite31
var nRefSqlite3 int32 = 0

func btree_open(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(180)
	defer tls.Free(180)

	var rc int32

	var n int32
	var zFilename uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29897, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72) != 0 {
		return TCL_ERROR
	}
	nRefSqlite3++
	if nRefSqlite3 == 1 {
		sDb.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		sDb.Fmutex = sqlite3.Xsqlite3MutexAlloc(tls, SQLITE_MUTEX_RECURSIVE)
		sqlite3.Xsqlite3_mutex_enter(tls, sDb.Fmutex)
	}
	n = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	zFilename = sqlite3.Xsqlite3_malloc(tls, n+2)
	if zFilename == uintptr(0) {
		return TCL_ERROR
	}
	libc.Xmemcpy(tls, zFilename, *(*uintptr)(unsafe.Pointer(argv + 1*4)), uint32(n+1))
	*(*int8)(unsafe.Pointer(zFilename + uintptr(n+1))) = int8(0)
	rc = sqlite3.Xsqlite3BtreeOpen(tls, sDb.FpVfs, zFilename, uintptr(unsafe.Pointer(&sDb)), bp+76, 0,
		SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_MAIN_DB)
	sqlite3.Xsqlite3_free(tls, zFilename)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, *(*uintptr)(unsafe.Pointer(bp + 76)), *(*int32)(unsafe.Pointer(bp + 72)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+80, ts+14791, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 76))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+80, 0))
	return TCL_OK
}

func btree_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	rc = sqlite3.Xsqlite3BtreeClose(tls, pBt)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	nRefSqlite3--
	if nRefSqlite3 == 0 {
		sqlite3.Xsqlite3_mutex_leave(tls, sDb.Fmutex)
		sqlite3.Xsqlite3_mutex_free(tls, sDb.Fmutex)
		sDb.Fmutex = uintptr(0)
		sDb.FpVfs = uintptr(0)
	}
	return TCL_OK
}

func btree_begin_transaction(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeBeginTrans(tls, pBt, 1, uintptr(0))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func btree_pager_stats(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pBt uintptr
	var i int32
	var a uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)

	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	for i = 0; i < 11; i++ {
		tcl.XTcl_AppendElement(tls, interp, zName1[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40, ts+1333, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)

	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return TCL_OK
}

var zName1 = [11]uintptr{
	ts + 29230, ts + 29234, ts + 23193, ts + 16776, ts + 9913, ts + 29239,
	ts + 29243, ts + 29247, ts + 29252, ts + 29921, ts + 29926,
}

func btree_cursor(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(110)
	defer tls.Free(110)

	var pBt uintptr

	var pCur uintptr
	var rc int32 = SQLITE_OK

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29932, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+72) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBoolean(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*4)), bp+76) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 76)) != 0 {
		*(*int32)(unsafe.Pointer(bp + 76)) = BTREE_WRCSR
	}
	pCur = tcl.XTcl_Alloc(tls, uint32(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	libc.Xmemset(tls, pCur, 0, uint32(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeLockTable(tls, pBt, *(*int32)(unsafe.Pointer(bp + 72)), libc.BoolUint8(!!(*(*int32)(unsafe.Pointer(bp + 76)) != 0)))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3BtreeCursor(tls, pBt, uint32(*(*int32)(unsafe.Pointer(bp + 72))), *(*int32)(unsafe.Pointer(bp + 76)), uintptr(0), pCur)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	if rc != 0 {
		tcl.XTcl_Free(tls, pCur)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+80, ts+14791, libc.VaList(bp+48, pCur))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+80, 0))
	return SQLITE_OK
}

func btree_close_cursor(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pCur uintptr
	var rc int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	{
		var pBt uintptr = (*BtCursor)(unsafe.Pointer(pCur)).FpBtree
		sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
		sqlite3.Xsqlite3BtreeEnter(tls, pBt)
		rc = sqlite3.Xsqlite3BtreeCloseCursor(tls, pCur)
		sqlite3.Xsqlite3BtreeLeave(tls, pBt)
		sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)

	}
	tcl.XTcl_Free(tls, pCur)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return SQLITE_OK
}

func btree_next(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var pCur uintptr
	var rc int32
	var res int32 = 0

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeNext(tls, pCur, 0)
	if rc == SQLITE_DONE {
		res = 1
		rc = SQLITE_OK
	}
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72, ts+1333, libc.VaList(bp+48, res))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72, 0))
	return SQLITE_OK
}

func btree_first(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var pCur uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 72)) = 0

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeFirst(tls, pCur, bp+72)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76, ts+1333, libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 72))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+76, 0))
	return SQLITE_OK
}

func btree_eof(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var rc int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeEof(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56, ts+1333, libc.VaList(bp+32, rc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56, 0))
	return SQLITE_OK
}

func btree_payload_size(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var n u32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	n = sqlite3.Xsqlite3BtreePayloadSize(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56, ts+22730, libc.VaList(bp+32, n))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56, 0))
	return SQLITE_OK
}

func btree_varint_test(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(512)
	defer tls.Free(512)

	var in u64

	var n1 int32
	var n2 int32
	var i int32
	var j int32

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29956, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+184) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+188) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*4)), bp+192) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*4)), bp+196) != 0 {
		return TCL_ERROR
	}
	in = u64(*(*u32)(unsafe.Pointer(bp + 184)))
	in = in * u64(*(*u32)(unsafe.Pointer(bp + 188)))
	for i = 0; i < int32(*(*u32)(unsafe.Pointer(bp + 192))); i++ {
		n1 = sqlite3.Xsqlite3PutVarint(tls, bp+200, in)
		if n1 > 9 || n1 < 1 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300,
				ts+29991, libc.VaList(bp+32, n1))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+300, 0))
			return TCL_ERROR
		}
		n2 = int32(sqlite3.Xsqlite3GetVarint(tls, bp+200, bp+500))
		if n1 != n2 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300,
				ts+30041, libc.VaList(bp+56, n1, n2))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, bp+300, 0))
			return TCL_ERROR
		}
		if in != *(*u64)(unsafe.Pointer(bp + 500)) {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300,
				ts+30089, libc.VaList(bp+88, in, *(*u64)(unsafe.Pointer(bp + 500))))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+104, bp+300, 0))
			return TCL_ERROR
		}
		if in&uint64(0xffffffff) == in {
			n2 = int32(func() uint8 {
				if int32(*(*uint8)(unsafe.Pointer(bp + 200))) < int32(u8(0x80)) {
					return uint8(func() int32 { *(*u32)(unsafe.Pointer(bp + 508)) = u32(*(*uint8)(unsafe.Pointer(bp + 200))); return 1 }())
				}
				return sqlite3.Xsqlite3GetVarint32(tls, bp+200, bp+508)
			}())
			*(*u64)(unsafe.Pointer(bp + 500)) = u64(*(*u32)(unsafe.Pointer(bp + 508)))
			if n1 != n2 {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300,
					ts+30128,
					libc.VaList(bp+120, n1, n2))
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+136, bp+300, 0))
				return TCL_ERROR
			}
			if in != *(*u64)(unsafe.Pointer(bp + 500)) {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300,
					ts+30178,
					libc.VaList(bp+152, in, *(*u64)(unsafe.Pointer(bp + 500))))
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+168, bp+300, 0))
				return TCL_ERROR
			}
		}

		for j = 0; j < 19; j++ {
			sqlite3.Xsqlite3GetVarint(tls, bp+200, bp+500)
		}
		in = in + u64(*(*u32)(unsafe.Pointer(bp + 196)))
	}
	return TCL_OK
}

func btree_from_db(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(204)
	defer tls.Free(204)

	var db uintptr
	var pBt uintptr
	var iDb int32 = 0

	if argc != 2 && argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30234, 0))
		return TCL_ERROR
	}

	if 1 != tcl.XTcl_GetCommandInfo(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)), bp+72) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30250, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+16912, 0))
		return TCL_ERROR
	}
	if argc == 3 {
		iDb = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	}

	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 72)).FobjClientData))

	pBt = (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(db)).FaDb + uintptr(iDb)*16)).FpBt
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+104, ts+14791, libc.VaList(bp+64, pBt))
	tcl.XTcl_SetResult(tls, interp, bp+104, uintptr(1))
	return TCL_OK
}

func btree_ismemdb(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pBt uintptr
	var res int32
	var pFile uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+29225, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	pFile = sqlite3.Xsqlite3PagerFile(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	res = libc.Bool32((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods == uintptr(0))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(res != 0)))
	return SQLITE_OK
}

func btree_set_cache_size(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pBt uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls,
			interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)), ts+30271, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+32) != 0 {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, pBt, *(*int32)(unsafe.Pointer(bp + 32)))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return TCL_OK
}

func btree_insert(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var pCur uintptr

	if objc != 4 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+30283)
		return TCL_ERROR
	}

	libc.Xmemset(tls, bp+16, 0, uint32(unsafe.Sizeof(BtreePayload{})))
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+48) != 0 {
			return TCL_ERROR
		}
		(*BtreePayload)(unsafe.Pointer(bp + 16)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 48)))
		(*BtreePayload)(unsafe.Pointer(bp + 16)).FpData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+16+24)
	} else {
		(*BtreePayload)(unsafe.Pointer(bp + 16)).FpKey = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+48)
		(*BtreePayload)(unsafe.Pointer(bp + 16)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 48)))
	}
	pCur = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	*(*int32)(unsafe.Pointer(bp + 48)) = sqlite3.Xsqlite3BtreeInsert(tls, pCur, bp+16, 0, 0)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)

	tcl.XTcl_ResetResult(tls, interp)
	if *(*int32)(unsafe.Pointer(bp + 48)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, *(*int32)(unsafe.Pointer(bp + 48))), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

func Sqlitetest3_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd3))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd3[i].FzName, aCmd3[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_CreateObjCommand(tls, interp, ts+30307, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{btree_insert})), uintptr(0), uintptr(0))

	return TCL_OK
}

var aCmd3 = [14]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 30320, FxProc: 0},
	{FzName: ts + 30331, FxProc: 0},
	{FzName: ts + 30343, FxProc: 0},
	{FzName: ts + 30367, FxProc: 0},
	{FzName: ts + 30385, FxProc: 0},
	{FzName: ts + 30398, FxProc: 0},
	{FzName: ts + 30417, FxProc: 0},
	{FzName: ts + 30428, FxProc: 0},
	{FzName: ts + 30438, FxProc: 0},
	{FzName: ts + 30457, FxProc: 0},
	{FzName: ts + 30469, FxProc: 0},
	{FzName: ts + 30487, FxProc: 0},
	{FzName: ts + 30501, FxProc: 0},
	{FzName: ts + 30515, FxProc: 0},
}

type sched_param = struct{ Fsched_priority int32 }

type _cpuset = struct{ F__bits [8]int32 }

type cpuset_t = _cpuset
type cpu_set_t = _cpuset

type _pthread_cleanup_info = struct{ Fpthread_cleanup_pad [8]uint32 }

type Thread1 = struct {
	FzFilename  uintptr
	FxOp        uintptr
	FzArg       uintptr
	Fopnum      int32
	Fbusy       int32
	Fcompleted  int32
	Fdb         uintptr
	FpStmt      uintptr
	FzErr       uintptr
	FzStaticErr uintptr
	Frc         int32
	Fargc       int32
	Fargv       [100]uintptr
	Fcolv       [100]uintptr
}

type Thread = Thread1

var threadset [26]Thread

func test_barrier(tls *libc.TLS) {
	var pMutex uintptr = sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_APP1)
	sqlite3.Xsqlite3_mutex_enter(tls, pMutex)
	sqlite3.Xsqlite3_mutex_leave(tls, pMutex)
}

func test_thread_main(tls *libc.TLS, pArg uintptr) uintptr {
	var p uintptr = pArg
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
	}
	sqlite3.Xsqlite3_open(tls, (*Thread)(unsafe.Pointer(p)).FzFilename, p+24)
	if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*Thread)(unsafe.Pointer(p)).Fdb) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.Xstrdup(tls, sqlite3.Xsqlite3_errmsg(tls, (*Thread)(unsafe.Pointer(p)).Fdb))
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	test_barrier(tls)
	(*Thread)(unsafe.Pointer(p)).Fcompleted = 1
	for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
		libc.Xsched_yield(tls)
	}
	test_barrier(tls)
	for (*Thread)(unsafe.Pointer(p)).FxOp != 0 {
		if (*Thread)(unsafe.Pointer(p)).FzErr != 0 && (*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr {
			sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
			(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Thread)(unsafe.Pointer(p)).FxOp})).f(tls, p)
		test_barrier(tls)
		(*Thread)(unsafe.Pointer(p)).Fcompleted++
		for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
			libc.Xsched_yield(tls)
		}
		test_barrier(tls)
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	if (*Thread)(unsafe.Pointer(p)).FzErr != 0 && (*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr {
		sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
		(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
	}
	test_barrier(tls)
	(*Thread)(unsafe.Pointer(p)).Fcompleted++
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return uintptr(0)
}

func parse_thread_id(tls *libc.TLS, interp uintptr, zArg uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if zArg == uintptr(0) || int32(*(*int8)(unsafe.Pointer(zArg))) == 0 || int32(*(*int8)(unsafe.Pointer(zArg + 1))) != 0 || !(__sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zArg)))), uint32(X_CTYPE_U)) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+30536, 0))
		return -1
	}
	return int32(*(*int8)(unsafe.Pointer(zArg))) - 'A'
}

func tcl_thread_create(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var i int32

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30575, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if threadset[i].Fbusy != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30588, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+30596, 0))
		return TCL_ERROR
	}
	threadset[i].Fbusy = 1
	sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
	threadset[i].FzFilename = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	threadset[i].Fopnum = 1
	threadset[i].Fcompleted = 0
	rc = libc.Xpthread_create(tls, bp+88, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{test_thread_main})), uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+30616, 0))
		sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
		threadset[i].Fbusy = 0
		return TCL_ERROR
	}
	libc.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp + 88)))
	return TCL_OK
}

func test_thread_wait(tls *libc.TLS, p uintptr) {
	test_barrier(tls)
	for (*Thread)(unsafe.Pointer(p)).Fopnum > (*Thread)(unsafe.Pointer(p)).Fcompleted {
		libc.Xsched_yield(tls)
	}
	test_barrier(tls)
}

func tcl_thread_wait(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30644, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	return TCL_OK
}

func test_stop_thread(tls *libc.TLS, p uintptr) {
	test_thread_wait(tls, p)
	(*Thread)(unsafe.Pointer(p)).FxOp = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fopnum++
	test_thread_wait(tls, p)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzArg)
	(*Thread)(unsafe.Pointer(p)).FzArg = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzFilename)
	(*Thread)(unsafe.Pointer(p)).FzFilename = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fbusy = 0
}

func tcl_thread_halt(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30644, 0))
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*4))))) == '*' && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*4)) + 1))) == 0 {
		for i = 0; i < N_THREAD; i++ {
			if threadset[i].Fbusy != 0 {
				test_stop_thread(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
			}
		}
	} else {
		i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		if i < 0 {
			return TCL_ERROR
		}
		if !(threadset[i].Fbusy != 0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
			return TCL_ERROR
		}
		test_stop_thread(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	}
	return TCL_OK
}

func tcl_thread_argc(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30644, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72, ts+1333, libc.VaList(bp+48, threadset[i].Fargc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72, 0))
	return TCL_OK
}

func tcl_thread_argv(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30663, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+80) != 0 {
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 || *(*int32)(unsafe.Pointer(bp + 80)) >= threadset[i].Fargc {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+30669, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848 + 48 + uintptr(*(*int32)(unsafe.Pointer(bp + 80)))*4)), 0))
	return TCL_OK
}

func tcl_thread_colname(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30663, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)), bp+80) != 0 {
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 || *(*int32)(unsafe.Pointer(bp + 80)) >= threadset[i].Fargc {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+30669, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*848 + 448 + uintptr(*(*int32)(unsafe.Pointer(bp + 80)))*4)), 0))
	return TCL_OK
}

func tcl_thread_result(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var zName uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30644, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	zName = sqlite3.Xsqlite3ErrName(tls, threadset[i].Frc)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, zName, 0))
	return TCL_OK
}

func tcl_thread_error(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30644, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, threadset[i].FzErr, 0))
	return TCL_OK
}

func do_compile(tls *libc.TLS, p uintptr) {
	if (*Thread)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36, ts+30696)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_prepare(tls, (*Thread)(unsafe.Pointer(p)).Fdb, (*Thread)(unsafe.Pointer(p)).FzArg, -1, p+28, uintptr(0))
}

func tcl_thread_compile(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30716, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_compile}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	test_barrier(tls)
	threadset[i].Fopnum++
	return TCL_OK
}

func do_step(tls *libc.TLS, p uintptr) {
	var i int32
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36, ts+30724)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_step(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	if (*Thread)(unsafe.Pointer(p)).Frc == SQLITE_ROW {
		(*Thread)(unsafe.Pointer(p)).Fargc = sqlite3.Xsqlite3_column_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		for i = 0; i < sqlite3.Xsqlite3_data_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt); i++ {
			*(*uintptr)(unsafe.Pointer(p + 48 + uintptr(i)*4)) = sqlite3.Xsqlite3_column_text(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
		for i = 0; i < (*Thread)(unsafe.Pointer(p)).Fargc; i++ {
			*(*uintptr)(unsafe.Pointer(p + 448 + uintptr(i)*4)) = sqlite3.Xsqlite3_column_name(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
	}
}

func tcl_thread_step(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30753, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_step}))
	test_barrier(tls)
	threadset[i].Fopnum++
	return TCL_OK
}

func do_finalize(tls *libc.TLS, p uintptr) {
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+36, ts+30724)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

func tcl_thread_finalize(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30753, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_finalize}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = uintptr(0)
	test_barrier(tls)
	threadset[i].Fopnum++
	return TCL_OK
}

func tcl_thread_swap(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var j int32
	var temp uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30758, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	j = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	if j < 0 {
		return TCL_ERROR
	}
	if !(threadset[j].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(j)*848)
	temp = threadset[i].Fdb
	threadset[i].Fdb = threadset[j].Fdb
	threadset[j].Fdb = temp
	return TCL_OK
}

func tcl_thread_db_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30644, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	sqlite3TestMakePointerStr(tls, interp, bp+64, threadset[i].Fdb)
	threadset[i].Fdb = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+64, uintptr(0)))
	return TCL_OK
}

func tcl_thread_db_put(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30767, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)

	threadset[i].Fdb = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
	return TCL_OK
}

func tcl_thread_stmt_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+30644, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+30648, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*848)
	sqlite3TestMakePointerStr(tls, interp, bp+64, threadset[i].FpStmt)
	threadset[i].FpStmt = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+64, uintptr(0)))
	return TCL_OK
}

func Sqlitetest4_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd4))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd4[i].FzName, aCmd4[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aCmd4 = [15]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 30774, FxProc: 0},
	{FzName: ts + 30788, FxProc: 0},
	{FzName: ts + 30800, FxProc: 0},
	{FzName: ts + 30812, FxProc: 0},
	{FzName: ts + 30824, FxProc: 0},
	{FzName: ts + 30836, FxProc: 0},
	{FzName: ts + 30851, FxProc: 0},
	{FzName: ts + 30865, FxProc: 0},
	{FzName: ts + 30878, FxProc: 0},
	{FzName: ts + 30893, FxProc: 0},
	{FzName: ts + 30905, FxProc: 0},
	{FzName: ts + 30921, FxProc: 0},
	{FzName: ts + 30933, FxProc: 0},
	{FzName: ts + 30947, FxProc: 0},
	{FzName: ts + 30961, FxProc: 0},
}

func binarize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var bytes uintptr
	var pRet uintptr

	bytes = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp)
	pRet = tcl.XTcl_NewByteArrayObj(tls, bytes, *(*int32)(unsafe.Pointer(bp))+1)
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

func test_value_overhead(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var i int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+30977, 0))
		return TCL_ERROR
	}

	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+36) != 0 {
		return TCL_ERROR
	}

	(*Mem)(unsafe.Pointer(bp + 40)).Fflags = u16(MEM_Str | MEM_Term | MEM_Static)
	(*Mem)(unsafe.Pointer(bp + 40)).Fz = ts + 31004
	(*Mem)(unsafe.Pointer(bp + 40)).Fenc = u8(SQLITE_UTF8)

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 32)); i++ {
		if *(*int32)(unsafe.Pointer(bp + 36)) != 0 {
			sqlite3.Xsqlite3_value_text(tls, bp+40)
		}
	}

	return TCL_OK
}

func name_to_enc(tls *libc.TLS, interp uintptr, pObj uintptr) u8 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	*(*[5]EncName)(unsafe.Pointer(bp + 24)) = [5]EncName{
		{FzName: ts + 31016, Fenc: u8(SQLITE_UTF8)},
		{FzName: ts + 31021, Fenc: u8(SQLITE_UTF16LE)},
		{FzName: ts + 31029, Fenc: u8(SQLITE_UTF16BE)},
		{FzName: ts + 31037, Fenc: u8(SQLITE_UTF16)},
		{},
	}
	var pEnc uintptr
	var z uintptr = tcl.XTcl_GetString(tls, pObj)
	for pEnc = bp + 24; (*EncName)(unsafe.Pointer(pEnc)).FzName != 0; pEnc += 8 {
		if 0 == sqlite3.Xsqlite3StrICmp(tls, z, (*EncName)(unsafe.Pointer(pEnc)).FzName) {
			break
		}
	}
	if !(int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+31043, z, 0))
	}
	if int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) == SQLITE_UTF16 {
		return u8(SQLITE_UTF16LE)
	}
	return (*EncName)(unsafe.Pointer(pEnc)).Fenc
}

type EncName = struct {
	FzName       uintptr
	Fenc         u8
	F__ccgo_pad1 [3]byte
}

func test_translate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var enc_from u8
	var enc_to u8
	var pVal uintptr
	var z uintptr

	var xDel uintptr = uintptr(0)

	if objc != 4 && objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)),
			ts+31062, 0))
		return TCL_ERROR
	}
	if objc == 5 {
		xDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))
	}

	enc_from = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if !(enc_from != 0) {
		return TCL_ERROR
	}
	enc_to = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if !(enc_to != 0) {
		return TCL_ERROR
	}

	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))

	if int32(enc_from) == SQLITE_UTF8 {
		z = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
		if objc == 5 {
			z = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+32, z))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	} else {
		z = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+40)
		if objc == 5 {
			var zTmp uintptr = z
			z = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 40)))
			libc.Xmemcpy(tls, z, zTmp, uint32(*(*int32)(unsafe.Pointer(bp + 40))))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	}

	z = sqlite3.Xsqlite3ValueText(tls, pVal, enc_to)
	*(*int32)(unsafe.Pointer(bp + 40)) = sqlite3.Xsqlite3ValueBytes(tls, pVal, enc_to) + func() int32 {
		if int32(enc_to) == SQLITE_UTF8 {
			return 1
		}
		return 2
	}()
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, z, *(*int32)(unsafe.Pointer(bp + 40))))

	sqlite3.Xsqlite3ValueFree(tls, pVal)

	return TCL_OK
}

func test_translate_selftest(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	sqlite3.Xsqlite3UtfSelfTest(tls)
	return SQLITE_OK
}

func Sqlitetest5_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd5))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd5[i].FzName, aCmd5[i].FxProc, uintptr(0), uintptr(0))
	}
	return SQLITE_OK
}

var aCmd5 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 31097, FxProc: 0},
	{FzName: ts + 31106, FxProc: 0},
	{FzName: ts + 31126, FxProc: 0},
	{FzName: ts + 31141, FxProc: 0},
}

type CrashFile1 = struct {
	FpMethod   uintptr
	FpRealFile uintptr
	FzName     uintptr
	Fflags     int32
	FzData     uintptr
	FnData     int32
	FiSize     i64
}

type CrashFile = CrashFile1
type CrashGlobal1 = struct {
	FpWriteList             uintptr
	FpWriteListEnd          uintptr
	FiSectorSize            int32
	FiDeviceCharacteristics int32
	FiCrash                 int32
	FzCrashFile             [500]int8
}

type CrashGlobal = CrashGlobal1
type WriteBuffer1 = struct {
	FiOffset i64
	FnBuf    int32
	FzBuf    uintptr
	FpFile   uintptr
	FpNext   uintptr
}

type WriteBuffer = WriteBuffer1

var g = CrashGlobal{FiSectorSize: SQLITE_DEFAULT_SECTOR_SIZE}

var sqlite3CrashTestEnable int32 = 0

func crash_malloc(tls *libc.TLS, nByte int32) uintptr {
	return tcl.XTcl_AttemptAlloc(tls, size_t(nByte))
}

func crash_free(tls *libc.TLS, p uintptr) {
	tcl.XTcl_Free(tls, p)
}

func crash_realloc(tls *libc.TLS, p uintptr, n int32) uintptr {
	return tcl.XTcl_AttemptRealloc(tls, p, size_t(n))
}

func writeDbFile(tls *libc.TLS, p uintptr, z uintptr, iAmt i64, iOff i64) int32 {
	var rc int32 = SQLITE_OK
	var iSkip int32 = 0
	if iAmt-i64(iSkip) > int64(0) {
		rc = sqlite3.Xsqlite3OsWrite(tls, (*CrashFile)(unsafe.Pointer(p)).FpRealFile, z+uintptr(iSkip), int32(iAmt-i64(iSkip)), iOff+i64(iSkip))
	}
	return rc
}

func writeListSync(tls *libc.TLS, pFile uintptr, isCrash int32) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = SQLITE_OK
	var iDc int32 = g.FiDeviceCharacteristics
	var pWrite uintptr
	var ppPtr uintptr

	var pFinal uintptr = uintptr(0)
	if !(isCrash != 0) {
		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			if (*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile {
				pFinal = pWrite
			}
		}
	} else if iDc&(SQLITE_IOCAP_SEQUENTIAL|SQLITE_IOCAP_SAFE_APPEND) != 0 {
		var nWrite int32 = 0

		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			nWrite++
		}
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp)
		*(*int32)(unsafe.Pointer(bp)) = func() int32 {
			if *(*int32)(unsafe.Pointer(bp)) < 0 {
				return -1 * *(*int32)(unsafe.Pointer(bp))
			}
			return *(*int32)(unsafe.Pointer(bp))
		}() % nWrite
		for pWrite = g.FpWriteList; *(*int32)(unsafe.Pointer(bp)) > 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			*(*int32)(unsafe.Pointer(bp))--
		}
		pFinal = pWrite
	}

	ppPtr = uintptr(unsafe.Pointer(&g))
	for pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)); rc == SQLITE_OK && pWrite != 0; pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)) {
		var pRealFile uintptr = (*CrashFile)(unsafe.Pointer((*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile)).FpRealFile

		var eAction int32 = 0
		if !(isCrash != 0) {
			eAction = 2
			if (*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile || iDc&SQLITE_IOCAP_SEQUENTIAL != 0 {
				eAction = 1
			}
		} else {
			sqlite3.Xsqlite3_randomness(tls, 1, bp+4)

			if iDc&SQLITE_IOCAP_ATOMIC != 0 || (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf == uintptr(0) {
				*(*int8)(unsafe.Pointer(bp + 4)) &= int8(0x01)
			}

			if iDc&SQLITE_IOCAP_SEQUENTIAL != 0 && pWrite != pFinal {
				*(*int8)(unsafe.Pointer(bp + 4)) = int8(0)
			}

			if iDc&SQLITE_IOCAP_SAFE_APPEND != 0 && (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0 {
				sqlite3.Xsqlite3OsFileSize(tls, pRealFile, bp+8)
				if *(*i64)(unsafe.Pointer(bp + 8)) == (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset {
					*(*int8)(unsafe.Pointer(bp + 4)) = int8(0)
				}
			}

			if int32(*(*int8)(unsafe.Pointer(bp + 4)))&0x06 == 0x06 {
				eAction = 3
			} else {
				eAction = func() int32 {
					if int32(*(*int8)(unsafe.Pointer(bp + 4)))&0x01 != 0 {
						return 2
					}
					return 1
				}()
			}
		}

		switch eAction {
		case 1:
			{
				if (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0 {
					rc = writeDbFile(tls,
						(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf, int64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf), (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				} else {
					rc = sqlite3.Xsqlite3OsTruncate(tls, pRealFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				}
				*(*uintptr)(unsafe.Pointer(ppPtr)) = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext
				crash_free(tls, pWrite)
				break

			}
		case 2:
			{
				ppPtr = pWrite + 20
				break

			}
		case 3:
			{
				var zGarbage uintptr
				var iFirst int32 = int32((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset / i64(g.FiSectorSize))
				var iLast int32 = int32(((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset + i64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf) - int64(1)) / i64(g.FiSectorSize))

				zGarbage = crash_malloc(tls, g.FiSectorSize)
				if zGarbage != 0 {
					var i sqlite3_int64
					for i = sqlite3_int64(iFirst); rc == SQLITE_OK && i <= sqlite3_int64(iLast); i++ {
						sqlite3.Xsqlite3_randomness(tls, g.FiSectorSize, zGarbage)
						rc = writeDbFile(tls,
							(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, zGarbage, int64(g.FiSectorSize), i*sqlite3_int64(g.FiSectorSize))
					}
					crash_free(tls, zGarbage)
				} else {
					rc = SQLITE_NOMEM
				}

				ppPtr = pWrite + 20
				break

			}

		default:
		}

		if pWrite == pFinal {
			break
		}
	}

	if rc == SQLITE_OK && isCrash != 0 {
		libc.Xexit(tls, -1)
	}

	for pWrite = g.FpWriteList; pWrite != 0 && (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
	}
	g.FpWriteListEnd = pWrite

	return rc
}

func writeListAppend(tls *libc.TLS, pFile uintptr, iOffset sqlite3_int64, zBuf uintptr, nBuf int32) int32 {
	var pNew uintptr

	pNew = crash_malloc(tls, int32(uint32(unsafe.Sizeof(WriteBuffer{}))+uint32(nBuf)))
	if pNew == uintptr(0) {
		libc.Xfprintf(tls, libc.X__stderrp, ts+31160, 0)
	}
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(WriteBuffer{}))+uint32(nBuf))
	(*WriteBuffer)(unsafe.Pointer(pNew)).FiOffset = iOffset
	(*WriteBuffer)(unsafe.Pointer(pNew)).FnBuf = nBuf
	(*WriteBuffer)(unsafe.Pointer(pNew)).FpFile = pFile
	if zBuf != 0 {
		(*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf = pNew + 1*24
		libc.Xmemcpy(tls, (*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf, zBuf, uint32(nBuf))
	}

	if g.FpWriteList != 0 {
		(*WriteBuffer)(unsafe.Pointer(g.FpWriteListEnd)).FpNext = pNew
	} else {
		g.FpWriteList = pNew
	}
	g.FpWriteListEnd = pNew

	return SQLITE_OK
}

func cfClose(tls *libc.TLS, pFile uintptr) int32 {
	var pCrash uintptr = pFile
	writeListSync(tls, pCrash, 0)
	sqlite3.Xsqlite3OsClose(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FpRealFile)
	return SQLITE_OK
}

func cfRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var pCrash uintptr = pFile
	var nCopy int32 = func() int32 {
		if i64(iAmt) < (*CrashFile)(unsafe.Pointer(pCrash)).FiSize-iOfst {
			return int32(i64(iAmt))
		}
		return int32((*CrashFile)(unsafe.Pointer(pCrash)).FiSize - iOfst)
	}()

	if nCopy > 0 {
		libc.Xmemcpy(tls, zBuf, (*CrashFile)(unsafe.Pointer(pCrash)).FzData+uintptr(iOfst), uint32(nCopy))
	}

	if nCopy < iAmt {
		return SQLITE_IOERR | int32(2)<<8
	}

	return SQLITE_OK
}

func cfWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var pCrash uintptr = pFile
	if sqlite_int64(iAmt)+iOfst > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(sqlite_int64(iAmt) + iOfst))
	}
	for (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > i64((*CrashFile)(unsafe.Pointer(pCrash)).FnData) {
		var zNew uintptr
		var nNew int32 = (*CrashFile)(unsafe.Pointer(pCrash)).FnData*2 + 4096
		zNew = crash_realloc(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FzData, nNew)
		if !(zNew != 0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, zNew+uintptr((*CrashFile)(unsafe.Pointer(pCrash)).FnData), 0, uint32(nNew-(*CrashFile)(unsafe.Pointer(pCrash)).FnData))
		(*CrashFile)(unsafe.Pointer(pCrash)).FnData = nNew
		(*CrashFile)(unsafe.Pointer(pCrash)).FzData = zNew
	}
	libc.Xmemcpy(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FzData+uintptr(iOfst), zBuf, uint32(iAmt))
	return writeListAppend(tls, pFile, iOfst, zBuf, iAmt)
}

func cfTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	var pCrash uintptr = pFile

	if (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > size {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(size))
	}
	return writeListAppend(tls, pFile, size, uintptr(0), 0)
}

func cfSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	var pCrash uintptr = pFile
	var isCrash int32 = 0

	var zName uintptr = (*CrashFile)(unsafe.Pointer(pCrash)).FzName
	var zCrashFile uintptr = uintptr(unsafe.Pointer(&g)) + 20
	var nName int32 = int32(libc.Xstrlen(tls, zName))
	var nCrashFile int32 = int32(libc.Xstrlen(tls, zCrashFile))

	if nCrashFile > 0 && int32(*(*int8)(unsafe.Pointer(zCrashFile + uintptr(nCrashFile-1)))) == '*' {
		nCrashFile--
		if nName > nCrashFile {
			nName = nCrashFile
		}
	}

	if nName == nCrashFile && 0 == libc.Xmemcmp(tls, zName, zCrashFile, uint32(nName)) {
		if libc.PreDecInt32(&g.FiCrash, 1) == 0 {
			isCrash = 1
		}
	}

	return writeListSync(tls, pCrash, isCrash)
}

func cfFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var pCrash uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = (*CrashFile)(unsafe.Pointer(pCrash)).FiSize
	return SQLITE_OK
}

func cfLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	return sqlite3.Xsqlite3OsLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}

func cfUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	return sqlite3.Xsqlite3OsUnlock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}

func cfCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, pResOut)
}

func cfFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	if op == SQLITE_FCNTL_SIZE_HINT {
		var pCrash uintptr = pFile
		var nByte i64 = *(*i64)(unsafe.Pointer(pArg))
		if nByte > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
			if SQLITE_OK == writeListAppend(tls, pFile, nByte, uintptr(0), 0) {
				(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(nByte))
			}
		}
		return SQLITE_OK
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, op, pArg)
}

func cfSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	return g.FiSectorSize
}

func cfDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	return g.FiDeviceCharacteristics
}

func cfShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 {
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmLock})).f(tls, pReal, ofst, n, flags)
}

func cfShmBarrier(tls *libc.TLS, pFile uintptr) {
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmBarrier})).f(tls, pReal)
}

func cfShmUnmap(tls *libc.TLS, pFile uintptr, delFlag int32) int32 {
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmUnmap})).f(tls, pReal, delFlag)
}

func cfShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, sz int32, w int32, pp uintptr) int32 {
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmMap})).f(tls, pReal, iRegion, sz, w, pp)
}

var CrashFileVtab = sqlite3_io_methods{
	FiVersion:               2,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
}

type crashAppData = struct{ FpOrig uintptr }

func cfOpen(tls *libc.TLS, pCfVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	var rc int32
	var pWrapper uintptr = pFile
	var pReal uintptr = pWrapper + 1*32

	libc.Xmemset(tls, pWrapper, 0, uint32(unsafe.Sizeof(CrashFile{})))
	rc = sqlite3.Xsqlite3OsOpen(tls, pVfs, zName, pReal, flags, pOutFlags)

	if rc == SQLITE_OK {
		(*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod = uintptr(unsafe.Pointer(&CrashFileVtab))
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzName = zName
		(*CrashFile)(unsafe.Pointer(pWrapper)).FpRealFile = pReal
		rc = sqlite3.Xsqlite3OsFileSize(tls, pReal, bp)
		(*CrashFile)(unsafe.Pointer(pWrapper)).FiSize = i64(int32(*(*i64)(unsafe.Pointer(bp))))
		(*CrashFile)(unsafe.Pointer(pWrapper)).Fflags = flags
	}
	if rc == SQLITE_OK {
		(*CrashFile)(unsafe.Pointer(pWrapper)).FnData = int32(int64(4096) + (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize)
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzData = crash_malloc(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FnData)
		if (*CrashFile)(unsafe.Pointer(pWrapper)).FzData != 0 {
			var iOff i64

			libc.Xmemset(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FzData, 0, uint32((*CrashFile)(unsafe.Pointer(pWrapper)).FnData))
			for iOff = int64(0); iOff < (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize; iOff = iOff + int64(512) {
				var nRead int32 = int32((*CrashFile)(unsafe.Pointer(pWrapper)).FiSize - iOff)
				if nRead > 512 {
					nRead = 512
				}
				rc = sqlite3.Xsqlite3OsRead(tls, pReal, (*CrashFile)(unsafe.Pointer(pWrapper)).FzData+uintptr(iOff), nRead, iOff)
			}
		} else {
			rc = SQLITE_NOMEM
		}
	}
	if rc != SQLITE_OK && (*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod != 0 {
		sqlite3.Xsqlite3OsClose(tls, pFile)
	}
	return rc
}

func cfDelete(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, dirSync int32) int32 {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDelete})).f(tls, pVfs, zPath, dirSync)
}

func cfAccess(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxAccess})).f(tls, pVfs, zPath, flags, pResOut)
}

func cfFullPathname(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, nPathOut int32, zPathOut uintptr) int32 {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxFullPathname})).f(tls, pVfs, zPath, nPathOut, zPathOut)
}

func cfDlOpen(tls *libc.TLS, pCfVfs uintptr, zPath uintptr) uintptr {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlOpen})).f(tls, pVfs, zPath)
}

func cfDlError(tls *libc.TLS, pCfVfs uintptr, nByte int32, zErrMsg uintptr) {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlError})).f(tls, pVfs, nByte, zErrMsg)
}

func cfDlSym(tls *libc.TLS, pCfVfs uintptr, pH uintptr, zSym uintptr) uintptr {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlSym})).f(tls, pVfs, pH, zSym)
}

func cfDlClose(tls *libc.TLS, pCfVfs uintptr, pHandle uintptr) {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlClose})).f(tls, pVfs, pHandle)
}

func cfRandomness(tls *libc.TLS, pCfVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxRandomness})).f(tls, pVfs, nByte, zBufOut)
}

func cfSleep(tls *libc.TLS, pCfVfs uintptr, nMicro int32) int32 {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSleep})).f(tls, pVfs, nMicro)
}

func cfCurrentTime(tls *libc.TLS, pCfVfs uintptr, pTimeOut uintptr) int32 {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTime})).f(tls, pVfs, pTimeOut)
}

func cfGetLastError(tls *libc.TLS, pCfVfs uintptr, n int32, z uintptr) int32 {
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetLastError})).f(tls, pVfs, n, z)
}

func processDevSymArgs(tls *libc.TLS, interp uintptr, objc int32, objv uintptr, piDeviceChar uintptr, piSectorSize uintptr) int32 {
	bp := tls.Alloc(196)
	defer tls.Free(196)

	*(*[14]DeviceFlag)(unsafe.Pointer(bp + 80)) = [14]DeviceFlag{
		{FzName: ts + 31198, FiValue: SQLITE_IOCAP_ATOMIC},
		{FzName: ts + 31205, FiValue: SQLITE_IOCAP_ATOMIC512},
		{FzName: ts + 31215, FiValue: SQLITE_IOCAP_ATOMIC1K},
		{FzName: ts + 31224, FiValue: SQLITE_IOCAP_ATOMIC2K},
		{FzName: ts + 31233, FiValue: SQLITE_IOCAP_ATOMIC4K},
		{FzName: ts + 31242, FiValue: SQLITE_IOCAP_ATOMIC8K},
		{FzName: ts + 31251, FiValue: SQLITE_IOCAP_ATOMIC16K},
		{FzName: ts + 31261, FiValue: SQLITE_IOCAP_ATOMIC32K},
		{FzName: ts + 31271, FiValue: SQLITE_IOCAP_ATOMIC64K},
		{FzName: ts + 31281, FiValue: SQLITE_IOCAP_SEQUENTIAL},
		{FzName: ts + 31292, FiValue: SQLITE_IOCAP_SAFE_APPEND},
		{FzName: ts + 31304, FiValue: SQLITE_IOCAP_POWERSAFE_OVERWRITE},
		{FzName: ts + 31324, FiValue: SQLITE_IOCAP_BATCH_ATOMIC},
		{},
	}
	var i int32
	var iDc int32 = 0
	*(*int32)(unsafe.Pointer(bp + 68)) = 0
	var setSectorsize int32 = 0
	var setDeviceChar int32 = 0

	for i = 0; i < objc; i = i + 2 {
		var zOpt uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp+64)

		if (*(*int32)(unsafe.Pointer(bp + 64)) > 11 || *(*int32)(unsafe.Pointer(bp + 64)) < 2 || libc.Xstrncmp(tls, ts+31337, zOpt, uint32(*(*int32)(unsafe.Pointer(bp + 64)))) != 0) &&
			(*(*int32)(unsafe.Pointer(bp + 64)) > 16 || *(*int32)(unsafe.Pointer(bp + 64)) < 2 || libc.Xstrncmp(tls, ts+31349, zOpt, uint32(*(*int32)(unsafe.Pointer(bp + 64)))) != 0) {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+31366, zOpt,
					ts+31380, 0))
			return TCL_ERROR
		}
		if i == objc-1 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+31428, zOpt, ts+16912, 0))
			return TCL_ERROR
		}

		if int32(*(*int8)(unsafe.Pointer(zOpt + 1))) == 's' {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+68) != 0 {
				return TCL_ERROR
			}
			setSectorsize = 1
		} else {
			var j int32

			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+72, bp+76) != 0 {
				return TCL_ERROR
			}
			for j = 0; j < *(*int32)(unsafe.Pointer(bp + 72)); j++ {
				var rc int32

				var pFlag uintptr = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 76)) + uintptr(j)*4)))
				(*Tcl_Obj)(unsafe.Pointer(pFlag)).FrefCount++
				tcl.XTcl_UtfToLower(tls, tcl.XTcl_GetString(tls, pFlag))

				rc = tcl.XTcl_GetIndexFromObjStruct(tls,
					interp, pFlag, bp+80, int32(unsafe.Sizeof(DeviceFlag{})), ts+31459, 0, bp+192)
				for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
					var _objPtr uintptr = pFlag
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rc != 0 {
					return TCL_ERROR
				}

				iDc = iDc | (*DeviceFlag)(unsafe.Pointer(bp+80+uintptr(*(*int32)(unsafe.Pointer(bp + 192)))*8)).FiValue
			}
			setDeviceChar = 1
		}
	}

	if setDeviceChar != 0 {
		*(*int32)(unsafe.Pointer(piDeviceChar)) = iDc
	}
	if setSectorsize != 0 {
		*(*int32)(unsafe.Pointer(piSectorSize)) = *(*int32)(unsafe.Pointer(bp + 68))
	}

	return TCL_OK
}

type DeviceFlag = struct {
	FzName  uintptr
	FiValue int32
}

func crashNowCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}
	writeListSync(tls, uintptr(0), 1)

	return TCL_OK
}

func crashEnableCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp + 4)) = 0

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31472)
		return TCL_ERROR
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	if objc == 3 && tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp)) != 0 && crashVfs.FpAppData != 0 || !(*(*int32)(unsafe.Pointer(bp)) != 0) && !(int32(crashVfs.FpAppData) != 0) {
		return TCL_OK
	}

	if crashVfs.FpAppData == uintptr(0) {
		var pOriginalVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		crashVfs.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FmxPathname
		crashVfs.FpAppData = pOriginalVfs
		crashVfs.FszOsFile = int32(uint32(unsafe.Sizeof(CrashFile{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FszOsFile))
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&crashVfs)), *(*int32)(unsafe.Pointer(bp + 4)))
	} else {
		crashVfs.FpAppData = uintptr(0)
		sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&crashVfs)))
	}

	return TCL_OK
}

var crashVfs = sqlite3_vfs{
	FiVersion:      2,
	FzName:         ts + 31489,
	FxOpen:         0,
	FxDelete:       0,
	FxAccess:       0,
	FxFullPathname: 0,
	FxDlOpen:       0,
	FxDlError:      0,
	FxDlSym:        0,
	FxDlClose:      0,
	FxRandomness:   0,
	FxSleep:        0,
	FxCurrentTime:  0,
	FxGetLastError: 0,
}

func crashParamsObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zCrashFile uintptr

	*(*int32)(unsafe.Pointer(bp + 40)) = -1
	*(*int32)(unsafe.Pointer(bp + 44)) = -1

	if !(objc < 3) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31495)
	goto error
__1:
	;
	zCrashFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*4)), bp+32)
	if !(uint32(*(*int32)(unsafe.Pointer(bp + 32))) >= uint32(unsafe.Sizeof([500]int8{}))) {
		goto __2
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+31521, zCrashFile, ts+16912, 0))
	goto error
__2:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*4)), bp+36) != 0) {
		goto __3
	}
	goto error
__3:
	;
	if !(processDevSymArgs(tls, interp, objc-3, objv+1*4, bp+40, bp+44) != 0) {
		goto __4
	}
	return TCL_ERROR
__4:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 40)) >= 0) {
		goto __5
	}
	g.FiDeviceCharacteristics = *(*int32)(unsafe.Pointer(bp + 40))
__5:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 44)) >= 0) {
		goto __6
	}
	g.FiSectorSize = *(*int32)(unsafe.Pointer(bp + 44))
__6:
	;
	g.FiCrash = *(*int32)(unsafe.Pointer(bp + 36))
	libc.Xmemcpy(tls, uintptr(unsafe.Pointer(&g))+20, zCrashFile, uint32(*(*int32)(unsafe.Pointer(bp + 32))+1))
	sqlite3CrashTestEnable = 1
	return TCL_OK

error:
	return TCL_ERROR
}

func devSymObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp)) = -1
	*(*int32)(unsafe.Pointer(bp + 4)) = -1

	if processDevSymArgs(tls, interp, objc-1, objv+1*4, bp, bp+4) != 0 {
		return TCL_ERROR
	}
	devsym_register(tls, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))

	return TCL_OK
}

func writeCrashObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = 0

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31545)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}

	devsym_crash_on_write(tls, *(*int32)(unsafe.Pointer(bp)))
	return TCL_OK
}

func dsUnregisterObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	devsym_unregister(tls)
	return TCL_OK
}

func jtObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zParent uintptr = uintptr(0)

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31552)
		return TCL_ERROR
	}
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if objc == 3 {
		if libc.Xstrcmp(tls, zParent, ts+31574) != 0 {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+16818, zParent, ts+31583, 0))
			return TCL_ERROR
		}
		zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	}

	if !(int32(*(*int8)(unsafe.Pointer(zParent))) != 0) {
		zParent = uintptr(0)
	}
	if jt_register(tls, zParent, libc.Bool32(objc == 3)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+31603, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func jtUnregisterObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	jt_unregister(tls)
	return TCL_OK
}

func Sqlitetest6_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31624, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashEnableCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31645, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashParamsObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31665, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashNowCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31683, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{devSymObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31707, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{writeCrashObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31730, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{dsUnregisterObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31748, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+31764, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtUnregisterObjCmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

type echo_vtab1 = struct {
	Fbase          sqlite3_vtab
	Finterp        uintptr
	Fdb            uintptr
	FisPattern     int32
	FinTransaction int32
	FzThis         uintptr
	FzTableName    uintptr
	FzLogName      uintptr
	FnCol          int32
	FaIndex        uintptr
	FaCol          uintptr
}

type echo_vtab = echo_vtab1
type echo_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
}

type echo_cursor = echo_cursor1

func simulateVtabError(tls *libc.TLS, p uintptr, zMethod uintptr) int32 {
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zErr uintptr

	*(*int8)(unsafe.Pointer(bp + 24 + 127)) = int8(0)
	sqlite3.Xsqlite3_snprintf(tls, 127, bp+24, ts+31782, libc.VaList(bp, zMethod, (*echo_vtab)(unsafe.Pointer(p)).FzTableName))
	zErr = tcl.XTcl_GetVar2(tls, (*echo_vtab)(unsafe.Pointer(p)).Finterp, bp+24, uintptr(0), TCL_GLOBAL_ONLY)
	if zErr != 0 {
		(*echo_vtab)(unsafe.Pointer(p)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+31806, libc.VaList(bp+16, zErr))
	}
	return libc.Bool32(zErr != uintptr(0))
}

func dequoteString(tls *libc.TLS, z uintptr) {
	var quote int32
	var i int32
	var j int32
	if z == uintptr(0) {
		return
	}
	quote = int32(*(*int8)(unsafe.Pointer(z)))
	switch quote {
	case '\'':
		break
	case '"':
		break
	case '`':
		break
	case '[':
		quote = ']'
		break
	default:
		return
	}
	i = 1
	j = 0
	for ; *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == quote {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(i+1)))) == quote {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(quote)
				i++
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(0)
				break
			}
		} else {
			*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
		}
	}
}

func getColumnNames(tls *libc.TLS, db uintptr, zTab uintptr, paCol uintptr, pnCol uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var aCol uintptr
	var zSql uintptr

	var rc int32
	var nCol int32
	var zName uintptr
	var ii int32
	var nBytes int32
	var zSpace uintptr
	aCol = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	rc = SQLITE_OK
	nCol = 0

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+31826, libc.VaList(bp, zTab))
	if !!(zSql != 0) {
		goto __1
	}
	rc = SQLITE_NOMEM
	goto out
__1:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	if !(rc == SQLITE_OK) {
		goto __2
	}
	nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))

	nBytes = int32(uint32(unsafe.Sizeof(uintptr(0))) * uint32(nCol))
	ii = 0
__3:
	if !(ii < nCol) {
		goto __5
	}
	zName = sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ii)
	if !!(zName != 0) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto out
__6:
	;
	nBytes = nBytes + (int32(libc.Xstrlen(tls, zName)) + 1)
	goto __4
__4:
	ii++
	goto __3
	goto __5
__5:
	;
	aCol = sqlite3.Xsqlite3MallocZero(tls, uint64(nBytes))
	if !!(aCol != 0) {
		goto __7
	}
	rc = SQLITE_NOMEM
	goto out
__7:
	;
	zSpace = aCol + uintptr(nCol)*4
	ii = 0
__8:
	if !(ii < nCol) {
		goto __10
	}
	*(*uintptr)(unsafe.Pointer(aCol + uintptr(ii)*4)) = zSpace
	sqlite3.Xsqlite3_snprintf(tls, nBytes, zSpace, ts, libc.VaList(bp+8, sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ii)))
	zSpace += uintptr(int32(libc.Xstrlen(tls, zSpace)) + 1)
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;
__2:
	;
	*(*uintptr)(unsafe.Pointer(paCol)) = aCol
	*(*int32)(unsafe.Pointer(pnCol)) = nCol

out:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	return rc
}

func getIndexArray(tls *libc.TLS, db uintptr, zTab uintptr, nCol int32, paIndex uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var aIndex uintptr
	var rc int32
	var zSql uintptr
	var cid int32
	var zIdx uintptr

	var rc2 int32
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	aIndex = uintptr(0)

	aIndex = sqlite3.Xsqlite3MallocZero(tls, uint64(uint32(unsafe.Sizeof(int32(0)))*uint32(nCol)))
	if !!(aIndex != 0) {
		goto __1
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__1:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+31843, libc.VaList(bp, zTab))
	if !!(zSql != 0) {
		goto __2
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__2:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

__3:
	if !(*(*uintptr)(unsafe.Pointer(bp + 16)) != 0 && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16))) == SQLITE_ROW) {
		goto __4
	}
	zIdx = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), 1)
	*(*uintptr)(unsafe.Pointer(bp + 20)) = uintptr(0)
	if !(zIdx == uintptr(0)) {
		goto __5
	}
	goto __3
__5:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+31865, libc.VaList(bp+8, zIdx))
	if !!(zSql != 0) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__6:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+20, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(*(*uintptr)(unsafe.Pointer(bp + 20)) != 0 && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 20))) == SQLITE_ROW) {
		goto __7
	}
	cid = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 20)), 1)

	*(*int32)(unsafe.Pointer(aIndex + uintptr(cid)*4)) = 1
__7:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 20)) != 0) {
		goto __8
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))
__8:
	;
	if !(rc != SQLITE_OK) {
		goto __9
	}
	goto get_index_array_out
__9:
	;
	goto __3
__4:
	;
get_index_array_out:
	if !(*(*uintptr)(unsafe.Pointer(bp + 16)) != 0) {
		goto __10
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	if !(rc == SQLITE_OK) {
		goto __11
	}
	rc = rc2
__11:
	;
__10:
	;
	if !(rc != SQLITE_OK) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, aIndex)
	aIndex = uintptr(0)
__12:
	;
	*(*uintptr)(unsafe.Pointer(paIndex)) = aIndex
	return rc
}

func appendToEchoModule(tls *libc.TLS, interp uintptr, zArg uintptr) {
	var flags int32 = TCL_APPEND_VALUE | TCL_LIST_ELEMENT | TCL_GLOBAL_ONLY
	tcl.XTcl_SetVar2(tls, interp, ts+31887, uintptr(0), func() uintptr {
		if zArg != 0 {
			return zArg
		}
		return ts + 584
	}(), flags)
}

func echoDeclareVtab(tls *libc.TLS, pVtab uintptr, db uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = SQLITE_OK

	if (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0 {
		*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare(tls, db,
			ts+31899,
			-1, bp, uintptr(0))
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp)), 1, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, -1, uintptr(0))
			if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp))) == SQLITE_ROW {
				var rc2 int32
				var zCreateTable uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp)), 0)
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
				rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp)))
				if rc == SQLITE_OK {
					rc = rc2
				}
			} else {
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp)))
				if rc == SQLITE_OK {
					rc = SQLITE_ERROR
				}
			}
			if rc == SQLITE_OK {
				rc = getColumnNames(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, pVtab+48, pVtab+40)
			}
			if rc == SQLITE_OK {
				rc = getIndexArray(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, (*echo_vtab)(unsafe.Pointer(pVtab)).FnCol, pVtab+44)
			}
		}
	}

	return rc
}

func echoDestructor(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaIndex)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaCol)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzLogName)
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

type EchoModule1 = struct {
	Finterp uintptr
	Fdb     uintptr
}

type EchoModule = EchoModule1

func echoConstructor(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var i int32
	var pVtab uintptr

	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_vtab{})))
	if !(pVtab != 0) {
		return SQLITE_NOMEM
	}
	(*echo_vtab)(unsafe.Pointer(pVtab)).Finterp = (*EchoModule)(unsafe.Pointer(pAux)).Finterp
	(*echo_vtab)(unsafe.Pointer(pVtab)).Fdb = db

	(*echo_vtab)(unsafe.Pointer(pVtab)).FzThis = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 2*4))))
	if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzThis) != 0) {
		echoDestructor(tls, pVtab)
		return SQLITE_NOMEM
	}

	if argc > 3 {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
		dequoteString(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
		if (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0 && int32(*(*int8)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))) == '*' {
			var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+31963, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 2*4)), (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName+1))
			sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
			(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = z
			(*echo_vtab)(unsafe.Pointer(pVtab)).FisPattern = 1
		}
		if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) != 0) {
			echoDestructor(tls, pVtab)
			return SQLITE_NOMEM
		}
	}

	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	}

	rc = echoDeclareVtab(tls, pVtab, db)
	if rc != SQLITE_OK {
		echoDestructor(tls, pVtab)
		return rc
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return SQLITE_OK
}

func echoCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+31968)
	rc = echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)

	if rc == SQLITE_OK && argc == 5 {
		var zSql uintptr
		var pVtab uintptr = *(*uintptr)(unsafe.Pointer(ppVtab))
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 4*4))))
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+31976, libc.VaList(bp+8, (*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+16, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}

	if *(*uintptr)(unsafe.Pointer(ppVtab)) != 0 && rc != SQLITE_OK {
		echoDestructor(tls, *(*uintptr)(unsafe.Pointer(ppVtab)))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	}

	if rc == SQLITE_OK {
		(*echo_vtab)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppVtab)))).FinTransaction = 1
	}

	return rc
}

func echoConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+32000)
	return echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

func echoDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32009)
	return echoDestructor(tls, pVtab)
}

func echoDestroy(tls *libc.TLS, pVtab uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	var p uintptr = pVtab
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32021)

	if p != 0 && (*echo_vtab)(unsafe.Pointer(p)).FzLogName != 0 {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+32030, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	if rc == SQLITE_OK {
		rc = echoDestructor(tls, pVtab)
	}
	return rc
}

func echoOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	if simulateVtabError(tls, pVTab, ts+32044) != 0 {
		return SQLITE_ERROR
	}
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return func() int32 {
		if pCur != 0 {
			return SQLITE_OK
		}
		return SQLITE_NOMEM
	}()
}

func echoClose(tls *libc.TLS, cur uintptr) int32 {
	var rc int32
	var pCur uintptr = cur
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
	sqlite3.Xsqlite3_free(tls, pCur)
	rc = sqlite3.Xsqlite3_finalize(tls, pStmt)
	return rc
}

func echoEof(tls *libc.TLS, cur uintptr) int32 {
	return func() int32 {
		if (*echo_cursor)(unsafe.Pointer(cur)).FpStmt != 0 {
			return 0
		}
		return 1
	}()
}

func echoNext(tls *libc.TLS, cur uintptr) int32 {
	var rc int32 = SQLITE_OK
	var pCur uintptr = cur

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+32050) != 0 {
		return SQLITE_ERROR
	}

	if (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt != 0 {
		rc = sqlite3.Xsqlite3_step(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
		if rc == SQLITE_ROW {
			rc = SQLITE_OK
		} else {
			rc = sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
			(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
		}
	}

	return rc
}

func echoColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var iCol int32 = i + 1
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+32056) != 0 {
		return SQLITE_ERROR
	}

	if !(pStmt != 0) {
		sqlite3.Xsqlite3_result_null(tls, ctx)
	} else {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, pStmt, iCol))
	}
	return SQLITE_OK
}

func echoRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+2304) != 0 {
		return SQLITE_ERROR
	}

	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	return SQLITE_OK
}

func hashString(tls *libc.TLS, zString uintptr) int32 {
	var val u32 = u32(0)
	var ii int32
	for ii = 0; *(*int8)(unsafe.Pointer(zString + uintptr(ii))) != 0; ii++ {
		val = val<<3 + u32(int32(*(*int8)(unsafe.Pointer(zString + uintptr(ii)))))
	}
	return int32(val & u32(0x7fffffff))
}

func echoFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var rc int32
	var i int32

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb

	if simulateVtabError(tls, pVtab, ts+32064) != 0 {
		return SQLITE_ERROR
	}

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32064)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, idxStr)
	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
	}

	sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)

	rc = sqlite3.Xsqlite3_prepare(tls, db, idxStr, -1, pCur+4, uintptr(0))

	for i = 0; rc == SQLITE_OK && i < argc; i++ {
		rc = sqlite3.Xsqlite3_bind_value(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt, i+1, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	}

	if rc == SQLITE_OK {
		rc = echoNext(tls, pVtabCursor)
	}

	return rc
}

func string_concat(tls *libc.TLS, pzStr uintptr, zAppend uintptr, doFree int32, pRc uintptr) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zIn uintptr = *(*uintptr)(unsafe.Pointer(pzStr))
	if !(zAppend != 0) && doFree != 0 && *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	}
	if *(*int32)(unsafe.Pointer(pRc)) != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, zIn)
		zIn = uintptr(0)
	} else {
		if zIn != 0 {
			var zTemp uintptr = zIn
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts+31963, libc.VaList(bp, zIn, zAppend))
			sqlite3.Xsqlite3_free(tls, zTemp)
		} else {
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+16, zAppend))
		}
		if !(zIn != 0) {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
	}
	*(*uintptr)(unsafe.Pointer(pzStr)) = zIn
	if doFree != 0 {
		sqlite3.Xsqlite3_free(tls, zAppend)
	}
}

func echoSelectList(tls *libc.TLS, pTab uintptr, pIdxInfo uintptr) uintptr {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zRet uintptr = uintptr(0)
	if sqlite3.Xsqlite3_libversion_number(tls) < 3010000 {
		zRet = sqlite3.Xsqlite3_mprintf(tls, ts+32072, 0)
	} else {
		var i int32
		for i = 0; i < (*echo_vtab)(unsafe.Pointer(pTab)).FnCol; i++ {
			if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed&(uint64(1)<<func() int32 {
				if i >= 63 {
					return 63
				}
				return i
			}()) != 0 {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+32076, libc.VaList(bp, zRet, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pTab)).FaCol + uintptr(i)*4))))
			} else {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+32083, libc.VaList(bp+16, zRet))
			}
			if !(zRet != 0) {
				break
			}
		}
	}
	return zRet
}

func echoBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var ii int32
	*(*uintptr)(unsafe.Pointer(bp + 84)) = uintptr(0)
	var zCol uintptr = uintptr(0)
	var zNew uintptr
	var nArg int32 = 0
	var zSep uintptr = ts + 9747
	var pVtab uintptr = tab
	*(*uintptr)(unsafe.Pointer(bp + 80)) = uintptr(0)
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp

	var nRow int32 = 0
	var useIdx int32 = 0
	*(*int32)(unsafe.Pointer(bp + 88)) = SQLITE_OK
	var useCost int32 = 0
	var cost float64 = float64(0)
	var isIgnoreUsable int32 = 0
	if tcl.XTcl_GetVar2(tls, interp, ts+32092, uintptr(0), TCL_GLOBAL_ONLY) != 0 {
		isIgnoreUsable = 1
	}

	if simulateVtabError(tls, pVtab, ts+32118) != 0 {
		return SQLITE_ERROR
	}

	if tcl.XTcl_GetVar2(tls, interp, ts+32129, uintptr(0), TCL_GLOBAL_ONLY) != 0 {
		cost = libc.Xatof(tls, tcl.XTcl_GetVar2(tls, interp, ts+32129, uintptr(0), TCL_GLOBAL_ONLY))
		useCost = 1
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 84)) = sqlite3.Xsqlite3_mprintf(tls, ts+32146, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 84)) != 0) {
			return SQLITE_NOMEM
		}
		*(*int32)(unsafe.Pointer(bp + 88)) = sqlite3.Xsqlite3_prepare(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb, *(*uintptr)(unsafe.Pointer(bp + 84)), -1, bp+80, uintptr(0))
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 84)))
		if *(*int32)(unsafe.Pointer(bp + 88)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp + 88))
		}
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80)))
		nRow = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), 0)
		*(*int32)(unsafe.Pointer(bp + 88)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 80)))
		if *(*int32)(unsafe.Pointer(bp + 88)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp + 88))
		}
	}

	zCol = echoSelectList(tls, pVtab, pIdxInfo)
	if !(zCol != 0) {
		return SQLITE_NOMEM
	}
	*(*uintptr)(unsafe.Pointer(bp + 84)) = sqlite3.Xsqlite3_mprintf(tls, ts+32170, libc.VaList(bp+8, zCol, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if !(*(*uintptr)(unsafe.Pointer(bp + 84)) != 0) {
		return SQLITE_NOMEM
	}

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pConstraint uintptr
		var pUsage uintptr
		var iCol int32

		pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8

		if !(isIgnoreUsable != 0) && !(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) != 0) {
			continue
		}

		iCol = (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn
		if iCol < 0 || *(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr(iCol)*4)) != 0 {
			var zNewCol uintptr
			if iCol >= 0 {
				zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*4))
			} else {
				zNewCol = ts + 6782
			}
			var zOp uintptr = uintptr(0)
			useIdx = 1
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) {
			case SQLITE_INDEX_CONSTRAINT_EQ:
				zOp = ts + 32193
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LT:
				zOp = ts + 32195
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GT:
				zOp = ts + 32197
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LE:
				zOp = ts + 32199
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GE:
				zOp = ts + 32202
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_MATCH:
				zOp = ts + 32205
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LIKE:
				zOp = ts + 32210
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GLOB:
				zOp = ts + 32215
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_REGEXP:
				zOp = ts + 7186
				break
			}
			if zOp != 0 {
				if int32(*(*int8)(unsafe.Pointer(zOp))) == 'L' {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+32220,
						libc.VaList(bp+24, zSep, zNewCol))
				} else {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+32255, libc.VaList(bp+40, zSep, zNewCol, zOp))
				}
				string_concat(tls, bp+84, zNew, 1, bp+88)
				zSep = ts + 9774
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&nArg, 1)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			}
		}
	}

	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 && ((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn < 0 || *(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn)*4)) != 0) {
		var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn
		var zNewCol uintptr
		if iCol >= 0 {
			zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*4))
		} else {
			zNewCol = ts + 6782
		}
		var zDir uintptr
		if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc != 0 {
			zDir = ts + 32267
		} else {
			zDir = ts + 32272
		}
		zNew = sqlite3.Xsqlite3_mprintf(tls, ts+32276, libc.VaList(bp+64, zNewCol, zDir))
		string_concat(tls, bp+84, zNew, 1, bp+88)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32118)

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(bp + 84)))

	if !(*(*uintptr)(unsafe.Pointer(bp + 84)) != 0) {
		return *(*int32)(unsafe.Pointer(bp + 88))
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = hashString(tls, *(*uintptr)(unsafe.Pointer(bp + 84)))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = *(*uintptr)(unsafe.Pointer(bp + 84))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
	if useCost != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = cost
	} else if useIdx != 0 {
		for ii = 0; uint32(ii) < uint32(unsafe.Sizeof(int32(0)))*uint32(8)-uint32(1); ii++ {
			if nRow&(int32(1)<<ii) != 0 {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(ii)
			}
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(nRow)
	}
	return *(*int32)(unsafe.Pointer(bp + 88))
}

func echoUpdate(tls *libc.TLS, tab uintptr, nData int32, apData uintptr, pRowid uintptr) int32 {
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var pVtab uintptr = tab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb
	*(*int32)(unsafe.Pointer(bp + 100)) = SQLITE_OK

	*(*uintptr)(unsafe.Pointer(bp + 112)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96)) = uintptr(0)
	var bindArgZero int32 = 0
	var bindArgOne int32 = 0
	var i int32

	if simulateVtabError(tls, pVtab, ts+32292) != 0 {
		return SQLITE_ERROR
	}

	if nData > 1 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_INTEGER {
		var zSep uintptr = ts + 32300
		*(*uintptr)(unsafe.Pointer(bp + 96)) = sqlite3.Xsqlite3_mprintf(tls, ts+32305, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 100)) = SQLITE_NOMEM
		}

		bindArgOne = libc.Bool32(*(*uintptr)(unsafe.Pointer(apData + 1*4)) != 0 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + 1*4))) == SQLITE_INTEGER)
		bindArgZero = 1

		if bindArgOne != 0 {
			string_concat(tls, bp+96, ts+32315, 0, bp+100)
			zSep = ts + 5115
		}
		for i = 2; i < nData; i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*4)) == uintptr(0) {
				continue
			}
			string_concat(tls, bp+96, sqlite3.Xsqlite3_mprintf(tls,
				ts+32330, libc.VaList(bp+8, zSep, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(i-2)*4)), i)), 1, bp+100)
			zSep = ts + 5115
		}
		string_concat(tls, bp+96, sqlite3.Xsqlite3_mprintf(tls, ts+32340, libc.VaList(bp+32, nData)), 1, bp+100)
	} else if nData == 1 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_INTEGER {
		*(*uintptr)(unsafe.Pointer(bp + 96)) = sqlite3.Xsqlite3_mprintf(tls, ts+32357, libc.VaList(bp+40, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 100)) = SQLITE_NOMEM
		}
		bindArgZero = 1
	} else if nData > 2 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_NULL {
		var ii int32
		*(*uintptr)(unsafe.Pointer(bp + 104)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 108)) = uintptr(0)

		*(*uintptr)(unsafe.Pointer(bp + 104)) = sqlite3.Xsqlite3_mprintf(tls, ts+32389, libc.VaList(bp+48, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 104)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 100)) = SQLITE_NOMEM
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + 1*4))) == SQLITE_INTEGER {
			bindArgOne = 1
			*(*uintptr)(unsafe.Pointer(bp + 108)) = sqlite3.Xsqlite3_mprintf(tls, ts+3349, 0)
			string_concat(tls, bp+104, ts+6782, 0, bp+100)
		}

		for ii = 2; ii < nData; ii++ {
			string_concat(tls, bp+104,
				sqlite3.Xsqlite3_mprintf(tls, ts+32406, libc.VaList(bp+56, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 108)) != 0 {
						return ts + 97
					}
					return ts + 584
				}(), *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(ii-2)*4)))), 1, bp+100)
			string_concat(tls, bp+108,
				sqlite3.Xsqlite3_mprintf(tls, ts+32411, libc.VaList(bp+72, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 108)) != 0 {
						return ts + 97
					}
					return ts + 584
				}(), ii)), 1, bp+100)
		}

		string_concat(tls, bp+96, *(*uintptr)(unsafe.Pointer(bp + 104)), 1, bp+100)
		string_concat(tls, bp+96, ts+32417, 0, bp+100)
		string_concat(tls, bp+96, *(*uintptr)(unsafe.Pointer(bp + 108)), 1, bp+100)
		string_concat(tls, bp+96, ts+585, 0, bp+100)
	} else {
		return SQLITE_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 100)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 100)) = sqlite3.Xsqlite3_prepare(tls, db, *(*uintptr)(unsafe.Pointer(bp + 96)), -1, bp+112, uintptr(0))
	}

	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 96)))
	if *(*int32)(unsafe.Pointer(bp + 100)) == SQLITE_OK {
		if bindArgZero != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), nData, *(*uintptr)(unsafe.Pointer(apData)))
		}
		if bindArgOne != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), 1, *(*uintptr)(unsafe.Pointer(apData + 1*4)))
		}
		for i = 2; i < nData && *(*int32)(unsafe.Pointer(bp + 100)) == SQLITE_OK; i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*4)) != 0 {
				*(*int32)(unsafe.Pointer(bp + 100)) = sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), i, *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*4)))
			}
		}
		if *(*int32)(unsafe.Pointer(bp + 100)) == SQLITE_OK {
			sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 112)))
			*(*int32)(unsafe.Pointer(bp + 100)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 112)))
		} else {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 112)))
		}
	}

	if pRowid != 0 && *(*int32)(unsafe.Pointer(bp + 100)) == SQLITE_OK {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
	}
	if *(*int32)(unsafe.Pointer(bp + 100)) != SQLITE_OK {
		(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+31806, libc.VaList(bp+88, sqlite3.Xsqlite3_errmsg(tls, db)))
	}

	return *(*int32)(unsafe.Pointer(bp + 100))
}

func echoTransactionCall(tls *libc.TLS, tab uintptr, zCall uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	var pVtab uintptr = tab
	z = sqlite3.Xsqlite3_mprintf(tls, ts+32427, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if z == uintptr(0) {
		return SQLITE_NOMEM
	}
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, zCall)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, z)
	sqlite3.Xsqlite3_free(tls, z)
	return SQLITE_OK
}

func echoBegin(tls *libc.TLS, tab uintptr) int32 {
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	if simulateVtabError(tls, pVtab, ts+32436) != 0 {
		return SQLITE_ERROR
	}

	rc = echoTransactionCall(tls, tab, ts+32436)

	if rc == SQLITE_OK {
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+32443, uintptr(0), TCL_GLOBAL_ONLY)
		if zVal != 0 && 0 == libc.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) {
			rc = SQLITE_ERROR
		}
	}
	if rc == SQLITE_OK {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 1
	}
	return rc
}

func echoSync(tls *libc.TLS, tab uintptr) int32 {
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	if simulateVtabError(tls, pVtab, ts+32466) != 0 {
		return SQLITE_ERROR
	}

	rc = echoTransactionCall(tls, tab, ts+32466)

	if rc == SQLITE_OK {
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+32472, uintptr(0), TCL_GLOBAL_ONLY)
		if zVal != 0 && 0 == libc.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) {
			rc = -1
		}
	}
	return rc
}

func echoCommit(tls *libc.TLS, tab uintptr) int32 {
	var pVtab uintptr = tab
	var rc int32

	if simulateVtabError(tls, pVtab, ts+32494) != 0 {
		return SQLITE_ERROR
	}

	sqlite3.Xsqlite3BeginBenignMalloc(tls)
	rc = echoTransactionCall(tls, tab, ts+32494)
	sqlite3.Xsqlite3EndBenignMalloc(tls)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}

func echoRollback(tls *libc.TLS, tab uintptr) int32 {
	var rc int32
	var pVtab uintptr = tab

	rc = echoTransactionCall(tls, tab, ts+32502)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}

func overloadedGlobFunction(tls *libc.TLS, pContext uintptr, nArg int32, apArg uintptr) {
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pContext)

	var i int32
	var rc int32
	tcl.XTcl_DStringInit(tls, bp)
	tcl.XTcl_DStringAppendElement(tls, bp, ts+32512)
	for i = 0; i < nArg; i++ {
		tcl.XTcl_DStringAppendElement(tls, bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))))
	}
	rc = tcl.XTcl_Eval(tls, interp, (*Tcl_DString)(unsafe.Pointer(bp)).Fstring)
	tcl.XTcl_DStringFree(tls, bp)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, pContext, tcl.XTcl_GetStringResult(tls, interp), -1)
	} else {
		sqlite3.Xsqlite3_result_text(tls, pContext, tcl.XTcl_GetStringResult(tls, interp),
			-1, libc.UintptrFromInt32(-1))
	}
	tcl.XTcl_ResetResult(tls, interp)
}

func echoFindFunction(tls *libc.TLS, vtab uintptr, nArg int32, zFuncName uintptr, pxFunc uintptr, ppArg uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pVtab uintptr = vtab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp

	if libc.Xstrcmp(tls, zFuncName, ts+32215) != 0 {
		return 0
	}
	if tcl.XTcl_GetCommandInfo(tls, interp, ts+32512, bp) == 0 {
		return 0
	}
	*(*uintptr)(unsafe.Pointer(pxFunc)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{overloadedGlobFunction}))
	*(*uintptr)(unsafe.Pointer(ppArg)) = interp
	return 1
}

func echoRename(tls *libc.TLS, vtab uintptr, zNewName uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	var p uintptr = vtab

	if simulateVtabError(tls, p, ts+32533) != 0 {
		return SQLITE_ERROR
	}

	if (*echo_vtab)(unsafe.Pointer(p)).FisPattern != 0 {
		var nThis int32 = int32(libc.Xstrlen(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis))
		var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+32541,
			libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzTableName, zNewName, (*echo_vtab)(unsafe.Pointer(p)).FzTableName+uintptr(nThis)))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	return rc
}

func echoSavepoint(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 {
	return SQLITE_OK
}

func echoRelease(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 {
	return SQLITE_OK
}

func echoRollbackTo(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 {
	return SQLITE_OK
}

var echoModule = sqlite3_module{
	FiVersion:      1,
	FxCreate:       0,
	FxConnect:      0,
	FxBestIndex:    0,
	FxDisconnect:   0,
	FxDestroy:      0,
	FxOpen:         0,
	FxClose:        0,
	FxFilter:       0,
	FxNext:         0,
	FxEof:          0,
	FxColumn:       0,
	FxRowid:        0,
	FxUpdate:       0,
	FxBegin:        0,
	FxSync:         0,
	FxCommit:       0,
	FxRollback:     0,
	FxFindFunction: 0,
	FxRename:       0,
}

var echoModuleV2 = sqlite3_module{
	FiVersion:      2,
	FxCreate:       0,
	FxConnect:      0,
	FxBestIndex:    0,
	FxDisconnect:   0,
	FxDestroy:      0,
	FxOpen:         0,
	FxClose:        0,
	FxFilter:       0,
	FxNext:         0,
	FxEof:          0,
	FxColumn:       0,
	FxRowid:        0,
	FxUpdate:       0,
	FxBegin:        0,
	FxSync:         0,
	FxCommit:       0,
	FxRollback:     0,
	FxFindFunction: 0,
	FxRename:       0,
	FxSavepoint:    0,
	FxRelease:      0,
	FxRollbackTo:   0,
}

func moduleDestroy(tls *libc.TLS, p uintptr) {
	var pMod uintptr = p
	sqlite3.Xsqlite3_create_function(tls, (*EchoModule)(unsafe.Pointer(pMod)).Fdb, ts+32571,
		SQLITE_ANY, 1, uintptr(0), uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, p)
}

func register_echo_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	var pMod uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}

	pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
	(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
	(*EchoModule)(unsafe.Pointer(pMod)).Fdb = *(*uintptr)(unsafe.Pointer(bp))
	rc = sqlite3.Xsqlite3_create_module_v2(tls,
		*(*uintptr)(unsafe.Pointer(bp)), ts+32609, uintptr(unsafe.Pointer(&echoModule)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{moduleDestroy})))

	if rc == SQLITE_OK {
		pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
		(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
		(*EchoModule)(unsafe.Pointer(pMod)).Fdb = *(*uintptr)(unsafe.Pointer(bp))
		rc = sqlite3.Xsqlite3_create_module_v2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+32614,
			uintptr(unsafe.Pointer(&echoModuleV2)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{moduleDestroy})))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func declare_vtab(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+14963)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_declare_vtab(tls, *(*uintptr)(unsafe.Pointer(bp)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp))), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

func Sqlitetest8_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd2))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd2[i].FzName,
			aObjCmd2[i].FxProc, aObjCmd2[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd2 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 32622, FxProc: 0},
	{FzName: ts + 32643, FxProc: 0},
}

func c_collation_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var zErrFunction uintptr

	var rc int32
	zErrFunction = ts + 32664
	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
	return TCL_ERROR
__1:
	;
	rc = sqlite3.Xsqlite3_open(tls, ts+1757, bp+24)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	zErrFunction = ts + 26445
	goto error_out
__2:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), ts+18363, 456, uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
	zErrFunction = ts + 32668
	goto error_out
__3:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32693, zErrFunction, 0))
	return TCL_ERROR
}

func c_realloc_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr
	var zErrFunction uintptr
	zErrFunction = ts + 32664

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
	return TCL_ERROR
__1:
	;
	p = sqlite3.Xsqlite3_malloc(tls, 5)
	if !!(p != 0) {
		goto __2
	}
	zErrFunction = ts + 32718
	goto error_out
__2:
	;
	p = sqlite3.Xsqlite3_realloc(tls, p, -1)
	if !(p != 0) {
		goto __3
	}
	zErrFunction = ts + 32733
	goto error_out
__3:
	;
	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32693, zErrFunction, 0))
	return TCL_ERROR
}

func c_misuse_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zErrFunction uintptr

	var rc int32
	zErrFunction = ts + 32664
	*(*uintptr)(unsafe.Pointer(bp + 24)) = uintptr(0)

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
	return TCL_ERROR
__1:
	;
	rc = sqlite3.Xsqlite3_open(tls, ts+1757, bp+24)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	zErrFunction = ts + 26445
	goto error_out
__2:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))

	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	zErrFunction = ts + 26351
	goto error_out
__3:
	;
	*(*uintptr)(unsafe.Pointer(bp + 28)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), uintptr(0), 0, bp+28, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	zErrFunction = ts + 26526
	goto error_out
__4:
	;
	*(*uintptr)(unsafe.Pointer(bp + 28)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), uintptr(0), 0, bp+28, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	zErrFunction = ts + 26560
	goto error_out
__5:
	;
	*(*uintptr)(unsafe.Pointer(bp + 28)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare16(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), uintptr(0), 0, bp+28, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	zErrFunction = ts + 26542
	goto error_out
__6:
	;
	*(*uintptr)(unsafe.Pointer(bp + 28)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare16_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), uintptr(0), 0, bp+28, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __7
	}
	zErrFunction = ts + 26622
	goto error_out
__7:
	;
	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32693, zErrFunction, 0))
	return TCL_ERROR
}

func Sqlitetest9_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd3))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd3[i].FzName,
			aObjCmd3[i].FxProc, aObjCmd3[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd3 = [3]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 32749, FxProc: 0},
	{FzName: ts + 32763, FxProc: 0},
	{FzName: ts + 32778, FxProc: 0},
}

func Sqlitetestasync_Init(tls *libc.TLS, interp uintptr) int32 {
	return TCL_OK
}

func resetAutoExtObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	sqlite3.Xsqlite3_reset_auto_extension(tls)
	return SQLITE_OK
}

func Sqlitetest_autoext_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32795,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{resetAutoExtObjCmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

func backupTestCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*[5]BackupSubCommand)(unsafe.Pointer(bp)) = [5]BackupSubCommand{
		{FzCmd: ts + 9840, FnArg: 1, FzArg: ts + 32824},
		{FzCmd: ts + 14670, FeCmd: uint32(1), FzArg: ts + 584},
		{FzCmd: ts + 32830, FeCmd: uint32(2), FzArg: ts + 584},
		{FzCmd: ts + 32840, FeCmd: uint32(3), FzArg: ts + 584},
		{},
	}

	var p uintptr = clientData

	var rc int32

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp, int32(unsafe.Sizeof(BackupSubCommand{})), ts+14633, 0, bp+80)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+(*BackupSubCommand)(unsafe.Pointer(bp+uintptr(*(*int32)(unsafe.Pointer(bp + 80)))*16)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*BackupSubCommand)(unsafe.Pointer(bp+uintptr(*(*int32)(unsafe.Pointer(bp + 80)))*16)).FzArg)
		return TCL_ERROR
	}

	switch (*BackupSubCommand)(unsafe.Pointer(bp + uintptr(*(*int32)(unsafe.Pointer(bp + 80)))*16)).FeCmd {
	case uint32(1):
		{
			var zCmdName uintptr

			zCmdName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv)))
			tcl.XTcl_GetCommandInfo(tls, interp, zCmdName, bp+84)
			(*Tcl_CmdInfo)(unsafe.Pointer(bp + 84)).FdeleteProc = uintptr(0)
			tcl.XTcl_SetCommandInfo(tls, interp, zCmdName, bp+84)
			tcl.XTcl_DeleteCommand(tls, interp, zCmdName)

			rc = sqlite3.Xsqlite3_backup_finish(tls, p)
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break

		}

	case uint32(0):
		{
			if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+116) {
				return TCL_ERROR
			}
			rc = sqlite3.Xsqlite3_backup_step(tls, p, *(*int32)(unsafe.Pointer(bp + 116)))
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break

		}

	case uint32(2):
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_remaining(tls, p)))
		break

	case uint32(3):
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_pagecount(tls, p)))
		break
	}

	return TCL_OK
}

type BackupSubCommand = struct {
	FzCmd uintptr
	FeCmd uint32
	FnArg int32
	FzArg uintptr
}

func backupTestFinish(tls *libc.TLS, clientData ClientData) {
	var pBackup uintptr = clientData
	sqlite3.Xsqlite3_backup_finish(tls, pBackup)
}

func backupTestInit(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pBackup uintptr

	var zDestName uintptr
	var zSrcName uintptr
	var zCmd uintptr

	if objc != 6 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+32850)
		return TCL_ERROR
	}

	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), bp+16)
	zDestName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4))), bp+20)
	zSrcName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 5*4)))

	pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), zDestName, *(*uintptr)(unsafe.Pointer(bp + 20)), zSrcName)
	if !(pBackup != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32896, 0))
		return TCL_ERROR
	}

	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestCmd})), pBackup, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{backupTestFinish})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func Sqlitetestbackup_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32925, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestInit})), uintptr(0), uintptr(0))
	return TCL_OK
}

type tcl_vtab1 = struct {
	Fbase              sqlite3_vtab
	Finterp            uintptr
	FpCmd              uintptr
	FpFindFunctionList uintptr
	Fdb                uintptr
}

type tcl_vtab = tcl_vtab1
type tcl_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
}

type tcl_cursor = tcl_cursor1
type TestFindFunction1 = struct {
	FpTab  uintptr
	FzName uintptr
	FpNext uintptr
}

type TestFindFunction = TestFindFunction1

func tclDequote(tls *libc.TLS, z uintptr) {
	var q int8 = *(*int8)(unsafe.Pointer(z))

	if int32(q) == '[' || int32(q) == '\'' || int32(q) == '"' || int32(q) == '`' {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}

		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(q) {
					iIn++
					break
				} else {
					iIn = iIn + 2
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
				}
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}

		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

func tclConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var interp uintptr = pAux
	var pTab uintptr = uintptr(0)
	var zCmd uintptr = uintptr(0)
	var pScript uintptr = uintptr(0)
	var rc int32 = SQLITE_OK

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+32940, 0)
		return SQLITE_ERROR
	}

	zCmd = sqlite3.Xsqlite3_malloc64(tls, uint64(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))+size_t(1)))
	pTab = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(tcl_vtab{})))
	if zCmd != 0 && pTab != 0 {
		libc.Xmemcpy(tls, zCmd, *(*uintptr)(unsafe.Pointer(argv + 3*4)), libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))+size_t(1))
		tclDequote(tls, zCmd)
		libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(tcl_vtab{})))

		(*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd = tcl.XTcl_NewStringObj(tls, zCmd, -1)
		(*tcl_vtab)(unsafe.Pointer(pTab)).Finterp = interp
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fdb = db
		(*Tcl_Obj)(unsafe.Pointer((*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)).FrefCount++

		pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+32000, -1))

		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
		if rc != TCL_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, tcl.XTcl_GetStringResult(tls, interp)))
			rc = SQLITE_ERROR
		} else {
			rc = sqlite3.Xsqlite3_declare_vtab(tls, db, tcl.XTcl_GetStringResult(tls, interp))
		}

		if rc != SQLITE_OK {
			sqlite3.Xsqlite3_free(tls, pTab)
			pTab = uintptr(0)
		}
	} else {
		rc = SQLITE_NOMEM
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	return rc
}

func tclDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var pTab uintptr = pVtab
	for (*tcl_vtab)(unsafe.Pointer(pTab)).FpFindFunctionList != 0 {
		var p uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).FpFindFunctionList
		(*tcl_vtab)(unsafe.Pointer(pTab)).FpFindFunctionList = (*TestFindFunction)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, p)
	}
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, pTab)
	return SQLITE_OK
}

func tclOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(tcl_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(tcl_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func tclClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	if pCur != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCur)).FpStmt)
		sqlite3.Xsqlite3_free(tls, pCur)
	}
	return SQLITE_OK
}

func tclNext(tls *libc.TLS, pVtabCursor uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = pVtabCursor
	if (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
		var rc int32 = sqlite3.Xsqlite3_step(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
		if rc != SQLITE_ROW {
			var zErr uintptr
			rc = sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
			(*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
			if rc != SQLITE_OK {
				zErr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
				(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zErr))
			}
		}
	}
	return SQLITE_OK
}

func tclFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pScript uintptr
	var pArg uintptr
	var ii int32
	var rc int32

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+32064, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewIntObj(tls, idxNum))
	if idxStr != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, idxStr, -1))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+584, -1))
	}

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < argc; ii++ {
		var zVal uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(ii)*4)))
		var pVal uintptr
		if zVal == uintptr(0) {
			pVal = tcl.XTcl_NewObj(tls)
			for rc = sqlite3.Xsqlite3_vtab_in_first(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(ii)*4)), bp+32); rc == SQLITE_OK && *(*uintptr)(unsafe.Pointer(bp + 32)) != 0; rc = sqlite3.Xsqlite3_vtab_in_next(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(ii)*4)), bp+32) {
				var pVal2 uintptr = uintptr(0)
				zVal = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))
				if zVal != 0 {
					pVal2 = tcl.XTcl_NewStringObj(tls, zVal, -1)
				} else {
					pVal2 = tcl.XTcl_NewObj(tls)
				}
				tcl.XTcl_ListObjAppendElement(tls, interp, pVal, pVal2)
			}
		} else {
			pVal = tcl.XTcl_NewStringObj(tls, zVal, -1)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pVal)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pArg)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = SQLITE_ERROR
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, zErr))
	} else {
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 40)) = uintptr(0)

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+36, bp+40)
		if rc != TCL_OK {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = SQLITE_ERROR
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, zErr))
		} else {
			for ii = 0; rc == SQLITE_OK && ii < *(*int32)(unsafe.Pointer(bp + 36)); ii = ii + 2 {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)) + uintptr(ii)*4)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)) + uintptr(ii+1)*4))
				if sqlite3.Xsqlite3_stricmp(tls, ts+1947, zCmd) == 0 {
					var zSql uintptr = tcl.XTcl_GetString(tls, p)
					rc = sqlite3.Xsqlite3_prepare_v2(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, pCsr+4, uintptr(0))
					if rc != SQLITE_OK {
						var zErr uintptr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
						(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+32966, libc.VaList(bp+16, zErr))
					}
				} else {
					rc = SQLITE_ERROR
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+32966, libc.VaList(bp+24, zCmd))
				}
			}
		}
	}

	if rc == SQLITE_OK {
		rc = tclNext(tls, pVtabCursor)
	}
	return rc
}

func tclColumn(tls *libc.TLS, pVtabCursor uintptr, ctx uintptr, i int32) int32 {
	var pCsr uintptr = pVtabCursor
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, i+1))
	return SQLITE_OK
}

func tclRowid(tls *libc.TLS, pVtabCursor uintptr, pRowid uintptr) int32 {
	var pCsr uintptr = pVtabCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return SQLITE_OK
}

func tclEof(tls *libc.TLS, pVtabCursor uintptr) int32 {
	var pCsr uintptr = pVtabCursor
	return libc.Bool32((*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0))
}

func testBestIndexObjConstraints(tls *libc.TLS, interp uintptr, pIdxInfo uintptr) {
	var ii int32
	var pRes uintptr = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRes)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		var zOp uintptr = uintptr(0)

		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) {
		case SQLITE_INDEX_CONSTRAINT_EQ:
			zOp = ts + 32981
			break
		case SQLITE_INDEX_CONSTRAINT_GT:
			zOp = ts + 32984
			break
		case SQLITE_INDEX_CONSTRAINT_LE:
			zOp = ts + 32987
			break
		case SQLITE_INDEX_CONSTRAINT_LT:
			zOp = ts + 32990
			break
		case SQLITE_INDEX_CONSTRAINT_GE:
			zOp = ts + 32993
			break
		case SQLITE_INDEX_CONSTRAINT_MATCH:
			zOp = ts + 32996
			break
		case SQLITE_INDEX_CONSTRAINT_LIKE:
			zOp = ts + 32210
			break
		case SQLITE_INDEX_CONSTRAINT_GLOB:
			zOp = ts + 32215
			break
		case SQLITE_INDEX_CONSTRAINT_REGEXP:
			zOp = ts + 7186
			break
		case SQLITE_INDEX_CONSTRAINT_NE:
			zOp = ts + 33002
			break
		case SQLITE_INDEX_CONSTRAINT_ISNOT:
			zOp = ts + 33005
			break
		case SQLITE_INDEX_CONSTRAINT_ISNOTNULL:
			zOp = ts + 33011
			break
		case SQLITE_INDEX_CONSTRAINT_ISNULL:
			zOp = ts + 33021
			break
		case SQLITE_INDEX_CONSTRAINT_IS:
			zOp = ts + 6208
			break
		case SQLITE_INDEX_CONSTRAINT_LIMIT:
			zOp = ts + 33028
			break
		case SQLITE_INDEX_CONSTRAINT_OFFSET:
			zOp = ts + 33034
			break
		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+6551, -1))
		if zOp != 0 {
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, zOp, -1))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop)))
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33041, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33048, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, pElem)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pElem
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, pRes)
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pRes
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func testBestIndexObjOrderby(tls *libc.TLS, interp uintptr, pIdxInfo uintptr) {
	var ii int32
	var pRes uintptr = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRes)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy; ii++ {
		var pOrder uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(ii)*8
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33041, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33055, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).Fdesc)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, pElem)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pElem
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, pRes)
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pRes
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func testBestIndexObj(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*[7]uintptr)(unsafe.Pointer(bp)) = [7]uintptr{
		ts + 33060,
		ts + 33072,
		ts + 33080,
		ts + 33085,
		ts + 33094,
		ts + 33097,
		uintptr(0),
	}

	var pIdxInfo uintptr = clientData

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2523)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp, int32(unsafe.Sizeof(uintptr(0))), ts+2014, 0, bp+28) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 28)) < 4 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 28)) == 4 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+33107)
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 28)) == 5 && objc != 3 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+33121)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 28)) {
	case 0:
		testBestIndexObjConstraints(tls, interp, pIdxInfo)
		break

	case 1:
		testBestIndexObjOrderby(tls, interp, pIdxInfo)
		break

	case 2:
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed)))
		break

	case 3:
		{
			var bDistinct int32 = sqlite3.Xsqlite3_vtab_distinct(tls, pIdxInfo)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, bDistinct))
			break

		}

	case 4:
		{
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+32) != 0 ||
				tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+36) != 0 {
				return TCL_ERROR
			}
			tcl.XTcl_SetObjResult(tls, interp,
				tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_vtab_in(tls, pIdxInfo, *(*int32)(unsafe.Pointer(bp + 32)), *(*int32)(unsafe.Pointer(bp + 36)))))
			break

		}

	case 5:
		{
			*(*int32)(unsafe.Pointer(bp + 40)) = 0
			var rc int32
			*(*uintptr)(unsafe.Pointer(bp + 44)) = uintptr(0)
			var zVal uintptr = ts + 584
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+40) != 0 {
				return TCL_ERROR
			}
			rc = sqlite3.Xsqlite3_vtab_rhs_value(tls, pIdxInfo, *(*int32)(unsafe.Pointer(bp + 40)), bp+44)
			if rc != SQLITE_OK && rc != SQLITE_NOTFOUND {
				tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
				return TCL_ERROR
			}
			if *(*uintptr)(unsafe.Pointer(bp + 44)) != 0 {
				zVal = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(bp + 44)))
			} else if objc == 4 {
				zVal = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zVal, -1))
			break

		}
	}

	return TCL_OK
}

func tclBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	bp := tls.Alloc(100)
	defer tls.Free(100)

	var pTab uintptr = tab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var rc int32 = SQLITE_OK

	var pScript uintptr

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+32118, -1))

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([24]int8{})), bp+56, ts+33137, libc.VaList(bp, libc.PostIncInt32(&iNext, 1)))
	tcl.XTcl_CreateObjCommand(tls, interp, bp+56, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testBestIndexObj})), pIdxInfo, uintptr(0))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, bp+56, -1))
	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	tcl.XTcl_DeleteCommand(tls, interp, bp+56)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	if rc != TCL_OK {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = SQLITE_ERROR
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, zErr))
	} else {
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 84)) = uintptr(0)

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+80, bp+84)
		if rc != TCL_OK {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = SQLITE_ERROR
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+16, zErr))
		} else {
			var ii int32
			var iArgv int32 = 1
			for ii = 0; rc == SQLITE_OK && ii < *(*int32)(unsafe.Pointer(bp + 80)); ii = ii + 2 {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 84)) + uintptr(ii)*4)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 84)) + uintptr(ii+1)*4))
				if sqlite3.Xsqlite3_stricmp(tls, ts+33149, zCmd) == 0 {
					rc = tcl.XTcl_GetDoubleFromObj(tls, interp, p, pIdxInfo+36)
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33072, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, pIdxInfo+32)
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33154, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, pIdxInfo+20)
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33161, zCmd) == 0 {
					sqlite3.Xsqlite3_free(tls, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+24, tcl.XTcl_GetString(tls, p)))
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33168, zCmd) == 0 {
					*(*Tcl_WideInt)(unsafe.Pointer(bp + 88)) = int64(0)
					rc = tcl.XTcl_GetWideIntFromObj(tls, interp, p, bp+88)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = sqlite3_int64(tRowcnt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 88))))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33173, zCmd) == 0 ||
					sqlite3.Xsqlite3_stricmp(tls, ts+33177, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, bp+96)
					if rc == SQLITE_OK {
						if *(*int32)(unsafe.Pointer(bp + 96)) < 0 || *(*int32)(unsafe.Pointer(bp + 96)) >= (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint {
							rc = SQLITE_ERROR
							(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+33182, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 96))))
						} else {
							var bOmit int32 = libc.Bool32(int32(*(*int8)(unsafe.Pointer(zCmd))) == 'o' || int32(*(*int8)(unsafe.Pointer(zCmd))) == 'O')
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)).FargvIndex = libc.PostIncInt32(&iArgv, 1)
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)).Fomit = uint8(bOmit)
						}
					}
				} else {
					rc = SQLITE_ERROR
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+32966, libc.VaList(bp+40, zCmd))
				}
				if rc != SQLITE_OK && (*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg == uintptr(0) {
					var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+48, zErr))
				}
			}
		}
	}

	return rc
}

var iNext int32 = 43

func tclFunction(tls *libc.TLS, pCtx uintptr, nArg int32, apArg uintptr) {
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer((*TestFindFunction)(unsafe.Pointer(p)).FpTab)).Finterp
	var pScript uintptr = uintptr(0)
	var pRet uintptr = uintptr(0)
	var ii int32

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer((*TestFindFunction)(unsafe.Pointer(p)).FpTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+18477, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, (*TestFindFunction)(unsafe.Pointer(p)).FzName, -1))

	for ii = 0; ii < nArg; ii++ {
		var zArg uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(ii)*4)))
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript,
			func() uintptr {
				if zArg != 0 {
					return tcl.XTcl_NewStringObj(tls, zArg, -1)
				}
				return tcl.XTcl_NewObj(tls)
			}())
	}
	tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	pRet = tcl.XTcl_GetObjResult(tls, interp)
	sqlite3.Xsqlite3_result_text(tls, pCtx, tcl.XTcl_GetString(tls, pRet), -1, libc.UintptrFromInt32(-1))
}

func tclFindFunction(tls *libc.TLS, tab uintptr, nArg int32, zName uintptr, pxFunc uintptr, ppArg uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = 0
	var pTab uintptr = tab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pScript uintptr = uintptr(0)
	var rc int32 = SQLITE_OK

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pScript, tcl.XTcl_NewStringObj(tls, ts+33197, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewIntObj(tls, nArg))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, zName, -1))
	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	if rc == SQLITE_OK {
		var pObj uintptr = tcl.XTcl_GetObjResult(tls, interp)

		if tcl.XTcl_GetIntFromObj(tls, interp, pObj, bp) != 0 {
			rc = SQLITE_ERROR
		} else if *(*int32)(unsafe.Pointer(bp)) > 0 {
			var nName sqlite3_int64 = sqlite3_int64(libc.Xstrlen(tls, zName))
			var nByte sqlite3_int64 = nName + int64(1) + sqlite3_int64(unsafe.Sizeof(TestFindFunction{}))
			var pNew uintptr = uintptr(0)

			pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
			if pNew == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp)) = 0
			} else {
				libc.Xmemset(tls, pNew, 0, uint32(nByte))
				(*TestFindFunction)(unsafe.Pointer(pNew)).FzName = pNew + 1*12
				libc.Xmemcpy(tls, (*TestFindFunction)(unsafe.Pointer(pNew)).FzName, zName, uint32(nName))
				(*TestFindFunction)(unsafe.Pointer(pNew)).FpTab = pTab
				(*TestFindFunction)(unsafe.Pointer(pNew)).FpNext = (*tcl_vtab)(unsafe.Pointer(pTab)).FpFindFunctionList
				(*tcl_vtab)(unsafe.Pointer(pTab)).FpFindFunctionList = pNew
				*(*uintptr)(unsafe.Pointer(ppArg)) = pNew
				*(*uintptr)(unsafe.Pointer(pxFunc)) = *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{tclFunction}))
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp))
}

var tclModule = sqlite3_module{
	FxCreate:       0,
	FxConnect:      0,
	FxBestIndex:    0,
	FxDisconnect:   0,
	FxDestroy:      0,
	FxOpen:         0,
	FxClose:        0,
	FxFilter:       0,
	FxNext:         0,
	FxEof:          0,
	FxColumn:       0,
	FxRowid:        0,
	FxFindFunction: 0,
}

func register_tcl_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+33211, uintptr(unsafe.Pointer(&tclModule)), interp)
	return TCL_OK
}

func Sqlitetesttcl_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd4))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd4[i].FzName,
			aObjCmd4[i].FxProc, aObjCmd4[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd4 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 33215, FxProc: 0},
}

func ptrToText(tls *libc.TLS, p uintptr) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, int32(uint32(unsafe.Sizeof(buf))-uint32(1)), uintptr(unsafe.Pointer(&buf)), ts+14791, libc.VaList(bp, p))
	return uintptr(unsafe.Pointer(&buf))
}

var buf [100]int8

func blobHandleFromObj1(tls *libc.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp)
	if *(*int32)(unsafe.Pointer(bp)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else if *(*int32)(unsafe.Pointer(bp)) > 9 && 0 == libc.Xmemcmp(tls, ts+33235, z, uint32(9)) {
		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4)
		if !(channel != 0) {
			return TCL_ERROR
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), SEEK_SET)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	} else {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = sqlite3TestTextToPtr(tls, z)
	}

	return TCL_OK
}

func blobStringFromObj(tls *libc.TLS, pObj uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var z uintptr
	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp)
	return func() uintptr {
		if *(*int32)(unsafe.Pointer(bp)) != 0 {
			return z
		}
		return uintptr(0)
	}()
}

func test_blob_open(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zDb uintptr
	var zTable uintptr
	var zColumn uintptr

	var zVarname uintptr

	*(*uintptr)(unsafe.Pointer(bp + 20)) = bp
	var rc int32

	if objc != 8 {
		var zUsage uintptr = ts + 33245
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, zUsage)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+4) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	zTable = blobStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 6*4)), bp) != 0 {
		return TCL_ERROR
	}
	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 7*4)), bp+16)

	if *(*int32)(unsafe.Pointer(bp + 16)) > 0 {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 4)), zDb, zTable, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp)), bp+20)
		tcl.XTcl_SetVar2(tls, interp, zVarname, uintptr(0), ptrToText(tls, *(*uintptr)(unsafe.Pointer(bp + 20))), 0)
	} else {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 4)), zDb, zTable, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	}

	if rc == SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

func test_blob_close(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_blob_close(tls, *(*uintptr)(unsafe.Pointer(bp)))

	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return TCL_OK
}

func test_blob_bytes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var nByte int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	nByte = sqlite3.Xsqlite3_blob_bytes(tls, *(*uintptr)(unsafe.Pointer(bp)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nByte))

	return TCL_OK
}

func test_blob_read(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var zBuf uintptr = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33297)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16) != 0 {
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+24) {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 24)) > 0 {
		zBuf = tcl.XTcl_AttemptAlloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 24))))
		if zBuf == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33314, 0))
			return TCL_ERROR
		}
	}
	rc = sqlite3.Xsqlite3_blob_read(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), zBuf, *(*int32)(unsafe.Pointer(bp + 24)), *(*int32)(unsafe.Pointer(bp + 20)))
	if rc == SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, zBuf, *(*int32)(unsafe.Pointer(bp + 24))))
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	tcl.XTcl_Free(tls, zBuf)

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

func test_blob_write(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	var zBuf uintptr

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33375)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) {
		return TCL_ERROR
	}

	zBuf = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8)
	if objc == 5 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_blob_write(tls, *(*uintptr)(unsafe.Pointer(bp)), zBuf, *(*int32)(unsafe.Pointer(bp + 8)), *(*int32)(unsafe.Pointer(bp + 4)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

func Sqlitetest_blob_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd5))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd5[i].FzName, aObjCmd5[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd5 = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 33402, FxProc: 0},
	{FzName: ts + 33420, FxProc: 0},
	{FzName: ts + 33439, FxProc: 0},
	{FzName: ts + 33458, FxProc: 0},
	{FzName: ts + 33476, FxProc: 0},
}

func sqlite3BtreeSharedCacheReport(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pBt uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	for pBt = sqlite3.Xsqlite3SharedCacheList; pBt != 0; pBt = (*BtShared)(unsafe.Pointer(pBt)).FpNext {
		var zFile uintptr = sqlite3.Xsqlite3PagerFilename(tls, (*BtShared)(unsafe.Pointer(pBt)).FpPager, 1)
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, zFile, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, (*BtShared)(unsafe.Pointer(pBt)).FnRef))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

func sqlite3BtreeCursorList(tls *libc.TLS, p uintptr) {
}

func set_options(tls *libc.TLS, interp uintptr) {
	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33510, ts+22605,
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33529, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33537, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33555, ts+33568, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33572, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33579, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33591, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33597, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33619, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33631, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33639, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33643, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33668, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33673,
		ts+33688, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33690, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33699, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33709, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33721, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+18414, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33735, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33743, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33748, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33753, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+18534, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33769, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33778, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33784, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33795, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+1957, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33806, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33816, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33828, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33836, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33842, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33852, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+15023, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33869, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33874, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+18005, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33882, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33892, ts+22605, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33903,
		ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33922, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33934, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33947, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33955, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33960, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33966, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33970, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+33985, ts+19147,
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34005, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+18400, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34025, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34034, ts+22605, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34043, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34053, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34062, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34071, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34082, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+5331, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34089, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34103, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34114, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34119, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34124, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34129, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34134, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34147, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34161, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34170, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34174, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+15849, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34189, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34201, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34214, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34223, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34232, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34242, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34252,
		func() uintptr {
			if uint32(unsafe.Sizeof(float64(0))) > uint32(unsafe.Sizeof(float64(0))) {
				return ts + 22605
			}
			return ts + 19147
		}(),
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34264, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34273, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34286, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34296, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34306, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34313, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34317, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34331, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+9919, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34338, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34346, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34352, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34367, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34382, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34397, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+23749, ts+22605, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34405, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34414, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34425, ts+19147, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34444, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34465, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34478, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34487, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34494,
		func() uintptr {
			if 1 != 0 {
				return ts + 22605
			}
			return ts + 19147
		}(), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34505,
		func() uintptr {
			if SQLITE_THREADSAFE == 1 {
				return ts + 22605
			}
			return ts + 19147
		}(), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34517,
		func() uintptr {
			if SQLITE_THREADSAFE == 2 {
				return ts + 22605
			}
			return ts + 19147
		}(), TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34529, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+18619, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34536, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34544, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+20687, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34557, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34564, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34569, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34574, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34578, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34582, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+18646, ts+22605, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34602, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34621, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34635, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34644, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34668, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34689, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34696, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34709, ts+19147, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+33495, ts+34719, ts+22605, TCL_GLOBAL_ONLY)

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34730, uintptr(unsafe.Pointer(&cv_MAX_LENGTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34748, uintptr(unsafe.Pointer(&cv_MAX_COLUMN)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34766, uintptr(unsafe.Pointer(&cv_MAX_SQL_LENGTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34788, uintptr(unsafe.Pointer(&cv_MAX_EXPR_DEPTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34810, uintptr(unsafe.Pointer(&cv_MAX_COMPOUND_SELECT)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34837, uintptr(unsafe.Pointer(&cv_MAX_VDBE_OP)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34856, uintptr(unsafe.Pointer(&cv_MAX_FUNCTION_ARG)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34880, uintptr(unsafe.Pointer(&cv_MAX_VARIABLE_NUMBER)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34907, uintptr(unsafe.Pointer(&cv_MAX_PAGE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34928, uintptr(unsafe.Pointer(&cv_MAX_PAGE_COUNT)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34950, uintptr(unsafe.Pointer(&cv_MAX_LIKE_PATTERN_LENGTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34981, uintptr(unsafe.Pointer(&cv_MAX_TRIGGER_DEPTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35006, uintptr(unsafe.Pointer(&cv_DEFAULT_CACHE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35032, uintptr(unsafe.Pointer(&cv_DEFAULT_PAGE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35057, uintptr(unsafe.Pointer(&cv_DEFAULT_FILE_FORMAT)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35084, uintptr(unsafe.Pointer(&cv_DEFAULT_SYNCHRONOUS)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35111, uintptr(unsafe.Pointer(&cv_DEFAULT_WAL_SYNCHRONOUS)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35142, uintptr(unsafe.Pointer(&cv_MAX_ATTACHED)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35162, uintptr(unsafe.Pointer(&cv_MAX_DEFAULT_PAGE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35191, uintptr(unsafe.Pointer(&cv_MAX_WORKER_THREADS)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35217, uintptr(unsafe.Pointer(&cv_TEMP_STORE)),
			TCL_LINK_INT|TCL_LINK_READ_ONLY)

	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35228, uintptr(unsafe.Pointer(&cv___GNUC__)),
			TCL_LINK_INT|TCL_LINK_READ_ONLY)

	}
}

var cv_MAX_LENGTH int32 = SQLITE_MAX_LENGTH
var cv_MAX_COLUMN int32 = SQLITE_MAX_COLUMN
var cv_MAX_SQL_LENGTH int32 = SQLITE_MAX_SQL_LENGTH
var cv_MAX_EXPR_DEPTH int32 = SQLITE_MAX_EXPR_DEPTH
var cv_MAX_COMPOUND_SELECT int32 = SQLITE_MAX_COMPOUND_SELECT
var cv_MAX_VDBE_OP int32 = SQLITE_MAX_VDBE_OP
var cv_MAX_FUNCTION_ARG int32 = SQLITE_MAX_FUNCTION_ARG
var cv_MAX_VARIABLE_NUMBER int32 = SQLITE_MAX_VARIABLE_NUMBER
var cv_MAX_PAGE_SIZE int32 = SQLITE_MAX_PAGE_SIZE
var cv_MAX_PAGE_COUNT int32 = SQLITE_MAX_PAGE_COUNT
var cv_MAX_LIKE_PATTERN_LENGTH int32 = SQLITE_MAX_LIKE_PATTERN_LENGTH
var cv_MAX_TRIGGER_DEPTH int32 = SQLITE_MAX_TRIGGER_DEPTH
var cv_DEFAULT_CACHE_SIZE int32 = -2000
var cv_DEFAULT_PAGE_SIZE int32 = SQLITE_DEFAULT_PAGE_SIZE
var cv_DEFAULT_FILE_FORMAT int32 = SQLITE_DEFAULT_FILE_FORMAT
var cv_DEFAULT_SYNCHRONOUS int32 = SQLITE_DEFAULT_SYNCHRONOUS
var cv_DEFAULT_WAL_SYNCHRONOUS int32 = SQLITE_DEFAULT_SYNCHRONOUS
var cv_MAX_ATTACHED int32 = SQLITE_MAX_ATTACHED
var cv_MAX_DEFAULT_PAGE_SIZE int32 = SQLITE_MAX_DEFAULT_PAGE_SIZE
var cv_MAX_WORKER_THREADS int32 = SQLITE_MAX_WORKER_THREADS
var cv_TEMP_STORE int32 = SQLITE_TEMP_STORE
var cv___GNUC__ int32 = 1

func Sqliteconfig_Init(tls *libc.TLS, interp uintptr) int32 {
	set_options(tls, interp)
	return TCL_OK
}

func sqlite3Delete83Name(tls *libc.TLS, z uintptr) {
	var i int32
	var sz int32
	sz = int32(libc.Xstrlen(tls, z))
	for i = sz - 1; i > 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '/' && int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '.'; i-- {
	}
	if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == '.' && sz > i+4 {
		libc.Xmemmove(tls, z+uintptr(i+1), z+uintptr(sz-3), uint32(4))
	}
}

func sqlite3DeleteUnlinkIfExists(tls *libc.TLS, pVfs uintptr, zFile uintptr, pbExists uintptr) int32 {
	var rc int32 = SQLITE_ERROR

	rc = libc.Xaccess(tls, zFile, F_OK)
	if rc != 0 {
		if *(*int32)(unsafe.Pointer(libc.X__error(tls))) == ENOENT {
			if pbExists != 0 {
				*(*int32)(unsafe.Pointer(pbExists)) = 0
			}
			rc = SQLITE_OK
		}
	} else {
		if pbExists != 0 {
			*(*int32)(unsafe.Pointer(pbExists)) = 1
		}
		rc = libc.Xunlink(tls, zFile)
	}
	return rc
}

func sqlite3_delete_database(tls *libc.TLS, zFile uintptr) int32 {
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var zBuf uintptr
	var nBuf int32
	var rc int32 = 0
	var i int32

	*(*[4]uintptr)(unsafe.Pointer(bp + 24)) = [4]uintptr{ts, ts + 35237, ts + 35248, ts + 35255}

	*(*[6]MFile)(unsafe.Pointer(bp + 40)) = [6]MFile{
		{FzFmt: ts + 35262},
		{FzFmt: ts + 35269},
		{FzFmt: ts + 35284},
		{FzFmt: ts + 35262, Fb83: 1},
		{FzFmt: ts + 35269, FiOffset: SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET, Fb83: 1},
		{FzFmt: ts + 35284, FiOffset: SQLITE_MULTIPLEX_WAL_8_3_OFFSET, Fb83: 1},
	}

	var pVfs uintptr = uintptr(0)

	nBuf = int32(libc.Xstrlen(tls, zFile)) + 100
	zBuf = sqlite3.Xsqlite3_malloc(tls, nBuf)
	if zBuf == uintptr(0) {
		return SQLITE_NOMEM
	}

	for i = 0; rc == 0 && uint32(i) < uint32(unsafe.Sizeof([4]uintptr{}))/uint32(unsafe.Sizeof(uintptr(0))); i++ {
		sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, *(*uintptr)(unsafe.Pointer(bp + 24 + uintptr(i)*4)), libc.VaList(bp, zFile))
		rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		if rc == 0 && i != 0 {
			sqlite3Delete83Name(tls, zBuf)
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		}
	}

	for i = 0; rc == 0 && uint32(i) < uint32(unsafe.Sizeof([6]MFile{}))/uint32(unsafe.Sizeof(MFile{})); i++ {
		var p uintptr = bp + 40 + uintptr(i)*12
		var iChunk int32
		for iChunk = 1; iChunk <= MX_CHUNK_NUMBER; iChunk++ {
			sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, (*MFile)(unsafe.Pointer(p)).FzFmt, libc.VaList(bp+8, zFile, iChunk+(*MFile)(unsafe.Pointer(p)).FiOffset))
			if (*MFile)(unsafe.Pointer(p)).Fb83 != 0 {
				sqlite3Delete83Name(tls, zBuf)
			}
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, bp+112)
			if *(*int32)(unsafe.Pointer(bp + 112)) == 0 || rc != 0 {
				break
			}
		}
	}

	sqlite3.Xsqlite3_free(tls, zBuf)
	return func() int32 {
		if rc != 0 {
			return SQLITE_ERROR
		}
		return SQLITE_OK
	}()
}

type MFile = struct {
	FzFmt    uintptr
	FiOffset int32
	Fb83     int32
}

func Sqlitetest_demovfs_Init(tls *libc.TLS, interp uintptr) int32 {
	return TCL_OK
}

type devsym_file1 = struct {
	Fbase  sqlite3_file
	FpReal uintptr
}

type devsym_file = devsym_file1

type DevsymGlobal = struct {
	FpVfs        uintptr
	FiDeviceChar int32
	FiSectorSize int32
	FnWriteCrash int32
}

var g1 = DevsymGlobal{FiSectorSize: 512}

func devsymClose(tls *libc.TLS, pFile uintptr) int32 {
	var p uintptr = pFile
	sqlite3.Xsqlite3OsClose(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
	return SQLITE_OK
}

func devsymRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

func devsymWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

func devsymTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsTruncate(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, size)
}

func devsymSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSync(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags)
}

func devsymFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pSize)
}

func devsymLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

func devsymUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsUnlock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

func devsymCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

func devsymFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileControl(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

func devsymSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	return g1.FiSectorSize
}

func devsymDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	return g1.FiDeviceChar
}

func devsymShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 {
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmLock})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
}

func devsymShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 {
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmMap})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, pp)
}

func devsymShmBarrier(tls *libc.TLS, pFile uintptr) {
	var p uintptr = pFile
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmBarrier})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

func devsymShmUnmap(tls *libc.TLS, pFile uintptr, delFlag int32) int32 {
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmUnmap})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, delFlag)
}

func devsymOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = p + 1*8
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&devsym_io_methods))
	}
	return rc
}

var devsym_io_methods = sqlite3_io_methods{
	FiVersion:               2,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
}

func devsymDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 {
	return sqlite3.Xsqlite3OsDelete(tls, g1.FpVfs, zPath, dirSync)
}

func devsymAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	return sqlite3.Xsqlite3OsAccess(tls, g1.FpVfs, zPath, flags, pResOut)
}

func devsymFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 {
	return sqlite3.Xsqlite3OsFullPathname(tls, g1.FpVfs, zPath, nOut, zOut)
}

func devsymRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	return sqlite3.Xsqlite3OsRandomness(tls, g1.FpVfs, nByte, zBufOut)
}

func devsymSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 {
	return sqlite3.Xsqlite3OsSleep(tls, g1.FpVfs, nMicro)
}

func devsymCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FxCurrentTime})).f(tls, g1.FpVfs, pTimeOut)
}

func writecrashSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

func writecrashDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

func writecrashWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var p uintptr = pFile
	if g1.FnWriteCrash > 0 {
		g1.FnWriteCrash--
		if g1.FnWriteCrash == 0 {
			libc.Xabort(tls)
		}
	}
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

func writecrashOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = p + 1*8
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&writecrash_io_methods))
	}
	return rc
}

var writecrash_io_methods = sqlite3_io_methods{
	FiVersion:               2,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
}

var devsym_vfs = sqlite3_vfs{
	FiVersion:      2,
	FszOsFile:      int32(unsafe.Sizeof(devsym_file{})),
	FmxPathname:    DEVSYM_MAX_PATHNAME,
	FzName:         ts + 35295,
	FxOpen:         0,
	FxDelete:       0,
	FxAccess:       0,
	FxFullPathname: 0,
	FxRandomness:   0,
	FxSleep:        0,
	FxCurrentTime:  0,
}

var writecrash_vfs = sqlite3_vfs{
	FiVersion:      2,
	FszOsFile:      int32(unsafe.Sizeof(devsym_file{})),
	FmxPathname:    DEVSYM_MAX_PATHNAME,
	FzName:         ts + 35302,
	FxOpen:         0,
	FxDelete:       0,
	FxAccess:       0,
	FxFullPathname: 0,
	FxRandomness:   0,
	FxSleep:        0,
	FxCurrentTime:  0,
}

func devsym_register(tls *libc.TLS, iDeviceChar int32, iSectorSize int32) {
	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	if iDeviceChar >= 0 {
		g1.FiDeviceChar = iDeviceChar
	} else {
		g1.FiDeviceChar = 0
	}
	if iSectorSize >= 0 {
		g1.FiSectorSize = iSectorSize
	} else {
		g1.FiSectorSize = 512
	}
}

func devsym_unregister(tls *libc.TLS) {
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&devsym_vfs)))
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&writecrash_vfs)))
	g1.FpVfs = uintptr(0)
	g1.FiDeviceChar = 0
	g1.FiSectorSize = 0
}

func devsym_crash_on_write(tls *libc.TLS, nWrite int32) {
	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	g1.FnWriteCrash = nWrite
}

type Tcl_StatBuf = stat

type fs_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
	FzDb  uintptr
	FzTbl uintptr
}

type fs_vtab = fs_vtab1
type fs_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpStmt  uintptr
	FzBuf   uintptr
	FnBuf   int32
	FnAlloc int32
}

type fs_cursor = fs_cursor1

type FsdirVtab1 = struct{ Fbase sqlite3_vtab }

type FsdirVtab = FsdirVtab1
type FsdirCsr1 = struct {
	Fbase   sqlite3_vtab_cursor
	FzDir   uintptr
	FpDir   uintptr
	FiRowid sqlite3_int64
	FpEntry uintptr
}

type FsdirCsr = FsdirCsr1

func fsdirConnect1(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+32940, 0)
		return SQLITE_ERROR
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FsdirVtab{})))
	if !(pTab != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(FsdirVtab{})))

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+35313)

	return SQLITE_OK
}

func fsdirDisconnect1(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func fsdirBestIndex1(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var ii int32

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0 && (*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			var pUsage uintptr
			pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return SQLITE_OK
}

func fsdirOpen1(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCur uintptr

	pCur = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(FsdirCsr{}))+uint32(256)))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(FsdirCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func fsdirClose1(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	if (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir != 0 {
		libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir)
	}
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FzDir)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func fsdirNext1(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur

	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry = libc.Xreaddir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry == uintptr(0) {
			libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
			(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
		}
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid++
	}

	return SQLITE_OK
}

func fsdirFilter1(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCsr uintptr = pVtabCursor
	var zDir uintptr
	var nDir int32

	if idxNum != 1 || argc != 1 {
		return SQLITE_ERROR
	}

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
	}

	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	nDir = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	(*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir = sqlite3.Xsqlite3_malloc(tls, nDir+1)
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemcpy(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, zDir, uint32(nDir+1))

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = libc.Xopendir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	return fsdirNext1(tls, pVtabCursor)
}

func fsdirEof1(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	return libc.Bool32((*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir == uintptr(0))
}

func fsdirColumn1(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCsr uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, -1, uintptr(0))
		break

	case 1:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry+24, -1, libc.UintptrFromInt32(-1))
		break

	default:
	}

	return SQLITE_OK
}

func fsdirRowid1(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid
	return SQLITE_OK
}

type FstreeVtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
}

type FstreeVtab = FstreeVtab1
type FstreeCsr1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
	Ffd    int32
}

type FstreeCsr = FstreeCsr1

func fstreeConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+32940, 0)
		return SQLITE_ERROR
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeVtab{})))
	if !(pTab != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pTab, 0, uint32(unsafe.Sizeof(FstreeVtab{})))
	(*FstreeVtab)(unsafe.Pointer(pTab)).Fdb = db

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+35342)

	return SQLITE_OK
}

func fstreeDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func fstreeBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0 && (*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0 && (int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_GLOB ||
			int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_LIKE ||
			int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			var pUsage uintptr
			pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100000.0
			return SQLITE_OK
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0
	return SQLITE_OK
}

func fstreeOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeCsr{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(FstreeCsr{})))
	(*FstreeCsr)(unsafe.Pointer(pCur)).Ffd = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func fstreeCloseFd(tls *libc.TLS, pCsr uintptr) {
	if (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd >= 0 {
		libc.Xclose(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = -1
	}
}

func fstreeClose(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

func fstreeNext(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	var rc int32

	fstreeCloseFd(tls, pCsr)
	rc = sqlite3.Xsqlite3_step(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	if rc != SQLITE_ROW {
		rc = sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	} else {
		rc = SQLITE_OK
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = libc.Xopen(tls, sqlite3.Xsqlite3_column_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0), O_RDONLY, 0)
	}

	return rc
}

func fstreeFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*FstreeCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	var rc int32
	var zSql uintptr = ts + 35378
	var zRoot uintptr
	var nRoot int32
	var zPrefix uintptr
	var nPrefix int32
	var zDir uintptr
	var nDir int32
	*(*[2]int8)(unsafe.Pointer(bp)) = [2]int8{int8(0), int8(0)}

	zRoot = ts + 35610
	nRoot = 1
	zPrefix = ts + 584
	nPrefix = 0

	zDir = zRoot
	nDir = nRoot

	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*FstreeVtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, pCsr+4, uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	if idxNum != 0 {
		var zQuery uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		switch idxNum {
		case SQLITE_INDEX_CONSTRAINT_GLOB:
			*(*int8)(unsafe.Pointer(bp)) = int8('*')
			*(*int8)(unsafe.Pointer(bp + 1)) = int8('?')
			break
			fallthrough
		case SQLITE_INDEX_CONSTRAINT_LIKE:
			*(*int8)(unsafe.Pointer(bp)) = int8('_')
			*(*int8)(unsafe.Pointer(bp + 1)) = int8('%')
			break
		}

		if sqlite3.Xsqlite3_strnicmp(tls, zQuery, zPrefix, nPrefix) == 0 {
			var i int32
			for i = nPrefix; *(*int8)(unsafe.Pointer(zQuery + uintptr(i))) != 0; i++ {
				if int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp))) || int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp + 1))) {
					break
				}
				if int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == '/' {
					nDir = i
				}
			}
			zDir = zQuery
		}
	}
	if nDir == 0 {
		nDir = 1
	}

	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 1, zDir, nDir, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 2, zRoot, nRoot, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 3, zPrefix, nPrefix, libc.UintptrFromInt32(-1))

	return fstreeNext(tls, pVtabCursor)
}

func fstreeEof(tls *libc.TLS, cur uintptr) int32 {
	var pCsr uintptr = cur
	return libc.Bool32((*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0))
}

func fstreeColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var pCsr uintptr = cur
	if i == 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0))
	} else {
		libc.Xfstat(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, bp)

		if int32((*stat)(unsafe.Pointer(bp)).Fst_mode)&0170000 == 0100000 {
			if i == 1 {
				sqlite3.Xsqlite3_result_int64(tls, ctx, (*stat)(unsafe.Pointer(bp)).Fst_size)
			} else {
				var nRead int32
				var aBuf uintptr = sqlite3.Xsqlite3_malloc(tls, int32((*stat)(unsafe.Pointer(bp)).Fst_mode)+1)
				if !(aBuf != 0) {
					return SQLITE_NOMEM
				}
				nRead = libc.Xread(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, aBuf, uint32((*stat)(unsafe.Pointer(bp)).Fst_mode))
				if nRead != int32((*stat)(unsafe.Pointer(bp)).Fst_mode) {
					return SQLITE_IOERR
				}
				sqlite3.Xsqlite3_result_blob(tls, ctx, aBuf, nRead, libc.UintptrFromInt32(-1))
				sqlite3.Xsqlite3_free(tls, aBuf)
			}
		}
	}

	return SQLITE_OK
}

func fstreeRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

func fsConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pVtab uintptr
	var nByte int32
	var zTbl uintptr
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*4))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+32940, 0)
		return SQLITE_ERROR
	}
	zTbl = *(*uintptr)(unsafe.Pointer(argv + 3*4))

	nByte = int32(uint32(unsafe.Sizeof(fs_vtab{})) + uint32(int32(libc.Xstrlen(tls, zTbl))) + uint32(1) + uint32(int32(libc.Xstrlen(tls, zDb))) + uint32(1))
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(nByte))
	if !(pVtab != 0) {
		return SQLITE_NOMEM
	}

	(*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl = pVtab + 1*24
	(*fs_vtab)(unsafe.Pointer(pVtab)).FzDb = (*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl + uintptr(libc.Xstrlen(tls, zTbl)+size_t(1))
	(*fs_vtab)(unsafe.Pointer(pVtab)).Fdb = db
	libc.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl, zTbl, libc.Xstrlen(tls, zTbl))
	libc.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzDb, zDb, libc.Xstrlen(tls, zDb))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+35612)

	return SQLITE_OK
}

func fsDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func fsOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(fs_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func fsClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func fsNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	var rc int32

	rc = sqlite3.Xsqlite3_step(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	if rc == SQLITE_ROW || rc == SQLITE_DONE {
		rc = SQLITE_OK
	}

	return rc
}

func fsFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var pCur uintptr = pVtabCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab

	if idxNum == 1 {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls,
			ts+35649, libc.VaList(bp, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return SQLITE_NOMEM
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, pCur+4, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_bind_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1, *(*uintptr)(unsafe.Pointer(argv)))
		}
	} else {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+3351, libc.VaList(bp+16, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return SQLITE_NOMEM
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, pCur+4, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
	}

	if rc == SQLITE_OK {
		rc = fsNext(tls, pVtabCursor)
	}
	return rc
}

func fsColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var pCur uintptr = cur

	if i == 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0))
	} else {
		var zFile uintptr = sqlite3.Xsqlite3_column_text(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1)

		var fd int32
		var n int32
		fd = libc.Xopen(tls, zFile, O_RDONLY, 0)
		if fd < 0 {
			return SQLITE_IOERR
		}
		libc.Xfstat(tls, fd, bp)

		if (*stat)(unsafe.Pointer(bp)).Fst_size >= off_t((*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc) {
			var nNew sqlite3_int64 = (*stat)(unsafe.Pointer(bp)).Fst_size * int64(2)
			var zNew uintptr
			if nNew < int64(1024) {
				nNew = int64(1024)
			}

			zNew = sqlite3.Xsqlite3Realloc(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint64(nNew))
			if zNew == uintptr(0) {
				libc.Xclose(tls, fd)
				return SQLITE_NOMEM
			}
			(*fs_cursor)(unsafe.Pointer(pCur)).FzBuf = zNew
			(*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc = int32(nNew)
		}

		n = libc.Xread(tls, fd, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint32((*stat)(unsafe.Pointer(bp)).Fst_size))
		libc.Xclose(tls, fd)
		if off_t(n) != (*stat)(unsafe.Pointer(bp)).Fst_size {
			return SQLITE_ERROR
		}
		(*fs_cursor)(unsafe.Pointer(pCur)).FnBuf = int32((*stat)(unsafe.Pointer(bp)).Fst_size)
		*(*int8)(unsafe.Pointer((*fs_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr((*fs_cursor)(unsafe.Pointer(pCur)).FnBuf))) = int8(0)

		sqlite3.Xsqlite3_result_text(tls, ctx, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, libc.UintptrFromInt32(-1))
	}
	return SQLITE_OK
}

func fsRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0)
	return SQLITE_OK
}

func fsEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return libc.Bool32(sqlite3.Xsqlite3_data_count(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt) == 0)
}

func fsBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn < 0 && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			var pUsage uintptr
			pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return SQLITE_OK
}

var fsModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

var fsdirModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

var fstreeModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func register_fs_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+35683, uintptr(unsafe.Pointer(&fsModule)), interp)
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+5682, uintptr(unsafe.Pointer(&fsdirModule)), uintptr(0))
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+35686, uintptr(unsafe.Pointer(&fstreeModule)), uintptr(0))
	return TCL_OK
}

func Sqlitetestfs_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd6))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd6[i].FzName,
			aObjCmd6[i].FxProc, aObjCmd6[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd6 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 35693, FxProc: 0},
}

func testContextMalloc(tls *libc.TLS, context uintptr, nByte int32) uintptr {
	var z uintptr = sqlite3.Xsqlite3_malloc(tls, nByte)
	if !(z != 0) && nByte > 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	}
	return z
}

func randStr(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(1004)
	defer tls.Free(1004)

	var iMin int32
	var iMax int32
	var n int32

	var i int32

	iMin = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if iMin < 0 {
		iMin = 0
	}
	if uint32(iMin) >= uint32(unsafe.Sizeof([1000]uint8{})) {
		iMin = int32(uint32(unsafe.Sizeof([1000]uint8{})) - uint32(1))
	}
	iMax = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
	if iMax < iMin {
		iMax = iMin
	}
	if uint32(iMax) >= uint32(unsafe.Sizeof([1000]uint8{})) {
		iMax = int32(uint32(unsafe.Sizeof([1000]uint8{})) - uint32(1))
	}
	n = iMin
	if iMax > iMin {
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp)
		*(*int32)(unsafe.Pointer(bp)) &= 0x7fffffff
		n = n + *(*int32)(unsafe.Pointer(bp))%(iMax+1-iMin)
	}

	sqlite3.Xsqlite3_randomness(tls, n, bp+4)
	for i = 0; i < n; i++ {
		*(*uint8)(unsafe.Pointer(bp + 4 + uintptr(i))) = zSrc[uint32(*(*uint8)(unsafe.Pointer(bp + 4 + uintptr(i))))%(uint32(unsafe.Sizeof(zSrc))-uint32(1))]
	}
	*(*uint8)(unsafe.Pointer(bp + 4 + uintptr(n))) = uint8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+4, n, libc.UintptrFromInt32(-1))
}

var zSrc = *(*[79]uint8)(unsafe.Pointer(ts + 35712))

var test_destructor_count_var int32 = 0

func destructor(tls *libc.TLS, p uintptr) {
	var zVal uintptr = p

	zVal--
	sqlite3.Xsqlite3_free(tls, zVal)
	test_destructor_count_var--
}

func test_destructor(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var zVal uintptr
	var len int32

	test_destructor_count_var++

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	len = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zVal = testContextMalloc(tls, pCtx, len+3)
	if !(zVal != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+1))) = int8(0)
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+2))) = int8(0)
	zVal++
	libc.Xmemcpy(tls, zVal, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), uint32(len))
	sqlite3.Xsqlite3_result_text(tls, pCtx, zVal, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{destructor})))
}

func test_destructor16(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var zVal uintptr
	var len int32

	test_destructor_count_var++

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	len = sqlite3.Xsqlite3_value_bytes16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zVal = testContextMalloc(tls, pCtx, len+3)
	if !(zVal != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+1))) = int8(0)
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+2))) = int8(0)
	zVal++
	libc.Xmemcpy(tls, zVal, sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv))), uint32(len))
	sqlite3.Xsqlite3_result_text16(tls, pCtx, zVal, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{destructor})))
}

func test_destructor_count(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	sqlite3.Xsqlite3_result_int(tls, pCtx, test_destructor_count_var)
}

func test_agg_errmsg16_step(tls *libc.TLS, a uintptr, b int32, c uintptr) {
}

func test_agg_errmsg16_final(tls *libc.TLS, ctx uintptr) {
	var z uintptr
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, ctx)
	sqlite3.Xsqlite3_aggregate_context(tls, ctx, 2048)
	z = sqlite3.Xsqlite3_errmsg16(tls, db)
	sqlite3.Xsqlite3_result_text16(tls, ctx, z, -1, libc.UintptrFromInt32(-1))
}

func free_test_auxdata(tls *libc.TLS, p uintptr) {
	sqlite3.Xsqlite3_free(tls, p)
}

func test_auxdata(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var i int32
	var zRet uintptr = testContextMalloc(tls, pCtx, nArg*2)
	if !(zRet != 0) {
		return
	}
	libc.Xmemset(tls, zRet, 0, uint32(nArg*2))
	for i = 0; i < nArg; i++ {
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
		if z != 0 {
			var n int32
			var zAux uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, i)
			if zAux != 0 {
				*(*int8)(unsafe.Pointer(zRet + uintptr(i*2))) = int8('1')

			} else {
				*(*int8)(unsafe.Pointer(zRet + uintptr(i*2))) = int8('0')
			}
			n = int32(libc.Xstrlen(tls, z)) + 1
			zAux = testContextMalloc(tls, pCtx, n)
			if zAux != 0 {
				libc.Xmemcpy(tls, zAux, z, uint32(n))
				sqlite3.Xsqlite3_set_auxdata(tls, pCtx, i, zAux, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{free_test_auxdata})))
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(i*2+1))) = int8(' ')
		}
	}
	sqlite3.Xsqlite3_result_text(tls, pCtx, zRet, 2*nArg-1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{free_test_auxdata})))
}

func test_error(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	sqlite3.Xsqlite3_result_error(tls, pCtx, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1)
	if nArg == 2 {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	}
}

func counterFunc(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var pCounter uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, 0)
	if pCounter == uintptr(0) {
		pCounter = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(int32(0))))
		if pCounter == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		*(*int32)(unsafe.Pointer(pCounter)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		sqlite3.Xsqlite3_set_auxdata(tls, pCtx, 0, pCounter, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		*(*int32)(unsafe.Pointer(pCounter))++
	}
	sqlite3.Xsqlite3_result_int(tls, pCtx, *(*int32)(unsafe.Pointer(pCounter)))
}

func test_isolation(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_value(tls, pCtx, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
}

func test_eval(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, pCtx)
	var zSql uintptr

	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8, uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
		if rc == SQLITE_ROW {
			sqlite3.Xsqlite3_result_value(tls, pCtx, sqlite3.Xsqlite3_column_value(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 0))
		}
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8)))
	}
	if rc != 0 {
		var zErr uintptr

		zErr = sqlite3.Xsqlite3_mprintf(tls, ts+35791, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		sqlite3.Xsqlite3_result_text(tls, pCtx, zErr, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	}
}

func testHexChar(tls *libc.TLS, c int8) int32 {
	if int32(c) >= '0' && int32(c) <= '9' {
		return int32(c) - '0'
	} else if int32(c) >= 'a' && int32(c) <= 'f' {
		return int32(c) - 'a' + 10
	} else if int32(c) >= 'A' && int32(c) <= 'F' {
		return int32(c) - 'A' + 10
	}
	return 0
}

func testHexToBin(tls *libc.TLS, zIn uintptr, zOut uintptr) {
	for *(*int8)(unsafe.Pointer(zIn)) != 0 && *(*int8)(unsafe.Pointer(zIn + 1)) != 0 {
		*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zOut, 1))) = int8(testHexChar(tls, *(*int8)(unsafe.Pointer(zIn)))<<4 + testHexChar(tls, *(*int8)(unsafe.Pointer(zIn + 1))))
		zIn += uintptr(2)
	}
}

func testHexToUtf16be(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, n/2)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text16be(tls, pCtx, zOut, n/2, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func testHexToUtf8(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, n/2)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text(tls, pCtx, zOut, n/2, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func testHexToUtf16le(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) {
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, n/2)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text16le(tls, pCtx, zOut, n/2, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func real2hex(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var i int32
	var bigEndian int32
	*(*sqlite3_uint64)(unsafe.Pointer(bp)) = uint64(1)
	bigEndian = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(bp))) == 0)
	*(*float64)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; i < 8; i++ {
		if bigEndian != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i*2))) = *(*int8)(unsafe.Pointer(ts + 35822 + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))>>4)))
			*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i*2+1))) = *(*int8)(unsafe.Pointer(ts + 35822 + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))&0xf)))
		} else {
			*(*int8)(unsafe.Pointer(bp + 8 + uintptr(14-i*2))) = *(*int8)(unsafe.Pointer(ts + 35822 + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))>>4)))
			*(*int8)(unsafe.Pointer(bp + 8 + uintptr(14-i*2+1))) = *(*int8)(unsafe.Pointer(ts + 35822 + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))&0xf)))
		}
	}
	*(*int8)(unsafe.Pointer(bp + 8 + 16)) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+8, -1, libc.UintptrFromInt32(-1))
}

func test_extract(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr
	var pHdr uintptr
	var pBody uintptr

	var iIdx int32
	var iCurrent int32 = 0

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	iIdx = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))

	pHdr = pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp))
	pBody = libc.AssignUintptr(&pEndHdr, pRec+uintptr(*(*u64)(unsafe.Pointer(bp))))

	for iCurrent = 0; pHdr < pEndHdr && iCurrent <= iIdx; iCurrent++ {
		libc.Xmemset(tls, bp+8, 0, uint32(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 8)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 8)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+48))
		sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 48))), bp+8)
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialTypeLen(tls, u32(*(*u64)(unsafe.Pointer(bp + 48)))))

		if iCurrent == iIdx {
			sqlite3.Xsqlite3_result_value(tls, context, bp+8)
		}

		if (*Mem)(unsafe.Pointer(bp+8)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+8)).FzMalloc)
		}
	}
}

func test_decode(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(107)
	defer tls.Free(107)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr
	var pHdr uintptr
	var pBody uintptr

	var pRet uintptr

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))

	pHdr = pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp+32))
	pBody = libc.AssignUintptr(&pEndHdr, pRec+uintptr(*(*u64)(unsafe.Pointer(bp + 32))))
	for pHdr < pEndHdr {
		var pVal uintptr = uintptr(0)

		libc.Xmemset(tls, bp+40, 0, uint32(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 40)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 40)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+80))
		sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 80))), bp+40)
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialTypeLen(tls, u32(*(*u64)(unsafe.Pointer(bp + 80)))))

		switch sqlite3.Xsqlite3_value_type(tls, bp+40) {
		case SQLITE_TEXT:
			pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, bp+40), -1)
			break

		case SQLITE_BLOB:
			{
				*(*[16]int8)(unsafe.Pointer(bp + 91)) = [16]int8{
					int8('0'), int8('1'), int8('2'), int8('3'), int8('4'), int8('5'), int8('6'), int8('7'),
					int8('8'), int8('9'), int8('a'), int8('b'), int8('c'), int8('d'), int8('e'), int8('f'),
				}
				var n int32 = sqlite3.Xsqlite3_value_bytes(tls, bp+40)
				var z uintptr = sqlite3.Xsqlite3_value_blob(tls, bp+40)
				var i int32
				pVal = tcl.XTcl_NewStringObj(tls, ts+6691, -1)
				for i = 0; i < n; i++ {
					*(*int8)(unsafe.Pointer(bp + 88)) = *(*int8)(unsafe.Pointer(bp + 91 + uintptr(int32(*(*u8)(unsafe.Pointer(z + uintptr(i))))>>4&0x0F)))
					*(*int8)(unsafe.Pointer(bp + 88 + 1)) = *(*int8)(unsafe.Pointer(bp + 91 + uintptr(int32(*(*u8)(unsafe.Pointer(z + uintptr(i))))&0x0F)))
					*(*int8)(unsafe.Pointer(bp + 88 + 2)) = int8(0)
					tcl.XTcl_AppendStringsToObj(tls, pVal, libc.VaList(bp, bp+88, 0))
				}
				tcl.XTcl_AppendStringsToObj(tls, pVal, libc.VaList(bp+16, ts+5981, 0))
				break

			}

		case SQLITE_FLOAT:
			pVal = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, bp+40))
			break

		case SQLITE_INTEGER:
			pVal = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, bp+40))
			break

		case SQLITE_NULL:
			pVal = tcl.XTcl_NewStringObj(tls, ts+6203, -1)
			break

		default:
		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, pVal)

		if (*Mem)(unsafe.Pointer(bp+40)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+40)).FzMalloc)
		}
	}

	sqlite3.Xsqlite3_result_text(tls, context, tcl.XTcl_GetString(tls, pRet), -1, libc.UintptrFromInt32(-1))
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func test_zeroblob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var nZero int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_zeroblob(tls, context, nZero)
}

func test_getsubtype(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	sqlite3.Xsqlite3_result_int(tls, context, int32(sqlite3.Xsqlite3_value_subtype(tls, *(*uintptr)(unsafe.Pointer(argv)))))
}

func test_frombind(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var m sqlite3_uint64 = uint64(0)
	var i int32
	for i = 0; i < argc && i < 63; i++ {
		if sqlite3.Xsqlite3_value_frombind(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))) != 0 {
			m = m | uint64(1)<<i
		}
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3_int64(m))
}

func test_setsubtype(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_subtype(tls, context, uint32(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))))
}

func registerTestFunctions(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aFuncs))/uint32(unsafe.Sizeof(struct {
		FzName       uintptr
		FnArg        int8
		F__ccgo_pad1 [3]byte
		FeTextRep    uint32
		FxFunc       uintptr
	}{})); i++ {
		sqlite3.Xsqlite3_create_function(tls, db, aFuncs[i].FzName, int32(aFuncs[i].FnArg),
			int32(aFuncs[i].FeTextRep), uintptr(0), aFuncs[i].FxFunc, uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_create_function(tls, db, ts+35839, 0, SQLITE_ANY, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_agg_errmsg16_step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{test_agg_errmsg16_final})))

	return SQLITE_OK
}

var aFuncs = [20]struct {
	FzName       uintptr
	FnArg        int8
	F__ccgo_pad1 [3]byte
	FeTextRep    uint32
	FxFunc       uintptr
}{
	{FzName: ts + 35857, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35865, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35881, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35899, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35914, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35929, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35941, FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35963, FnArg: int8(-1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35976, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35976, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35987, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 35997, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 36012, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 36025, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 36034, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 36046, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 36059, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8 | SQLITE_DETERMINISTIC), FxFunc: 0},
	{FzName: ts + 36073, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 36089, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 36105, FnArg: int8(-1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
}

func autoinstall_test_funcs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32 = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{Md5_Register})))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func tStep(tls *libc.TLS, a uintptr, b int32, c uintptr) {
}

func tFinal(tls *libc.TLS, a uintptr) {
}

func abuse_create_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var rc int32
	var mxArg int32

	if !(getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0) {
		goto __1
	}
	return TCL_ERROR
__1:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+36119, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __2
	}
	goto abuse_err
__2:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+36119, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	goto abuse_err
__3:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+36119, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	goto abuse_err
__4:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+36119, 1, SQLITE_UTF8, uintptr(0), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	goto abuse_err
__5:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+36119, 1, SQLITE_UTF8, uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	goto abuse_err
__6:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+36119, -2, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __7
	}
	goto abuse_err
__7:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+36119, 128, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __8
	}
	goto abuse_err
__8:
	;
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)),
		ts+36122,
		1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __9
	}
	goto abuse_err
__9:
	;
	sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), SQLITE_LIMIT_FUNCTION_ARG, 10000)
	mxArg = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), SQLITE_LIMIT_FUNCTION_ARG, -1)
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16)),
		ts+36379,
		mxArg, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __10
	}
	goto abuse_err
__10:
	;
	return TCL_OK

abuse_err:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+36635,
		uintptr(0)))
	return TCL_ERROR
}

func rankfunc(tls *libc.TLS, pCtx uintptr, nVal int32, apVal uintptr) {
	var aMatchinfo uintptr
	var nMatchinfo int32
	var nCol int32
	var nPhrase int32
	var iPhrase int32
	var score float64
	var nHitCount int32
	var nGlobalHitCount int32
	var weight float64
	var iCol int32

	var aPhraseinfo uintptr
	nCol = 0
	nPhrase = 0
	score = 0.0

	if !(nVal < 1) {
		goto __1
	}
	goto wrong_number_args
__1:
	;
	aMatchinfo = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	nMatchinfo = int32(uint32(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))) / uint32(unsafe.Sizeof(int32(0))))
	if !(nMatchinfo >= 2) {
		goto __2
	}
	nPhrase = *(*int32)(unsafe.Pointer(aMatchinfo))
	nCol = *(*int32)(unsafe.Pointer(aMatchinfo + 1*4))
__2:
	;
	if !(nMatchinfo != 2+3*nCol*nPhrase) {
		goto __3
	}
	sqlite3.Xsqlite3_result_error(tls, pCtx,
		ts+36678, -1)
	return
__3:
	;
	if !(nVal != 1+nCol) {
		goto __4
	}
	goto wrong_number_args
__4:
	;
	iPhrase = 0
__5:
	if !(iPhrase < nPhrase) {
		goto __7
	}

	aPhraseinfo = aMatchinfo + uintptr(2+iPhrase*nCol*3)*4
	iCol = 0
__8:
	if !(iCol < nCol) {
		goto __10
	}
	nHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr(3*iCol)*4))
	nGlobalHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr(3*iCol+1)*4))
	weight = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(iCol+1)*4)))
	if !(nHitCount > 0) {
		goto __11
	}
	score = score + float64(nHitCount)/float64(nGlobalHitCount)*weight
__11:
	;
	goto __9
__9:
	iCol++
	goto __8
	goto __10
__10:
	;
	goto __6
__6:
	iPhrase++
	goto __5
	goto __7
__7:
	;
	sqlite3.Xsqlite3_result_double(tls, pCtx, score)
	return

wrong_number_args:
	sqlite3.Xsqlite3_result_error(tls, pCtx, ts+36727, -1)
}

func install_fts3_rank_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}

	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+36772, -1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{rankfunc})), uintptr(0), uintptr(0))
	return TCL_OK
}

func Sqlitetest_func_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd7))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd7[i].FzName, aObjCmd7[i].FxProc, uintptr(0), uintptr(0))
	}
	sqlite3.Xsqlite3_initialize(tls)
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{Md5_Register})))
	return TCL_OK
}

var aObjCmd7 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 36777, FxProc: 0},
	{FzName: ts + 36804, FxProc: 0},
	{FzName: ts + 36826, FxProc: 0},
}

func sqlite3TestBinToHex(tls *libc.TLS, zBuf uintptr, N int32) {
	bp := tls.Alloc(17)
	defer tls.Free(17)

	*(*[17]uint8)(unsafe.Pointer(bp)) = *(*[17]uint8)(unsafe.Pointer(ts + 36853))
	var i int32
	var j int32
	var c uint8
	i = N * 2
	*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = uint8(0)
	for j = N - 1; j >= 0; j-- {
		c = *(*uint8)(unsafe.Pointer(zBuf + uintptr(j)))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp + uintptr(int32(c)&0xf)))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp + uintptr(int32(c)>>4)))
	}

}

func sqlite3TestHexToBin(tls *libc.TLS, zIn uintptr, N int32, aOut uintptr) int32 {
	bp := tls.Alloc(256)
	defer tls.Free(256)

	*(*[256]uint8)(unsafe.Pointer(bp)) = [256]uint8{
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
	}
	var i int32
	var j int32
	var hi int32 = 1
	var c uint8

	for i = libc.AssignInt32(&j, 0); i < N; i++ {
		c = *(*uint8)(unsafe.Pointer(bp + uintptr(*(*uint8)(unsafe.Pointer(zIn + uintptr(i))))))
		if int32(c) == 0 {
			continue
		}
		if hi != 0 {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(j))) = uint8((int32(c) - 1) << 4)
			hi = 0
		} else {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(libc.PostIncInt32(&j, 1)))) |= uint8(int32(c) - 1)
			hi = 1
		}
	}
	return j
}

func hexio_read(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var got int32
	var zFile uintptr
	var zBuf uintptr
	var in uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36870)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+40) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+44) != 0 {
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zBuf = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 44))*2+1)
	if zBuf == uintptr(0) {
		return TCL_ERROR
	}
	in = libc.Xfopen(tls, zFile, ts+4759)
	if in == uintptr(0) {
		in = libc.Xfopen(tls, zFile, ts+36890)
	}
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+36892, zFile, 0))
		return TCL_ERROR
	}
	libc.Xfseek(tls, in, *(*int32)(unsafe.Pointer(bp + 40)), SEEK_SET)
	got = int32(libc.Xfread(tls, zBuf, uint32(1), uint32(*(*int32)(unsafe.Pointer(bp + 44))), in))
	libc.Xfclose(tls, in)
	if got < 0 {
		got = 0
	}
	sqlite3TestBinToHex(tls, zBuf, got)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, zBuf, 0))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return TCL_OK
}

func hexio_write(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var nOut int32
	var written int32
	var zFile uintptr
	var zIn uintptr
	var aOut uintptr
	var out uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36916)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+24) != 0 {
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+28)
	aOut = sqlite3.Xsqlite3_malloc(tls, 1+*(*int32)(unsafe.Pointer(bp + 28))/2)
	if aOut == uintptr(0) {
		return TCL_ERROR
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp + 28)), aOut)
	out = libc.Xfopen(tls, zFile, ts+36940)
	if out == uintptr(0) {
		out = libc.Xfopen(tls, zFile, ts+36944)
	}
	if out == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+36947, zFile, 0))
		return TCL_ERROR
	}
	libc.Xfseek(tls, out, *(*int32)(unsafe.Pointer(bp + 24)), SEEK_SET)
	written = int32(libc.Xfwrite(tls, aOut, uint32(1), uint32(nOut), out))
	sqlite3.Xsqlite3_free(tls, aOut)
	libc.Xfclose(tls, out)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, written))
	return TCL_OK
}

func hexio_get_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var val int32

	var nOut int32
	var zIn uintptr
	var aOut uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36972)
		return TCL_ERROR
	}
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp)
	aOut = sqlite3.Xsqlite3_malloc(tls, 1+*(*int32)(unsafe.Pointer(bp))/2)
	if aOut == uintptr(0) {
		return TCL_ERROR
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp)), aOut)
	if nOut >= 4 {
		libc.Xmemcpy(tls, bp+4, aOut, uint32(4))
	} else {
		libc.Xmemset(tls, bp+4, 0, uint32(unsafe.Sizeof([4]uint8{})))
		libc.Xmemcpy(tls, bp+4+uintptr(4-nOut), aOut, uint32(nOut))
	}
	sqlite3.Xsqlite3_free(tls, aOut)
	val = int32(*(*uint8)(unsafe.Pointer(bp + 4)))<<24 | int32(*(*uint8)(unsafe.Pointer(bp + 4 + 1)))<<16 | int32(*(*uint8)(unsafe.Pointer(bp + 4 + 2)))<<8 | int32(*(*uint8)(unsafe.Pointer(bp + 4 + 3)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, val))
	return TCL_OK
}

func hexio_render_int16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(14)
	defer tls.Free(14)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2413)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	*(*uint8)(unsafe.Pointer(bp + 4)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 8)
	*(*uint8)(unsafe.Pointer(bp + 4 + 1)) = uint8(*(*int32)(unsafe.Pointer(bp)))
	sqlite3TestBinToHex(tls, bp+4, 2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4, 4))
	return TCL_OK
}

func hexio_render_int32(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(14)
	defer tls.Free(14)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2413)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	*(*uint8)(unsafe.Pointer(bp + 4)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 24)
	*(*uint8)(unsafe.Pointer(bp + 4 + 1)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 16)
	*(*uint8)(unsafe.Pointer(bp + 4 + 2)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 8)
	*(*uint8)(unsafe.Pointer(bp + 4 + 3)) = uint8(*(*int32)(unsafe.Pointer(bp)))
	sqlite3TestBinToHex(tls, bp+4, 4)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4, 8))
	return TCL_OK
}

func utf8_to_utf8(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp, ts+36980, 0))
	return TCL_ERROR
}

func getFts3Varint(tls *libc.TLS, p uintptr, v uintptr) int32 {
	var q uintptr = p
	var x sqlite_uint64 = uint64(0)
	var y sqlite_uint64 = uint64(1)
	for int32(*(*uint8)(unsafe.Pointer(q)))&0x80 == 0x80 {
		x = x + y*sqlite_uint64(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))))&0x7f)
		y <<= 7
	}
	x = x + y*sqlite_uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))))
	*(*sqlite_int64)(unsafe.Pointer(v)) = sqlite_int64(x)
	return (int32(q) - int32(p)) / 1
}

func putFts3Varint(tls *libc.TLS, p uintptr, v sqlite_int64) int32 {
	var q uintptr = p
	var vu sqlite_uint64 = sqlite_uint64(v)
	for __ccgo := true; __ccgo; __ccgo = vu != uint64(0) {
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(vu&uint64(0x7f) | uint64(0x80))
		vu >>= 7
	}
	*(*uint8)(unsafe.Pointer(q + libc.UintptrFromInt32(-1))) &= uint8(0x7f)

	return (int32(q) - int32(p)) / 1
}

func read_fts3varint(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var zBlob uintptr

	var nVal int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37034)
		return TCL_ERROR
	}
	zBlob = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp)

	nVal = getFts3Varint(tls, zBlob, bp+4)
	tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(0), tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 4))), 0)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nVal))
	return TCL_OK
}

func make_fts3record(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	*(*uintptr)(unsafe.Pointer(bp + 4)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp)) = 0
	var aOut uintptr = uintptr(0)
	var nOut int32 = 0
	var nAlloc int32 = 0
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37047)
		return TCL_ERROR
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp, bp+4) != 0 {
		return TCL_ERROR
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp)); i++ {
		if TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4)) + uintptr(i)*4)), bp+8) {
			if nOut+10 > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = nAlloc * 2
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return TCL_ERROR
				}
				aOut = aNew
				nAlloc = nNew
			}
			nOut = nOut + putFts3Varint(tls, aOut+uintptr(nOut), *(*sqlite3_int64)(unsafe.Pointer(bp + 8)))
		} else {
			*(*int32)(unsafe.Pointer(bp + 16)) = 0
			var zVal uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4)) + uintptr(i)*4)), bp+16)
			for nOut+*(*int32)(unsafe.Pointer(bp + 16)) > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = nAlloc * 2
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return TCL_ERROR
				}
				aOut = aNew
				nAlloc = nNew
			}
			libc.Xmemcpy(tls, aOut+uintptr(nOut), zVal, uint32(*(*int32)(unsafe.Pointer(bp + 16))))
			nOut = nOut + *(*int32)(unsafe.Pointer(bp + 16))
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, aOut, nOut))
	sqlite3.Xsqlite3_free(tls, aOut)
	return TCL_OK
}

func Sqlitetest_hexio_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd8))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd8[i].FzName, aObjCmd8[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd8 = [8]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 37052, FxProc: 0},
	{FzName: ts + 37063, FxProc: 0},
	{FzName: ts + 37075, FxProc: 0},
	{FzName: ts + 37089, FxProc: 0},
	{FzName: ts + 37108, FxProc: 0},
	{FzName: ts + 37127, FxProc: 0},
	{FzName: ts + 37140, FxProc: 0},
	{FzName: ts + 37156, FxProc: 0},
}

type Wrapped = struct {
	Fpcache      sqlite3_pcache_methods2
	Fmem         sqlite3_mem_methods
	Fmutex       sqlite3_mutex_methods
	Fmem_init    int32
	Fmem_fail    int32
	Fmutex_init  int32
	Fmutex_fail  int32
	Fpcache_init int32
	Fpcache_fail int32
}

var wrapped Wrapped

func wrMemInit(tls *libc.TLS, pAppData uintptr) int32 {
	var rc int32
	if wrapped.Fmem_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxInit})).f(tls, wrapped.Fmem.FpAppData)
	}
	if rc == SQLITE_OK {
		wrapped.Fmem_init = 1
	}
	return rc
}

func wrMemShutdown(tls *libc.TLS, pAppData uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxShutdown})).f(tls, wrapped.Fmem.FpAppData)
	wrapped.Fmem_init = 0
}

func wrMemMalloc(tls *libc.TLS, n int32) uintptr {
	return (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxMalloc})).f(tls, n)
}

func wrMemFree(tls *libc.TLS, p uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxFree})).f(tls, p)
}

func wrMemRealloc(tls *libc.TLS, p uintptr, n int32) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxRealloc})).f(tls, p, n)
}

func wrMemSize(tls *libc.TLS, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxSize})).f(tls, p)
}

func wrMemRoundup(tls *libc.TLS, n int32) int32 {
	return (*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxRoundup})).f(tls, n)
}

func wrMutexInit(tls *libc.TLS) int32 {
	var rc int32
	if wrapped.Fmutex_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexInit})).f(tls)
	}
	if rc == SQLITE_OK {
		wrapped.Fmutex_init = 1
	}
	return rc
}

func wrMutexEnd(tls *libc.TLS) int32 {
	(*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexEnd})).f(tls)
	wrapped.Fmutex_init = 0
	return SQLITE_OK
}

func wrMutexAlloc(tls *libc.TLS, e int32) uintptr {
	return (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexAlloc})).f(tls, e)
}

func wrMutexFree(tls *libc.TLS, p uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexFree})).f(tls, p)
}

func wrMutexEnter(tls *libc.TLS, p uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexEnter})).f(tls, p)
}

func wrMutexTry(tls *libc.TLS, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexTry})).f(tls, p)
}

func wrMutexLeave(tls *libc.TLS, p uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexLeave})).f(tls, p)
}

func wrMutexHeld(tls *libc.TLS, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexHeld})).f(tls, p)
}

func wrMutexNotheld(tls *libc.TLS, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexNotheld})).f(tls, p)
}

func wrPCacheInit(tls *libc.TLS, pArg uintptr) int32 {
	var rc int32
	if wrapped.Fpcache_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxInit})).f(tls, wrapped.Fpcache.FpArg)
	}
	if rc == SQLITE_OK {
		wrapped.Fpcache_init = 1
	}
	return rc
}

func wrPCacheShutdown(tls *libc.TLS, pArg uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxShutdown})).f(tls, wrapped.Fpcache.FpArg)
	wrapped.Fpcache_init = 0
}

func wrPCacheCreate(tls *libc.TLS, a int32, b int32, c int32) uintptr {
	return (*struct {
		f func(*libc.TLS, int32, int32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxCreate})).f(tls, a, b, c)
}

func wrPCacheCachesize(tls *libc.TLS, p uintptr, n int32) {
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxCachesize})).f(tls, p, n)
}

func wrPCachePagecount(tls *libc.TLS, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxPagecount})).f(tls, p)
}

func wrPCacheFetch(tls *libc.TLS, p uintptr, a uint32, b int32) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uint32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxFetch})).f(tls, p, a, b)
}

func wrPCacheUnpin(tls *libc.TLS, p uintptr, a uintptr, b int32) {
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxUnpin})).f(tls, p, a, b)
}

func wrPCacheRekey(tls *libc.TLS, p uintptr, a uintptr, b uint32, c uint32) {
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uint32, uint32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxRekey})).f(tls, p, a, b, c)
}

func wrPCacheTruncate(tls *libc.TLS, p uintptr, a uint32) {
	(*struct {
		f func(*libc.TLS, uintptr, uint32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxTruncate})).f(tls, p, a)
}

func wrPCacheDestroy(tls *libc.TLS, p uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxDestroy})).f(tls, p)
}

func installInitWrappers(tls *libc.TLS) {
	bp := tls.Alloc(168)
	defer tls.Free(168)

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 48)) = sqlite3_mutex_methods{
		FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{wrMutexInit})), FxMutexEnd: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{wrMutexEnd})), FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{wrMutexAlloc})),
		FxMutexFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexFree})), FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexEnter})), FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexTry})),
		FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexLeave})), FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexHeld})), FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexNotheld})),
	}
	*(*sqlite3_pcache_methods2)(unsafe.Pointer(bp + 116)) = sqlite3_pcache_methods2{
		FiVersion: 1,
		FxInit: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrPCacheInit})), FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrPCacheShutdown})), FxCreate: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32, int32, int32) uintptr
		}{wrPCacheCreate})),
		FxCachesize: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32)
		}{wrPCacheCachesize})), FxPagecount: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrPCachePagecount})), FxFetch: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uint32, int32) uintptr
		}{wrPCacheFetch})),
		FxUnpin: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		}{wrPCacheUnpin})), FxRekey: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uint32, uint32)
		}{wrPCacheRekey})), FxTruncate: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uint32)
		}{wrPCacheTruncate})),
		FxDestroy: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrPCacheDestroy})),
	}
	*(*sqlite3_mem_methods)(unsafe.Pointer(bp + 84)) = sqlite3_mem_methods{
		FxMalloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{wrMemMalloc})), FxFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMemFree})), FxRealloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		}{wrMemRealloc})),
		FxSize: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMemSize})), FxRoundup: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{wrMemRoundup})), FxInit: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMemInit})),
		FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMemShutdown})),
	}

	libc.Xmemset(tls, uintptr(unsafe.Pointer(&wrapped)), 0, uint32(unsafe.Sizeof(wrapped)))

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMUTEX, libc.VaList(bp, uintptr(unsafe.Pointer(&wrapped))+84))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp+8, uintptr(unsafe.Pointer(&wrapped))+52))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETPCACHE2, libc.VaList(bp+16, uintptr(unsafe.Pointer(&wrapped))))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+24, bp+48))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+32, bp+84))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+40, bp+116))
}

func init_wrapper_install(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var i int32
	installInitWrappers(tls)
	for i = 1; i < objc; i++ {
		var z uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)))
		if libc.Xstrcmp(tls, z, ts+37172) == 0 {
			wrapped.Fmem_fail = 1
		} else if libc.Xstrcmp(tls, z, ts+33778) == 0 {
			wrapped.Fmutex_fail = 1
		} else if libc.Xstrcmp(tls, z, ts+37176) == 0 {
			wrapped.Fpcache_fail = 1
		} else {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37183, z, ts+16912))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

func init_wrapper_uninstall(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp, uintptr(unsafe.Pointer(&wrapped))+84))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+8, uintptr(unsafe.Pointer(&wrapped))+52))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+16, uintptr(unsafe.Pointer(&wrapped))))
	return TCL_OK
}

func init_wrapper_clear(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	wrapped.Fmem_fail = 0
	wrapped.Fmutex_fail = 0
	wrapped.Fpcache_fail = 0
	return TCL_OK
}

func init_wrapper_query(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var pRet uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	if wrapped.Fmutex_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+33778, -1))
	}
	if wrapped.Fmem_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+37172, -1))
	}
	if wrapped.Fpcache_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+37176, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

func Sqlitetest_init_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd9))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd9[i].FzName, aObjCmd9[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aObjCmd9 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 37203, FxProc: 0},
	{FzName: ts + 37224, FxProc: 0},
	{FzName: ts + 37243, FxProc: 0},
	{FzName: ts + 37266, FxProc: 0},
}

type sqlite3_intarray1 = struct {
	Fn     int32
	Fa     uintptr
	FxFree uintptr
}

type sqlite3_intarray = sqlite3_intarray1

type intarray_vtab1 = struct {
	Fbase     sqlite3_vtab
	FpContent uintptr
}

type intarray_vtab = intarray_vtab1
type intarray_cursor1 = struct {
	Fbase sqlite3_vtab_cursor
	Fi    int32
}

type intarray_cursor = intarray_cursor1

func intarrayFree(tls *libc.TLS, p uintptr) {
	if (*sqlite3_intarray)(unsafe.Pointer(p)).FxFree != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_intarray)(unsafe.Pointer(p)).FxFree})).f(tls, (*sqlite3_intarray)(unsafe.Pointer(p)).Fa)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func intarrayDestroy(tls *libc.TLS, p uintptr) int32 {
	var pVtab uintptr = p
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

func intarrayCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var rc int32 = SQLITE_NOMEM
	var pVtab uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_vtab{})))

	if pVtab != 0 {
		libc.Xmemset(tls, pVtab, 0, uint32(unsafe.Sizeof(intarray_vtab{})))
		(*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent = pAux
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+37285)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

func intarrayOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var rc int32 = SQLITE_NOMEM
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_cursor{})))
	if pCur != 0 {
		libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(intarray_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = SQLITE_OK
	}
	return rc
}

func intarrayClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func intarrayColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if (*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= 0 && (*intarray_cursor)(unsafe.Pointer(pCur)).Fi < (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn {
		sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer((*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fa + uintptr((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)*8)))
	}
	return SQLITE_OK
}

func intarrayRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)
	return SQLITE_OK
}

func intarrayEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	return libc.Bool32((*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn)
}

func intarrayNext(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi++
	return SQLITE_OK
}

func intarrayFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = pVtabCursor
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi = 0
	return SQLITE_OK
}

func intarrayBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	return SQLITE_OK
}

var intarrayModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func sqlite3_intarray_create(tls *libc.TLS, db uintptr, zName uintptr, ppReturn uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = SQLITE_OK
	var p uintptr

	*(*uintptr)(unsafe.Pointer(ppReturn)) = libc.AssignUintptr(&p, sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(sqlite3_intarray{}))))
	if p == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(sqlite3_intarray{})))
	rc = sqlite3.Xsqlite3_create_module_v2(tls, db, zName, uintptr(unsafe.Pointer(&intarrayModule)), p,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{intarrayFree})))
	if rc == SQLITE_OK {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+37327,
			libc.VaList(bp, zName, zName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	return rc
}

func sqlite3_intarray_bind(tls *libc.TLS, pIntArray uintptr, nElements int32, aElements uintptr, xFree uintptr) int32 {
	if (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree})).f(tls, (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa)
	}
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fn = nElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa = aElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree = xFree
	return SQLITE_OK
}

func test_intarray_create(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var zName uintptr

	var rc int32 = SQLITE_OK

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	rc = sqlite3_intarray_create(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), zName, bp+36)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}
	sqlite3TestMakePointerStr(tls, interp, bp+40, *(*uintptr)(unsafe.Pointer(bp + 36)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, bp+40, uintptr(0)))
	return TCL_OK
}

func test_intarray_bind(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var pArray uintptr
	var rc int32 = SQLITE_OK
	var i int32
	var n int32
	var a uintptr

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37365)
		return TCL_ERROR
	}
	pArray = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	n = objc - 2
	a = sqlite3.Xsqlite3_malloc64(tls, uint64(uint32(unsafe.Sizeof(sqlite3_int64(0)))*uint32(n)))
	if a == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37374, uintptr(0)))
		return TCL_ERROR
	}
	for i = 0; i < n; i++ {
		*(*Tcl_WideInt)(unsafe.Pointer(bp + 32)) = int64(0)
		tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + uintptr(i+2)*4)), bp+32)
		*(*sqlite3_int64)(unsafe.Pointer(a + uintptr(i)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 32))
	}
	rc = sqlite3_intarray_bind(tls, pArray, n, a, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

func Sqlitetestintarray_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd10))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd10[i].FzName,
			aObjCmd10[i].FxProc, aObjCmd10[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd10 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 37387, FxProc: 0},
	{FzName: ts + 37411, FxProc: 0},
}

type jt_file1 = struct {
	Fbase      sqlite3_file
	FzName     uintptr
	Fflags     int32
	FeLock     int32
	FnPage     u32
	FnPagesize u32
	FpWritable uintptr
	FaCksum    uintptr
	FnSync     int32
	FiMaxOff   sqlite3_int64
	FpNext     uintptr
	FpReal     uintptr
}

type jt_file = jt_file1

var jt_vfs = sqlite3_vfs{
	FiVersion:          2,
	FszOsFile:          int32(unsafe.Sizeof(jt_file{})),
	FmxPathname:        JT_MAX_PATHNAME,
	FzName:             ts + 37433,
	FxOpen:             0,
	FxDelete:           0,
	FxAccess:           0,
	FxFullPathname:     0,
	FxDlOpen:           0,
	FxDlError:          0,
	FxDlSym:            0,
	FxDlClose:          0,
	FxRandomness:       0,
	FxSleep:            0,
	FxCurrentTime:      0,
	FxGetLastError:     0,
	FxCurrentTimeInt64: 0,
}

var jt_io_methods = sqlite3_io_methods{
	FiVersion:               1,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
}

type JtGlobal = struct {
	FpVfs  uintptr
	FpList uintptr
}

var g2 = JtGlobal{}

func enterJtMutex(tls *libc.TLS) {
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_PRNG))
}

func leaveJtMutex(tls *libc.TLS) {
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_PRNG))
}

func stop_ioerr_simulation(tls *libc.TLS, piSave uintptr, piSave2 uintptr) {
	*(*int32)(unsafe.Pointer(piSave)) = libc.AtomicLoadInt32(&sqlite3.Xsqlite3_io_error_pending)
	*(*int32)(unsafe.Pointer(piSave2)) = sqlite3.Xsqlite3_io_error_hit
	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(-1))
	sqlite3.Xsqlite3_io_error_hit = 0
}

func start_ioerr_simulation(tls *libc.TLS, iSave int32, iSave2 int32) {
	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, iSave)
	sqlite3.Xsqlite3_io_error_hit = iSave2
}

func closeTransaction(tls *libc.TLS, p uintptr) {
	sqlite3.Xsqlite3BitvecDestroy(tls, (*jt_file)(unsafe.Pointer(p)).FpWritable)
	sqlite3.Xsqlite3_free(tls, (*jt_file)(unsafe.Pointer(p)).FaCksum)
	(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FnSync = 0
}

func jtClose(tls *libc.TLS, pFile uintptr) int32 {
	var pp uintptr
	var p uintptr = pFile

	closeTransaction(tls, p)
	enterJtMutex(tls)
	if (*jt_file)(unsafe.Pointer(p)).FzName != 0 {
		for pp = uintptr(unsafe.Pointer(&g2)) + 4; *(*uintptr)(unsafe.Pointer(pp)) != p; pp = *(*uintptr)(unsafe.Pointer(pp)) + 44 {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*jt_file)(unsafe.Pointer(p)).FpNext
	}
	leaveJtMutex(tls)
	sqlite3.Xsqlite3OsClose(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
	return SQLITE_OK
}

func jtRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

func locateDatabaseHandle(tls *libc.TLS, zJournal uintptr, noLock int32) uintptr {
	var pMain uintptr = uintptr(0)
	enterJtMutex(tls)
	for pMain = g2.FpList; pMain != 0; pMain = (*jt_file)(unsafe.Pointer(pMain)).FpNext {
		var nName int32 = int32(libc.Xstrlen(tls, zJournal) - libc.Xstrlen(tls, ts+37436))
		if (*jt_file)(unsafe.Pointer(pMain)).Fflags&SQLITE_OPEN_MAIN_DB != 0 &&
			int32(libc.Xstrlen(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName)) == nName &&
			0 == libc.Xmemcmp(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName, zJournal, uint32(nName)) &&
			((*jt_file)(unsafe.Pointer(pMain)).FeLock >= SQLITE_LOCK_RESERVED || noLock != 0) {
			break
		}
	}
	leaveJtMutex(tls)
	return pMain
}

func decodeUint32(tls *libc.TLS, z uintptr) u32 {
	return u32(int32(*(*uint8)(unsafe.Pointer(z)))<<24 + int32(*(*uint8)(unsafe.Pointer(z + 1)))<<16 + int32(*(*uint8)(unsafe.Pointer(z + 2)))<<8 + int32(*(*uint8)(unsafe.Pointer(z + 3))))
}

func genCksum(tls *libc.TLS, z uintptr, n int32) u32 {
	var i int32
	var cksum u32 = u32(0)
	for i = 0; i < n; i++ {
		cksum = cksum + u32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) + cksum<<3
	}
	return cksum
}

func decodeJournalHdr(tls *libc.TLS, zBuf uintptr, pnRec uintptr, pnPage uintptr, pnSector uintptr, pnPagesize uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[8]uint8)(unsafe.Pointer(bp)) = [8]uint8{uint8(0xd9), uint8(0xd5), uint8(0x05), uint8(0xf9), uint8(0x20), uint8(0xa1), uint8(0x63), uint8(0xd7)}
	if libc.Xmemcmp(tls, bp, zBuf, uint32(8)) != 0 {
		return SQLITE_ERROR
	}
	if pnRec != 0 {
		*(*u32)(unsafe.Pointer(pnRec)) = decodeUint32(tls, zBuf+8)
	}
	if pnPage != 0 {
		*(*u32)(unsafe.Pointer(pnPage)) = decodeUint32(tls, zBuf+16)
	}
	if pnSector != 0 {
		*(*u32)(unsafe.Pointer(pnSector)) = decodeUint32(tls, zBuf+20)
	}
	if pnPagesize != 0 {
		*(*u32)(unsafe.Pointer(pnPagesize)) = decodeUint32(tls, zBuf+24)
	}
	return SQLITE_OK
}

func openTransaction(tls *libc.TLS, pMain uintptr, pJournal uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var aData uintptr
	var p uintptr = (*jt_file)(unsafe.Pointer(pMain)).FpReal
	var rc int32 = SQLITE_OK

	closeTransaction(tls, pMain)
	aData = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	(*jt_file)(unsafe.Pointer(pMain)).FpWritable = sqlite3.Xsqlite3BitvecCreate(tls, (*jt_file)(unsafe.Pointer(pMain)).FnPage)
	(*jt_file)(unsafe.Pointer(pMain)).FaCksum = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(u32(0)))*((*jt_file)(unsafe.Pointer(pMain)).FnPage+u32(1))))
	(*jt_file)(unsafe.Pointer(pJournal)).FiMaxOff = int64(0)

	if !(int32((*jt_file)(unsafe.Pointer(pMain)).FpWritable) != 0) || !(int32((*jt_file)(unsafe.Pointer(pMain)).FaCksum) != 0) || !(aData != 0) {
		rc = SQLITE_IOERR | int32(12)<<8
	} else if (*jt_file)(unsafe.Pointer(pMain)).FnPage > u32(0) {
		var iTrunk u32

		stop_ioerr_simulation(tls, bp, bp+4)

		rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), int64(0))
		if rc == SQLITE_OK {
			var nDbsize u32 = decodeUint32(tls, aData+28)
			if nDbsize > u32(0) && libc.Xmemcmp(tls, aData+24, aData+92, uint32(4)) == 0 {
				var iPg u32
				for iPg = nDbsize + u32(1); iPg <= (*jt_file)(unsafe.Pointer(pMain)).FnPage; iPg++ {
					sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, iPg)
				}
			}
		}
		iTrunk = decodeUint32(tls, aData+32)
		for rc == SQLITE_OK && iTrunk > u32(0) {
			var nLeaf u32
			var iLeaf u32
			var iOff sqlite3_int64 = i64(iTrunk-u32(1)) * i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize)
			rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
			nLeaf = decodeUint32(tls, aData+4)
			for iLeaf = u32(0); rc == SQLITE_OK && iLeaf < nLeaf; iLeaf++ {
				var pgno u32 = decodeUint32(tls, aData+uintptr(u32(8)+u32(4)*iLeaf))
				sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
			}
			iTrunk = decodeUint32(tls, aData)
		}

		if rc == SQLITE_OK {
			var ii int32
			for ii = 0; rc == SQLITE_OK && ii < int32((*jt_file)(unsafe.Pointer(pMain)).FnPage); ii++ {
				var iOff i64 = i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize) * i64(ii)
				if iOff == i64(sqlite3.Xsqlite3PendingByte) {
					continue
				}
				rc = sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(pMain)).FpReal, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
				*(*u32)(unsafe.Pointer((*jt_file)(unsafe.Pointer(pMain)).FaCksum + uintptr(ii)*4)) = genCksum(tls, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
				if ii+1 == int32((*jt_file)(unsafe.Pointer(pMain)).FnPage) && rc == SQLITE_IOERR|int32(2)<<8 {
					rc = SQLITE_OK
				}
			}
		}

		start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))
	}

	sqlite3.Xsqlite3_free(tls, aData)
	return rc
}

func readJournalFile(tls *libc.TLS, p uintptr, pMain uintptr) int32 {
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32

	var pReal uintptr
	var iOff sqlite3_int64
	var iSize sqlite3_int64
	var aPage uintptr

	var cksum u32
	_ = cksum
	var pgno u32

	var ii u32
	rc = SQLITE_OK
	pReal = (*jt_file)(unsafe.Pointer(p)).FpReal
	iOff = int64(0)
	iSize = (*jt_file)(unsafe.Pointer(p)).FiMaxOff

	aPage = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	if !!(aPage != 0) {
		goto __1
	}
	return SQLITE_IOERR | int32(12)<<8
__1:
	;
	stop_ioerr_simulation(tls, bp, bp+4)

__2:
	if !(rc == SQLITE_OK && iOff < iSize) {
		goto __3
	}

	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8, 28, iOff)
	if !(rc != SQLITE_OK ||
		decodeJournalHdr(tls, bp+8, bp+36, bp+40, bp+44, bp+48) != 0) {
		goto __4
	}
	goto finish_rjf
__4:
	;
	iOff = iOff + sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44)))

	if !(*(*u32)(unsafe.Pointer(bp + 36)) == u32(0)) {
		goto __5
	}

	if !(iSize >= iOff+sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44)))) {
		goto __6
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8, 28, iOff)
	if !(rc != SQLITE_OK || 0 == decodeJournalHdr(tls, bp+8, uintptr(0), uintptr(0), uintptr(0), uintptr(0))) {
		goto __7
	}
	goto __2
__7:
	;
__6:
	;
	*(*u32)(unsafe.Pointer(bp + 36)) = u32((iSize - iOff) / sqlite3_int64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize+u32(8)))
__5:
	;
	ii = u32(0)
__8:
	if !(rc == SQLITE_OK && ii < *(*u32)(unsafe.Pointer(bp + 36)) && iOff < iSize) {
		goto __10
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8, 4, iOff)
	if !(rc == SQLITE_OK) {
		goto __11
	}
	pgno = decodeUint32(tls, bp+8)
	if !(pgno > u32(0) && pgno <= (*jt_file)(unsafe.Pointer(pMain)).FnPage) {
		goto __12
	}
	if !(0 == sqlite3.Xsqlite3BitvecTest(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)) {
		goto __13
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff+int64(4))
	if !(rc == SQLITE_OK) {
		goto __14
	}
	cksum = genCksum(tls, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))

__14:
	;
__13:
	;
	sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
__12:
	;
	iOff = iOff + sqlite3_int64(u32(8)+(*jt_file)(unsafe.Pointer(pMain)).FnPagesize)
__11:
	;
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;
	iOff = (iOff + sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44))-u32(1))) / sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44))) * sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44)))
	goto __2
__3:
	;
finish_rjf:
	start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))
	sqlite3.Xsqlite3_free(tls, aPage)
	if !(rc == SQLITE_IOERR|int32(2)<<8) {
		goto __15
	}
	rc = SQLITE_OK
__15:
	;
	return rc
}

func jtWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var rc int32
	var p uintptr = pFile
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 {
		if iOfst == int64(0) {
			var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

			if iAmt == 28 {
				closeTransaction(tls, pMain)
			} else if iAmt != 12 {
				var z uintptr = zBuf
				(*jt_file)(unsafe.Pointer(pMain)).FnPage = decodeUint32(tls, z+16)
				(*jt_file)(unsafe.Pointer(pMain)).FnPagesize = decodeUint32(tls, z+24)
				if SQLITE_OK != libc.AssignInt32(&rc, openTransaction(tls, pMain, p)) {
					return rc
				}
			}
		}
		if (*jt_file)(unsafe.Pointer(p)).FiMaxOff < iOfst+sqlite_int64(iAmt) {
			(*jt_file)(unsafe.Pointer(p)).FiMaxOff = iOfst + sqlite_int64(iAmt)
		}
	}

	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_DB != 0 && (*jt_file)(unsafe.Pointer(p)).FpWritable != 0 {
		if iAmt < int32((*jt_file)(unsafe.Pointer(p)).FnPagesize) &&
			(*jt_file)(unsafe.Pointer(p)).FnPagesize%u32(iAmt) == u32(0) &&
			iOfst >= sqlite_int64(sqlite3.Xsqlite3PendingByte+512) &&
			iOfst+sqlite_int64(iAmt) <= sqlite_int64(u32(sqlite3.Xsqlite3PendingByte)+(*jt_file)(unsafe.Pointer(p)).FnPagesize) {
		} else {
			var pgno u32 = u32(iOfst/sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize) + int64(1))
			_ = pgno

		}
	}

	rc = sqlite3.Xsqlite3OsWrite(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 && iAmt == 12 {
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		var rc2 int32 = readJournalFile(tls, p, pMain)
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	return rc
}

func jtTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	var p uintptr = pFile
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 && size == int64(0) {
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		closeTransaction(tls, pMain)
	}
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_DB != 0 && (*jt_file)(unsafe.Pointer(p)).FpWritable != 0 {
		var pgno u32
		var locking_page u32 = u32(sqlite3.Xsqlite3PendingByte)/(*jt_file)(unsafe.Pointer(p)).FnPagesize + u32(1)
		_ = locking_page
		for pgno = u32(size/sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize) + int64(1)); pgno <= (*jt_file)(unsafe.Pointer(p)).FnPage; pgno++ {
		}
	}
	return sqlite3.Xsqlite3OsTruncate(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, size)
}

func jtSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	var p uintptr = pFile

	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 {
		var rc int32
		var pMain uintptr

		pMain = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

		if pMain != 0 && (*jt_file)(unsafe.Pointer(pMain)).FpWritable != 0 {
			(*jt_file)(unsafe.Pointer(pMain)).FnSync++
			rc = readJournalFile(tls, p, pMain)
			if rc != SQLITE_OK {
				return rc
			}
		}
	}

	return sqlite3.Xsqlite3OsSync(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, flags)
}

func jtFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pSize)
}

func jtLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if rc == SQLITE_OK && eLock > (*jt_file)(unsafe.Pointer(p)).FeLock {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

func jtUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsUnlock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if rc == SQLITE_OK && eLock < (*jt_file)(unsafe.Pointer(p)).FeLock {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

func jtCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

func jtFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxFileControl})).f(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

func jtSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

func jtDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

func jtOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	var rc int32
	var p uintptr = pFile
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FpReal = p + 1*52
	(*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods = uintptr(0)
	rc = sqlite3.Xsqlite3OsOpen(tls, g2.FpVfs, zName, (*jt_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)

	if rc == SQLITE_OK {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&jt_io_methods))
		(*jt_file)(unsafe.Pointer(p)).FeLock = 0
		(*jt_file)(unsafe.Pointer(p)).FzName = zName
		(*jt_file)(unsafe.Pointer(p)).Fflags = flags
		(*jt_file)(unsafe.Pointer(p)).FpNext = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
		enterJtMutex(tls)
		if zName != 0 {
			(*jt_file)(unsafe.Pointer(p)).FpNext = g2.FpList
			g2.FpList = p
		}
		leaveJtMutex(tls)
	}
	return rc
}

func jtDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 {
	var nPath int32 = int32(libc.Xstrlen(tls, zPath))
	if nPath > 8 && 0 == libc.Xstrcmp(tls, ts+37436, zPath+uintptr(nPath-8)) {
		var pMain uintptr = locateDatabaseHandle(tls, zPath, 0)
		if pMain != 0 {
			closeTransaction(tls, pMain)
		}
	}

	return sqlite3.Xsqlite3OsDelete(tls, g2.FpVfs, zPath, dirSync)
}

func jtAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	return sqlite3.Xsqlite3OsAccess(tls, g2.FpVfs, zPath, flags, pResOut)
}

func jtFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 {
	return sqlite3.Xsqlite3OsFullPathname(tls, g2.FpVfs, zPath, nOut, zOut)
}

func jtDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlOpen})).f(tls, g2.FpVfs, zPath)
}

func jtDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlError})).f(tls, g2.FpVfs, nByte, zErrMsg)
}

func jtDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlSym})).f(tls, g2.FpVfs, p, zSym)
}

func jtDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlClose})).f(tls, g2.FpVfs, pHandle)
}

func jtRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	return sqlite3.Xsqlite3OsRandomness(tls, g2.FpVfs, nByte, zBufOut)
}

func jtSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 {
	return sqlite3.Xsqlite3OsSleep(tls, g2.FpVfs, nMicro)
}

func jtCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTime})).f(tls, g2.FpVfs, pTimeOut)
}

func jtCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTimeInt64})).f(tls, g2.FpVfs, pTimeOut)
}

func jtGetLastError(tls *libc.TLS, pVfs uintptr, n int32, z uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxGetLastError})).f(tls, g2.FpVfs, n, z)
}

func jt_register(tls *libc.TLS, zWrap uintptr, isDefault int32) int32 {
	g2.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, zWrap)
	if g2.FpVfs == uintptr(0) {
		return SQLITE_ERROR
	}
	jt_vfs.FszOsFile = int32(uint32(unsafe.Sizeof(jt_file{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FszOsFile))
	if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FiVersion == 1 {
		jt_vfs.FiVersion = 1
	} else if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTimeInt64 == uintptr(0) {
		jt_vfs.FxCurrentTimeInt64 = uintptr(0)
	}
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&jt_vfs)), isDefault)
	return SQLITE_OK
}

func jt_unregister(tls *libc.TLS) {
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&jt_vfs)))
}

type MemFault = struct {
	FiCountdown   int32
	FnRepeat      int32
	FnBenign      int32
	FnFail        int32
	FnOkBefore    int32
	FnOkAfter     int32
	Fenable       u8
	F__ccgo_pad1  [3]byte
	FisInstalled  int32
	FisBenignMode int32
	Fm            sqlite3_mem_methods
}

var memfault MemFault

func sqlite3Fault(tls *libc.TLS) {
	cnt1++
}

var cnt1 int32 = 0

func sqlite3FirstFault(tls *libc.TLS) {
	cnt2++
}

var cnt2 int32 = 0

func faultsimStep(tls *libc.TLS) int32 {
	if !(int32(memfault.Fenable) != 0) {
		memfault.FnOkAfter++
		return 0
	}
	if memfault.FiCountdown > 0 {
		memfault.FiCountdown--
		memfault.FnOkBefore++
		return 0
	}
	if memfault.FnFail == 0 {
		sqlite3FirstFault(tls)
	}
	sqlite3Fault(tls)
	memfault.FnFail++
	if memfault.FisBenignMode > 0 {
		memfault.FnBenign++
	}
	memfault.FnRepeat--
	if memfault.FnRepeat <= 0 {
		memfault.Fenable = u8(0)
	}
	return 1
}

func faultsimMalloc(tls *libc.TLS, n int32) uintptr {
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{memfault.Fm.FxMalloc})).f(tls, n)
	}
	return p
}

func faultsimRealloc(tls *libc.TLS, pOld uintptr, n int32) uintptr {
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{memfault.Fm.FxRealloc})).f(tls, pOld, n)
	}
	return p
}

func faultsimConfig(tls *libc.TLS, nDelay int32, nRepeat int32) {
	memfault.FiCountdown = nDelay
	memfault.FnRepeat = nRepeat
	memfault.FnBenign = 0
	memfault.FnFail = 0
	memfault.FnOkBefore = 0
	memfault.FnOkAfter = 0
	memfault.Fenable = u8(libc.Bool32(nDelay >= 0))

	memfault.FisBenignMode = 0
}

func faultsimFailures(tls *libc.TLS) int32 {
	return memfault.FnFail
}

func faultsimBenignFailures(tls *libc.TLS) int32 {
	return memfault.FnBenign
}

func faultsimPending(tls *libc.TLS) int32 {
	if memfault.Fenable != 0 {
		return memfault.FiCountdown
	} else {
		return -1
	}
	return int32(0)
}

func faultsimBeginBenign(tls *libc.TLS) {
	memfault.FisBenignMode++
}

func faultsimEndBenign(tls *libc.TLS) {
	memfault.FisBenignMode--
}

func faultsimInstall(tls *libc.TLS, install int32) int32 {
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var rc int32

	install = func() int32 {
		if install != 0 {
			return 1
		}
		return 0
	}()

	if install == memfault.FisInstalled {
		return SQLITE_ERROR
	}

	if install != 0 {
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp, uintptr(unsafe.Pointer(&memfault))+36))

		if rc == SQLITE_OK {
			*(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72)) = memfault.Fm
			(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72)).FxMalloc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, int32) uintptr
			}{faultsimMalloc}))
			(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72)).FxRealloc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			}{faultsimRealloc}))
			rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+8, bp+72))
		}
		sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,
			libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{faultsimBeginBenign})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{faultsimEndBenign}))))
	} else {
		libc.Xmemset(tls, bp+104, 0, uint32(unsafe.Sizeof(sqlite3_mem_methods{})))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+32, bp+104))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp+40, bp+104))

		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+48, uintptr(unsafe.Pointer(&memfault))+36))
		sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,
			libc.VaList(bp+56, uintptr(0), uintptr(0)))
	}

	if rc == SQLITE_OK {
		memfault.FisInstalled = 1
	}
	return rc
}

func pointerToText(tls *libc.TLS, p uintptr, z uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = p

	var i int32
	var k int32

	if *(*uintptr)(unsafe.Pointer(bp + 8)) == uintptr(0) {
		libc.Xstrcpy(tls, z, ts+19147)
		return
	}
	if uint32(unsafe.Sizeof(sqlite3_uint64(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp, bp+8, uint32(unsafe.Sizeof(uintptr(0))))
	} else if uint32(unsafe.Sizeof(uint32(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp+12, bp+8, uint32(unsafe.Sizeof(uint32(0))))
		*(*sqlite3_uint64)(unsafe.Pointer(bp)) = sqlite3_uint64(*(*uint32)(unsafe.Pointer(bp + 12)))
	} else {
	}
	i = 0
	k = int32(uint32(unsafe.Sizeof(uintptr(0)))*uint32(2) - uint32(1))
__1:
	if !(uint32(i) < uint32(unsafe.Sizeof(uintptr(0)))*uint32(2)) {
		goto __3
	}
	{
		*(*int8)(unsafe.Pointer(z + uintptr(k))) = zHex[*(*sqlite3_uint64)(unsafe.Pointer(bp))&uint64(0xf)]
		*(*sqlite3_uint64)(unsafe.Pointer(bp)) >>= 4

	}
	goto __2
__2:
	i++
	k--
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(z + 8)) = int8(0)
}

var zHex = *(*[17]int8)(unsafe.Pointer(ts + 35822))

func hexToInt(tls *libc.TLS, h int32) int32 {
	if h >= '0' && h <= '9' {
		return h - '0'
	} else if h >= 'a' && h <= 'f' {
		return h - 'a' + 10
	} else {
		return -1
	}
	return int32(0)
}

func textToPointer(tls *libc.TLS, z uintptr, pp uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*sqlite3_uint64)(unsafe.Pointer(bp)) = uint64(0)
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(uintptr(0)))*uint32(2) && *(*int8)(unsafe.Pointer(z)) != 0; i++ {
		var v int32
		v = hexToInt(tls, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))))
		if v < 0 {
			return TCL_ERROR
		}
		*(*sqlite3_uint64)(unsafe.Pointer(bp)) = *(*sqlite3_uint64)(unsafe.Pointer(bp))*uint64(16) + sqlite3_uint64(v)
	}
	if int32(*(*int8)(unsafe.Pointer(z))) != 0 {
		return TCL_ERROR
	}
	if uint32(unsafe.Sizeof(sqlite3_uint64(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, pp, bp, uint32(unsafe.Sizeof(sqlite3_uint64(0))))
	} else if uint32(unsafe.Sizeof(uint32(0))) == uint32(unsafe.Sizeof(uintptr(0))) {
		*(*uint32)(unsafe.Pointer(bp + 8)) = uint32(*(*sqlite3_uint64)(unsafe.Pointer(bp)))
		libc.Xmemcpy(tls, pp, bp+8, uint32(unsafe.Sizeof(uint32(0))))
	} else {
	}
	return TCL_OK
}

func test_malloc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var p uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37445)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16) != 0 {
		return TCL_ERROR
	}
	p = sqlite3.Xsqlite3_malloc(tls, int32(uint32(*(*int32)(unsafe.Pointer(bp + 16)))))
	pointerToText(tls, p, bp+20)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+20, uintptr(0)))
	return TCL_OK
}

func test_realloc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(148)
	defer tls.Free(148)

	var p uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37452)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+40) != 0 {
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+44) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37465, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	p = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(bp + 44)), int32(uint32(*(*int32)(unsafe.Pointer(bp + 40)))))
	pointerToText(tls, p, bp+48)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, bp+48, uintptr(0)))
	return TCL_OK
}

func test_free(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37479)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+24) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37465, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 24)))
	return TCL_OK
}

func test_memset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(168)
	defer tls.Free(168)

	var i int32
	var zHex uintptr
	var zOut uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37485)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37465, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+60) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 60)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+37502, uintptr(0)))
		return TCL_ERROR
	}
	zHex = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+64)
	if uint32(*(*int32)(unsafe.Pointer(bp + 64))) > uint32(unsafe.Sizeof([100]int8{}))*uint32(2) {
		*(*int32)(unsafe.Pointer(bp + 64)) = int32(uint32(unsafe.Sizeof([100]int8{})) * uint32(2))
	}
	*(*int32)(unsafe.Pointer(bp + 64)) = sqlite3TestHexToBin(tls, zHex, *(*int32)(unsafe.Pointer(bp + 64)), bp+68)
	if *(*int32)(unsafe.Pointer(bp + 64)) == 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+37524, uintptr(0)))
		return TCL_ERROR
	}
	zOut = *(*uintptr)(unsafe.Pointer(bp + 56))
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 60)); i++ {
		*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = *(*int8)(unsafe.Pointer(bp + 68 + uintptr(i%*(*int32)(unsafe.Pointer(bp + 64)))))
	}
	return TCL_OK
}

func test_memget(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var n int32
	var zBin uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37532)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+56) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37465, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+60) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 60)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+37502, uintptr(0)))
		return TCL_ERROR
	}
	zBin = *(*uintptr)(unsafe.Pointer(bp + 56))
	for *(*int32)(unsafe.Pointer(bp + 60)) > 0 {
		if uint32(*(*int32)(unsafe.Pointer(bp + 60))) > (uint32(unsafe.Sizeof([100]int8{}))-uint32(1))/uint32(2) {
			n = int32((uint32(unsafe.Sizeof([100]int8{})) - uint32(1)) / uint32(2))
		} else {
			n = *(*int32)(unsafe.Pointer(bp + 60))
		}
		libc.Xmemcpy(tls, bp+64, zBin, uint32(n))
		zBin += uintptr(n)
		*(*int32)(unsafe.Pointer(bp + 60)) -= n
		sqlite3TestBinToHex(tls, bp+64, n)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+64, uintptr(0)))
	}
	return TCL_OK
}

func test_memory_used(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_memory_used(tls)))
	return TCL_OK
}

func test_memory_highwater(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = 0
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37545)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_memory_highwater(tls, *(*int32)(unsafe.Pointer(bp)))))
	return TCL_OK
}

func test_memdebug_backtrace(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37553)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

func test_memdebug_dump(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37558)
		return TCL_ERROR
	}
	return TCL_OK
}

func test_memdebug_malloc_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var nMalloc int32 = -1
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nMalloc))
	return TCL_OK
}

func test_memdebug_fail(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var ii int32

	*(*int32)(unsafe.Pointer(bp + 32)) = 1
	var pBenignCnt uintptr = uintptr(0)
	var nBenign int32
	var nFail int32 = 0

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37567)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+24) != 0 {
		return TCL_ERROR
	}

	for ii = 2; ii < objc; ii = ii + 2 {
		var zOption uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(ii)*4)), bp+28)
		var zErr uintptr = uintptr(0)

		if *(*int32)(unsafe.Pointer(bp + 28)) > 1 && libc.Xstrncmp(tls, zOption, ts+37585, uint32(*(*int32)(unsafe.Pointer(bp + 28)))) == 0 {
			if ii == objc-1 {
				zErr = ts + 17599
			} else {
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(ii+1)*4)), bp+32) != 0 {
					return TCL_ERROR
				}
			}
		} else if *(*int32)(unsafe.Pointer(bp + 28)) > 1 && libc.Xstrncmp(tls, zOption, ts+37593, uint32(*(*int32)(unsafe.Pointer(bp + 28)))) == 0 {
			if ii == objc-1 {
				zErr = ts + 17599
			} else {
				pBenignCnt = *(*uintptr)(unsafe.Pointer(objv + uintptr(ii+1)*4))
			}
		} else {
			zErr = ts + 17405
		}

		if zErr != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, zErr, zOption, 0))
			return TCL_ERROR
		}
	}

	nBenign = faultsimBenignFailures(tls)
	nFail = faultsimFailures(tls)
	faultsimConfig(tls, *(*int32)(unsafe.Pointer(bp + 24)), *(*int32)(unsafe.Pointer(bp + 32)))

	if pBenignCnt != 0 {
		tcl.XTcl_ObjSetVar2(tls, interp, pBenignCnt, uintptr(0), tcl.XTcl_NewIntObj(tls, nBenign), 0)
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nFail))
	return TCL_OK
}

func test_memdebug_pending(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var nPending int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}
	nPending = faultsimPending(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nPending))
	return TCL_OK
}

var sqlite3_memdebug_title_count int32 = 0

func test_memdebug_settitle(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	sqlite3_memdebug_title_count++
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37604)
		return TCL_ERROR
	}
	return TCL_OK
}

var aMallocLog Tcl_HashTable
var mallocLogEnabled int32 = 0

type MallocLog1 = struct {
	FnCall int32
	FnByte int32
}

type MallocLog = MallocLog1

func test_memdebug_log_clear(tls *libc.TLS) {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pEntry uintptr
	for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp) {
		var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
		tcl.XTcl_Free(tls, pLog)
	}
	tcl.XTcl_DeleteHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)))
	tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), int32(uint32(10)*func() uint32 {
		if uint32(unsafe.Sizeof(int32(0))) >= uint32(unsafe.Sizeof(uintptr(0))) {
			return uint32(1)
		}
		return uint32(unsafe.Sizeof(uintptr(0))) / uint32(unsafe.Sizeof(int32(0)))
	}()))
}

func test_memdebug_log(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(64)
	defer tls.Free(64)

	if !(isInit != 0) {
		tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), int32(uint32(10)*func() uint32 {
			if uint32(unsafe.Sizeof(int32(0))) >= uint32(unsafe.Sizeof(uintptr(0))) {
				return uint32(1)
			}
			return uint32(unsafe.Sizeof(uintptr(0))) / uint32(unsafe.Sizeof(int32(0)))
		}()))
		isInit = 1
	}

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37610)
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&MB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+2014, 0, bp) != 0 {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp))) {
	case uint32(0):
		mallocLogEnabled = 1
		break
	case uint32(1):
		mallocLogEnabled = 0
		break
	case uint32(2):
		{
			var pEntry uintptr
			var pRet uintptr = tcl.XTcl_NewObj(tls)

			for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp+4); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp+4) {
				var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
				var aKey uintptr = func() uintptr {
					if (*Tcl_HashTable)(unsafe.Pointer(uintptr(unsafe.Pointer(&aMallocLog)))).FkeyType == 1 || (*Tcl_HashTable)(unsafe.Pointer(uintptr(unsafe.Pointer(&aMallocLog)))).FkeyType == -1 {
						return *(*uintptr)(unsafe.Pointer(pEntry + 16))
					}
					return pEntry + 16
				}()
				var ii int32

				*(*uintptr)(unsafe.Pointer(bp + 16)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnCall)
				*(*uintptr)(unsafe.Pointer(bp + 16 + 1*4)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnByte)
				for ii = 0; ii < MALLOC_LOG_FRAMES; ii++ {
					*(*uintptr)(unsafe.Pointer(bp + 16 + uintptr(ii+2)*4)) = tcl.XTcl_NewWideIntObj(tls, *(*Tcl_WideInt)(unsafe.Pointer(aKey + uintptr(ii)*8)))
				}

				tcl.XTcl_ListObjAppendElement(tls, interp, pRet,
					tcl.XTcl_NewListObj(tls, MALLOC_LOG_FRAMES+2, bp+16))
			}

			tcl.XTcl_SetObjResult(tls, interp, pRet)
			break

		}
	case uint32(3):
		{
			test_memdebug_log_clear(tls)
			break

		}

	case uint32(4):
		{
			break

		}
	}

	return TCL_OK
}

var isInit int32 = 0
var MB_strs = [5]uintptr{ts + 37626, ts + 37632, ts + 37637, ts + 37642, ts + 37648}

func test_config_pagecache(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var pRes uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37653)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+48) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+52) != 0 {
		return TCL_ERROR
	}
	libc.Xfree(tls, buf1)
	buf1 = uintptr(0)

	pRes = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszPage))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnPage))
	tcl.XTcl_SetObjResult(tls, interp, pRes)

	if *(*int32)(unsafe.Pointer(bp + 48)) < 0 {
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PAGECACHE, libc.VaList(bp, uintptr(0), 0, 0))
	} else {
		buf1 = libc.Xmalloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 48))**(*int32)(unsafe.Pointer(bp + 52))))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PAGECACHE, libc.VaList(bp+24, buf1, *(*int32)(unsafe.Pointer(bp + 48)), *(*int32)(unsafe.Pointer(bp + 52))))
	}
	return TCL_OK
}

var buf1 uintptr = uintptr(0)

func test_alt_pcache(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*int32)(unsafe.Pointer(bp + 20)) = 0
	*(*int32)(unsafe.Pointer(bp + 24)) = 0
	*(*int32)(unsafe.Pointer(bp + 28)) = 0
	if objc < 2 || objc > 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+37660)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16) != 0 {
		return TCL_ERROR
	}
	if objc >= 3 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20) != 0 {
		return TCL_ERROR
	}
	if objc >= 4 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+24) != 0 {
		return TCL_ERROR
	}
	if objc >= 5 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+28) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 20)) < 0 || *(*int32)(unsafe.Pointer(bp + 20)) > 100 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37707,
			uintptr(0)))
		return TCL_ERROR
	}
	installTestPCache(tls, *(*int32)(unsafe.Pointer(bp + 16)), uint32(*(*int32)(unsafe.Pointer(bp + 20))), uint32(*(*int32)(unsafe.Pointer(bp + 24))),
		uint32(*(*int32)(unsafe.Pointer(bp + 28))))
	return TCL_OK
}

func test_config_memstatus(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23177)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MEMSTATUS, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_config_lookaside(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var pRet uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37750)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+20) != 0 {
		return TCL_ERROR
	}
	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszLookaside))
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnLookaside))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOOKASIDE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16)), *(*int32)(unsafe.Pointer(bp + 20))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

func test_db_config_lookaside(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var rc int32

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37761)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+68) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+76) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 68)) == 0 {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), SQLITE_DBCONFIG_LOOKASIDE, libc.VaList(bp, uintptr(0), *(*int32)(unsafe.Pointer(bp + 72)), *(*int32)(unsafe.Pointer(bp + 76))))
	} else if *(*int32)(unsafe.Pointer(bp + 68)) >= 1 && *(*int32)(unsafe.Pointer(bp + 68)) <= 2 && uint32(*(*int32)(unsafe.Pointer(bp + 72))**(*int32)(unsafe.Pointer(bp + 76))) <= uint32(unsafe.Sizeof([10000]int8{})) {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), SQLITE_DBCONFIG_LOOKASIDE, libc.VaList(bp+24, uintptr(unsafe.Pointer(&azBuf))+uintptr(*(*int32)(unsafe.Pointer(bp + 68)))*10000, *(*int32)(unsafe.Pointer(bp + 72)), *(*int32)(unsafe.Pointer(bp + 76))))
	} else {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+37778, uintptr(0)))
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

var azBuf [2][10000]int8

func test_config_heap(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var rc int32

	var aArg uintptr = objv + 1*4
	var nArg int32 = objc - 1

	if nArg != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37816)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg)), bp+48) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg + 1*4)), bp+52) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 48)) == 0 {
		libc.Xfree(tls, zBuf)
		zBuf = uintptr(0)
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_HEAP, libc.VaList(bp, uintptr(0), 0, 0))
	} else {
		zBuf = libc.Xrealloc(tls, zBuf, uint32(*(*int32)(unsafe.Pointer(bp + 48))))
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_HEAP, libc.VaList(bp+24, zBuf, *(*int32)(unsafe.Pointer(bp + 48)), *(*int32)(unsafe.Pointer(bp + 52))))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

var zBuf uintptr

func test_config_heap_size(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	var aArg uintptr = objv + 1*4
	var nArg int32 = objc - 1

	if nArg != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21164)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_WIN32_HEAPSIZE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8))))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_config_error(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	if objc != 2 && objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37832)
		return TCL_ERROR
	}
	if objc == 2 {
		if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+32) != 0 {
			return TCL_ERROR
		}
		if sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), 99999, 0) != SQLITE_ERROR {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+37837,
					uintptr(0)))
			return TCL_ERROR
		}
	} else {
		if sqlite3.Xsqlite3_config(tls, 99999, 0) != SQLITE_ERROR {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp+16, ts+37895,
					uintptr(0)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

func test_config_uri(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15054)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_URI, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

func test_config_cis(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15054)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_COVERING_INDEX_SCAN, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

func test_config_pmasz(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15054)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PMASZ, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

func test_dump_memsys3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37558)
		return TCL_ERROR
	}

	switch int32(clientData) {
	case 3:
		{
		}
		fallthrough
	case 5:
		{
		}
	}
	return TCL_OK
}

func test_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32

	var i int32
	*(*int32)(unsafe.Pointer(bp)) = 0

	var zOpName uintptr
	var pResult uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37946)
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	for i = 0; i < int32(uint32(unsafe.Sizeof(aOp1))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{}))); i++ {
		if libc.Xstrcmp(tls, aOp1[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp)) = aOp1[i].Fop
			break
		}
	}
	if i >= int32(uint32(unsafe.Sizeof(aOp1))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{}))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 8)) = 0
	*(*int32)(unsafe.Pointer(bp + 12)) = 0
	rc = sqlite3.Xsqlite3_status(tls, *(*int32)(unsafe.Pointer(bp)), bp+8, bp+12, *(*int32)(unsafe.Pointer(bp + 4)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

var aOp1 = [10]struct {
	FzName uintptr
	Fop    int32
}{
	{FzName: ts + 37966},
	{FzName: ts + 37992, Fop: SQLITE_STATUS_MALLOC_SIZE},
	{FzName: ts + 38018, Fop: SQLITE_STATUS_PAGECACHE_USED},
	{FzName: ts + 38047, Fop: SQLITE_STATUS_PAGECACHE_OVERFLOW},
	{FzName: ts + 38080, Fop: SQLITE_STATUS_PAGECACHE_SIZE},
	{FzName: ts + 38109, Fop: SQLITE_STATUS_SCRATCH_USED},
	{FzName: ts + 38136, Fop: SQLITE_STATUS_SCRATCH_OVERFLOW},
	{FzName: ts + 38167, Fop: SQLITE_STATUS_SCRATCH_SIZE},
	{FzName: ts + 38194, Fop: SQLITE_STATUS_PARSER_STACK},
	{FzName: ts + 38221, Fop: SQLITE_STATUS_MALLOC_COUNT},
}

func test_db_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var rc int32

	var i int32
	*(*int32)(unsafe.Pointer(bp + 4)) = 0

	var zOpName uintptr

	var pResult uintptr
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38248)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if libc.Xmemcmp(tls, zOpName, ts+38271, uint32(7)) == 0 {
		zOpName += uintptr(7)
	}
	if libc.Xmemcmp(tls, zOpName, ts+38279, uint32(9)) == 0 {
		zOpName += uintptr(9)
	}
	for i = 0; i < int32(uint32(unsafe.Sizeof(aOp2))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{}))); i++ {
		if libc.Xstrcmp(tls, aOp2[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 4)) = aOp2[i].Fop
			break
		}
	}
	if i >= int32(uint32(unsafe.Sizeof(aOp2))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
	}{}))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+4) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+8) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 12)) = 0
	*(*int32)(unsafe.Pointer(bp + 16)) = 0
	rc = sqlite3.Xsqlite3_db_status(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)), bp+12, bp+16, *(*int32)(unsafe.Pointer(bp + 8)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

var aOp2 = [13]struct {
	FzName uintptr
	Fop    int32
}{
	{FzName: ts + 38289},
	{FzName: ts + 38304, Fop: SQLITE_DBSTATUS_CACHE_USED},
	{FzName: ts + 38315, Fop: SQLITE_DBSTATUS_SCHEMA_USED},
	{FzName: ts + 38327, Fop: SQLITE_DBSTATUS_STMT_USED},
	{FzName: ts + 38337, Fop: SQLITE_DBSTATUS_LOOKASIDE_HIT},
	{FzName: ts + 38351, Fop: SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE},
	{FzName: ts + 38371, Fop: SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL},
	{FzName: ts + 38391, Fop: SQLITE_DBSTATUS_CACHE_HIT},
	{FzName: ts + 38401, Fop: SQLITE_DBSTATUS_CACHE_MISS},
	{FzName: ts + 38412, Fop: SQLITE_DBSTATUS_CACHE_WRITE},
	{FzName: ts + 38424, Fop: SQLITE_DBSTATUS_DEFERRED_FKS},
	{FzName: ts + 38437, Fop: SQLITE_DBSTATUS_CACHE_USED_SHARED},
	{FzName: ts + 38455, Fop: SQLITE_DBSTATUS_CACHE_SPILL},
}

func test_install_malloc_faultsim(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23177)
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) {
		return TCL_ERROR
	}
	rc = faultsimInstall(tls, *(*int32)(unsafe.Pointer(bp)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_install_memsys3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32 = SQLITE_MISUSE
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_vfs_oom_test(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38467)
		return TCL_ERROR
	} else if objc == 2 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp) != 0 {
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_memdebug_vfs_oom_test = *(*int32)(unsafe.Pointer(bp))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_memdebug_vfs_oom_test))
	return TCL_OK
}

func Sqlitetest_malloc_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd11))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData int32
	}{})); i++ {
		var c ClientData = uintptr(aObjCmd11[i].FclientData)
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd11[i].FzName, aObjCmd11[i].FxProc, c, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd11 = [32]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData int32
}{
	{FzName: ts + 32718, FxProc: 0},
	{FzName: ts + 32733, FxProc: 0},
	{FzName: ts + 38477, FxProc: 0},
	{FzName: ts + 38490, FxProc: 0},
	{FzName: ts + 38497, FxProc: 0},
	{FzName: ts + 38504, FxProc: 0},
	{FzName: ts + 38524, FxProc: 0},
	{FzName: ts + 38549, FxProc: 0},
	{FzName: ts + 38576, FxProc: 0},
	{FzName: ts + 38598, FxProc: 0},
	{FzName: ts + 38620, FxProc: 0},
	{FzName: ts + 38645, FxProc: 0},
	{FzName: ts + 38671, FxProc: 0},
	{FzName: ts + 38701, FxProc: 0},
	{FzName: ts + 38722, FxProc: 0},
	{FzName: ts + 38747, FxProc: 0},
	{FzName: ts + 38773, FxProc: 0},
	{FzName: ts + 38788, FxProc: 0},
	{FzName: ts + 38806, FxProc: 0},
	{FzName: ts + 38830, FxProc: 0},
	{FzName: ts + 38850, FxProc: 0},
	{FzName: ts + 38875, FxProc: 0},
	{FzName: ts + 38900, FxProc: 0},
	{FzName: ts + 38925, FxProc: 0},
	{FzName: ts + 38946, FxProc: 0},
	{FzName: ts + 38965, FxProc: 0},
	{FzName: ts + 38984, FxProc: 0},
	{FzName: ts + 39005, FxProc: 0},
	{FzName: ts + 39033, FxProc: 0, FclientData: 3},
	{FzName: ts + 39054, FxProc: 0, FclientData: 5},
	{FzName: ts + 39075, FxProc: 0},
	{FzName: ts + 39099, FxProc: 0},
}

type MD5Context1 = struct {
	FisInit int32
	Fbuf    [4]uint32
	Fbits   [2]uint32
	Fin     [64]uint8
}

type MD5Context = MD5Context1

func byteReverse(tls *libc.TLS, buf uintptr, longs uint32) {
	var t uint32
	for __ccgo := true; __ccgo; __ccgo = libc.PreDecUint32(&longs, 1) != 0 {
		t = (uint32(*(*uint8)(unsafe.Pointer(buf + 3)))<<8|uint32(*(*uint8)(unsafe.Pointer(buf + 2))))<<16 | (uint32(*(*uint8)(unsafe.Pointer(buf + 1)))<<8 | uint32(*(*uint8)(unsafe.Pointer(buf))))
		*(*uint32)(unsafe.Pointer(buf)) = t
		buf += uintptr(4)
	}
}

func MD5Transform(tls *libc.TLS, buf uintptr, in uintptr) {
	var a uint32
	var b uint32
	var c uint32
	var d uint32

	a = *(*uint32)(unsafe.Pointer(buf))
	b = *(*uint32)(unsafe.Pointer(buf + 1*4))
	c = *(*uint32)(unsafe.Pointer(buf + 2*4))
	d = *(*uint32)(unsafe.Pointer(buf + 3*4))

	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in)) + 0xd76aa478)
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0xe8c7b756)
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 2*4)) + uint32(0x242070db))
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0xc1bdceee)
	b = b<<22 | b>>(32-22)
	b = b + c
	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in + 4*4)) + 0xf57c0faf)
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 5*4)) + uint32(0x4787c62a))
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 6*4)) + 0xa8304613)
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 7*4)) + 0xfd469501)
	b = b<<22 | b>>(32-22)
	b = b + c
	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in + 8*4)) + uint32(0x698098d8))
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 9*4)) + 0x8b44f7af)
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 10*4)) + 0xffff5bb1)
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 11*4)) + 0x895cd7be)
	b = b<<22 | b>>(32-22)
	b = b + c
	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in + 12*4)) + uint32(0x6b901122))
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 13*4)) + 0xfd987193)
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xa679438e)
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 15*4)) + uint32(0x49b40821))
	b = b<<22 | b>>(32-22)
	b = b + c

	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0xf61e2562)
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 6*4)) + 0xc040b340)
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 11*4)) + uint32(0x265e5a51))
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in)) + 0xe9b6c7aa)
	b = b<<20 | b>>(32-20)
	b = b + c
	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 5*4)) + 0xd62f105d)
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 10*4)) + uint32(0x02441453))
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 15*4)) + 0xd8a1e681)
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in + 4*4)) + 0xe7d3fbc8)
	b = b<<20 | b>>(32-20)
	b = b + c
	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 9*4)) + uint32(0x21e1cde6))
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xc33707d6)
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0xf4d50d87)
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in + 8*4)) + uint32(0x455a14ed))
	b = b<<20 | b>>(32-20)
	b = b + c
	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 13*4)) + 0xa9e3e905)
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 2*4)) + 0xfcefa3f8)
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 7*4)) + uint32(0x676f02d9))
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in + 12*4)) + 0x8d2a4c8a)
	b = b<<20 | b>>(32-20)
	b = b + c

	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 5*4)) + 0xfffa3942)
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in + 8*4)) + 0x8771f681)
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 11*4)) + uint32(0x6d9d6122))
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xfde5380c)
	b = b<<23 | b>>(32-23)
	b = b + c
	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0xa4beea44)
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in + 4*4)) + uint32(0x4bdecfa9))
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 7*4)) + 0xf6bb4b60)
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 10*4)) + 0xbebfbc70)
	b = b<<23 | b>>(32-23)
	b = b + c
	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 13*4)) + uint32(0x289b7ec6))
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in)) + 0xeaa127fa)
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0xd4ef3085)
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 6*4)) + uint32(0x04881d05))
	b = b<<23 | b>>(32-23)
	b = b + c
	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 9*4)) + 0xd9d4d039)
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in + 12*4)) + 0xe6db99e5)
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 15*4)) + uint32(0x1fa27cf8))
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 2*4)) + 0xc4ac5665)
	b = b<<23 | b>>(32-23)
	b = b + c

	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in)) + 0xf4292244)
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 7*4)) + uint32(0x432aff97))
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xab9423a7)
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 5*4)) + 0xfc93a039)
	b = b<<21 | b>>(32-21)
	b = b + c
	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in + 12*4)) + uint32(0x655b59c3))
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0x8f0ccc92)
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 10*4)) + 0xffeff47d)
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0x85845dd1)
	b = b<<21 | b>>(32-21)
	b = b + c
	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in + 8*4)) + uint32(0x6fa87e4f))
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 15*4)) + 0xfe2ce6e0)
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 6*4)) + 0xa3014314)
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 13*4)) + uint32(0x4e0811a1))
	b = b<<21 | b>>(32-21)
	b = b + c
	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in + 4*4)) + 0xf7537e82)
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 11*4)) + 0xbd3af235)
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 2*4)) + uint32(0x2ad7d2bb))
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 9*4)) + 0xeb86d391)
	b = b<<21 | b>>(32-21)
	b = b + c

	*(*uint32)(unsafe.Pointer(buf)) += a
	*(*uint32)(unsafe.Pointer(buf + 1*4)) += b
	*(*uint32)(unsafe.Pointer(buf + 2*4)) += c
	*(*uint32)(unsafe.Pointer(buf + 3*4)) += d
}

func MD5Init(tls *libc.TLS, ctx uintptr) {
	(*MD5Context)(unsafe.Pointer(ctx)).FisInit = 1
	*(*uint32)(unsafe.Pointer(ctx + 4)) = uint32(0x67452301)
	*(*uint32)(unsafe.Pointer(ctx + 4 + 1*4)) = 0xefcdab89
	*(*uint32)(unsafe.Pointer(ctx + 4 + 2*4)) = 0x98badcfe
	*(*uint32)(unsafe.Pointer(ctx + 4 + 3*4)) = uint32(0x10325476)
	*(*uint32)(unsafe.Pointer(ctx + 20)) = uint32(0)
	*(*uint32)(unsafe.Pointer(ctx + 20 + 1*4)) = uint32(0)
}

func MD5Update(tls *libc.TLS, ctx uintptr, buf uintptr, len uint32) {
	var t uint32

	t = *(*uint32)(unsafe.Pointer(ctx + 20))
	if libc.AssignPtrUint32(ctx+20, t+len<<3) < t {
		*(*uint32)(unsafe.Pointer(ctx + 20 + 1*4))++
	}
	*(*uint32)(unsafe.Pointer(ctx + 20 + 1*4)) += len >> 29

	t = t >> 3 & uint32(0x3f)

	if t != 0 {
		var p uintptr = ctx + 28 + uintptr(t)

		t = uint32(64) - t
		if len < t {
			libc.Xmemcpy(tls, p, buf, len)
			return
		}
		libc.Xmemcpy(tls, p, buf, t)
		byteReverse(tls, ctx+28, uint32(16))
		MD5Transform(tls, ctx+4, ctx+28)
		buf += uintptr(t)
		len = len - t
	}

	for len >= uint32(64) {
		libc.Xmemcpy(tls, ctx+28, buf, uint32(64))
		byteReverse(tls, ctx+28, uint32(16))
		MD5Transform(tls, ctx+4, ctx+28)
		buf += uintptr(64)
		len = len - uint32(64)
	}

	libc.Xmemcpy(tls, ctx+28, buf, len)
}

func MD5Final(tls *libc.TLS, digest uintptr, ctx uintptr) {
	var count uint32
	var p uintptr

	count = *(*uint32)(unsafe.Pointer(ctx + 20)) >> 3 & uint32(0x3F)

	p = ctx + 28 + uintptr(count)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(0x80)

	count = uint32(64-1) - count

	if count < uint32(8) {
		libc.Xmemset(tls, p, 0, count)
		byteReverse(tls, ctx+28, uint32(16))
		MD5Transform(tls, ctx+4, ctx+28)

		libc.Xmemset(tls, ctx+28, 0, uint32(56))
	} else {
		libc.Xmemset(tls, p, 0, count-uint32(8))
	}
	byteReverse(tls, ctx+28, uint32(14))

	libc.Xmemcpy(tls, ctx+28+uintptr(14*4), ctx+20, uint32(8))

	MD5Transform(tls, ctx+4, ctx+28)
	byteReverse(tls, ctx+4, uint32(4))
	libc.Xmemcpy(tls, digest, ctx+4, uint32(16))
}

func MD5DigestToBase16(tls *libc.TLS, digest uintptr, zBuf uintptr) {
	var i int32
	var j int32

	for j = libc.AssignInt32(&i, 0); i < 16; i++ {
		var a int32 = int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i))))
		*(*int8)(unsafe.Pointer(zBuf + uintptr(libc.PostIncInt32(&j, 1)))) = zEncode[a>>4&0xf]
		*(*int8)(unsafe.Pointer(zBuf + uintptr(libc.PostIncInt32(&j, 1)))) = zEncode[a&0xf]
	}
	*(*int8)(unsafe.Pointer(zBuf + uintptr(j))) = int8(0)
}

var zEncode = *(*[17]int8)(unsafe.Pointer(ts + 35822))

func MD5DigestToBase10x8(tls *libc.TLS, digest uintptr, zDigest uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var j int32
	var x uint32
	for i = libc.AssignInt32(&j, 0); i < 16; i = i + 2 {
		x = uint32(int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i))))*256 + int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i+1)))))
		if i > 0 {
			*(*int8)(unsafe.Pointer(zDigest + uintptr(libc.PostIncInt32(&j, 1)))) = int8('-')
		}
		sqlite3.Xsqlite3_snprintf(tls, 50-j, zDigest+uintptr(j), ts+39129, libc.VaList(bp, x))
		j = j + 5
	}
	*(*int8)(unsafe.Pointer(zDigest + uintptr(j))) = int8(0)
}

func md5_cmd(tls *libc.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(206)
	defer tls.Free(206)

	var converter uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+20261, uintptr(0)))
		return TCL_ERROR
	}
	MD5Init(tls, bp+48)
	MD5Update(tls, bp+48, *(*uintptr)(unsafe.Pointer(argv + 1*4)), libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))))
	MD5Final(tls, bp+140, bp+48)
	converter = cd
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{converter})).f(tls, bp+140, bp+156)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+156, uintptr(0)))
	return TCL_OK
}

func md5file_cmd(tls *libc.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 {
	bp := tls.Alloc(10428)
	defer tls.Free(10428)

	var in uintptr
	var ofst int32
	var amt int32

	var converter uintptr

	if argc != 2 && argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903, *(*uintptr)(unsafe.Pointer(argv)),
			ts+39134, uintptr(0)))
		return TCL_ERROR
	}
	if argc == 4 {
		ofst = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*4)))
		amt = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 3*4)))
	} else {
		ofst = 0
		amt = 2147483647
	}
	in = libc.Xfopen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+4759)
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+39158, *(*uintptr)(unsafe.Pointer(argv + 1*4)),
			ts+39180, uintptr(0)))
		return TCL_ERROR
	}
	libc.Xfseek(tls, in, ofst, SEEK_SET)
	MD5Init(tls, bp+80)
	for amt > 0 {
		var n int32
		n = int32(libc.Xfread(tls, bp+172, uint32(1), func() uint32 {
			if uint32(unsafe.Sizeof([10240]int8{})) <= uint32(amt) {
				return uint32(unsafe.Sizeof([10240]int8{}))
			}
			return uint32(amt)
		}(), in))
		if n <= 0 {
			break
		}
		MD5Update(tls, bp+80, bp+172, uint32(n))
		amt = amt - n
	}
	libc.Xfclose(tls, in)
	MD5Final(tls, bp+10412, bp+80)
	converter = cd
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{converter})).f(tls, bp+10412, bp+172)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+172, uintptr(0)))
	return TCL_OK
}

func Md5_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateCommand(tls, interp, ts+39194, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+39198, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+39207, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+39215, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	return TCL_OK
}

func md5step(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	var p uintptr
	var i int32
	if argc < 1 {
		return
	}
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	if p == uintptr(0) {
		return
	}
	if !((*MD5Context)(unsafe.Pointer(p)).FisInit != 0) {
		MD5Init(tls, p)
	}
	for i = 0; i < argc; i++ {
		var zData uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
		if zData != 0 {
			MD5Update(tls, p, zData, uint32(int32(libc.Xstrlen(tls, zData))))
		}
	}
}

func md5finalize(tls *libc.TLS, context uintptr) {
	bp := tls.Alloc(49)
	defer tls.Free(49)

	var p uintptr

	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	MD5Final(tls, bp, p)
	MD5DigestToBase16(tls, bp, bp+16)
	sqlite3.Xsqlite3_result_text(tls, context, bp+16, -1, libc.UintptrFromInt32(-1))
}

func Md5_Register(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 {
	var rc int32 = sqlite3.Xsqlite3_create_function(tls, db, ts+39228, -1, SQLITE_UTF8, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{md5step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{md5finalize})))
	sqlite3.Xsqlite3_overload_function(tls, db, ts+39228, -1)
	return rc
}

type multiplexGroup1 = struct {
	FaReal       uintptr
	FnReal       int32
	FzName       uintptr
	FnName       int32
	Fflags       int32
	FszChunk     uint32
	FbEnabled    uint8
	FbTruncate   uint8
	F__ccgo_pad1 [2]byte
}

type multiplexGroup = multiplexGroup1
type multiplexConn1 = struct {
	Fbase   sqlite3_file
	FpGroup uintptr
}

type multiplexConn = multiplexConn1

type multiplexReal = struct {
	Fp uintptr
	Fz uintptr
}

var gMultiplex struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
}

func multiplexStrlen30(tls *libc.TLS, z uintptr) int32 {
	var z2 uintptr = z
	if z == uintptr(0) {
		return 0
	}
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return 0x3fffffff & ((int32(z2) - int32(z)) / 1)
}

func multiplexFilename(tls *libc.TLS, zBase uintptr, nBase int32, flags int32, iChunk int32, zOut uintptr) {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var n int32 = nBase
	libc.Xmemcpy(tls, zOut, zBase, uint32(n+1))
	if iChunk != 0 && iChunk <= MX_CHUNK_NUMBER {
		sqlite3.Xsqlite3_snprintf(tls, 4, zOut+uintptr(n), ts+39235, libc.VaList(bp, iChunk))
		n = n + 3
	}

	*(*int8)(unsafe.Pointer(zOut + uintptr(n+1))) = int8(0)
}

func multiplexSubFilename(tls *libc.TLS, pGroup uintptr, iChunk int32) int32 {
	if iChunk >= (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal {
		var p uintptr
		p = sqlite3.Xsqlite3_realloc64(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal, uint64(uint32(iChunk+1)*uint32(unsafe.Sizeof(multiplexReal{}))))
		if p == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, p+uintptr((*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal)*8, 0, uint32(unsafe.Sizeof(multiplexReal{}))*uint32(iChunk+1-(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = p
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = iChunk + 1
	}
	if (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName != 0 && (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz == uintptr(0) {
		var z uintptr
		var n int32 = (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName
		z = sqlite3.Xsqlite3_malloc64(tls, uint64(n+5))
		if z == uintptr(0) {
			return SQLITE_NOMEM
		}
		multiplexFilename(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName, (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags, iChunk, z)
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fz = sqlite3.Xsqlite3_create_filename(tls, z, ts+584, ts+584, 0, uintptr(0))
		sqlite3.Xsqlite3_free(tls, z)
		if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz == uintptr(0) {
			return SQLITE_NOMEM
		}
	}
	return SQLITE_OK
}

func multiplexSubOpen(tls *libc.TLS, pGroup uintptr, iChunk int32, rc uintptr, pOutFlags uintptr, createFlag int32) uintptr {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pSubOpen uintptr = uintptr(0)
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs

	*(*int32)(unsafe.Pointer(rc)) = multiplexSubFilename(tls, pGroup, iChunk)
	if *(*int32)(unsafe.Pointer(rc)) == SQLITE_OK && libc.AssignUintptr(&pSubOpen, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fp) == uintptr(0) {
		var flags int32

		flags = (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags
		if createFlag != 0 {
			flags = flags | SQLITE_OPEN_CREATE
		} else if iChunk == 0 {
		} else if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz == uintptr(0) {
			return uintptr(0)
		} else {
			*(*int32)(unsafe.Pointer(rc)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz,
				SQLITE_ACCESS_EXISTS, bp+16)
			if *(*int32)(unsafe.Pointer(rc)) != 0 || !(*(*int32)(unsafe.Pointer(bp + 16)) != 0) {
				if *(*int32)(unsafe.Pointer(rc)) != 0 {
					sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+39240,
						libc.VaList(bp, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz))
				}
				return uintptr(0)
			}
			flags = flags & libc.CplInt32(SQLITE_OPEN_CREATE)
		}
		pSubOpen = sqlite3.Xsqlite3_malloc64(tls, uint64((*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FszOsFile))
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(rc)) = SQLITE_IOERR | int32(12)<<8
			return uintptr(0)
		}
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fp = pSubOpen
		*(*int32)(unsafe.Pointer(rc)) = (*struct {
			f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, pSubOpen,
			flags, pOutFlags)
		if *(*int32)(unsafe.Pointer(rc)) != SQLITE_OK {
			sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+39274,
				libc.VaList(bp+8, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz))
			sqlite3.Xsqlite3_free(tls, pSubOpen)
			(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fp = uintptr(0)
			return uintptr(0)
		}
	}
	return pSubOpen
}

func multiplexSubSize(tls *libc.TLS, pGroup uintptr, iChunk int32, rc uintptr) sqlite3_int64 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSub uintptr
	*(*sqlite3_int64)(unsafe.Pointer(bp)) = int64(0)

	if *(*int32)(unsafe.Pointer(rc)) != 0 {
		return int64(0)
	}
	pSub = multiplexSubOpen(tls, pGroup, iChunk, rc, uintptr(0), 0)
	if pSub == uintptr(0) {
		return int64(0)
	}
	*(*int32)(unsafe.Pointer(rc)) = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSub)).FpMethods)).FxFileSize})).f(tls, pSub, bp)
	return *(*sqlite3_int64)(unsafe.Pointer(bp))
}

func multiplexControlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = SQLITE_OK
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var op int32 = 0

	if !(db != 0) || argc != 2 {
		rc = SQLITE_ERROR
	} else {
		op = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))

		switch op {
		case 1:
			op = MULTIPLEX_CTRL_ENABLE
			break
			fallthrough
		case 2:
			op = MULTIPLEX_CTRL_SET_CHUNK_SIZE
			break
			fallthrough
		case 3:
			op = MULTIPLEX_CTRL_SET_MAX_CHUNKS
			break
			fallthrough
		default:
			rc = SQLITE_NOTFOUND
			break
		}
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_file_control(tls, db, uintptr(0), op, bp)
	}
	sqlite3.Xsqlite3_result_error_code(tls, context, rc)
}

func multiplexFuncInit(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 {
	var rc int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+39306, 2, SQLITE_ANY,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{multiplexControlFunc})), uintptr(0), uintptr(0))
	return rc
}

func multiplexSubClose(tls *libc.TLS, pGroup uintptr, iChunk int32, pOrigVfs uintptr) {
	var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*8)).Fp
	if pSubOpen != 0 {
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxClose})).f(tls, pSubOpen)
		if pOrigVfs != 0 && (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, 0)
		}
		sqlite3.Xsqlite3_free(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fp)
	}
	sqlite3.Xsqlite3_free_filename(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz)
	libc.Xmemset(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8, 0, uint32(unsafe.Sizeof(multiplexReal{})))
}

func multiplexFreeComponents(tls *libc.TLS, pGroup uintptr) {
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		multiplexSubClose(tls, pGroup, i, uintptr(0))
	}
	sqlite3.Xsqlite3_free(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = uintptr(0)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = 0
}

func multiplexOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 {
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pMultiplexOpen uintptr
	var pGroup uintptr = uintptr(0)
	var pSubOpen uintptr = uintptr(0)
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs
	var nName int32 = 0
	var sz int32 = 0
	var zToFree uintptr = uintptr(0)

	_ = pVfs
	libc.Xmemset(tls, pConn, 0, uint32((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile))

	pMultiplexOpen = pConn

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		if zName != 0 {
			nName = multiplexStrlen30(tls, zName)
		} else {
			nName = 0
		}
		sz = int32(uint32(unsafe.Sizeof(multiplexGroup{})) +
			uint32(nName) + uint32(1))
		pGroup = sqlite3.Xsqlite3_malloc64(tls, uint64(sz))
		if pGroup == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_NOMEM
		}
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		var zUri uintptr
		if flags&SQLITE_OPEN_URI != 0 {
			zUri = zName
		} else {
			zUri = uintptr(0)
		}

		libc.Xmemset(tls, pGroup, 0, uint32(sz))
		(*multiplexConn)(unsafe.Pointer(pMultiplexOpen)).FpGroup = pGroup
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = libc.Uint8(libc.Uint8FromInt32(-1))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(sqlite3.Xsqlite3_uri_boolean(tls, zUri, ts+23243,
			libc.Bool32(flags&SQLITE_OPEN_MAIN_DB == 0)))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(sqlite3.Xsqlite3_uri_int64(tls, zUri, ts+39324,
			int64(SQLITE_MULTIPLEX_CHUNK_SIZE))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = ((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk + uint32(0xffff)) & libc.Uint32FromInt32(libc.CplInt32(0xffff))
		if zName != 0 {
			var p uintptr = pGroup + 1*28
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FzName = p
			libc.Xmemcpy(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, zName, uint32(nName+1))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FnName = nName
		}
		if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled != 0 {
			for uint32(sqlite3.Xsqlite3PendingByte)%(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk >= (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk-uint32(65536) {
				*(*uint32)(unsafe.Pointer(pGroup + 20)) += uint32(65536)
			}
		}
		(*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags = flags & libc.CplInt32(SQLITE_OPEN_URI)
		*(*int32)(unsafe.Pointer(bp)) = multiplexSubFilename(tls, pGroup, 1)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp, pOutFlags, 0)
			if pSubOpen == uintptr(0) && *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				*(*int32)(unsafe.Pointer(bp)) = SQLITE_CANTOPEN
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			*(*int32)(unsafe.Pointer(bp)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileSize})).f(tls, pSubOpen, bp+4)
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && zName != 0 {
				if flags&SQLITE_OPEN_SUPER_JOURNAL != 0 {
					(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
				} else if *(*sqlite3_int64)(unsafe.Pointer(bp + 4)) == int64(0) {
					if flags&SQLITE_OPEN_MAIN_JOURNAL != 0 {
						var iChunk int32 = 1
						for __ccgo := true; __ccgo; __ccgo = *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && *(*int32)(unsafe.Pointer(bp + 12)) != 0 {
							*(*int32)(unsafe.Pointer(bp)) = (*struct {
								f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
							})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs,
								(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, SQLITE_ACCESS_EXISTS, bp+12)
							if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && *(*int32)(unsafe.Pointer(bp + 12)) != 0 {
								*(*int32)(unsafe.Pointer(bp)) = (*struct {
									f func(*libc.TLS, uintptr, uintptr, int32) int32
								})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*8)).Fz, 0)
								if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
									*(*int32)(unsafe.Pointer(bp)) = multiplexSubFilename(tls, pGroup, libc.PreIncInt32(&iChunk, 1))
								}
							}
						}
					}
				} else {
					*(*int32)(unsafe.Pointer(bp)) = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+1*8)).Fz,
						SQLITE_ACCESS_EXISTS, bp+12)
					*(*int32)(unsafe.Pointer(bp + 12)) = libc.Bool32(multiplexSubSize(tls, pGroup, 1, bp) > int64(0))
					if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && *(*int32)(unsafe.Pointer(bp + 12)) != 0 && *(*sqlite3_int64)(unsafe.Pointer(bp + 4)) == *(*sqlite3_int64)(unsafe.Pointer(bp + 4))&int64(0xffff0000) && *(*sqlite3_int64)(unsafe.Pointer(bp + 4)) > int64(0) &&
						*(*sqlite3_int64)(unsafe.Pointer(bp + 4)) != sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 4))))
					} else if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && !(*(*int32)(unsafe.Pointer(bp + 12)) != 0) && *(*sqlite3_int64)(unsafe.Pointer(bp + 4)) > sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
					}
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*sqlite3_file)(unsafe.Pointer(pConn)).FpMethods = uintptr(unsafe.Pointer(&gMultiplex)) + 92
			} else {
				(*sqlite3_file)(unsafe.Pointer(pConn)).FpMethods = uintptr(unsafe.Pointer(&gMultiplex)) + 168
			}
		} else {
			multiplexFreeComponents(tls, pGroup)
			sqlite3.Xsqlite3_free(tls, pGroup)
		}
	}
	sqlite3.Xsqlite3_free(tls, zToFree)
	return *(*int32)(unsafe.Pointer(bp))
}

func multiplexDelete(tls *libc.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, zName, syncDir)
	if rc == SQLITE_OK {
		var nName int32 = int32(libc.Xstrlen(tls, zName))
		var z uintptr
		z = sqlite3.Xsqlite3_malloc64(tls, uint64(nName+5))
		if z == uintptr(0) {
			rc = SQLITE_IOERR | int32(12)<<8
		} else {
			var iChunk int32 = 0

			for __ccgo := true; __ccgo; __ccgo = rc == SQLITE_OK && *(*int32)(unsafe.Pointer(bp)) != 0 {
				multiplexFilename(tls, zName, nName, SQLITE_OPEN_MAIN_JOURNAL, libc.PreIncInt32(&iChunk, 1), z)
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, z, SQLITE_ACCESS_EXISTS, bp)
			}
			for rc == SQLITE_OK && iChunk > 1 {
				multiplexFilename(tls, zName, nName, SQLITE_OPEN_MAIN_JOURNAL, libc.PreDecInt32(&iChunk, 1), z)
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, z, syncDir)
			}
			if rc == SQLITE_OK {
				iChunk = 0
				for __ccgo1 := true; __ccgo1; __ccgo1 = rc == SQLITE_OK && *(*int32)(unsafe.Pointer(bp)) != 0 {
					multiplexFilename(tls, zName, nName, SQLITE_OPEN_WAL, libc.PreIncInt32(&iChunk, 1), z)
					rc = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, z, SQLITE_ACCESS_EXISTS, bp)
				}
				for rc == SQLITE_OK && iChunk > 1 {
					multiplexFilename(tls, zName, nName, SQLITE_OPEN_WAL, libc.PreDecInt32(&iChunk, 1), z)
					rc = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, z, syncDir)
				}
			}
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	return rc
}

func multiplexAccess(tls *libc.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxAccess})).f(tls, gMultiplex.FpOrigVfs, b, c, d)
}

func multiplexFullPathname(tls *libc.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxFullPathname})).f(tls, gMultiplex.FpOrigVfs, b, c, d)
}

func multiplexDlOpen(tls *libc.TLS, a uintptr, b uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlOpen})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexDlError(tls *libc.TLS, a uintptr, b int32, c uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlError})).f(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexDlSym(tls *libc.TLS, a uintptr, b uintptr, c uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlSym})).f(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexDlClose(tls *libc.TLS, a uintptr, b uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlClose})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexRandomness(tls *libc.TLS, a uintptr, b int32, c uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxRandomness})).f(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexSleep(tls *libc.TLS, a uintptr, b int32) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxSleep})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexCurrentTime(tls *libc.TLS, a uintptr, b uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxCurrentTime})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexGetLastError(tls *libc.TLS, a uintptr, b int32, c uintptr) int32 {
	if (*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxGetLastError != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxGetLastError})).f(tls, gMultiplex.FpOrigVfs, b, c)
	} else {
		return 0
	}
	return int32(0)
}

func multiplexCurrentTimeInt64(tls *libc.TLS, a uintptr, b uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxCurrentTimeInt64})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexClose(tls *libc.TLS, pConn uintptr) int32 {
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = SQLITE_OK
	multiplexFreeComponents(tls, pGroup)
	sqlite3.Xsqlite3_free(tls, pGroup)
	return rc
}

func multiplexRead(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR | int32(1)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxRead})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for iAmt > 0 {
			var i int32 = int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
			var pSubOpen uintptr
			pSubOpen = multiplexSubOpen(tls, pGroup, i, bp, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = int32(uint32(int32(iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))+iAmt) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - extra
				*(*int32)(unsafe.Pointer(bp)) = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxRead})).f(tls, pSubOpen, pBuf, iAmt,
					iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
					break
				}
				pBuf = pBuf + uintptr(iAmt)
				iOfst = iOfst + sqlite3_int64(iAmt)
				iAmt = extra
			} else {
				*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR | int32(1)<<8
				break
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func multiplexWrite(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR | int32(3)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxWrite})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && iAmt > 0 {
			var i int32 = int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
			var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, i, bp, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = int32(uint32(int32(iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))+iAmt) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - extra
				*(*int32)(unsafe.Pointer(bp)) = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxWrite})).f(tls, pSubOpen, pBuf, iAmt,
					iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				pBuf = pBuf + uintptr(iAmt)
				iOfst = iOfst + sqlite3_int64(iAmt)
				iAmt = extra
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func multiplexTruncate(tls *libc.TLS, pConn uintptr, size sqlite3_int64) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR | int32(6)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp)) = (*struct {
				f func(*libc.TLS, uintptr, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, size)
		}
	} else {
		var i int32
		var iBaseGroup int32 = int32(size / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
		var pSubOpen uintptr
		var pOrigVfs uintptr = gMultiplex.FpOrigVfs

		for i = (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal - 1; i > iBaseGroup && *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK; i-- {
			if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
				multiplexSubClose(tls, pGroup, i, pOrigVfs)
			} else {
				pSubOpen = multiplexSubOpen(tls, pGroup, i, bp, uintptr(0), 0)
				if pSubOpen != 0 {
					*(*int32)(unsafe.Pointer(bp)) = (*struct {
						f func(*libc.TLS, uintptr, sqlite3_int64) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, int64(0))
				}
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			pSubOpen = multiplexSubOpen(tls, pGroup, iBaseGroup, bp, uintptr(0), 0)
			if pSubOpen != 0 {
				*(*int32)(unsafe.Pointer(bp)) = (*struct {
					f func(*libc.TLS, uintptr, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, size%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) != 0 {
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR | int32(6)<<8
		}
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func multiplexSync(tls *libc.TLS, pConn uintptr, flags int32) int32 {
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = SQLITE_OK
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(i)*8)).Fp
		if pSubOpen != 0 {
			var rc2 int32 = (*struct {
				f func(*libc.TLS, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSync})).f(tls, pSubOpen, flags)
			if rc2 != SQLITE_OK {
				rc = rc2
			}
		}
	}
	return rc
}

func multiplexFileSize(tls *libc.TLS, pConn uintptr, pSize uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var i int32
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR | int32(7)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileSize})).f(tls, pSubOpen, pSize)
		}
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = int64(0)
		for i = 0; *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK; i++ {
			var sz sqlite3_int64 = multiplexSubSize(tls, pGroup, i, bp)
			if sz == int64(0) {
				break
			}
			*(*sqlite3_int64)(unsafe.Pointer(pSize)) = sqlite3_int64(i)*sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) + sz
		}
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func multiplexLock(tls *libc.TLS, pConn uintptr, lock int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxLock})).f(tls, pSubOpen, lock)
	}
	return SQLITE_BUSY
}

func multiplexUnlock(tls *libc.TLS, pConn uintptr, lock int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxUnlock})).f(tls, pSubOpen, lock)
	}
	return SQLITE_IOERR | int32(8)<<8
}

func multiplexCheckReservedLock(tls *libc.TLS, pConn uintptr, pResOut uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxCheckReservedLock})).f(tls, pSubOpen, pResOut)
	}
	return SQLITE_IOERR | int32(14)<<8
}

func multiplexFileControl(tls *libc.TLS, pConn uintptr, op int32, pArg uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_ERROR
	var pSubOpen uintptr

	if !(gMultiplex.FisInitialized != 0) {
		return SQLITE_MISUSE
	}
	switch op {
	case MULTIPLEX_CTRL_ENABLE:
		if pArg != 0 {
			var bEnabled int32 = *(*int32)(unsafe.Pointer(pArg))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(bEnabled)
			*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
		}
		break
	case MULTIPLEX_CTRL_SET_CHUNK_SIZE:
		if pArg != 0 {
			var szChunk uint32 = *(*uint32)(unsafe.Pointer(pArg))
			if szChunk < uint32(1) {
				*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_MISUSE
			} else {
				szChunk = szChunk + uint32(MAX_PAGE_SIZE-1)
				szChunk = szChunk & libc.Uint32FromInt32(libc.CplInt32(MAX_PAGE_SIZE-1))
				(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = szChunk
				*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
			}
		}
		break
	case MULTIPLEX_CTRL_SET_MAX_CHUNKS:
		*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
		break
	case SQLITE_FCNTL_SIZE_HINT:
		fallthrough
	case SQLITE_FCNTL_CHUNK_SIZE:
		*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
		break
	case SQLITE_FCNTL_PRAGMA:
		{
			var aFcntl uintptr = pArg

			if *(*uintptr)(unsafe.Pointer(aFcntl + 1*4)) != 0 && sqlite3.Xsqlite3_strnicmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*4)), ts+39334, 10) == 0 {
				*(*sqlite3_int64)(unsafe.Pointer(bp + 32)) = int64(0)
				multiplexFileSize(tls, pConn, bp+32)

				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*4)), ts+39345) == 0 {
					if *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)) != 0 && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(aFcntl + 2*4)))) != 0 {
						if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+4535) == 0 ||
							sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+22605) == 0 {
							(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(1)
						} else if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+4899) == 0 ||
							sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*4)), ts+19147) == 0 {
							(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(0)
						}
					}

					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, func() uintptr {
						if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
							return ts + 4535
						}
						return ts + 4899
					}(), 0)
					*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
					break
				}

				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*4)), ts+39364) == 0 {
					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, ts+1333, libc.VaList(bp, libc.Bool32(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0)))
					*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
					break
				}

				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*4)), ts+39382) == 0 &&
					(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled != 0 {
					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, ts+22730, libc.VaList(bp+8, (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
					*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
					break
				}

				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*4)), ts+39402) == 0 {
					var n int32 = 0
					var ii int32
					for ii = 0; ii < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; ii++ {
						if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(ii)*8)).Fp != uintptr(0) {
							n++
						}
					}
					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, ts+1333, libc.VaList(bp+16, n))
					*(*int32)(unsafe.Pointer(bp + 40)) = SQLITE_OK
					break
				}
			}

		}
		fallthrough
	default:
		pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp+40, uintptr(0), 0)
		if pSubOpen != 0 {
			*(*int32)(unsafe.Pointer(bp + 40)) = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileControl})).f(tls, pSubOpen, op, pArg)
			if op == SQLITE_FCNTL_VFSNAME && *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
				*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+39422, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(pArg))))
			}
		}
		break
	}
	return *(*int32)(unsafe.Pointer(bp + 40))
}

func multiplexSectorSize(tls *libc.TLS, pConn uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize})).f(tls, pSubOpen)
	}
	return DEFAULT_SECTOR_SIZE
}

func multiplexDeviceCharacteristics(tls *libc.TLS, pConn uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxDeviceCharacteristics})).f(tls, pSubOpen)
	}
	return 0
}

func multiplexShmMap(tls *libc.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmMap})).f(tls, pSubOpen, iRegion, szRegion, bExtend, pp)
	}
	return SQLITE_IOERR
}

func multiplexShmLock(tls *libc.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmLock})).f(tls, pSubOpen, ofst, n, flags)
	}
	return SQLITE_BUSY
}

func multiplexShmBarrier(tls *libc.TLS, pConn uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmBarrier})).f(tls, pSubOpen)
	}
}

func multiplexShmUnmap(tls *libc.TLS, pConn uintptr, deleteFlag int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmUnmap})).f(tls, pSubOpen, deleteFlag)
	}
	return SQLITE_OK
}

func sqlite3_multiplex_initialize(tls *libc.TLS, zOrigVfsName uintptr, makeDefault int32) int32 {
	var pOrigVfs uintptr
	if gMultiplex.FisInitialized != 0 {
		return SQLITE_MISUSE
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return SQLITE_ERROR
	}

	gMultiplex.FisInitialized = 1
	gMultiplex.FpOrigVfs = pOrigVfs
	gMultiplex.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gMultiplex)) + 4 + 4)) += int32(uint32(unsafe.Sizeof(multiplexConn{})))
	gMultiplex.FsThisVfs.FzName = ts + 39435
	gMultiplex.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{multiplexOpen}))
	gMultiplex.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{multiplexDelete}))
	gMultiplex.FsThisVfs.FxAccess = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexAccess}))
	gMultiplex.FsThisVfs.FxFullPathname = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexFullPathname}))
	gMultiplex.FsThisVfs.FxDlOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	}{multiplexDlOpen}))
	gMultiplex.FsThisVfs.FxDlError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{multiplexDlError}))
	gMultiplex.FsThisVfs.FxDlSym = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	}{multiplexDlSym}))
	gMultiplex.FsThisVfs.FxDlClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{multiplexDlClose}))
	gMultiplex.FsThisVfs.FxRandomness = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexRandomness}))
	gMultiplex.FsThisVfs.FxSleep = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexSleep}))
	gMultiplex.FsThisVfs.FxCurrentTime = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTime}))
	gMultiplex.FsThisVfs.FxGetLastError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexGetLastError}))
	gMultiplex.FsThisVfs.FxCurrentTimeInt64 = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTimeInt64}))

	gMultiplex.FsIoMethodsV1.FiVersion = 1
	gMultiplex.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexClose}))
	gMultiplex.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexRead}))
	gMultiplex.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexWrite}))
	gMultiplex.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	}{multiplexTruncate}))
	gMultiplex.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexSync}))
	gMultiplex.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexFileSize}))
	gMultiplex.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexLock}))
	gMultiplex.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexUnlock}))
	gMultiplex.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCheckReservedLock}))
	gMultiplex.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexFileControl}))
	gMultiplex.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexSectorSize}))
	gMultiplex.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexDeviceCharacteristics}))
	gMultiplex.FsIoMethodsV2 = gMultiplex.FsIoMethodsV1
	gMultiplex.FsIoMethodsV2.FiVersion = 2
	gMultiplex.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{multiplexShmMap}))
	gMultiplex.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	}{multiplexShmLock}))
	gMultiplex.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{multiplexShmBarrier}))
	gMultiplex.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&gMultiplex))+4, makeDefault)

	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{multiplexFuncInit})))

	return SQLITE_OK
}

func sqlite3_multiplex_shutdown(tls *libc.TLS, eForce int32) int32 {
	var rc int32 = SQLITE_OK
	if gMultiplex.FisInitialized == 0 {
		return SQLITE_MISUSE
	}
	gMultiplex.FisInitialized = 0
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&gMultiplex))+4)
	libc.Xmemset(tls, uintptr(unsafe.Pointer(&gMultiplex)), 0, uint32(unsafe.Sizeof(gMultiplex)))
	return rc
}

func test_multiplex_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr

	var rc int32

	_ = clientData

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39445)
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 {
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(zName))) == 0 {
		zName = uintptr(0)
	}

	rc = sqlite3_multiplex_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

func test_multiplex_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32

	_ = clientData

	if objc == 2 && libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), ts+39462) != 0 {
		objc = 3
	}
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39469)
		return TCL_ERROR
	}

	rc = sqlite3_multiplex_shutdown(tls, libc.Bool32(objc == 2))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

func test_multiplex_control(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var rc int32

	var db uintptr
	*(*int32)(unsafe.Pointer(bp + 124)) = 0
	var pArg uintptr = uintptr(0)

	*(*[4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 72)) = [4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	}{
		{FzName: ts + 15047, Fop: MULTIPLEX_CTRL_ENABLE, Fargtype: 1},
		{FzName: ts + 39478, Fop: MULTIPLEX_CTRL_SET_CHUNK_SIZE, Fargtype: 1},
		{FzName: ts + 39489, Fop: MULTIPLEX_CTRL_SET_MAX_CHUNKS, Fargtype: 1},
		{},
	}

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39500)
		return TCL_ERROR
	}

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+40) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+39536, 0))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), ts+16912, 0))
		return TCL_ERROR
	} else {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 40)).FobjClientData))
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+72, int32(unsafe.Sizeof(struct {
			FzName   uintptr
			Fop      int32
			Fargtype int32
		}{})), ts+2014, 0, bp+120)
	if rc != TCL_OK {
		return rc
	}

	switch (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 72 + uintptr(*(*int32)(unsafe.Pointer(bp + 120)))*12)).Fargtype {
	case 1:
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+124) != 0 {
			return TCL_ERROR
		}
		pArg = bp + 124
		break
	default:
		tcl.XTcl_WrongNumArgs(tls, interp, 4, objv, ts+2523)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp+72+uintptr(*(*int32)(unsafe.Pointer(bp + 120)))*12)).Fop, pArg)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if rc == SQLITE_OK {
		return TCL_OK
	}
	return TCL_ERROR
}

func Sqlitemultiplex_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd6))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd6[i].FzName, aCmd6[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aCmd6 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 39568, FxProc: 0},
	{FzName: ts + 39597, FxProc: 0},
	{FzName: ts + 39624, FxProc: 0},
}

type sqlite3_mutex = sqlite3_mutex1

var aName = [15]uintptr{
	ts + 39650, ts + 39655, ts + 39665, ts + 39677,
	ts + 39688, ts + 39700, ts + 39712, ts + 39723,
	ts + 39735, ts + 39747, ts + 39759, ts + 39771,
	ts + 39783, ts + 39795, uintptr(0),
}

type test_mutex_globals = struct {
	FisInstalled int32
	FdisableInit int32
	FdisableTry  int32
	FisInit      int32
	Fm           sqlite3_mutex_methods
	FaCounter    [14]int32
	FaStatic     [12]sqlite3_mutex
}

var g3 = test_mutex_globals{}

func counterMutexHeld(tls *libc.TLS, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexHeld})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

func counterMutexNotheld(tls *libc.TLS, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexNotheld})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

func counterMutexInit(tls *libc.TLS) int32 {
	var rc int32
	if g3.FdisableInit != 0 {
		return g3.FdisableInit
	}
	rc = (*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexInit})).f(tls)
	g3.FisInit = 1
	return rc
}

func counterMutexEnd(tls *libc.TLS) int32 {
	g3.FisInit = 0
	return (*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexEnd})).f(tls)
}

func counterMutexAlloc(tls *libc.TLS, eType int32) uintptr {
	var pReal uintptr
	var pRet uintptr = uintptr(0)

	pReal = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexAlloc})).f(tls, eType)
	if !(pReal != 0) {
		return uintptr(0)
	}

	if eType == SQLITE_MUTEX_FAST || eType == SQLITE_MUTEX_RECURSIVE {
		pRet = libc.Xmalloc(tls, uint32(unsafe.Sizeof(sqlite3_mutex{})))
	} else {
		var eStaticType int32 = eType - (SQLITE_MUTEX_STATIC_VFS3 + 1 - (SQLITE_MUTEX_STATIC_VFS3 + 1 - (SQLITE_MUTEX_RECURSIVE + 1)))

		pRet = uintptr(unsafe.Pointer(&g3)) + 108 + uintptr(eStaticType)*8
	}

	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FeType = eType
	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FpReal = pReal
	return pRet
}

func counterMutexFree(tls *libc.TLS, p uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexFree})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
	if (*sqlite3_mutex)(unsafe.Pointer(p)).FeType == SQLITE_MUTEX_FAST || (*sqlite3_mutex)(unsafe.Pointer(p)).FeType == SQLITE_MUTEX_RECURSIVE {
		libc.Xfree(tls, p)
	}
}

func counterMutexEnter(tls *libc.TLS, p uintptr) {
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 52 + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexEnter})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

func counterMutexTry(tls *libc.TLS, p uintptr) int32 {
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 52 + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	if g3.FdisableTry != 0 {
		return SQLITE_BUSY
	}
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexTry})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

func counterMutexLeave(tls *libc.TLS, p uintptr) {
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexLeave})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

func test_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_initialize(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_install_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var rc int32 = SQLITE_OK

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 60)) = sqlite3_mutex_methods{
		FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{counterMutexInit})),
		FxMutexEnd:  *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{counterMutexEnd})),
		FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{counterMutexAlloc})),
		FxMutexFree:  *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexFree})),
		FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexEnter})),
		FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexTry})),
		FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexLeave})),
		FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexHeld})),
		FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexNotheld})),
	}

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23177)
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+56) {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 56)) == g3.FisInstalled {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+39807, 0))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 56)) != 0 {
				return ts + 39827
			}
			return ts + 39845
		}(), 0))
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 56)) != 0 {
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMUTEX, libc.VaList(bp+32, uintptr(unsafe.Pointer(&g3))+16))
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+40, bp+60))
		}
		g3.FdisableTry = 0
	} else {
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+48, uintptr(unsafe.Pointer(&g3))+16))
		libc.Xmemset(tls, uintptr(unsafe.Pointer(&g3))+16, 0, uint32(unsafe.Sizeof(sqlite3_mutex_methods{})))
	}

	if rc == SQLITE_OK {
		g3.FisInstalled = *(*int32)(unsafe.Pointer(bp + 56))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_read_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pRet uintptr
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	for ii = 0; ii < SQLITE_MUTEX_STATIC_VFS3+1; ii++ {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, aName[ii], -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 52 + uintptr(ii)*4))))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return TCL_OK
}

func test_clear_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	for ii = 0; ii < SQLITE_MUTEX_STATIC_VFS3+1; ii++ {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 52 + uintptr(ii)*4)) = 0
	}
	return TCL_OK
}

func test_alloc_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var p uintptr = sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_FAST)

	sqlite3.Xsqlite3_mutex_free(tls, p)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24, ts+14791, libc.VaList(bp, p))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, bp+24, uintptr(0)))
	return TCL_OK
}

func test_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*[4]ConfigOption)(unsafe.Pointer(bp)) = [4]ConfigOption{
		{FzName: ts + 39859, FiValue: SQLITE_CONFIG_SINGLETHREAD},
		{FzName: ts + 39872, FiValue: SQLITE_CONFIG_MULTITHREAD},
		{FzName: ts + 39884, FiValue: SQLITE_CONFIG_SERIALIZED},
		{},
	}
	var s int32 = int32(unsafe.Sizeof(ConfigOption{}))

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp, s, ts+22558, 0, bp+32) != 0 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+32) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 32)) = (*ConfigOption)(unsafe.Pointer(bp + uintptr(*(*int32)(unsafe.Pointer(bp + 32)))*8)).FiValue
	}

	rc = sqlite3.Xsqlite3_config(tls, *(*int32)(unsafe.Pointer(bp + 32)), 0)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

type ConfigOption = struct {
	FzName  uintptr
	FiValue int32
}

func getDbPointer2(tls *libc.TLS, pInterp uintptr, pObj uintptr) uintptr {
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var db uintptr

	var zCmd uintptr = tcl.XTcl_GetString(tls, pObj)
	if tcl.XTcl_GetCommandInfo(tls, pInterp, zCmd, bp) != 0 {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp)).FobjClientData))
	} else {
		db = sqlite3TestTextToPtr(tls, zCmd)
	}

	return db
}

func getStaticMutexPointer(tls *libc.TLS, pInterp uintptr, pObj uintptr) uintptr {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if tcl.XTcl_GetIndexFromObjStruct(tls, pInterp, pObj, uintptr(unsafe.Pointer(&aName)), int32(unsafe.Sizeof(uintptr(0))), ts+39895, 0, bp) != 0 {
		return uintptr(0)
	}

	return counterMutexAlloc(tls, *(*int32)(unsafe.Pointer(bp)))
}

func test_enter_static_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10139)
		return TCL_ERROR
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(pMutex != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, pMutex)
	return TCL_OK
}

func test_leave_static_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10139)
		return TCL_ERROR
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(pMutex != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, pMutex)
	return TCL_OK
}

func test_enter_db_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	db = getDbPointer2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(db != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return TCL_OK
}

func test_leave_db_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	db = getDbPointer2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if !(db != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return TCL_OK
}

func Sqlitetest_mutex_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd7))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd7[i].FzName, aCmd7[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_LinkVar(tls, interp, ts+39906,
		uintptr(unsafe.Pointer(&g3))+4, TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+39925,
		uintptr(unsafe.Pointer(&g3))+8, TCL_LINK_INT)
	return SQLITE_OK
}

var aCmd7 = [11]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 39943, FxProc: 0},
	{FzName: ts + 39960, FxProc: 0},
	{FzName: ts + 39979, FxProc: 0},
	{FzName: ts + 39994, FxProc: 0},
	{FzName: ts + 40013, FxProc: 0},
	{FzName: ts + 40032, FxProc: 0},
	{FzName: ts + 40047, FxProc: 0},
	{FzName: ts + 40062, FxProc: 0},
	{FzName: ts + 40082, FxProc: 0},
	{FzName: ts + 40105, FxProc: 0},
	{FzName: ts + 40125, FxProc: 0},
}

type fs_real_file1 = struct {
	FpFile     uintptr
	FzName     uintptr
	FnDatabase int32
	FnJournal  int32
	FnBlob     int32
	FnRef      int32
	FpNext     uintptr
	FppThis    uintptr
}

type fs_real_file = fs_real_file1

type fs_file1 = struct {
	Fbase  sqlite3_file
	FeType int32
	FpReal uintptr
}

type fs_file = fs_file1

type tmp_file1 = struct {
	Fbase   sqlite3_file
	FnSize  int32
	FnAlloc int32
	FzAlloc uintptr
}

type tmp_file = tmp_file1

type fs_vfs_t1 = struct {
	Fbase      sqlite3_vfs
	FpFileList uintptr
	FpParent   uintptr
}

type fs_vfs_t = fs_vfs_t1

var fs_vfs = fs_vfs_t{
	Fbase: sqlite3_vfs{
		FiVersion:      1,
		FzName:         ts + 35683,
		FxOpen:         0,
		FxDelete:       0,
		FxAccess:       0,
		FxFullPathname: 0,
		FxDlOpen:       0,
		FxDlError:      0,
		FxDlSym:        0,
		FxDlClose:      0,
		FxRandomness:   0,
		FxSleep:        0,
		FxCurrentTime:  0,
	},
}

var fs_io_methods = sqlite3_io_methods{
	FiVersion:               1,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
}

var tmp_io_methods = sqlite3_io_methods{
	FiVersion:               1,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
}

func tmpClose(tls *libc.TLS, pFile uintptr) int32 {
	var pTmp uintptr = pFile
	sqlite3.Xsqlite3_free(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc)
	return SQLITE_OK
}

func tmpRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var pTmp uintptr = pFile
	if sqlite_int64(iAmt)+iOfst > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) {
		return SQLITE_IOERR | int32(2)<<8
	}
	libc.Xmemcpy(tls, zBuf, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc+uintptr(iOfst), uint32(iAmt))
	return SQLITE_OK
}

func tmpWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var pTmp uintptr = pFile
	if sqlite_int64(iAmt)+iOfst > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc) {
		var nNew int32 = int32(int64(2) * (sqlite_int64(iAmt) + iOfst + sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc)))
		var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc, nNew)
		if !(zNew != 0) {
			return SQLITE_NOMEM
		}
		(*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc = zNew
		(*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc = nNew
	}
	libc.Xmemcpy(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc+uintptr(iOfst), zBuf, uint32(iAmt))
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) > iOfst+sqlite_int64(iAmt) {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return int32(iOfst + sqlite_int64(iAmt))
	}()
	return SQLITE_OK
}

func tmpTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	var pTmp uintptr = pFile
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) < size {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return int32(size)
	}()
	return SQLITE_OK
}

func tmpSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	return SQLITE_OK
}

func tmpFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var pTmp uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)
	return SQLITE_OK
}

func tmpLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	return SQLITE_OK
}

func tmpUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	return SQLITE_OK
}

func tmpCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return SQLITE_OK
}

func tmpFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	return SQLITE_OK
}

func tmpSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	return 0
}

func tmpDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	return 0
}

func fsClose1(tls *libc.TLS, pFile uintptr) int32 {
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal

	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef--

	if (*fs_real_file)(unsafe.Pointer(pReal)).FnRef == 0 {
		*(*uintptr)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FppThis)) = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
		if (*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0 {
			(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = (*fs_real_file)(unsafe.Pointer(pReal)).FppThis
		}
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods)).FxClose})).f(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
		sqlite3.Xsqlite3_free(tls, pReal)
	}

	return rc
}

func fsRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE && sqlite_int64(iAmt)+iOfst > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) ||
		(*fs_file)(unsafe.Pointer(p)).FeType == JOURNAL_FILE && sqlite_int64(iAmt)+iOfst > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) {
		rc = SQLITE_IOERR | int32(2)<<8
	} else if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxRead})).f(tls, pF, zBuf, iAmt, iOfst+int64(BLOCKSIZE))
	} else {
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for iRem > 0 && rc == SQLITE_OK {
			var iRealOff int32 = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - BLOCKSIZE*(ii/BLOCKSIZE+1) + ii%BLOCKSIZE
			var iRealAmt int32 = func() int32 {
				if iRem < BLOCKSIZE-iRealOff%BLOCKSIZE {
					return iRem
				}
				return BLOCKSIZE - iRealOff%BLOCKSIZE
			}()

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxRead})).f(tls, pF, zBuf+uintptr(iBuf), iRealAmt, int64(iRealOff))
			ii = ii + iRealAmt
			iBuf = iBuf + iRealAmt
			iRem = iRem - iRealAmt
		}
	}

	return rc
}

func fsWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		if sqlite_int64(iAmt)+iOfst+int64(BLOCKSIZE) > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob-(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) {
			rc = SQLITE_FULL
		} else {
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxWrite})).f(tls, pF, zBuf, iAmt, iOfst+int64(BLOCKSIZE))
			if rc == SQLITE_OK {
				(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
					if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) > sqlite_int64(iAmt)+iOfst {
						return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
					}
					return int32(sqlite_int64(iAmt) + iOfst)
				}()
			}
		}
	} else {
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for iRem > 0 && rc == SQLITE_OK {
			var iRealOff int32 = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - BLOCKSIZE*(ii/BLOCKSIZE+1) + ii%BLOCKSIZE
			var iRealAmt int32 = func() int32 {
				if iRem < BLOCKSIZE-iRealOff%BLOCKSIZE {
					return iRem
				}
				return BLOCKSIZE - iRealOff%BLOCKSIZE
			}()

			if iRealOff < (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase+BLOCKSIZE {
				rc = SQLITE_FULL
			} else {
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxWrite})).f(tls, pF, zBuf+uintptr(iBuf), iRealAmt, int64(iRealOff))
				ii = ii + iRealAmt
				iBuf = iBuf + iRealAmt
				iRem = iRem - iRealAmt
			}
		}
		if rc == SQLITE_OK {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
				if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) > sqlite_int64(iAmt)+iOfst {
					return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
				}
				return int32(sqlite_int64(iAmt) + iOfst)
			}()
		}
	}

	return rc
}

func fsTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
			if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) < size {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
			}
			return int32(size)
		}()
	} else {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
			if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) < size {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
			}
			return int32(size)
		}()
	}
	return SQLITE_OK
}

func fsSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pRealFile uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
	var rc int32 = SQLITE_OK

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		*(*uint8)(unsafe.Pointer(bp)) = uint8(uint32((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) & 0xFF000000 >> 24)
		*(*uint8)(unsafe.Pointer(bp + 1)) = uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x00FF0000 >> 16)
		*(*uint8)(unsafe.Pointer(bp + 2)) = uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x0000FF00 >> 8)
		*(*uint8)(unsafe.Pointer(bp + 3)) = uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x000000FF)
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxWrite})).f(tls, pRealFile, bp, 4, int64(0))
	}
	if rc == SQLITE_OK {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxSync})).f(tls, pRealFile, flags&libc.CplInt32(SQLITE_SYNC_DATAONLY))
	}

	return rc
}

func fsFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)
	}
	return SQLITE_OK
}

func fsLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	return SQLITE_OK
}

func fsUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	return SQLITE_OK
}

func fsCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return SQLITE_OK
}

func fsFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	if op == SQLITE_FCNTL_PRAGMA {
		return SQLITE_NOTFOUND
	}
	return SQLITE_OK
}

func fsSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	return BLOCKSIZE
}

func fsDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	return 0
}

func fsOpen1(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pFsVfs uintptr
	var p uintptr
	var pReal uintptr
	var eType int32
	var nName int32
	var rc int32
	var p2 uintptr

	var real_flags int32

	var pRealFile uintptr
	var pParent uintptr
	pFsVfs = pVfs
	p = pFile
	pReal = uintptr(0)
	rc = SQLITE_OK

	if !(0 == flags&(SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_MAIN_JOURNAL)) {
		goto __1
	}
	p2 = pFile
	libc.Xmemset(tls, p2, 0, uint32(unsafe.Sizeof(tmp_file{})))
	(*tmp_file)(unsafe.Pointer(p2)).Fbase.FpMethods = uintptr(unsafe.Pointer(&tmp_io_methods))
	return SQLITE_OK
__1:
	;
	eType = func() int32 {
		if flags&SQLITE_OPEN_MAIN_DB != 0 {
			return DATABASE_FILE
		}
		return JOURNAL_FILE
	}()
	(*fs_file)(unsafe.Pointer(p)).Fbase.FpMethods = uintptr(unsafe.Pointer(&fs_io_methods))
	(*fs_file)(unsafe.Pointer(p)).FeType = eType

	nName = int32(libc.Xstrlen(tls, zName)) - func() int32 {
		if eType == JOURNAL_FILE {
			return 8
		}
		return 0
	}()
	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
__2:
	if !(pReal != 0 && libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zName, uint32(nName)) != 0) {
		goto __4
	}
	goto __3
__3:
	pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
	goto __2
	goto __4
__4:
	;
	if !!(pReal != 0) {
		goto __5
	}
	real_flags = flags&libc.CplInt32(SQLITE_OPEN_MAIN_DB) | SQLITE_OPEN_TEMP_DB
	pParent = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpParent

	pReal = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(fs_real_file{}))+uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)))
	if !!(pReal != 0) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto open_out
__6:
	;
	libc.Xmemset(tls, pReal, 0, uint32(unsafe.Sizeof(fs_real_file{}))+uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile))
	(*fs_real_file)(unsafe.Pointer(pReal)).FzName = zName
	(*fs_real_file)(unsafe.Pointer(pReal)).FpFile = pReal + 1*32

	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxOpen})).f(tls, pParent, zName, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile, real_flags, pOutFlags)
	if !(rc != SQLITE_OK) {
		goto __7
	}
	goto open_out
__7:
	;
	pRealFile = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxFileSize})).f(tls, pRealFile, bp)
	if !(rc != SQLITE_OK) {
		goto __8
	}
	goto open_out
__8:
	;
	if !(*(*sqlite3_int64)(unsafe.Pointer(bp)) == int64(0)) {
		goto __9
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxWrite})).f(tls, pRealFile, ts+40146, 1, int64(BLOBSIZE-1))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = BLOBSIZE
	goto __10
__9:
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = int32(*(*sqlite3_int64)(unsafe.Pointer(bp)))
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxRead})).f(tls, pRealFile, bp+8, 4, int64(0))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = int32(*(*uint8)(unsafe.Pointer(bp + 8)))<<24 + int32(*(*uint8)(unsafe.Pointer(bp + 8 + 1)))<<16 + int32(*(*uint8)(unsafe.Pointer(bp + 8 + 2)))<<8 + int32(*(*uint8)(unsafe.Pointer(bp + 8 + 3)))
	if !(rc == SQLITE_OK) {
		goto __11
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxRead})).f(tls, pRealFile, bp+8, 4, int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob-4))
	if !(*(*uint8)(unsafe.Pointer(bp + 8)) != 0 || *(*uint8)(unsafe.Pointer(bp + 8 + 1)) != 0 || *(*uint8)(unsafe.Pointer(bp + 8 + 2)) != 0 || *(*uint8)(unsafe.Pointer(bp + 8 + 3)) != 0) {
		goto __12
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob
__12:
	;
__11:
	;
__10:
	;
	if !(rc == SQLITE_OK) {
		goto __13
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FpNext = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	if !((*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0) {
		goto __14
	}
	(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = pReal + 24
__14:
	;
	(*fs_real_file)(unsafe.Pointer(pReal)).FppThis = pFsVfs + 88
	(*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList = pReal
__13:
	;
__5:
	;
open_out:
	if !(pReal != 0) {
		goto __15
	}
	if !(rc == SQLITE_OK) {
		goto __16
	}
	(*fs_file)(unsafe.Pointer(p)).FpReal = pReal
	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef++
	goto __17
__16:
	if !((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods != 0) {
		goto __18
	}
	(*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods)).FxClose})).f(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
__18:
	;
	sqlite3.Xsqlite3_free(tls, pReal)
__17:
	;
__15:
	;
	return rc
}

func fsDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 {
	var rc int32 = SQLITE_OK
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var pF uintptr
	var nName int32 = int32(libc.Xstrlen(tls, zPath)) - 8

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; pReal != 0 && libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint32(nName)) != 0; pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}
	if pReal != 0 {
		pF = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxWrite})).f(tls, pF, ts+40148, 4, int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob-BLOCKSIZE))
		if rc == SQLITE_OK {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = 0
		}
	}
	return rc
}

func fsAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var isJournal int32 = 0
	var nName int32 = int32(libc.Xstrlen(tls, zPath))

	if flags != SQLITE_ACCESS_EXISTS {
		var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxAccess})).f(tls, pParent, zPath, flags, pResOut)
	}

	if nName > 8 && libc.Xstrcmp(tls, ts+37436, zPath+uintptr(nName-8)) == 0 {
		nName = nName - 8
		isJournal = 1
	}

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; pReal != 0 && libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint32(nName)) != 0; pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}

	*(*int32)(unsafe.Pointer(pResOut)) = libc.Bool32(pReal != 0 && (!(isJournal != 0) || (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal > 0))
	return SQLITE_OK
}

func fsFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxFullPathname})).f(tls, pParent, zPath, nOut, zOut)
}

func fsDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlOpen})).f(tls, pParent, zPath)
}

func fsDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlError})).f(tls, pParent, nByte, zErrMsg)
}

func fsDlSym(tls *libc.TLS, pVfs uintptr, pH uintptr, zSym uintptr) uintptr {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlSym})).f(tls, pParent, pH, zSym)
}

func fsDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlClose})).f(tls, pParent, pHandle)
}

func fsRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxRandomness})).f(tls, pParent, nByte, zBufOut)
}

func fsSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxSleep})).f(tls, pParent, nMicro)
}

func fsCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxCurrentTime})).f(tls, pParent, pTimeOut)
}

func fs_register(tls *libc.TLS) int32 {
	if fs_vfs.FpParent != 0 {
		return SQLITE_OK
	}
	fs_vfs.FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	fs_vfs.Fbase.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(fs_vfs.FpParent)).FmxPathname
	fs_vfs.Fbase.FszOsFile = func() int32 {
		if uint32(unsafe.Sizeof(tmp_file{})) > uint32(unsafe.Sizeof(fs_file{})) {
			return int32(unsafe.Sizeof(tmp_file{}))
		}
		return int32(unsafe.Sizeof(fs_file{}))
	}()
	return sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&fs_vfs)), 0)
}

func SqlitetestOnefile_Init(tls *libc.TLS) int32 {
	return fs_register(tls)
}

type VfslogVfs1 = struct {
	Fbase        sqlite3_vfs
	FpVfs        uintptr
	FiNextFileId int32
	FpLog        uintptr
	FiOffset     sqlite3_int64
	FnBuf        int32
	FaBuf        [8192]int8
}

type VfslogVfs = VfslogVfs1
type VfslogFile1 = struct {
	Fbase    sqlite3_file
	FpReal   uintptr
	FpVfslog uintptr
	FiFileId int32
}

type VfslogFile = VfslogFile1

var vfslog_vfs = sqlite3_vfs{
	FiVersion:          1,
	FszOsFile:          int32(unsafe.Sizeof(VfslogFile{})),
	FmxPathname:        INST_MAX_PATHNAME,
	FxOpen:             0,
	FxDelete:           0,
	FxAccess:           0,
	FxFullPathname:     0,
	FxDlOpen:           0,
	FxDlError:          0,
	FxDlSym:            0,
	FxDlClose:          0,
	FxRandomness:       0,
	FxSleep:            0,
	FxCurrentTime:      0,
	FxGetLastError:     0,
	FxCurrentTimeInt64: 0,
}

var vfslog_io_methods = sqlite3_io_methods{
	FiVersion:               2,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
}

func vfslog_time(tls *libc.TLS) sqlite3_uint64 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	libc.Xgettimeofday(tls, bp, uintptr(0))
	return sqlite3_uint64((*timeval)(unsafe.Pointer(bp)).Ftv_usec) + sqlite3_uint64((*timeval)(unsafe.Pointer(bp)).Ftv_sec)*uint64(1000000)
}

func vfslogClose(tls *libc.TLS, pFile uintptr) int32 {
	var t sqlite3_uint64
	var rc int32 = SQLITE_OK
	var p uintptr = pFile

	t = vfslog_time(tls)
	if (*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxClose})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	}
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_CLOSE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxRead})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_READ, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

func vfslogWrite(tls *libc.TLS, pFile uintptr, z uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxWrite})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, z, iAmt, iOfst)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_WRITE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

func vfslogTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxTruncate})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, size)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_TRUNCATE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(size))
	return rc
}

func vfslogSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxSync})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SYNC, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, flags, 0)
	return rc
}

func vfslogFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxFileSize})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pSize)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_FILESIZE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(*(*sqlite_int64)(unsafe.Pointer(pSize))))
	return rc
}

func vfslogLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxLock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_LOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

func vfslogUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxUnlock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_UNLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

func vfslogCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxCheckReservedLock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pResOut)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_CHECKRESERVEDLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, *(*int32)(unsafe.Pointer(pResOut)), 0)
	return rc
}

func vfslogFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pFile
	var rc int32 = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxFileControl})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, op, pArg)
	if op == SQLITE_FCNTL_VFSNAME && rc == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+40153, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

func vfslogSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxSectorSize})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SECTORSIZE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxDeviceCharacteristics})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_DEVCHAR, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmLock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmMap})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, pp)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMMAP, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmBarrier(tls *libc.TLS, pFile uintptr) {
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmBarrier})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMBARRIER, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), SQLITE_OK, 0, 0)
}

func vfslogShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmUnmap})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, deleteFlag)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMUNMAP, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	var pLog uintptr = pVfs

	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&vfslog_io_methods))
	(*VfslogFile)(unsafe.Pointer(p)).FpReal = p + 1*16
	(*VfslogFile)(unsafe.Pointer(p)).FpVfslog = pVfs
	(*VfslogFile)(unsafe.Pointer(p)).FiFileId = libc.PreIncInt32(&(*VfslogVfs)(unsafe.Pointer(pLog)).FiNextFileId, 1)

	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxOpen})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zName, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	t = vfslog_time(tls) - t

	vfslog_call(tls, pVfs, OS_OPEN, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	vfslog_string(tls, pVfs, zName)
	return rc
}

func vfslogDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 {
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDelete})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, dirSync)
	t = vfslog_time(tls) - t
	vfslog_call(tls, pVfs, OS_DELETE, 0, int64(t), rc, dirSync, 0)
	vfslog_string(tls, pVfs, zPath)
	return rc
}

func vfslogAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxAccess})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, flags, pResOut)
	t = vfslog_time(tls) - t
	vfslog_call(tls, pVfs, OS_ACCESS, 0, int64(t), rc, flags, *(*int32)(unsafe.Pointer(pResOut)))
	vfslog_string(tls, pVfs, zPath)
	return rc
}

func vfslogFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxFullPathname})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, nOut, zOut)
}

func vfslogDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlOpen})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath)
}

func vfslogDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlError})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zErrMsg)
}

func vfslogDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlSym})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p, zSym)
}

func vfslogDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) {
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlClose})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pHandle)
}

func vfslogRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxRandomness})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zBufOut)
}

func vfslogSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxSleep})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nMicro)
}

func vfslogCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxCurrentTime})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pTimeOut)
}

func vfslogGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxGetLastError})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, a, b)
}

func vfslogCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxCurrentTimeInt64})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p)
}

func vfslog_flush(tls *libc.TLS, p uintptr) {
	var pending int32 = libc.AtomicLoadInt32(&sqlite3.Xsqlite3_io_error_pending)
	var persist int32 = sqlite3.Xsqlite3_io_error_persist
	var diskfull int32 = sqlite3.Xsqlite3_diskfull_pending

	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(0))
	sqlite3.Xsqlite3_io_error_persist = 0
	sqlite3.Xsqlite3_diskfull_pending = 0

	if (*VfslogVfs)(unsafe.Pointer(p)).FnBuf != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods)).FxWrite})).f(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, p+112, (*VfslogVfs)(unsafe.Pointer(p)).FnBuf, (*VfslogVfs)(unsafe.Pointer(p)).FiOffset)
		*(*sqlite3_int64)(unsafe.Pointer(p + 100)) += sqlite3_int64((*VfslogVfs)(unsafe.Pointer(p)).FnBuf)
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 0
	}

	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, pending)
	sqlite3.Xsqlite3_io_error_persist = persist
	sqlite3.Xsqlite3_diskfull_pending = diskfull
}

func put32bits(tls *libc.TLS, p uintptr, v uint32) {
	*(*uint8)(unsafe.Pointer(p)) = uint8(v >> 24)
	*(*uint8)(unsafe.Pointer(p + 1)) = uint8(v >> 16)
	*(*uint8)(unsafe.Pointer(p + 2)) = uint8(v >> 8)
	*(*uint8)(unsafe.Pointer(p + 3)) = uint8(v)
}

func vfslog_call(tls *libc.TLS, pVfs uintptr, eEvent int32, iFileid int32, nClick sqlite3_int64, return_code int32, size int32, offset int32) {
	var p uintptr = pVfs
	var zRec uintptr
	if uint32(24+(*VfslogVfs)(unsafe.Pointer(p)).FnBuf) > uint32(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = p + 112 + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf)
	put32bits(tls, zRec, uint32(eEvent))
	put32bits(tls, zRec+4, uint32(iFileid))
	put32bits(tls, zRec+8, uint32(nClick&int64(0xffff)))
	put32bits(tls, zRec+12, uint32(return_code))
	put32bits(tls, zRec+16, uint32(size))
	put32bits(tls, zRec+20, uint32(offset))
	*(*int32)(unsafe.Pointer(p + 108)) += 24
}

func vfslog_string(tls *libc.TLS, pVfs uintptr, zStr uintptr) {
	var p uintptr = pVfs
	var zRec uintptr
	var nStr int32
	if zStr != 0 {
		nStr = int32(libc.Xstrlen(tls, zStr))
	} else {
		nStr = 0
	}
	if uint32(4+nStr+(*VfslogVfs)(unsafe.Pointer(p)).FnBuf) > uint32(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = p + 112 + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf)
	put32bits(tls, zRec, uint32(nStr))
	if zStr != 0 {
		libc.Xmemcpy(tls, zRec+4, zStr, uint32(nStr))
	}
	*(*int32)(unsafe.Pointer(p + 108)) += 4 + nStr
}

func vfslog_finalize(tls *libc.TLS, p uintptr) {
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods != 0 {
		vfslog_flush(tls, p)
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods)).FxClose})).f(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func sqlite3_vfslog_finalize(tls *libc.TLS, zVfs uintptr) int32 {
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen})) {
		return SQLITE_ERROR
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, pVfs)
	vfslog_finalize(tls, pVfs)
	return SQLITE_OK
}

func sqlite3_vfslog_new(tls *libc.TLS, zVfs uintptr, zParentVfs uintptr, zLog uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var pParent uintptr
	var nByte int32

	var rc int32
	var zFile uintptr
	var nVfs int32

	pParent = sqlite3.Xsqlite3_vfs_find(tls, zParentVfs)
	if !(pParent != 0) {
		return SQLITE_ERROR
	}

	nVfs = int32(libc.Xstrlen(tls, zVfs))
	nByte = int32(uint32(unsafe.Sizeof(VfslogVfs{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile) + uint32(nVfs) + uint32(1) + uint32((*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname) + uint32(1))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	libc.Xmemset(tls, p, 0, uint32(nByte))

	(*VfslogVfs)(unsafe.Pointer(p)).FpVfs = pParent
	(*VfslogVfs)(unsafe.Pointer(p)).FpLog = p + 1*8304
	libc.Xmemcpy(tls, p, uintptr(unsafe.Pointer(&vfslog_vfs)), uint32(unsafe.Sizeof(sqlite3_vfs{})))
	(*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName = (*VfslogVfs)(unsafe.Pointer(p)).FpLog + uintptr((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)
	*(*int32)(unsafe.Pointer(p + 4)) += (*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile
	libc.Xmemcpy(tls, (*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName, zVfs, uint32(nVfs))

	zFile = (*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName + uintptr(nVfs+1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxFullPathname})).f(tls, pParent, zLog, (*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname, zFile)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_SUPER_JOURNAL
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDelete})).f(tls, pParent, zFile, 0)
	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxOpen})).f(tls, pParent, zFile, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, *(*int32)(unsafe.Pointer(bp)), bp)
	if rc == SQLITE_OK {
		libc.Xmemcpy(tls, p+112, ts+40163, uint32(20))
		(*VfslogVfs)(unsafe.Pointer(p)).FiOffset = int64(0)
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 20
		rc = sqlite3.Xsqlite3_vfs_register(tls, p, 1)
	}
	if rc != 0 {
		vfslog_finalize(tls, p)
	}
	return rc
}

func sqlite3_vfslog_annotate(tls *libc.TLS, zVfs uintptr, zMsg uintptr) int32 {
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen})) {
		return SQLITE_ERROR
	}
	vfslog_call(tls, pVfs, OS_ANNOTATE, 0, int64(0), 0, 0, 0)
	vfslog_string(tls, pVfs, zMsg)
	return SQLITE_OK
}

func vfslog_eventname(tls *libc.TLS, eEvent int32) uintptr {
	var zEvent uintptr = uintptr(0)

	switch eEvent {
	case OS_CLOSE:
		zEvent = ts + 40184
		break
	case OS_READ:
		zEvent = ts + 40191
		break
	case OS_WRITE:
		zEvent = ts + 40197
		break
	case OS_TRUNCATE:
		zEvent = ts + 40204
		break
	case OS_SYNC:
		zEvent = ts + 32466
		break
	case OS_FILESIZE:
		zEvent = ts + 40214
		break
	case OS_LOCK:
		zEvent = ts + 40224
		break
	case OS_UNLOCK:
		zEvent = ts + 40230
		break
	case OS_CHECKRESERVEDLOCK:
		zEvent = ts + 40238
		break
	case OS_FILECONTROL:
		zEvent = ts + 40252
		break
	case OS_SECTORSIZE:
		zEvent = ts + 40265
		break
	case OS_DEVCHAR:
		zEvent = ts + 40277
		break
	case OS_OPEN:
		zEvent = ts + 32044
		break
	case OS_DELETE:
		zEvent = ts + 40289
		break
	case OS_ACCESS:
		zEvent = ts + 40297
		break
	case OS_FULLPATHNAME:
		zEvent = ts + 40305
		break
	case OS_RANDOMNESS:
		zEvent = ts + 40319
		break
	case OS_SLEEP:
		zEvent = ts + 40331
		break
	case OS_CURRENTTIME:
		zEvent = ts + 40338
		break

	case OS_SHMUNMAP:
		zEvent = ts + 40351
		break
	case OS_SHMLOCK:
		zEvent = ts + 40361
		break
	case OS_SHMBARRIER:
		zEvent = ts + 40370
		break
	case OS_SHMMAP:
		zEvent = ts + 40382
		break

	case OS_ANNOTATE:
		zEvent = ts + 40390
		break
	}

	return zEvent
}

type VfslogVtab1 = struct {
	Fbase  sqlite3_vtab
	FpFd   uintptr
	FnByte sqlite3_int64
	FzFile uintptr
}

type VfslogVtab = VfslogVtab1
type VfslogCsr1 = struct {
	Fbase       sqlite3_vtab_cursor
	FiRowid     sqlite3_int64
	FiOffset    sqlite3_int64
	FzTransient uintptr
	FnFile      int32
	FazFile     uintptr
	FaBuf       [1024]uint8
}

type VfslogCsr = VfslogCsr1

func get32bits(tls *libc.TLS, p uintptr) uint32 {
	return uint32(int32(*(*uint8)(unsafe.Pointer(p)))<<24 + int32(*(*uint8)(unsafe.Pointer(p + 1)))<<16 + int32(*(*uint8)(unsafe.Pointer(p + 2)))<<8 + int32(*(*uint8)(unsafe.Pointer(p + 3))))
}

func dequote(tls *libc.TLS, z uintptr) {
	var quote int8
	quote = *(*int8)(unsafe.Pointer(z))
	if int32(quote) == '[' || int32(quote) == '\'' || int32(quote) == '"' || int32(quote) == '`' {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(quote) == '[' {
			quote = int8(']')
		}
		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(quote) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(quote) {
					break
				}
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = quote
				iIn = iIn + 2
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}
		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

func vlogConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pVfs uintptr

	var p uintptr
	var rc int32
	var nByte int32
	var zFile uintptr

	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nByte = int32(uint32(unsafe.Sizeof(VfslogVtab{})) + uint32((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile) + uint32((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	if p == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, p, 0, uint32(nByte))

	(*VfslogVtab)(unsafe.Pointer(p)).FpFd = p + 1*28
	(*VfslogVtab)(unsafe.Pointer(p)).FzFile = (*VfslogVtab)(unsafe.Pointer(p)).FpFd + uintptr((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile)

	zFile = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 3*4))))
	if !(zFile != 0) {
		sqlite3.Xsqlite3_free(tls, p)
		return SQLITE_NOMEM
	}
	dequote(tls, zFile)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxFullPathname})).f(tls, pVfs, zFile, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname, (*VfslogVtab)(unsafe.Pointer(p)).FzFile)
	sqlite3.Xsqlite3_free(tls, zFile)

	*(*int32)(unsafe.Pointer(bp + 8)) = SQLITE_OPEN_READWRITE | SQLITE_OPEN_SUPER_JOURNAL
	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen})).f(tls, pVfs, (*VfslogVtab)(unsafe.Pointer(p)).FzFile, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, *(*int32)(unsafe.Pointer(bp + 8)), bp+8)

	if rc == SQLITE_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxFileSize})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, p+16)
		sqlite3.Xsqlite3_declare_vtab(tls, db,
			ts+40401)
		*(*uintptr)(unsafe.Pointer(ppVtab)) = p
	} else {
		sqlite3.Xsqlite3_free(tls, p)
	}

	return rc
}

func vlogBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
	return SQLITE_OK
}

func vlogDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	var p uintptr = pVtab
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods != 0 {
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxClose})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd)
		(*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods = uintptr(0)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func vlogOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCsr uintptr

	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(VfslogCsr{})))
	if !(pCsr != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint32(unsafe.Sizeof(VfslogCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return SQLITE_OK
}

func vlogClose(tls *libc.TLS, pCursor uintptr) int32 {
	var p uintptr = pCursor
	var i int32
	for i = 0; i < (*VfslogCsr)(unsafe.Pointer(p)).FnFile; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(p)).FazFile + uintptr(i)*4)))
	}
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FazFile)
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FzTransient)
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func vlogNext(tls *libc.TLS, pCursor uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	var rc int32 = SQLITE_OK
	var nRead int32

	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = uintptr(0)

	nRead = 24
	if (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset+sqlite3_int64(nRead) <= (*VfslogVtab)(unsafe.Pointer(p)).FnByte {
		var eEvent int32
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxRead})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, pCsr+32, nRead, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset)

		eEvent = int32(get32bits(tls, pCsr+32))
		if rc == SQLITE_OK &&
			(eEvent == OS_OPEN || eEvent == OS_DELETE || eEvent == OS_ACCESS) {
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxRead})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, bp, 4, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset+sqlite3_int64(nRead))
			nRead = nRead + 4
			if rc == SQLITE_OK {
				var nStr int32 = int32(get32bits(tls, bp))
				var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, nStr+1)
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxRead})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, zStr, nStr, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset+sqlite3_int64(nRead))
				*(*int8)(unsafe.Pointer(zStr + uintptr(nStr))) = int8(0)
				nRead = nRead + nStr

				if eEvent == OS_OPEN {
					var iFileid int32 = int32(get32bits(tls, pCsr+32+4))
					if iFileid >= (*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile {
						var nNew int32 = int32(uint32(unsafe.Sizeof(uintptr(0))) * uint32(iFileid+1))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile = sqlite3.Xsqlite3_realloc(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile, nNew)
						nNew = int32(uint32(nNew) - uint32(unsafe.Sizeof(uintptr(0)))*uint32((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile))
						libc.Xmemset(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile+uintptr((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)*4, 0, uint32(nNew))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile = iFileid + 1
					}
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*4)))
					*(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*4)) = zStr
				} else {
					(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = zStr
				}
			}
		}
	}

	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 4)) += int64(1)
	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 12)) += sqlite3_int64(nRead)
	return rc
}

func vlogEof(tls *libc.TLS, pCursor uintptr) int32 {
	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	return libc.Bool32((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset >= (*VfslogVtab)(unsafe.Pointer(p)).FnByte)
}

func vlogFilter(tls *libc.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCsr uintptr = pCursor
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset = int64(20)
	return vlogNext(tls, pCursor)
}

func vlogColumn(tls *libc.TLS, pCursor uintptr, ctx uintptr, i int32) int32 {
	var val uint32
	var pCsr uintptr = pCursor

	val = get32bits(tls, pCsr+32+uintptr(4*i))

	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, vfslog_eventname(tls, int32(val)), -1, uintptr(0))
			break

		}
	case 1:
		{
			var zStr uintptr = (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient
			if val != uint32(0) && val < uint32((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile) {
				zStr = *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(val)*4))
			}
			sqlite3.Xsqlite3_result_text(tls, ctx, zStr, -1, libc.UintptrFromInt32(-1))
			break

		}
	default:
		sqlite3.Xsqlite3_result_int(tls, ctx, int32(val))
		break
	}

	return SQLITE_OK
}

func vlogRowid(tls *libc.TLS, pCursor uintptr, pRowid uintptr) int32 {
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid
	return SQLITE_OK
}

func sqlite3_vfslog_register(tls *libc.TLS, db uintptr) int32 {
	sqlite3.Xsqlite3_create_module(tls, db, ts+40456, uintptr(unsafe.Pointer(&vfslog_module)), uintptr(0))
	return SQLITE_OK
}

var vfslog_module = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func test_vfslog(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var db uintptr

	var rc int32 = SQLITE_ERROR

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37610)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), uintptr(unsafe.Pointer(&strs)), int32(unsafe.Sizeof(uintptr(0))), ts+2014, 0, bp+72) != 0 {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 72))) {
	case uint32(0):
		{
			var zVfs uintptr
			var zMsg uintptr
			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+40463)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			zMsg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			rc = sqlite3_vfslog_annotate(tls, zVfs, zMsg)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+40467, 0))
				return TCL_ERROR
			}
			break

		}
	case uint32(1):
		{
			var zVfs uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+40463)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			rc = sqlite3_vfslog_finalize(tls, zVfs)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+40467, 0))
				return TCL_ERROR
			}
			break

		}

	case uint32(2):
		{
			var zVfs uintptr
			var zParent uintptr
			var zLog uintptr
			if objc != 5 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+40474)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
			zLog = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
			if int32(*(*int8)(unsafe.Pointer(zParent))) == 0 {
				zParent = uintptr(0)
			}
			rc = sqlite3_vfslog_new(tls, zVfs, zParent, zLog)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+40467, 0))
				return TCL_ERROR
			}
			break

		}

	case uint32(3):
		{
			var zDb uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+2050)
				return TCL_ERROR
			}
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
			if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+76) != 0 {
				db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 76)).FobjClientData)).Fdb
				rc = sqlite3_vfslog_register(tls, db)
			}
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+40493, zDb, uintptr(0)))
				return TCL_ERROR
			}
			break

		}
	}

	return TCL_OK
}

var strs = [5]uintptr{ts + 40514, ts + 40523, ts + 18963, ts + 40532, uintptr(0)}

func SqlitetestOsinst_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+40456, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfslog})), uintptr(0), uintptr(0))
	return TCL_OK
}

type testpcacheGlobalType1 = struct {
	FpDummy        uintptr
	FnInstance     int32
	FdiscardChance uint32
	FprngSeed      uint32
	FhighStress    uint32
}

type testpcacheGlobalType = testpcacheGlobalType1

var testpcacheGlobal testpcacheGlobalType

func testpcacheInit(tls *libc.TLS, pArg uintptr) int32 {
	testpcacheGlobal.FpDummy = sqlite3.Xsqlite3_malloc(tls, 10)
	if testpcacheGlobal.FpDummy == uintptr(0) {
		return SQLITE_NOMEM
	}
	return SQLITE_OK
}

func testpcacheShutdown(tls *libc.TLS, pArg uintptr) {
	sqlite3.Xsqlite3_free(tls, testpcacheGlobal.FpDummy)
	testpcacheGlobal.FpDummy = uintptr(0)
}

type testpcache1 = struct {
	FszPage     int32
	FszExtra    int32
	FbPurgeable int32
	FnFree      int32
	FnPinned    int32
	FiRand      uint32
	FiMagic     uint32
	Fa          [217]struct {
		Fpage     sqlite3_pcache_page
		Fkey      uint32
		FisPinned int32
	}
}

type testpcache = testpcache1
type testpcachePage = struct {
	Fpage     sqlite3_pcache_page
	Fkey      uint32
	FisPinned int32
}

func testpcacheRandom(tls *libc.TLS, p uintptr) uint32 {
	var x uint32 = uint32(0)
	var i int32
	for i = 0; i < 4; i++ {
		(*testpcache)(unsafe.Pointer(p)).FiRand = (*testpcache)(unsafe.Pointer(p)).FiRand*uint32(69069) + uint32(5)
		x = x<<8 | (*testpcache)(unsafe.Pointer(p)).FiRand>>16&uint32(0xff)
	}
	return x
}

func testpcacheCreate(tls *libc.TLS, szPage int32, szExtra int32, bPurgeable int32) uintptr {
	var nMem int32
	var x uintptr
	var p uintptr
	var i int32

	szPage = (szPage + 7) & libc.CplInt32(7)
	nMem = int32(uint32(unsafe.Sizeof(testpcache{})) + uint32(TESTPCACHE_NPAGE*(szPage+szExtra)))
	p = sqlite3.Xsqlite3_malloc(tls, nMem)
	if p == uintptr(0) {
		return uintptr(0)
	}
	x = p + 1*3500
	(*testpcache)(unsafe.Pointer(p)).FszPage = szPage
	(*testpcache)(unsafe.Pointer(p)).FszExtra = szExtra
	(*testpcache)(unsafe.Pointer(p)).FnFree = TESTPCACHE_NPAGE
	(*testpcache)(unsafe.Pointer(p)).FnPinned = 0
	(*testpcache)(unsafe.Pointer(p)).FiRand = testpcacheGlobal.FprngSeed
	(*testpcache)(unsafe.Pointer(p)).FbPurgeable = bPurgeable
	(*testpcache)(unsafe.Pointer(p)).FiMagic = uint32(TESTPCACHE_VALID)
	i = 0
__1:
	if !(i < TESTPCACHE_NPAGE) {
		goto __3
	}
	{
		(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).Fkey = uint32(0)
		(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).FisPinned = 0
		(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).Fpage.FpBuf = x
		(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).Fpage.FpExtra = x + uintptr(szPage)

	}
	goto __2
__2:
	i++
	x += uintptr(szPage + szExtra)
	goto __1
	goto __3
__3:
	;
	testpcacheGlobal.FnInstance++
	return p
}

func testpcacheCachesize(tls *libc.TLS, pCache uintptr, newSize int32) {
	var p uintptr = pCache
	_ = p

}

func testpcachePagecount(tls *libc.TLS, pCache uintptr) int32 {
	var p uintptr = pCache

	return TESTPCACHE_NPAGE - (*testpcache)(unsafe.Pointer(p)).FnFree
}

func testpcacheFetch(tls *libc.TLS, pCache uintptr, key uint32, createFlag int32) uintptr {
	var p uintptr = pCache
	var i int32
	var j int32

	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer(p+28+uintptr(i)*16)).Fkey == key {
			if !((*testpcachePage)(unsafe.Pointer(p+28+uintptr(i)*16)).FisPinned != 0) {
				(*testpcache)(unsafe.Pointer(p)).FnPinned++

				(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).FisPinned = 1
			}
			return p + 28 + uintptr(i)*16
		}
	}

	if createFlag == 0 {
		return uintptr(0)
	}

	if (*testpcache)(unsafe.Pointer(p)).FnPinned == TESTPCACHE_NPAGE {
		return uintptr(0)
	}

	if (*testpcache)(unsafe.Pointer(p)).FnPinned >= TESTPCACHE_NPAGE-TESTPCACHE_RESERVE && createFlag < 2 {
		return uintptr(0)
	}

	if testpcacheGlobal.FhighStress != 0 && createFlag < 2 {
		return uintptr(0)
	}

	if (*testpcache)(unsafe.Pointer(p)).FnFree > TESTPCACHE_RESERVE || createFlag == 2 && (*testpcache)(unsafe.Pointer(p)).FnFree > 0 {
		j = int32(testpcacheRandom(tls, p) % uint32(TESTPCACHE_NPAGE))
		i = 0
	__1:
		if !(i < TESTPCACHE_NPAGE) {
			goto __3
		}
		{
			if (*testpcachePage)(unsafe.Pointer(p+28+uintptr(j)*16)).Fkey == uint32(0) {
				(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(j)*16)).Fkey = key
				(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(j)*16)).FisPinned = 1
				libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+28+uintptr(j)*16)).Fpage.FpBuf, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszPage))
				libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+28+uintptr(j)*16)).Fpage.FpExtra, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszExtra))
				(*testpcache)(unsafe.Pointer(p)).FnPinned++
				(*testpcache)(unsafe.Pointer(p)).FnFree--

				return p + 28 + uintptr(j)*16
			}

		}
		goto __2
	__2:
		i++
		j = (j + 1) % TESTPCACHE_NPAGE
		goto __1
		goto __3
	__3:
	}

	if (*testpcache)(unsafe.Pointer(p)).FbPurgeable == 0 {
		return uintptr(0)
	}

	j = int32(testpcacheRandom(tls, p) % uint32(TESTPCACHE_NPAGE))
	i = 0
__4:
	if !(i < TESTPCACHE_NPAGE) {
		goto __6
	}
	{
		if (*testpcachePage)(unsafe.Pointer(p+28+uintptr(j)*16)).Fkey > uint32(0) && (*testpcachePage)(unsafe.Pointer(p+28+uintptr(j)*16)).FisPinned == 0 {
			(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(j)*16)).Fkey = key
			(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(j)*16)).FisPinned = 1
			libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+28+uintptr(j)*16)).Fpage.FpBuf, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszPage))
			libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+28+uintptr(j)*16)).Fpage.FpExtra, 0, uint32((*testpcache)(unsafe.Pointer(p)).FszExtra))
			(*testpcache)(unsafe.Pointer(p)).FnPinned++

			return p + 28 + uintptr(j)*16
		}

	}
	goto __5
__5:
	i++
	j = (j + 1) % TESTPCACHE_NPAGE
	goto __4
	goto __6
__6:
	;
	return uintptr(0)
}

func testpcacheUnpin(tls *libc.TLS, pCache uintptr, pOldPage uintptr, discard int32) {
	var p uintptr = pCache
	var i int32

	if (*testpcache)(unsafe.Pointer(p)).FbPurgeable != 0 &&
		uint32(100)-testpcacheGlobal.FdiscardChance <= testpcacheRandom(tls, p)%uint32(100) {
		discard = 1
	}

	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if p+28+uintptr(i)*16 == pOldPage {
			(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).FisPinned = 0
			(*testpcache)(unsafe.Pointer(p)).FnPinned--

			if discard != 0 {
				(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).Fkey = uint32(0)
				(*testpcache)(unsafe.Pointer(p)).FnFree++

			}
			return
		}
	}

}

func testpcacheRekey(tls *libc.TLS, pCache uintptr, pOldPage uintptr, oldKey uint32, newKey uint32) {
	var p uintptr = pCache
	var i int32

	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer(p+28+uintptr(i)*16)).Fkey == newKey {
			(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).Fkey = uint32(0)
			(*testpcache)(unsafe.Pointer(p)).FnFree++

			break
		}
	}

	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer(p+28+uintptr(i)*16)).Fkey == oldKey {
			(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).Fkey = newKey
			return
		}
	}

}

func testpcacheTruncate(tls *libc.TLS, pCache uintptr, iLimit uint32) {
	var p uintptr = pCache
	var i uint32

	for i = uint32(0); i < uint32(TESTPCACHE_NPAGE); i++ {
		if (*testpcachePage)(unsafe.Pointer(p+28+uintptr(i)*16)).Fkey >= iLimit {
			(*testpcachePage)(unsafe.Pointer(p + 28 + uintptr(i)*16)).Fkey = uint32(0)
			if (*testpcachePage)(unsafe.Pointer(p+28+uintptr(i)*16)).FisPinned != 0 {
				(*testpcache)(unsafe.Pointer(p)).FnPinned--

			}
			(*testpcache)(unsafe.Pointer(p)).FnFree++

		}
	}
}

func testpcacheDestroy(tls *libc.TLS, pCache uintptr) {
	var p uintptr = pCache

	(*testpcache)(unsafe.Pointer(p)).FiMagic = TESTPCACHE_CLEAR
	sqlite3.Xsqlite3_free(tls, p)
	testpcacheGlobal.FnInstance--
}

func installTestPCache(tls *libc.TLS, installFlag int32, discardChance uint32, prngSeed uint32, highStress uint32) {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	testpcacheGlobal.FdiscardChance = discardChance
	testpcacheGlobal.FprngSeed = prngSeed ^ prngSeed<<16
	testpcacheGlobal.FhighStress = highStress
	if installFlag != isInstalled {
		if installFlag != 0 {
			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETPCACHE2, libc.VaList(bp, uintptr(unsafe.Pointer(&defaultPcache))))

			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+8, uintptr(unsafe.Pointer(&testPcache))))
		} else {
			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+16, uintptr(unsafe.Pointer(&defaultPcache))))
		}
		isInstalled = installFlag
	}
}

var testPcache = sqlite3_pcache_methods2{
	FiVersion:   1,
	FpArg:       0,
	FxInit:      0,
	FxShutdown:  0,
	FxCreate:    0,
	FxCachesize: 0,
	FxPagecount: 0,
	FxFetch:     0,
	FxUnpin:     0,
	FxRekey:     0,
	FxTruncate:  0,
	FxDestroy:   0,
}
var defaultPcache sqlite3_pcache_methods2
var isInstalled int32 = 0

type quota_FILE1 = struct {
	Ff     uintptr
	FiOfst sqlite3_int64
	FpFile uintptr
}

type quota_FILE = quota_FILE1

type quotaGroup1 = struct {
	FzPattern  uintptr
	FiLimit    sqlite3_int64
	FiSize     sqlite3_int64
	FxCallback uintptr
	FpArg      uintptr
	FxDestroy  uintptr
	FpNext     uintptr
	FppPrev    uintptr
	FpFiles    uintptr
}

type quotaGroup = quotaGroup1
type quotaConn1 = struct {
	Fbase  sqlite3_file
	FpFile uintptr
}

type quotaConn = quotaConn1
type quotaFile1 = struct {
	FzFilename     uintptr
	FpGroup        uintptr
	FiSize         sqlite3_int64
	FnRef          int32
	FdeleteOnClose int32
	FpNext         uintptr
	FppPrev        uintptr
}

type quotaFile = quotaFile1

var gQuota struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
	FpMutex        uintptr
	FpGroup        uintptr
}

func quotaEnter(tls *libc.TLS) {
	sqlite3.Xsqlite3_mutex_enter(tls, gQuota.FpMutex)
}

func quotaLeave(tls *libc.TLS) {
	sqlite3.Xsqlite3_mutex_leave(tls, gQuota.FpMutex)
}

func quotaGroupOpenFileCount(tls *libc.TLS, pGroup uintptr) int32 {
	var N int32 = 0
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for pFile != 0 {
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
			N++
		}
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	return N
}

func quotaRemoveFile(tls *libc.TLS, pFile uintptr) {
	var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
	*(*sqlite3_int64)(unsafe.Pointer(pGroup + 12)) -= (*quotaFile)(unsafe.Pointer(pFile)).FiSize
	*(*uintptr)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FppPrev)) = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	if (*quotaFile)(unsafe.Pointer(pFile)).FpNext != 0 {
		(*quotaFile)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpNext)).FppPrev = (*quotaFile)(unsafe.Pointer(pFile)).FppPrev
	}
	sqlite3.Xsqlite3_free(tls, pFile)
}

func quotaRemoveAllFiles(tls *libc.TLS, pGroup uintptr) {
	for (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {
		quotaRemoveFile(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)
	}
}

func quotaGroupDeref(tls *libc.TLS, pGroup uintptr) {
	if (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit == int64(0) && quotaGroupOpenFileCount(tls, pGroup) == 0 {
		quotaRemoveAllFiles(tls, pGroup)
		*(*uintptr)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev)) = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext != 0 {
			(*quotaGroup)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpNext)).FppPrev = (*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev
		}
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy})).f(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
		}
		sqlite3.Xsqlite3_free(tls, pGroup)
	}
}

func quotaStrglob(tls *libc.TLS, zGlob uintptr, z uintptr) int32 {
	var c int32
	var c2 int32
	var cx int32
	var invert int32
	var seen int32

	for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) != 0 {
		if c == '*' {
			for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) == '*' || c == '?' {
				if c == '?' && int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
					return 0
				}
			}
			if c == 0 {
				return 1
			} else if c == '[' {
				for *(*int8)(unsafe.Pointer(z)) != 0 && quotaStrglob(tls, zGlob-uintptr(1), z) == 0 {
					z++
				}
				return libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) != 0)
			}
			if c == '/' {
				cx = '\\'
			} else {
				cx = c
			}
			for libc.AssignInt32(&c2, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) != 0 {
				for c2 != c && c2 != cx {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
					if c2 == 0 {
						return 0
					}
				}
				if quotaStrglob(tls, zGlob, z) != 0 {
					return 1
				}
			}
			return 0
		} else if c == '?' {
			if int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
				return 0
			}
		} else if c == '[' {
			var prior_c int32 = 0
			seen = 0
			invert = 0
			c = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
			if c == 0 {
				return 0
			}
			c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			if c2 == '^' {
				invert = 1
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == ']' {
				if c == ']' {
					seen = 1
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			for c2 != 0 && c2 != ']' {
				if c2 == '-' && int32(*(*int8)(unsafe.Pointer(zGlob))) != ']' && int32(*(*int8)(unsafe.Pointer(zGlob))) != 0 && prior_c > 0 {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
					if c >= prior_c && c <= c2 {
						seen = 1
					}
					prior_c = 0
				} else {
					if c == c2 {
						seen = 1
					}
					prior_c = c2
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == 0 || seen^invert == 0 {
				return 0
			}
		} else if c == '/' {
			if int32(*(*int8)(unsafe.Pointer(z))) != '/' && int32(*(*int8)(unsafe.Pointer(z))) != '\\' {
				return 0
			}
			z++
		} else {
			if c != int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) {
				return 0
			}
		}
	}
	return libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) == 0)
}

func quotaGroupFind(tls *libc.TLS, zFilename uintptr) uintptr {
	var p uintptr
	for p = gQuota.FpGroup; p != 0 && quotaStrglob(tls, (*quotaGroup)(unsafe.Pointer(p)).FzPattern, zFilename) == 0; p = (*quotaGroup)(unsafe.Pointer(p)).FpNext {
	}
	return p
}

func quotaSubOpen(tls *libc.TLS, pConn uintptr) uintptr {
	var p uintptr = pConn
	return p + 1*8
}

func quotaFindFile(tls *libc.TLS, pGroup uintptr, zName uintptr, createFlag int32) uintptr {
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for pFile != 0 && libc.Xstrcmp(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName) != 0 {
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	if pFile == uintptr(0) && createFlag != 0 {
		var nName int32 = int32(libc.Xstrlen(tls, zName) & size_t(0x3fffffff))
		pFile = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(quotaFile{}))+uint32(nName)+uint32(1)))
		if pFile != 0 {
			libc.Xmemset(tls, pFile, 0, uint32(unsafe.Sizeof(quotaFile{})))
			(*quotaFile)(unsafe.Pointer(pFile)).FzFilename = pFile + 1*32
			libc.Xmemcpy(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName, uint32(nName+1))
			(*quotaFile)(unsafe.Pointer(pFile)).FpNext = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {
				(*quotaFile)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)).FppPrev = pFile + 24
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FppPrev = pGroup + 40
			(*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles = pFile
			(*quotaFile)(unsafe.Pointer(pFile)).FpGroup = pGroup
		}
	}
	return pFile
}

func quota_utf8_to_mbcs(tls *libc.TLS, zUtf8 uintptr) uintptr {
	return zUtf8
}

func quota_mbcs_free(tls *libc.TLS, zOld uintptr) {
}

func quotaOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 {
	var rc int32
	var pQuotaOpen uintptr
	var pFile uintptr
	var pGroup uintptr
	var pSubOpen uintptr
	var pOrigVfs uintptr = gQuota.FpOrigVfs

	if flags&(SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_WAL) == 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	}

	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zName)
	if pGroup == uintptr(0) {
		rc = (*struct {
			f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	} else {
		pQuotaOpen = pConn
		pSubOpen = quotaSubOpen(tls, pConn)
		rc = (*struct {
			f func(*libc.TLS, uintptr, sqlite3_filename, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, zName, pSubOpen, flags, pOutFlags)
		if rc == SQLITE_OK {
			pFile = quotaFindFile(tls, pGroup, zName, 1)
			if pFile == uintptr(0) {
				quotaLeave(tls)
				(*struct {
					f func(*libc.TLS, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxClose})).f(tls, pSubOpen)
				return SQLITE_NOMEM
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = libc.Bool32(flags&SQLITE_OPEN_DELETEONCLOSE != 0)
			(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
			(*quotaConn)(unsafe.Pointer(pQuotaOpen)).FpFile = pFile
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = uintptr(unsafe.Pointer(&gQuota)) + 92
			} else {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = uintptr(unsafe.Pointer(&gQuota)) + 168
			}
		}
	}
	quotaLeave(tls)
	return rc
}

func quotaDelete(tls *libc.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 {
	var rc int32
	var pFile uintptr
	var pGroup uintptr
	var pOrigVfs uintptr = gQuota.FpOrigVfs

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, zName, syncDir)

	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = quotaGroupFind(tls, zName)
		if pGroup != 0 {
			pFile = quotaFindFile(tls, pGroup, zName, 0)
			if pFile != 0 {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
		quotaLeave(tls)
	}
	return rc
}

func quotaClose(tls *libc.TLS, pConn uintptr) int32 {
	var p uintptr = pConn
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32
	rc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxClose})).f(tls, pSubOpen)
	quotaEnter(tls)
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
	if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxDelete})).f(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
			quotaRemoveFile(tls, pFile)
		}
		quotaGroupDeref(tls, pGroup)
	}
	quotaLeave(tls)
	return rc
}

func quotaRead(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxRead})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
}

func quotaWrite(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 {
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var iEnd sqlite3_int64 = iOfst + sqlite3_int64(iAmt)
	var pGroup uintptr
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var szNew sqlite3_int64

	if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd {
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize + iEnd
		if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback})).f(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, pGroup+4, szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
				quotaLeave(tls)
				return SQLITE_FULL
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxWrite})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
}

func quotaTruncate(tls *libc.TLS, pConn uintptr, size sqlite3_int64) int32 {
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, size)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 12)) -= (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = size
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 12)) += size
		quotaLeave(tls)
	}
	return rc
}

func quotaSync(tls *libc.TLS, pConn uintptr, flags int32) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSync})).f(tls, pSubOpen, flags)
}

func quotaFileSize(tls *libc.TLS, pConn uintptr, pSize uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr

	var rc int32

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileSize})).f(tls, pSubOpen, bp)
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 12)) -= (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = *(*sqlite3_int64)(unsafe.Pointer(bp))
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 12)) += *(*sqlite3_int64)(unsafe.Pointer(bp))
		quotaLeave(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = *(*sqlite3_int64)(unsafe.Pointer(bp))
	}
	return rc
}

func quotaLock(tls *libc.TLS, pConn uintptr, lock int32) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxLock})).f(tls, pSubOpen, lock)
}

func quotaUnlock(tls *libc.TLS, pConn uintptr, lock int32) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxUnlock})).f(tls, pSubOpen, lock)
}

func quotaCheckReservedLock(tls *libc.TLS, pConn uintptr, pResOut uintptr) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxCheckReservedLock})).f(tls, pSubOpen, pResOut)
}

func quotaFileControl(tls *libc.TLS, pConn uintptr, op int32, pArg uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileControl})).f(tls, pSubOpen, op, pArg)
	if op == SQLITE_FCNTL_VFSNAME && rc == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+40541, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

func quotaSectorSize(tls *libc.TLS, pConn uintptr) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize})).f(tls, pSubOpen)
}

func quotaDeviceCharacteristics(tls *libc.TLS, pConn uintptr) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxDeviceCharacteristics})).f(tls, pSubOpen)
}

func quotaShmMap(tls *libc.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmMap})).f(tls, pSubOpen, iRegion, szRegion, bExtend, pp)
}

func quotaShmLock(tls *libc.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmLock})).f(tls, pSubOpen, ofst, n, flags)
}

func quotaShmBarrier(tls *libc.TLS, pConn uintptr) {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmBarrier})).f(tls, pSubOpen)
}

func quotaShmUnmap(tls *libc.TLS, pConn uintptr, deleteFlag int32) int32 {
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmUnmap})).f(tls, pSubOpen, deleteFlag)
}

func sqlite3_quota_initialize(tls *libc.TLS, zOrigVfsName uintptr, makeDefault int32) int32 {
	var pOrigVfs uintptr
	if gQuota.FisInitialized != 0 {
		return SQLITE_MISUSE
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return SQLITE_ERROR
	}

	gQuota.FpMutex = sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_FAST)
	if !(int32(gQuota.FpMutex) != 0) {
		return SQLITE_NOMEM
	}
	gQuota.FisInitialized = 1
	gQuota.FpOrigVfs = pOrigVfs
	gQuota.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	gQuota.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{quotaOpen}))
	gQuota.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{quotaDelete}))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gQuota)) + 4 + 4)) += int32(uint32(unsafe.Sizeof(quotaConn{})))
	gQuota.FsThisVfs.FzName = ts + 40550
	gQuota.FsIoMethodsV1.FiVersion = 1
	gQuota.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaClose}))
	gQuota.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaRead}))
	gQuota.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaWrite}))
	gQuota.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	}{quotaTruncate}))
	gQuota.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaSync}))
	gQuota.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{quotaFileSize}))
	gQuota.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaLock}))
	gQuota.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaUnlock}))
	gQuota.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{quotaCheckReservedLock}))
	gQuota.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{quotaFileControl}))
	gQuota.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaSectorSize}))
	gQuota.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaDeviceCharacteristics}))
	gQuota.FsIoMethodsV2 = gQuota.FsIoMethodsV1
	gQuota.FsIoMethodsV2.FiVersion = 2
	gQuota.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{quotaShmMap}))
	gQuota.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	}{quotaShmLock}))
	gQuota.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{quotaShmBarrier}))
	gQuota.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&gQuota))+4, makeDefault)
	return SQLITE_OK
}

func sqlite3_quota_shutdown(tls *libc.TLS) int32 {
	var pGroup uintptr
	if gQuota.FisInitialized == 0 {
		return SQLITE_MISUSE
	}
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		if quotaGroupOpenFileCount(tls, pGroup) > 0 {
			return SQLITE_MISUSE
		}
	}
	for gQuota.FpGroup != 0 {
		pGroup = gQuota.FpGroup
		gQuota.FpGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = int64(0)

		quotaGroupDeref(tls, pGroup)
	}
	gQuota.FisInitialized = 0
	sqlite3.Xsqlite3_mutex_free(tls, gQuota.FpMutex)
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&gQuota))+4)
	libc.Xmemset(tls, uintptr(unsafe.Pointer(&gQuota)), 0, uint32(unsafe.Sizeof(gQuota)))
	return SQLITE_OK
}

func sqlite3_quota_set(tls *libc.TLS, zPattern uintptr, iLimit sqlite3_int64, xCallback uintptr, pArg uintptr, xDestroy uintptr) int32 {
	var pGroup uintptr
	quotaEnter(tls)
	pGroup = gQuota.FpGroup
	for pGroup != 0 && libc.Xstrcmp(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern) != 0 {
		pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
	}
	if pGroup == uintptr(0) {
		var nPattern int32 = int32(libc.Xstrlen(tls, zPattern) & size_t(0x3fffffff))
		if iLimit <= int64(0) {
			quotaLeave(tls)
			return SQLITE_OK
		}
		pGroup = sqlite3.Xsqlite3_malloc(tls, int32(uint32(unsafe.Sizeof(quotaGroup{}))+uint32(nPattern)+uint32(1)))
		if pGroup == uintptr(0) {
			quotaLeave(tls)
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pGroup, 0, uint32(unsafe.Sizeof(quotaGroup{})))
		(*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern = pGroup + 1*44
		libc.Xmemcpy(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern, uint32(nPattern+1))
		if gQuota.FpGroup != 0 {
			(*quotaGroup)(unsafe.Pointer(gQuota.FpGroup)).FppPrev = pGroup + 32
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FpNext = gQuota.FpGroup
		(*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev = uintptr(unsafe.Pointer(&gQuota)) + 252
		gQuota.FpGroup = pGroup
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = iLimit
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback = xCallback
	if (*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0 && (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg != pArg {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy})).f(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg = pArg
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy = xDestroy
	quotaGroupDeref(tls, pGroup)
	quotaLeave(tls)
	return SQLITE_OK
}

func sqlite3_quota_file(tls *libc.TLS, zFilename uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var zFull uintptr = uintptr(0)
	var fd uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp)) = 0

	var nAlloc int32 = gQuota.FsThisVfs.FszOsFile + gQuota.FsThisVfs.FmxPathname + 2

	fd = sqlite3.Xsqlite3_malloc(tls, nAlloc)
	if fd == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		zFull = fd + uintptr(gQuota.FsThisVfs.FszOsFile)
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxFullPathname})).f(tls, gQuota.FpOrigVfs, zFilename,
			gQuota.FsThisVfs.FmxPathname+1, zFull)
	}

	if rc == SQLITE_OK {
		*(*int8)(unsafe.Pointer(zFull + uintptr(libc.Xstrlen(tls, zFull)+size_t(1)))) = int8(0)
		rc = quotaOpen(tls, uintptr(unsafe.Pointer(&gQuota))+4, zFull, fd,
			SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_DB, bp)
		if rc == SQLITE_OK {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxFileSize})).f(tls, fd, bp+4)
			(*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxClose})).f(tls, fd)
		} else if rc == SQLITE_CANTOPEN {
			var pGroup uintptr
			var pFile uintptr
			quotaEnter(tls)
			pGroup = quotaGroupFind(tls, zFull)
			if pGroup != 0 {
				pFile = quotaFindFile(tls, pGroup, zFull, 0)
				if pFile != 0 {
					quotaRemoveFile(tls, pFile)
				}
			}
			quotaLeave(tls)
		}
	}

	sqlite3.Xsqlite3_free(tls, fd)
	return rc
}

func sqlite3_quota_fopen(tls *libc.TLS, zFilename uintptr, zMode uintptr) uintptr {
	var p uintptr
	var zFull uintptr
	var zFullTranslated uintptr
	var rc int32
	var pGroup uintptr
	var pFile uintptr
	p = uintptr(0)
	zFull = uintptr(0)
	zFullTranslated = uintptr(0)

	zFull = sqlite3.Xsqlite3_malloc(tls, gQuota.FsThisVfs.FmxPathname+1)
	if !(zFull == uintptr(0)) {
		goto __1
	}
	return uintptr(0)
__1:
	;
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxFullPathname})).f(tls, gQuota.FpOrigVfs, zFilename,
		gQuota.FsThisVfs.FmxPathname+1, zFull)
	if !(rc != 0) {
		goto __2
	}
	goto quota_fopen_error
__2:
	;
	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(quota_FILE{})))
	if !(p == uintptr(0)) {
		goto __3
	}
	goto quota_fopen_error
__3:
	;
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(quota_FILE{})))
	zFullTranslated = quota_utf8_to_mbcs(tls, zFull)
	if !(zFullTranslated == uintptr(0)) {
		goto __4
	}
	goto quota_fopen_error
__4:
	;
	(*quota_FILE)(unsafe.Pointer(p)).Ff = libc.Xfopen(tls, zFullTranslated, zMode)
	if !((*quota_FILE)(unsafe.Pointer(p)).Ff == uintptr(0)) {
		goto __5
	}
	goto quota_fopen_error
__5:
	;
	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if !(pGroup != 0) {
		goto __6
	}
	pFile = quotaFindFile(tls, pGroup, zFull, 1)
	if !(pFile == uintptr(0)) {
		goto __7
	}
	quotaLeave(tls)
	goto quota_fopen_error
__7:
	;
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
	(*quota_FILE)(unsafe.Pointer(p)).FpFile = pFile
__6:
	;
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return p

quota_fopen_error:
	quota_mbcs_free(tls, zFullTranslated)
	sqlite3.Xsqlite3_free(tls, zFull)
	if !(p != 0 && (*quota_FILE)(unsafe.Pointer(p)).Ff != 0) {
		goto __8
	}
	libc.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
__8:
	;
	sqlite3.Xsqlite3_free(tls, p)
	return uintptr(0)
}

func sqlite3_quota_fread(tls *libc.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t {
	return libc.Xfread(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

func sqlite3_quota_fwrite(tls *libc.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t {
	var iOfst sqlite3_int64
	var iEnd sqlite3_int64
	var szNew sqlite3_int64
	var pFile uintptr
	var rc size_t

	iOfst = sqlite3_int64(libc.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff))
	iEnd = iOfst + sqlite3_int64(size*nmemb)
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if pFile != 0 && (*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize + iEnd
		if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback})).f(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, pGroup+4, szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
				iEnd = (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit - (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize + (*quotaFile)(unsafe.Pointer(pFile)).FiSize
				nmemb = size_t((iEnd - iOfst) / sqlite3_int64(size))
				iEnd = iOfst + sqlite3_int64(size*nmemb)
				szNew = (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize + iEnd
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	} else {
		pFile = uintptr(0)
	}
	rc = libc.Xfwrite(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)

	if rc < nmemb && pFile != 0 {
		var nWritten size_t = rc
		var iNewEnd sqlite3_int64 = iOfst + sqlite3_int64(size*nWritten)
		if iNewEnd < iEnd {
			iNewEnd = iEnd
		}
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpGroup + 12)) += iNewEnd - (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iNewEnd
		quotaLeave(tls)
	}
	return rc
}

func sqlite3_quota_fclose(tls *libc.TLS, p uintptr) int32 {
	var rc int32
	var pFile uintptr
	rc = libc.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if pFile != 0 {
		quotaEnter(tls)
		(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
			var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
			if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, int32) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxDelete})).f(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
				quotaRemoveFile(tls, pFile)
			}
			quotaGroupDeref(tls, pGroup)
		}
		quotaLeave(tls)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return rc
}

func sqlite3_quota_fflush(tls *libc.TLS, p uintptr, doFsync int32) int32 {
	var rc int32
	rc = libc.Xfflush(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	if rc == 0 && doFsync != 0 {
		rc = libc.Xfsync(tls, func() int32 {
			if !(libc.X__isthreaded != 0) {
				return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
			}
			return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
		}())
	}
	return libc.Bool32(rc != 0)
}

func sqlite3_quota_fseek(tls *libc.TLS, p uintptr, offset int32, whence int32) int32 {
	return libc.Xfseek(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff, offset, whence)
}

func sqlite3_quota_rewind(tls *libc.TLS, p uintptr) {
	libc.Xrewind(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

func sqlite3_quota_ftell(tls *libc.TLS, p uintptr) int32 {
	return libc.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

func sqlite3_quota_ferror(tls *libc.TLS, p uintptr) int32 {
	return func() int32 {
		if !(libc.X__isthreaded != 0) {
			return libc.Bool32(int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_flags)&0x0040 != 0)
		}
		return libc.Xferror(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}()
}

func sqlite3_quota_ftruncate(tls *libc.TLS, p uintptr, szNew sqlite3_int64) int32 {
	var pFile uintptr = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	var rc int32
	if libc.AssignUintptr(&pFile, (*quota_FILE)(unsafe.Pointer(p)).FpFile) != uintptr(0) && (*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew {
		var pGroup uintptr
		if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew {
			return -1
		}
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 12)) += szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		quotaLeave(tls)
	}
	rc = libc.Xftruncate(tls, func() int32 {
		if !(libc.X__isthreaded != 0) {
			return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
		}
		return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}(), szNew)
	if pFile != 0 && rc == 0 {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 12)) += szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = szNew
		quotaLeave(tls)
	}
	return rc
}

func sqlite3_quota_file_mtime(tls *libc.TLS, p uintptr, pTime uintptr) int32 {
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var rc int32

	rc = libc.Xfstat(tls, func() int32 {
		if !(libc.X__isthreaded != 0) {
			return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
		}
		return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}(), bp)
	if rc == 0 {
		*(*time_t)(unsafe.Pointer(pTime)) = (*stat)(unsafe.Pointer(bp)).Fst_mtim.Ftv_sec
	}
	return rc
}

func sqlite3_quota_file_truesize(tls *libc.TLS, p uintptr) sqlite3_int64 {
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var rc int32

	rc = libc.Xfstat(tls, func() int32 {
		if !(libc.X__isthreaded != 0) {
			return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
		}
		return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}(), bp)
	if rc == 0 {
		return (*stat)(unsafe.Pointer(bp)).Fst_size
	}
	return int64(-1)
}

func sqlite3_quota_file_size(tls *libc.TLS, p uintptr) sqlite3_int64 {
	if (*quota_FILE)(unsafe.Pointer(p)).FpFile != 0 {
		return (*quotaFile)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).FpFile)).FiSize
	}
	return int64(-1)
}

func sqlite3_quota_file_available(tls *libc.TLS, p uintptr) int32 {
	var f uintptr = (*quota_FILE)(unsafe.Pointer(p)).Ff
	var pos1 int32
	var pos2 int32
	var rc int32
	pos1 = libc.Xftell(tls, f)
	if pos1 < 0 {
		return -1
	}
	rc = libc.Xfseek(tls, f, 0, SEEK_END)
	if rc != 0 {
		return -1
	}
	pos2 = libc.Xftell(tls, f)
	if pos2 < 0 {
		return -1
	}
	rc = libc.Xfseek(tls, f, pos1, SEEK_SET)
	if rc != 0 {
		return -1
	}
	return pos2 - pos1
}

func sqlite3_quota_remove(tls *libc.TLS, zFilename uintptr) int32 {
	var zFull uintptr
	var nFull size_t
	var rc int32
	var pGroup uintptr
	var pFile uintptr
	var pNextFile uintptr
	var diff int32
	var c int8

	zFull = sqlite3.Xsqlite3_malloc(tls, gQuota.FsThisVfs.FmxPathname+1)
	if zFull == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxFullPathname})).f(tls, gQuota.FpOrigVfs, zFilename,
		gQuota.FsThisVfs.FmxPathname+1, zFull)
	if rc != 0 {
		sqlite3.Xsqlite3_free(tls, zFull)
		return rc
	}

	nFull = libc.Xstrlen(tls, zFull)
	if nFull > size_t(0) && (int32(*(*int8)(unsafe.Pointer(zFull + uintptr(nFull-size_t(1))))) == '/' || int32(*(*int8)(unsafe.Pointer(zFull + uintptr(nFull-size_t(1))))) == '\\') {
		nFull--
		*(*int8)(unsafe.Pointer(zFull + uintptr(nFull))) = int8(0)
	}

	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if pGroup != 0 {
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; pFile != 0 && rc == SQLITE_OK; pFile = pNextFile {
			pNextFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
			diff = libc.Xstrncmp(tls, zFull, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, nFull)
			if diff == 0 && (int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FzFilename + uintptr(nFull))))) == 0 || int32(c) == '/' || int32(c) == '\\') {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					rc = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxDelete})).f(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
	}
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return rc
}

type TclQuotaCallback1 = struct {
	Finterp  uintptr
	FpScript uintptr
}

type TclQuotaCallback = TclQuotaCallback1

func tclQuotaCallback(tls *libc.TLS, zFilename uintptr, piLimit uintptr, iSize sqlite3_int64, pArg uintptr) {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var p uintptr
	var pEval uintptr
	var pVarname uintptr

	var rc int32

	p = pArg
	if p == uintptr(0) {
		return
	}

	pVarname = tcl.XTcl_NewStringObj(tls, ts+40556, -1)
	(*Tcl_Obj)(unsafe.Pointer(pVarname)).FrefCount++
	sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(uint32(0))), bp)
	tcl.XTcl_AppendObjToObj(tls, pVarname, tcl.XTcl_NewIntObj(tls, int32(*(*uint32)(unsafe.Pointer(bp))&uint32(0x7FFFFFFF))))
	tcl.XTcl_ObjSetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(piLimit))), 0)

	pEval = tcl.XTcl_DuplicateObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, zFilename, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pVarname)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewWideIntObj(tls, iSize))
	rc = tcl.XTcl_EvalObjEx(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)

	if rc == TCL_OK {
		var pLimit uintptr = tcl.XTcl_ObjGetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), 0)
		rc = tcl.XTcl_GetWideIntFromObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pLimit, bp+4)
		*(*sqlite3_int64)(unsafe.Pointer(piLimit)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 4))
		tcl.XTcl_UnsetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetString(tls, pVarname), uintptr(0), 0)
	}

	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pVarname
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp)
	}
}

func tclCallbackDestructor(tls *libc.TLS, pObj uintptr) {
	var p uintptr = pObj
	if p != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

func test_quota_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39445)
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 {
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(zName))) == 0 {
		zName = uintptr(0)
	}

	rc = sqlite3_quota_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

func test_quota_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}

	rc = sqlite3_quota_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

func test_quota_set(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var zPattern uintptr

	var pScript uintptr
	var rc int32
	var p uintptr

	var xDestroy uintptr
	var xCallback uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40567)
		return TCL_ERROR
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 {
		return TCL_ERROR
	}
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*4))
	tcl.XTcl_GetStringFromObj(tls, pScript, bp+8)

	if *(*int32)(unsafe.Pointer(bp + 8)) > 0 {
		p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TclQuotaCallback{})))
		if !(p != 0) {
			tcl.XTcl_SetResult(tls, interp, ts+37374, uintptr(0))
			return TCL_OK
		}
		libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(TclQuotaCallback{})))
		(*TclQuotaCallback)(unsafe.Pointer(p)).Finterp = interp
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		(*TclQuotaCallback)(unsafe.Pointer(p)).FpScript = pScript
		xDestroy = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tclCallbackDestructor}))
		xCallback = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
		}{tclQuotaCallback}))
	} else {
		p = uintptr(0)
		xDestroy = uintptr(0)
		xCallback = uintptr(0)
	}

	rc = sqlite3_quota_set(tls, zPattern, *(*Tcl_WideInt)(unsafe.Pointer(bp)), xCallback, p, xDestroy)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_quota_file(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var zFilename uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37558)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))

	rc = sqlite3_quota_file(tls, zFilename)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_quota_dump(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(1008)
	defer tls.Free(1008)

	var pResult uintptr
	var pGroupTerm uintptr
	var pFileTerm uintptr
	var pGroup uintptr
	var pFile uintptr

	pResult = tcl.XTcl_NewObj(tls)
	quotaEnter(tls)
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		pGroupTerm = tcl.XTcl_NewObj(tls)
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewStringObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize))
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; pFile != 0; pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext {
			var i int32

			pFileTerm = tcl.XTcl_NewObj(tls)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+8, ts, libc.VaList(bp, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename))
			for i = 0; *(*int8)(unsafe.Pointer(bp + 8 + uintptr(i))) != 0; i++ {
				if int32(*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i)))) == '\\' {
					*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i))) = int8('/')
				}
			}
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewStringObj(tls, bp+8, -1))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, (*quotaFile)(unsafe.Pointer(pFile)).FiSize))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FnRef)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm, pFileTerm)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pResult, pGroupTerm)
	}
	quotaLeave(tls)
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

func test_quota_fopen(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(58)
	defer tls.Free(58)

	var zFilename uintptr
	var zMode uintptr
	var p uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40588)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zMode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	p = sqlite3_quota_fopen(tls, zFilename, zMode)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+8, ts+14791, libc.VaList(bp, p))
	tcl.XTcl_SetResult(tls, interp, bp+8, uintptr(1))
	return TCL_OK
}

func test_quota_fread(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr

	var got size_t

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40602)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	zBuf = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp))**(*int32)(unsafe.Pointer(bp + 4))+1)
	if zBuf == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, ts+2069, uintptr(0))
		return TCL_ERROR
	}
	got = sqlite3_quota_fread(tls, zBuf, uint32(*(*int32)(unsafe.Pointer(bp))), uint32(*(*int32)(unsafe.Pointer(bp + 4))), p)
	*(*int8)(unsafe.Pointer(zBuf + uintptr(got*size_t(*(*int32)(unsafe.Pointer(bp)))))) = int8(0)
	tcl.XTcl_SetResult(tls, interp, zBuf, uintptr(1))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return TCL_OK
}

func test_quota_fwrite(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr

	var got size_t

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40620)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4) != 0 {
		return TCL_ERROR
	}
	zBuf = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	got = sqlite3_quota_fwrite(tls, zBuf, uint32(*(*int32)(unsafe.Pointer(bp))), uint32(*(*int32)(unsafe.Pointer(bp + 4))), p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(got)))
	return TCL_OK
}

func test_quota_fclose(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var p uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	rc = sqlite3_quota_fclose(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_quota_fflush(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp)) = 0

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40646)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if objc == 3 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 {
			return TCL_ERROR
		}
	}
	rc = sqlite3_quota_fflush(tls, p, *(*int32)(unsafe.Pointer(bp)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_quota_fseek(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr

	var zWhence uintptr
	var whence int32
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40664)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16) != 0 {
		return TCL_ERROR
	}
	zWhence = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	if libc.Xstrcmp(tls, zWhence, ts+40685) == 0 {
		whence = SEEK_SET
	} else if libc.Xstrcmp(tls, zWhence, ts+40694) == 0 {
		whence = SEEK_CUR
	} else if libc.Xstrcmp(tls, zWhence, ts+40703) == 0 {
		whence = SEEK_END
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp, ts+40712, uintptr(0)))
		return TCL_ERROR
	}
	rc = sqlite3_quota_fseek(tls, p, *(*int32)(unsafe.Pointer(bp + 16)), whence)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_quota_rewind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var p uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	sqlite3_quota_rewind(tls, p)
	return TCL_OK
}

func test_quota_ftell(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_int64(sqlite3_quota_ftell(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

func test_quota_ftruncate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var x sqlite3_int64

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40761)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 {
		return TCL_ERROR
	}
	x = *(*Tcl_WideInt)(unsafe.Pointer(bp))
	rc = sqlite3_quota_ftruncate(tls, p, x)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_quota_file_size(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_quota_file_size(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

func test_quota_file_truesize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_quota_file_truesize(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

func test_quota_file_mtime(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	*(*time_t)(unsafe.Pointer(bp)) = 0
	sqlite3_quota_file_mtime(tls, p, bp)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(*(*time_t)(unsafe.Pointer(bp)))))
	return TCL_OK
}

func test_quota_remove(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var zFilename uintptr
	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37558)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	rc = sqlite3_quota_remove(tls, zFilename)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_quota_glob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var zPattern uintptr
	var zText uintptr
	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+40773)
		return TCL_ERROR
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	zText = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	rc = quotaStrglob(tls, zPattern, zText)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

func test_quota_file_available(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_int64(sqlite3_quota_file_available(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

func test_quota_ferror(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var p uintptr
	var x int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	x = sqlite3_quota_ferror(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, x))
	return TCL_OK
}

func Sqlitequota_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aCmd8))/uint32(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd8[i].FzName, aCmd8[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aCmd8 = [21]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 40786, FxProc: 0},
	{FzName: ts + 40811, FxProc: 0},
	{FzName: ts + 40834, FxProc: 0},
	{FzName: ts + 40852, FxProc: 0},
	{FzName: ts + 40871, FxProc: 0},
	{FzName: ts + 40890, FxProc: 0},
	{FzName: ts + 40910, FxProc: 0},
	{FzName: ts + 40930, FxProc: 0},
	{FzName: ts + 40951, FxProc: 0},
	{FzName: ts + 40972, FxProc: 0},
	{FzName: ts + 40993, FxProc: 0},
	{FzName: ts + 41013, FxProc: 0},
	{FzName: ts + 41034, FxProc: 0},
	{FzName: ts + 41054, FxProc: 0},
	{FzName: ts + 41078, FxProc: 0},
	{FzName: ts + 41102, FxProc: 0},
	{FzName: ts + 41130, FxProc: 0},
	{FzName: ts + 41155, FxProc: 0},
	{FzName: ts + 41176, FxProc: 0},
	{FzName: ts + 41195, FxProc: 0},
	{FzName: ts + 41224, FxProc: 0},
}

type Circle1 = struct {
	FaBox [2]struct {
		Fxmin float64
		Fxmax float64
		Fymin float64
		Fymax float64
	}
	Fcenterx    float64
	Fcentery    float64
	Fradius     float64
	FmxArea     float64
	FeScoreType int32
}

type Circle = Circle1
type Box = struct {
	Fxmin float64
	Fxmax float64
	Fymin float64
	Fymax float64
}

func circle_del(tls *libc.TLS, p uintptr) {
	sqlite3.Xsqlite3_free(tls, p)
}

func circle_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, pRes uintptr) int32 {
	var i int32
	var pCircle uintptr
	var xmin float64
	var xmax float64
	var ymin float64
	var ymax float64

	xmin = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord))
	xmax = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 1*8))
	ymin = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 2*8))
	ymax = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 3*8))
	pCircle = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser
	if pCircle == uintptr(0) {
		if nCoord != 4 {
			return SQLITE_ERROR
		}

		if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != 3 || *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8)) < 0.0 {
			return SQLITE_ERROR
		}

		pCircle = libc.AssignPtrUintptr(p+12, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Circle{}))))
		if !(pCircle != 0) {
			return SQLITE_NOMEM
		}
		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{circle_del}))

		(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam))
		(*Circle)(unsafe.Pointer(pCircle)).Fcentery = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 1*8))
		(*Circle)(unsafe.Pointer(pCircle)).Fradius = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8))

		(*Box)(unsafe.Pointer(pCircle)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Circle)(unsafe.Pointer(pCircle)).FmxArea = (xmax-xmin)*(ymax-ymin) + 1.0
	}

	for i = 0; i < 4; i++ {
		var x float64
		if i&0x01 != 0 {
			x = xmax
		} else {
			x = xmin
		}
		var y float64
		if i&0x02 != 0 {
			y = ymax
		} else {
			y = ymin
		}
		var d2 float64

		d2 = (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx) * (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx)
		d2 = d2 + (y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)*(y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)
		if d2 < (*Circle)(unsafe.Pointer(pCircle)).Fradius*(*Circle)(unsafe.Pointer(pCircle)).Fradius {
			*(*int32)(unsafe.Pointer(pRes)) = 1
			return SQLITE_OK
		}
	}

	for i = 0; i < 2; i++ {
		if xmin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmin &&
			xmax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmax &&
			ymin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymin &&
			ymax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymax {
			*(*int32)(unsafe.Pointer(pRes)) = 1
			return SQLITE_OK
		}
	}

	*(*int32)(unsafe.Pointer(pRes)) = 0
	return SQLITE_OK
}

func circle_query_func(tls *libc.TLS, p uintptr) int32 {
	var i int32
	var pCircle uintptr
	var xmin float64
	var xmax float64
	var ymin float64
	var ymax float64
	var nWithin int32 = 0

	xmin = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord))
	xmax = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 1*8))
	ymin = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 2*8))
	ymax = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 3*8))
	pCircle = (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FpUser
	if pCircle == uintptr(0) {
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnCoord != 4 {
			return SQLITE_ERROR
		}

		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 4 && (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 1 {
			return SQLITE_ERROR
		}

		pCircle = libc.AssignPtrUintptr(p+12, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Circle{}))))
		if !(pCircle != 0) {
			return SQLITE_NOMEM
		}
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{circle_del}))

		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam == 4 {
			(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam))
			(*Circle)(unsafe.Pointer(pCircle)).Fcentery = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 1*8))
			(*Circle)(unsafe.Pointer(pCircle)).Fradius = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 2*8))
			(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = libc.Int32FromFloat64(*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 3*8)))
		} else {
			var z uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FapSqlParam)))
			(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).Fcentery = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).Fradius = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = 0
			for z != 0 && *(*int8)(unsafe.Pointer(z)) != 0 {
				if int32(*(*int8)(unsafe.Pointer(z))) == 'r' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).Fradius = libc.Xatof(tls, z+2)
				} else if int32(*(*int8)(unsafe.Pointer(z))) == 'x' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = libc.Xatof(tls, z+2)
				} else if int32(*(*int8)(unsafe.Pointer(z))) == 'y' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).Fcentery = libc.Xatof(tls, z+2)
				} else if int32(*(*int8)(unsafe.Pointer(z))) == 'e' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = libc.Int32FromFloat64(libc.Xatof(tls, z+2))
				} else if int32(*(*int8)(unsafe.Pointer(z))) == ' ' {
					z++
					continue
				}
				for int32(*(*int8)(unsafe.Pointer(z))) != 0 && int32(*(*int8)(unsafe.Pointer(z))) != ' ' {
					z++
				}
				for int32(*(*int8)(unsafe.Pointer(z))) == ' ' {
					z++
				}
			}
		}
		if (*Circle)(unsafe.Pointer(pCircle)).Fradius < 0.0 {
			sqlite3.Xsqlite3_free(tls, pCircle)
			return SQLITE_NOMEM
		}

		(*Box)(unsafe.Pointer(pCircle)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Circle)(unsafe.Pointer(pCircle)).FmxArea = float64(200.0) * 200.0
	}

	for i = 0; i < 4; i++ {
		var x float64
		if i&0x01 != 0 {
			x = xmax
		} else {
			x = xmin
		}
		var y float64
		if i&0x02 != 0 {
			y = ymax
		} else {
			y = ymin
		}
		var d2 float64

		d2 = (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx) * (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx)
		d2 = d2 + (y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)*(y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)
		if d2 < (*Circle)(unsafe.Pointer(pCircle)).Fradius*(*Circle)(unsafe.Pointer(pCircle)).Fradius {
			nWithin++
		}
	}

	if nWithin == 0 {
		for i = 0; i < 2; i++ {
			if xmin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmin &&
				xmax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmax &&
				ymin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymin &&
				ymax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymax {
				nWithin = 1
				break
			}
		}
	}

	if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 1 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 2 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 3 {
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel == 1 {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 1.0 - (xmax-xmin)*(ymax-ymin)/(*Circle)(unsafe.Pointer(pCircle)).FmxArea
			if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore < 0.01 {
				(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 0.01
			}
		} else {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 0.0
		}
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 4 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiRowid&int64(1) != 0 {
			nWithin = 0
		}
	} else {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiRowid&int64(1) != 0 {
			nWithin = 0
		}
	}
	if nWithin == 0 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = NOT_WITHIN
	} else if nWithin >= 4 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = PARTLY_WITHIN
	}
	return SQLITE_OK
}

func bfs_query_func(tls *libc.TLS, p uintptr) int32 {
	var x0 float64
	var x1 float64
	var y0 float64
	var y1 float64
	var bx0 float64
	var bx1 float64
	var by0 float64
	var by1 float64

	if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 4 {
		return SQLITE_ERROR
	}
	x0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord))
	x1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 1*8))
	y0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 2*8))
	y1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 3*8))
	bx0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam))
	bx1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 1*8))
	by0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 2*8))
	by1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 3*8))
	(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
	if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeParentWithin == FULLY_WITHIN {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else if x0 >= bx0 && x1 <= bx1 && y0 >= by0 && y1 <= by1 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else if x1 >= bx0 && x0 <= bx1 && y1 >= by0 && y0 <= by1 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = PARTLY_WITHIN
	} else {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = NOT_WITHIN
	}
	return SQLITE_OK
}

type Cube1 = struct {
	Fx      float64
	Fy      float64
	Fz      float64
	Fwidth  float64
	Fheight float64
	Fdepth  float64
}

type Cube = Cube1

func cube_context_free(tls *libc.TLS, p uintptr) {
	sqlite3.Xsqlite3_free(tls, p)
}

var gHere int32 = 42

func cube_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, piRes uintptr) int32 {
	var pCube uintptr = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser

	if pCube == uintptr(0) {
		if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != 6 || nCoord != 6 ||
			*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 3*8)) <= 0.0 || *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 4*8)) <= 0.0 || *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 5*8)) <= 0.0 {
			return SQLITE_ERROR
		}
		pCube = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Cube{})))
		if !(pCube != 0) {
			return SQLITE_NOMEM
		}
		(*Cube)(unsafe.Pointer(pCube)).Fx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam))
		(*Cube)(unsafe.Pointer(pCube)).Fy = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 1*8))
		(*Cube)(unsafe.Pointer(pCube)).Fz = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8))
		(*Cube)(unsafe.Pointer(pCube)).Fwidth = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 3*8))
		(*Cube)(unsafe.Pointer(pCube)).Fheight = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 4*8))
		(*Cube)(unsafe.Pointer(pCube)).Fdepth = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 5*8))

		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser = pCube
		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cube_context_free}))
	}

	*(*int32)(unsafe.Pointer(piRes)) = 0
	if *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord)) <= (*Cube)(unsafe.Pointer(pCube)).Fx+(*Cube)(unsafe.Pointer(pCube)).Fwidth &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 1*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fx &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 2*8)) <= (*Cube)(unsafe.Pointer(pCube)).Fy+(*Cube)(unsafe.Pointer(pCube)).Fheight &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 3*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fy &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 4*8)) <= (*Cube)(unsafe.Pointer(pCube)).Fz+(*Cube)(unsafe.Pointer(pCube)).Fdepth &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 5*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fz {
		*(*int32)(unsafe.Pointer(piRes)) = 1
	}

	return SQLITE_OK
}

func register_cube_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+41245, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{cube_geom})), uintptr(unsafe.Pointer(&gHere)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func register_circle_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+41250, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{circle_geom})), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_rtree_query_callback(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+41257,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) int32
			}{circle_query_func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_rtree_query_callback(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+41265,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) int32
			}{bfs_query_func})), uintptr(0), uintptr(0))
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func Sqlitetestrtree_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+41284, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_cube_geom})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+41303, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_circle_geom})), uintptr(0), uintptr(0))
	return TCL_OK
}

type schema_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
}

type schema_vtab = schema_vtab1
type schema_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FpDbList     uintptr
	FpTableList  uintptr
	FpColumnList uintptr
	Frowid       int32
}

type schema_cursor = schema_cursor1

func schemaDestroy(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

func schemaCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var rc int32 = SQLITE_NOMEM
	var pVtab uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_vtab{})))
	if pVtab != 0 {
		libc.Xmemset(tls, pVtab, 0, uint32(unsafe.Sizeof(schema_vtab{})))
		(*schema_vtab)(unsafe.Pointer(pVtab)).Fdb = db
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+41324)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

func schemaOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var rc int32 = SQLITE_NOMEM
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_cursor{})))
	if pCur != 0 {
		libc.Xmemset(tls, pCur, 0, uint32(unsafe.Sizeof(schema_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = SQLITE_OK
	}
	return rc
}

func schemaClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func schemaColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1))
		break
	case 1:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0))
		break
	default:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList, i-2))
		break
	}
	return SQLITE_OK
}

func schemaRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*schema_cursor)(unsafe.Pointer(pCur)).Frowid)
	return SQLITE_OK
}

func finalize(tls *libc.TLS, ppStmt uintptr) int32 {
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(ppStmt)))
	*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
	return rc
}

func schemaEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return func() int32 {
		if (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList != 0 {
			return 0
		}
		return 1
	}()
}

func schemaNext(tls *libc.TLS, cur uintptr) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var pCur uintptr
	var pVtab uintptr
	var zSql uintptr
	var pDbList uintptr
	rc = SQLITE_OK
	pCur = cur
	pVtab = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	zSql = uintptr(0)

__1:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList) != 0) || SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList)) {
		goto __2
	}
	if !(SQLITE_OK != libc.AssignInt32(&rc, finalize(tls, pCur+12))) {
		goto __3
	}
	goto next_exit
__3:
	;
__4:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpTableList) != 0) || SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList)) {
		goto __5
	}
	if !(SQLITE_OK != libc.AssignInt32(&rc, finalize(tls, pCur+8))) {
		goto __6
	}
	goto next_exit
__6:
	;
__7:
	if !(SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)) {
		goto __8
	}
	rc = finalize(tls, pCur+4)
	goto next_exit
	goto __7
__8:
	;
	if !(sqlite3.Xsqlite3_column_int(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 0) == 1) {
		goto __9
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+41396, 0)
	goto __10
__9:
	pDbList = (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+41451,
		libc.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pDbList, 1)))
__10:
	;
	if !!(zSql != 0) {
		goto __11
	}
	rc = SQLITE_NOMEM
	goto next_exit
__11:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, pCur+8, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != SQLITE_OK) {
		goto __12
	}
	goto next_exit
__12:
	;
	goto __4
__5:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+41504,
		libc.VaList(bp+8, sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1),
			sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0)))

	if !!(zSql != 0) {
		goto __13
	}
	rc = SQLITE_NOMEM
	goto next_exit
__13:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, pCur+12, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != SQLITE_OK) {
		goto __14
	}
	goto next_exit
__14:
	;
	goto __1
__2:
	;
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid++

next_exit:
	return rc
}

func schemaFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var rc int32
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCur uintptr = pVtabCursor
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid = 0
	finalize(tls, pCur+8)
	finalize(tls, pCur+12)
	finalize(tls, pCur+4)
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, ts+41529, -1, pCur+4, uintptr(0))
	return func() int32 {
		if rc == SQLITE_OK {
			return schemaNext(tls, pVtabCursor)
		}
		return rc
	}()
}

func schemaBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	return SQLITE_OK
}

var schemaModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
}

func register_schema_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+5165, uintptr(unsafe.Pointer(&schemaModule)), uintptr(0))
	return TCL_OK
}

func Sqlitetestschema_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd12))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd12[i].FzName,
			aObjCmd12[i].FxProc, aObjCmd12[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd12 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 41550, FxProc: 0},
}

type SuperlockBusy1 = struct {
	FxBusy    uintptr
	FpBusyArg uintptr
	FnBusy    int32
}

type SuperlockBusy = SuperlockBusy1

type Superlock1 = struct {
	Fdb   uintptr
	FbWal int32
}

type Superlock = Superlock1

func superlockBusyHandler(tls *libc.TLS, pCtx uintptr, UNUSED int32) int32 {
	var pBusy uintptr = pCtx
	if (*SuperlockBusy)(unsafe.Pointer(pBusy)).FxBusy == uintptr(0) {
		return 0
	}
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*SuperlockBusy)(unsafe.Pointer(pBusy)).FxBusy})).f(tls, (*SuperlockBusy)(unsafe.Pointer(pBusy)).FpBusyArg, libc.PostIncInt32(&(*SuperlockBusy)(unsafe.Pointer(pBusy)).FnBusy, 1))
}

func superlockIsWal(tls *libc.TLS, pLock uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	rc = sqlite3.Xsqlite3_prepare(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+41573, -1, bp, uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	(*Superlock)(unsafe.Pointer(pLock)).FbWal = 0
	if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp))) {
		var zMode uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp)), 0)
		if zMode != 0 && libc.Xstrlen(tls, zMode) == size_t(3) && sqlite3.Xsqlite3_strnicmp(tls, ts+34574, zMode, 3) == 0 {
			(*Superlock)(unsafe.Pointer(pLock)).FbWal = 1
		}
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp)))
}

func superlockShmLock(tls *libc.TLS, fd uintptr, idx int32, nByte int32, pBusy uintptr) int32 {
	var rc int32
	var xShmLock uintptr = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxShmLock
	for __ccgo := true; __ccgo; __ccgo = rc == SQLITE_BUSY && superlockBusyHandler(tls, pBusy, 0) != 0 {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{xShmLock})).f(tls, fd, idx, nByte, SQLITE_SHM_LOCK|SQLITE_SHM_EXCLUSIVE)
	}
	return rc
}

func superlockWalLock(tls *libc.TLS, db uintptr, pBusy uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 4)) = uintptr(0)

	rc = sqlite3.Xsqlite3_file_control(tls, db, ts+85, SQLITE_FCNTL_FILE_POINTER, bp)
	if rc != SQLITE_OK {
		return rc
	}

	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp)), 2, 1, pBusy)
	if rc != SQLITE_OK {
		return rc
	}

	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods)).FxShmMap})).f(tls, *(*uintptr)(unsafe.Pointer(bp)), 0, 32*1024, 1, bp+4)
	if rc != SQLITE_OK {
		return rc
	}
	libc.Xmemset(tls, *(*uintptr)(unsafe.Pointer(bp + 4)), 0, uint32(32))

	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp)), 3, SQLITE_SHM_NLOCK-3, pBusy)
	return rc
}

func sqlite3demo_superunlock(tls *libc.TLS, pLock uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pLock
	if (*Superlock)(unsafe.Pointer(p)).FbWal != 0 {
		var rc int32
		var flags int32 = SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE
		*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, (*Superlock)(unsafe.Pointer(p)).Fdb, ts+85, SQLITE_FCNTL_FILE_POINTER, bp)
		if rc == SQLITE_OK {
			(*struct {
				f func(*libc.TLS, uintptr, int32, int32, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods)).FxShmLock})).f(tls, *(*uintptr)(unsafe.Pointer(bp)), 2, 1, flags)
			(*struct {
				f func(*libc.TLS, uintptr, int32, int32, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FpMethods)).FxShmLock})).f(tls, *(*uintptr)(unsafe.Pointer(bp)), 3, SQLITE_SHM_NLOCK-3, flags)
		}
	}
	sqlite3.Xsqlite3_close(tls, (*Superlock)(unsafe.Pointer(p)).Fdb)
	sqlite3.Xsqlite3_free(tls, p)
}

func sqlite3demo_superlock(tls *libc.TLS, zPath uintptr, zVfs uintptr, xBusy uintptr, pBusyArg uintptr, ppLock uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*SuperlockBusy)(unsafe.Pointer(bp)) = SuperlockBusy{}
	var rc int32
	var pLock uintptr

	pLock = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Superlock{})))
	if !(pLock != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pLock, 0, uint32(unsafe.Sizeof(Superlock{})))

	rc = sqlite3.Xsqlite3_open_v2(tls,
		zPath, pLock, SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs)

	if rc == SQLITE_OK {
		(*SuperlockBusy)(unsafe.Pointer(bp)).FxBusy = xBusy
		(*SuperlockBusy)(unsafe.Pointer(bp)).FpBusyArg = pBusyArg
		sqlite3.Xsqlite3_busy_handler(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{superlockBusyHandler})), bp)
		rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+18178, uintptr(0), uintptr(0), uintptr(0))
	}

	if rc == SQLITE_OK {
		if SQLITE_OK == libc.AssignInt32(&rc, superlockIsWal(tls, pLock)) && (*Superlock)(unsafe.Pointer(pLock)).FbWal != 0 {
			rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+14542, uintptr(0), uintptr(0), uintptr(0))
			if rc == SQLITE_OK {
				rc = superlockWalLock(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, bp)
			}
		}
	}

	if rc != SQLITE_OK {
		sqlite3demo_superunlock(tls, pLock)
		*(*uintptr)(unsafe.Pointer(ppLock)) = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(ppLock)) = pLock
	}

	return rc
}

type InterpAndScript1 = struct {
	Finterp  uintptr
	FpScript uintptr
}

type InterpAndScript = InterpAndScript1

func superunlock_del(tls *libc.TLS, cd ClientData) {
	sqlite3demo_superunlock(tls, cd)
}

func superunlock_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584)
		return TCL_ERROR
	}
	tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
	return TCL_OK
}

func superlock_busy(tls *libc.TLS, pCtx uintptr, nBusy int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pEval uintptr
	*(*int32)(unsafe.Pointer(bp)) = 0

	pEval = tcl.XTcl_DuplicateObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, nBusy))
	tcl.XTcl_EvalObjEx(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	tcl.XTcl_GetIntFromObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp), bp)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func superlock_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var zPath uintptr
	var zVfs uintptr = uintptr(0)
	*(*InterpAndScript)(unsafe.Pointer(bp + 16)) = InterpAndScript{}
	var xBusy uintptr = uintptr(0)
	var rc int32

	if objc < 3 || objc > 5 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+41598)
		return TCL_ERROR
	}

	zPath = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))

	if objc > 3 {
		zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
		if libc.Xstrlen(tls, zVfs) == size_t(0) {
			zVfs = uintptr(0)
		}
	}
	if objc > 4 {
		(*InterpAndScript)(unsafe.Pointer(bp + 16)).Finterp = interp
		(*InterpAndScript)(unsafe.Pointer(bp + 16)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 4*4))
		xBusy = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{superlock_busy}))
	}

	rc = sqlite3demo_superlock(tls, zPath, zVfs, xBusy, bp+16, bp+24)

	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}

	tcl.XTcl_CreateObjCommand(tls,
		interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{superunlock_cmd})), *(*uintptr)(unsafe.Pointer(bp + 24)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{superunlock_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	return TCL_OK
}

func SqliteSuperlock_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+41639, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{superlock_cmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

type shm_largepage_conf = struct {
	Fpsind        int32
	Falloc_policy int32
	Fpad          [10]int32
}

type TestSyscallGlobal = struct {
	FbPersist         int32
	FnCount           int32
	FnFail            int32
	Fpgsz             int32
	Forig_getpagesize sqlite3_syscall_ptr
}

var gSyscall = TestSyscallGlobal{}

type TestSyscallArray = struct {
	FzName         uintptr
	FxTest         sqlite3_syscall_ptr
	FxOrig         sqlite3_syscall_ptr
	Fdefault_errno int32
	Fcustom_errno  int32
}

var aSyscall = [19]TestSyscallArray{
	{FzName: ts + 41661, FxTest: 0, Fdefault_errno: EACCES},
	{FzName: ts + 9845, FxTest: 0},
	{FzName: ts + 41666, FxTest: 0},
	{FzName: ts + 41673, FxTest: 0},
	{FzName: ts + 41680, FxTest: 0},
	{FzName: ts + 41685, FxTest: 0},
	{FzName: ts + 41691, FxTest: 0, Fdefault_errno: EIO},
	{FzName: ts + 41701, FxTest: 0, Fdefault_errno: EACCES},
	{FzName: ts + 29921, FxTest: 0},
	{FzName: ts + 41707, FxTest: 0},
	{FzName: ts + 41713, FxTest: 0},
	{FzName: ts + 29926, FxTest: 0},
	{FzName: ts + 41721, FxTest: 0},
	{FzName: ts + 41728, FxTest: 0},
	{FzName: ts + 41737, FxTest: 0},
	{FzName: ts + 41744, FxTest: 0},
	{FzName: ts + 33668, FxTest: 0},
	{FzName: ts + 41754, FxTest: 0},
	{},
}

func tsIsFail(tls *libc.TLS) int32 {
	gSyscall.FnCount--
	if gSyscall.FnCount == 0 || gSyscall.FnFail != 0 && gSyscall.FbPersist != 0 {
		gSyscall.FnFail++
		return 1
	}
	return 0
}

func tsErrno(tls *libc.TLS, zFunc uintptr) int32 {
	var i int32
	var nFunc int32 = int32(libc.Xstrlen(tls, zFunc))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if libc.Xstrlen(tls, aSyscall[i].FzName) != size_t(nFunc) {
			continue
		}
		if libc.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint32(nFunc)) != 0 {
			continue
		}
		return aSyscall[i].Fcustom_errno
	}

	return 0
}

func tsIsFailErrno(tls *libc.TLS, zFunc uintptr) int32 {
	if tsIsFail(tls) != 0 {
		*(*int32)(unsafe.Pointer(libc.X__error(tls))) = tsErrno(tls, zFunc)
		return 1
	}
	return 0
}

func ts_open(tls *libc.TLS, zFile uintptr, flags int32, mode int32) int32 {
	if tsIsFailErrno(tls, ts+41661) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 8)))(tls, zFile, flags, mode)
}

func ts_close(tls *libc.TLS, fd int32) int32 {
	if tsIsFail(tls) != 0 {
		(*(*func(*libc.TLS, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 1*20 + 8)))(tls, fd)
		return -1
	}
	return (*(*func(*libc.TLS, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 1*20 + 8)))(tls, fd)
}

func ts_access(tls *libc.TLS, zPath uintptr, mode int32) int32 {
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 2*20 + 8)))(tls, zPath, mode)
}

func ts_getcwd(tls *libc.TLS, zPath uintptr, nPath size_t) uintptr {
	if tsIsFail(tls) != 0 {
		return uintptr(0)
	}
	return (*(*func(*libc.TLS, uintptr, size_t) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 3*20 + 8)))(tls, zPath, nPath)
}

func ts_stat(tls *libc.TLS, zPath uintptr, p uintptr) int32 {
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 4*20 + 8)))(tls, zPath, p)
}

func ts_fstat(tls *libc.TLS, fd int32, p uintptr) int32 {
	if tsIsFailErrno(tls, ts+41685) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 5*20 + 8)))(tls, fd, p)
}

func ts_ftruncate(tls *libc.TLS, fd int32, n off_t) int32 {
	if tsIsFailErrno(tls, ts+41691) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, off_t) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 6*20 + 8)))(tls, fd, n)
}

func ts_fcntl(tls *libc.TLS, fd int32, cmd int32, va uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+41701) != 0 {
		return -1
	}
	ap = va
	pArg = libc.VaUintptr(&ap)
	return (*(*func(*libc.TLS, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 7*20 + 8)))(tls, fd, cmd, libc.VaList(bp, pArg))
}

func ts_read(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 {
	if tsIsFailErrno(tls, ts+29921) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 8*20 + 8)))(tls, fd, aBuf, nBuf)
}

func ts_pread(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 {
	if tsIsFailErrno(tls, ts+41707) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 9*20 + 8)))(tls, fd, aBuf, nBuf, off)
}

func ts_pread64(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 {
	if tsIsFailErrno(tls, ts+41713) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 10*20 + 8)))(tls, fd, aBuf, nBuf, off)
}

func ts_write(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 {
	if tsIsFailErrno(tls, ts+29926) != 0 {
		if tsErrno(tls, ts+29926) == EINTR {
			(*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 11*20 + 8)))(tls, fd, aBuf, nBuf/size_t(2))
		}
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 11*20 + 8)))(tls, fd, aBuf, nBuf)
}

func ts_pwrite(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 {
	if tsIsFailErrno(tls, ts+41721) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 12*20 + 8)))(tls, fd, aBuf, nBuf, off)
}

func ts_pwrite64(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 {
	if tsIsFailErrno(tls, ts+41728) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 13*20 + 8)))(tls, fd, aBuf, nBuf, off)
}

func ts_fchmod(tls *libc.TLS, fd int32, mode mode_t) int32 {
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, mode_t) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 14*20 + 8)))(tls, fd, mode)
}

func ts_fallocate(tls *libc.TLS, fd int32, off off_t, len off_t) int32 {
	if tsIsFail(tls) != 0 {
		return tsErrno(tls, ts+41744)
	}
	return (*(*func(*libc.TLS, int32, off_t, off_t) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 15*20 + 8)))(tls, fd, off, len)
}

func ts_mmap(tls *libc.TLS, pAddr uintptr, nByte size_t, prot int32, flags int32, fd int32, iOff off_t) uintptr {
	if tsIsFailErrno(tls, ts+33668) != 0 {
		return libc.UintptrFromInt32(-1)
	}
	return (*(*func(*libc.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 16*20 + 8)))(tls, pAddr, nByte, prot, flags, fd, iOff)
}

func ts_mremap(tls *libc.TLS, a uintptr, b size_t, c size_t, d int32, va uintptr) uintptr {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+41754) != 0 {
		return libc.UintptrFromInt32(-1)
	}
	ap = va
	pArg = libc.VaUintptr(&ap)
	return (*(*func(*libc.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 17*20 + 8)))(tls, a, b, c, d, libc.VaList(bp, pArg))
}

func test_syscall_install(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pVfs uintptr

	var i int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+41761)
		return TCL_ERROR
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp, bp+4) != 0 {
		return TCL_ERROR
	}
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	for i = 0; i < *(*int32)(unsafe.Pointer(bp)); i++ {
		var rc int32 = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 4)) + uintptr(i)*4)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+41774, 0, bp+8)
		if rc != 0 {
			return rc
		}
		if aSyscall[*(*int32)(unsafe.Pointer(bp + 8))].FxOrig == uintptr(0) {
			aSyscall[*(*int32)(unsafe.Pointer(bp + 8))].FxOrig = (*struct {
				f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetSystemCall})).f(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 8))].FzName)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 8))].FzName, aSyscall[*(*int32)(unsafe.Pointer(bp + 8))].FxTest)
		}
		aSyscall[*(*int32)(unsafe.Pointer(bp + 8))].Fcustom_errno = aSyscall[*(*int32)(unsafe.Pointer(bp + 8))].Fdefault_errno
	}

	return TCL_OK
}

func test_syscall_uninstall(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pVfs uintptr
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if aSyscall[i].FxOrig != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, aSyscall[i].FzName, uintptr(0))
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	return TCL_OK
}

func test_syscall_reset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pVfs uintptr
	var i int32
	var rc int32

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc == 2 {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, uintptr(0), uintptr(0))
		for i = 0; aSyscall[i].FzName != 0; i++ {
			aSyscall[i].FxOrig = uintptr(0)
		}
	} else {
		var zFunc uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp)
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), uintptr(0))
		for i = 0; rc == SQLITE_OK && aSyscall[i].FzName != 0; i++ {
			if libc.Xstrlen(tls, aSyscall[i].FzName) != size_t(*(*int32)(unsafe.Pointer(bp))) {
				continue
			}
			if libc.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint32(*(*int32)(unsafe.Pointer(bp)))) != 0 {
				continue
			}
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func test_syscall_exists(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pVfs uintptr
	var x sqlite3_syscall_ptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	x = (*struct {
		f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetSystemCall})).f(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))))

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(libc.Bool32(x != uintptr(0)) != 0)))
	return TCL_OK
}

func test_syscall_fault(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp)) = 0
	*(*int32)(unsafe.Pointer(bp + 4)) = 0

	if objc != 2 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+41786)
		return TCL_ERROR
	}

	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp) != 0 ||
			tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4) != 0 {
			return TCL_ERROR
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, gSyscall.FnFail))
	gSyscall.FnCount = *(*int32)(unsafe.Pointer(bp))
	gSyscall.FbPersist = *(*int32)(unsafe.Pointer(bp + 4))
	gSyscall.FnFail = 0
	return TCL_OK
}

func test_syscall_errno(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var rc int32

	*(*[12]Errno)(unsafe.Pointer(bp + 4)) = [12]Errno{
		{Fz: ts + 41802, Fi: EACCES},
		{Fz: ts + 41809, Fi: EINTR},
		{Fz: ts + 41815, Fi: EIO},
		{Fz: ts + 41819, Fi: EOVERFLOW},
		{Fz: ts + 41829, Fi: ENOMEM},
		{Fz: ts + 41836, Fi: EAGAIN},
		{Fz: ts + 41843, Fi: ETIMEDOUT},
		{Fz: ts + 41853, Fi: EBUSY},
		{Fz: ts + 41859, Fi: EPERM},
		{Fz: ts + 41865, Fi: EDEADLK},
		{Fz: ts + 41873, Fi: ENOLCK},
		{},
	}

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+41880)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 2*4)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+41774, 0, bp)
	if rc != TCL_OK {
		return rc
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4, int32(unsafe.Sizeof(Errno{})), ts+41894, 0, bp+100)
	if rc != TCL_OK {
		return rc
	}

	aSyscall[*(*int32)(unsafe.Pointer(bp))].Fcustom_errno = (*Errno)(unsafe.Pointer(bp + 4 + uintptr(*(*int32)(unsafe.Pointer(bp + 100)))*8)).Fi
	return TCL_OK
}

type Errno = struct {
	Fz uintptr
	Fi int32
}

func test_syscall_list(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var zSys uintptr
	var pVfs uintptr
	var pList uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	for zSys = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxNextSystemCall})).f(tls, pVfs, uintptr(0)); zSys != uintptr(0); zSys = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxNextSystemCall})).f(tls, pVfs, zSys) {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, zSys, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pList)
	for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
		var _objPtr uintptr = pList
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return TCL_OK
}

func test_syscall_defaultvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pVfs uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	return TCL_OK
}

func ts_getpagesize(tls *libc.TLS) int32 {
	return gSyscall.Fpgsz
}

func test_syscall_pagesize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+41900)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 16)) < 0 {
		if gSyscall.Forig_getpagesize != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, ts+41905, gSyscall.Forig_getpagesize)
		}
	} else {
		if *(*int32)(unsafe.Pointer(bp + 16)) < 512 || *(*int32)(unsafe.Pointer(bp + 16))&(*(*int32)(unsafe.Pointer(bp + 16))-1) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+41917, 0))
			return TCL_ERROR
		}
		gSyscall.Forig_getpagesize = (*struct {
			f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetSystemCall})).f(tls, pVfs, ts+41905)
		gSyscall.Fpgsz = *(*int32)(unsafe.Pointer(bp + 16))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls,
			pVfs, ts+41905, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{ts_getpagesize})))
	}

	return TCL_OK
}

func test_syscall(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(100)
	defer tls.Free(100)

	*(*[10]SyscallCmd)(unsafe.Pointer(bp + 16)) = [10]SyscallCmd{
		{FzName: ts + 41935, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_fault}))},
		{FzName: ts + 41941, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_install}))},
		{FzName: ts + 41949, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_uninstall}))},
		{FzName: ts + 8288, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_reset}))},
		{FzName: ts + 41894, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_errno}))},
		{FzName: ts + 18470, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_exists}))},
		{FzName: ts + 41959, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_list}))},
		{FzName: ts + 41964, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_defaultvfs}))},
		{FzName: ts + 41975, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_pagesize}))},
		{},
	}

	var rc int32
	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37610)
		return TCL_ERROR
	}
	if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion < 3 || (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+41984, 0))
		rc = TCL_ERROR
	} else {
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+16, int32(unsafe.Sizeof(SyscallCmd{})), ts+2014, 0, bp+96)
	}
	if rc != TCL_OK {
		return rc
	}
	return (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*SyscallCmd)(unsafe.Pointer(bp + 16 + uintptr(*(*int32)(unsafe.Pointer(bp + 96)))*8)).FxCmd})).f(tls, clientData, interp, objc, objv)
}

type SyscallCmd = struct {
	FzName uintptr
	FxCmd  uintptr
}

func SqlitetestSyscall_Init(tls *libc.TLS, interp uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[1]SyscallCmd)(unsafe.Pointer(bp)) = [1]SyscallCmd{
		{FzName: ts + 42020, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall}))},
	}
	var i int32

	for i = 0; uint32(i) < uint32(unsafe.Sizeof([1]SyscallCmd{}))/uint32(unsafe.Sizeof(SyscallCmd{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, (*SyscallCmd)(unsafe.Pointer(bp+uintptr(i)*8)).FzName, (*SyscallCmd)(unsafe.Pointer(bp+uintptr(i)*8)).FxCmd, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

func sqlite3TestInit(tls *libc.TLS, interp uintptr) uintptr {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	{
		libc.Xgetrlimit(tls, RLIMIT_CORE, bp)
		(*rlimit)(unsafe.Pointer(bp)).Frlim_cur = (*rlimit)(unsafe.Pointer(bp)).Frlim_max
		libc.Xsetrlimit(tls, RLIMIT_CORE, bp)

	}

	if tcl.XTcl_GetCommandInfo(tls, interp, ts+19221, bp+16) == 0 {
		Sqlite3_Init(tls, interp)
	}
	Md5_Init(tls, interp)
	Sqliteconfig_Init(tls, interp)
	Sqlitetest1_Init(tls, interp)
	Sqlitetest2_Init(tls, interp)
	Sqlitetest3_Init(tls, interp)
	Sqlitetest4_Init(tls, interp)
	Sqlitetest5_Init(tls, interp)
	Sqlitetest6_Init(tls, interp)
	Sqlitetest8_Init(tls, interp)
	Sqlitetest9_Init(tls, interp)
	Sqlitetestasync_Init(tls, interp)
	Sqlitetest_autoext_Init(tls, interp)
	Sqlitetest_blob_Init(tls, interp)
	Sqlitetest_demovfs_Init(tls, interp)
	Sqlitetest_func_Init(tls, interp)
	Sqlitetest_hexio_Init(tls, interp)
	Sqlitetest_init_Init(tls, interp)
	Sqlitetest_malloc_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlitetestschema_Init(tls, interp)
	Sqlitetesttclvar_Init(tls, interp)
	Sqlitetestfs_Init(tls, interp)
	SqlitetestThread_Init(tls, interp)
	SqlitetestOnefile_Init(tls)
	SqlitetestOsinst_Init(tls, interp)
	Sqlitetestbackup_Init(tls, interp)
	Sqlitetestintarray_Init(tls, interp)
	Sqlitetestvfs_Init(tls, interp)
	Sqlitetestrtree_Init(tls, interp)
	Sqlitetestrtreedoc_Init(tls, interp)
	Sqlitequota_Init(tls, interp)
	Sqlitemultiplex_Init(tls, interp)
	SqliteSuperlock_Init(tls, interp)
	SqlitetestSyscall_Init(tls, interp)
	TestSession_Init(tls, interp)
	Fts5tcl_Init(tls, interp)
	SqliteRbu_Init(tls, interp)
	Sqlitetesttcl_Init(tls, interp)

	TestExpert_Init(tls, interp)
	Sqlitetest_window_Init(tls, interp)
	Sqlitetestvdbecov_Init(tls, interp)
	TestRecover_Init(tls, interp)

	tcl.XTcl_CreateObjCommand(tls,
		interp, ts+42033, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{load_testfixture_extensions})), uintptr(0), uintptr(0))
	return uintptr(0)
}

func load_testfixture_extensions(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var slave uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42061)
		return TCL_ERROR
	}

	slave = tcl.XTcl_GetSlave(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	if !(slave != 0) {
		return TCL_ERROR
	}

	sqlite3TestInit(tls, slave)
	return TCL_OK
}

type tclvar_vtab1 = struct {
	Fbase   sqlite3_vtab
	Finterp uintptr
}

type tclvar_vtab = tclvar_vtab1
type tclvar_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpList1 uintptr
	FpList2 uintptr
	Fi1     int32
	Fi2     int32
}

type tclvar_cursor = tclvar_cursor1

func tclvarConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 {
	var pVtab uintptr
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_vtab{})))
	if pVtab == uintptr(0) {
		return SQLITE_NOMEM
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	(*tclvar_vtab)(unsafe.Pointer(pVtab)).Finterp = pAux
	sqlite3.Xsqlite3_declare_vtab(tls, db, uintptr(unsafe.Pointer(&zSchema)))
	return SQLITE_OK
}

var zSchema = *(*[100]int8)(unsafe.Pointer(ts + 42067))

func tclvarDisconnect(tls *libc.TLS, pVtab uintptr) int32 {
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

func tclvarOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 {
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func tclvarClose(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func next2(tls *libc.TLS, interp uintptr, pCur uintptr, pObj uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr

	if pObj != 0 {
		if !(int32((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2) != 0) {
			p = tcl.XTcl_NewStringObj(tls, ts+42167, -1)
			(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, pObj)
			tcl.XTcl_EvalObjEx(tls, interp, p, TCL_EVAL_GLOBAL)
			for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
				var _objPtr uintptr = p
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = tcl.XTcl_GetObjResult(tls, interp)
			(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2)).FrefCount++

		} else {
			*(*int32)(unsafe.Pointer(bp)) = 0
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2++
			tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, bp)
			if (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 >= *(*int32)(unsafe.Pointer(bp)) {
				for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
					var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
				(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
				return 0
			}
		}
	}

	return 1
}

func tclvarNext(tls *libc.TLS, cur uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp)) = 0
	var ok int32 = 0

	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, bp)
	for !(ok != 0) && (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 < *(*int32)(unsafe.Pointer(bp)) {
		tcl.XTcl_ListObjIndex(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+4)
		ok = next2(tls, interp, pCur, *(*uintptr)(unsafe.Pointer(bp + 4)))
		if !(ok != 0) {
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1++
		}
	}

	return 0
}

func tclvarFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 {
	var pCur uintptr = pVtabCursor
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).Finterp
	var p uintptr = tcl.XTcl_NewStringObj(tls, ts+42179, -1)

	var zEq uintptr = ts + 584
	var zMatch uintptr = ts + 584
	var zGlob uintptr = ts + 584
	var zRegexp uintptr = ts + 584
	var zLike uintptr = ts + 584
	var i int32

	for i = 0; *(*int8)(unsafe.Pointer(idxStr + uintptr(i))) != 0; i++ {
		switch int32(*(*int8)(unsafe.Pointer(idxStr + uintptr(i)))) {
		case 'e':
			zEq = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'm':
			zMatch = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'g':
			zGlob = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'r':
			zRegexp = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		case 'l':
			zLike = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
			break
		default:
		}
	}

	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zEq, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zMatch, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zGlob, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zRegexp, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zLike, -1))

	tcl.XTcl_EvalObjEx(tls, interp, p, TCL_EVAL_GLOBAL)
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
	}
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 = tcl.XTcl_GetObjResult(tls, interp)
	(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1)).FrefCount++

	for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
		var _objPtr uintptr = p
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return tclvarNext(tls, pVtabCursor)
}

func tclvarColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 {
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var z1 uintptr
	var z2 uintptr = ts + 584
	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+16)
	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2, bp+20)
	z1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	if *(*uintptr)(unsafe.Pointer(bp + 20)) != 0 {
		z2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 20)))
	}
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, libc.UintptrFromInt32(-1))
			break

		}
	case 1:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z2, -1, libc.UintptrFromInt32(-1))
			break

		}
	case 2:
		{
			var pVal uintptr = tcl.XTcl_GetVar2Ex(tls, interp, z1, func() uintptr {
				if *(*int8)(unsafe.Pointer(z2)) != 0 {
					return z2
				}
				return uintptr(0)
			}(), TCL_GLOBAL_ONLY)
			sqlite3.Xsqlite3_result_text(tls, ctx, tcl.XTcl_GetString(tls, pVal), -1, libc.UintptrFromInt32(-1))
			break

		}
	case 3:
		{
			var z3 uintptr
			if *(*uintptr)(unsafe.Pointer(bp + 20)) != 0 {
				z3 = sqlite3.Xsqlite3_mprintf(tls, ts+42197, libc.VaList(bp, z1, z2))
				sqlite3.Xsqlite3_result_text(tls, ctx, z3, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
			} else {
				sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, libc.UintptrFromInt32(-1))
			}
			break

		}
	}
	return SQLITE_OK
}

func tclvarRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 {
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

func tclvarEof(tls *libc.TLS, cur uintptr) int32 {
	var pCur uintptr = cur
	return func() int32 {
		if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
			return 0
		}
		return 1
	}()
}

func tclvarAddToIdxstr(tls *libc.TLS, zStr uintptr, x int8) int32 {
	var i int32
	for i = 0; *(*int8)(unsafe.Pointer(zStr + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) == int32(x) {
			return 1
		}
	}
	*(*int8)(unsafe.Pointer(zStr + uintptr(i))) = x
	*(*int8)(unsafe.Pointer(zStr + uintptr(i+1))) = int8(0)
	return 0
}

func tclvarSetOmit(tls *libc.TLS, interp uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	*(*int32)(unsafe.Pointer(bp)) = 0
	var pRes uintptr
	rc = tcl.XTcl_Eval(tls, interp,
		ts+42204)
	if rc == TCL_OK {
		pRes = tcl.XTcl_GetObjResult(tls, interp)
		rc = tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), pRes, bp)
	}
	return libc.Bool32(rc == TCL_OK && *(*int32)(unsafe.Pointer(bp)) != 0)
}

func tclvarBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 {
	var pTab uintptr = tab
	var ii int32
	var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, 32)
	var iStr int32 = 0

	if zStr == uintptr(0) {
		return SQLITE_NOMEM
	}
	*(*int8)(unsafe.Pointer(zStr)) = int8(0)

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		var pUsage uintptr

		pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 {
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('e')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
				}
			}

			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('m')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
				}
			}

			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_GLOB && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('g')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_REGEXP && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('r')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_LIKE && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('l')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}
		}
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = zStr
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1

	return SQLITE_OK
}

func tclvarUpdate(tls *libc.TLS, tab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 {
	var pTab uintptr = tab
	if argc == 1 {
		var zVar uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zVar, uintptr(0), TCL_GLOBAL_ONLY)
		return SQLITE_OK
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)))
		var zName uintptr
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4))) != SQLITE_TEXT {
			(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+42265, 0)
			return SQLITE_ERROR
		}
		zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 5*4)))
		if zValue != 0 {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), zValue, TCL_GLOBAL_ONLY)
		} else {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), TCL_GLOBAL_ONLY)
		}
		return SQLITE_OK
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_TEXT &&
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4))) == SQLITE_TEXT {
		var zOldName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var zNewName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)))
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*4)))

		if libc.Xstrcmp(tls, zOldName, zNewName) != 0 || zValue == uintptr(0) {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zOldName, uintptr(0), TCL_GLOBAL_ONLY)
		}
		if zValue != uintptr(0) {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zNewName, uintptr(0), zValue, TCL_GLOBAL_ONLY)
		}
		return SQLITE_OK
	}
	(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+42300, 0)
	return SQLITE_ERROR
}

var tclvarModule = sqlite3_module{
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0,
	FxClose:      0,
	FxFilter:     0,
	FxNext:       0,
	FxEof:        0,
	FxColumn:     0,
	FxRowid:      0,
	FxUpdate:     0,
}

func register_tclvar_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = TCL_OK

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+34487, uintptr(unsafe.Pointer(&tclvarModule)), interp)
	rc = tcl.XTcl_Eval(tls, interp,
		ts+42331)
	return rc
}

func Sqlitetesttclvar_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd13))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd13[i].FzName,
			aObjCmd13[i].FxProc, aObjCmd13[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd13 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 42867, FxProc: 0},
}

type SqlThread1 = struct {
	Fparent   Tcl_ThreadId
	Finterp   uintptr
	FzScript  uintptr
	FzVarname uintptr
}

type SqlThread = SqlThread1

type EvalEvent1 = struct {
	Fbase    Tcl_Event
	FzScript uintptr
	Finterp  uintptr
}

type EvalEvent = EvalEvent1

func tclScriptEvent(tls *libc.TLS, evPtr uintptr, flags int32) int32 {
	var rc int32
	var p uintptr = evPtr
	rc = tcl.XTcl_Eval(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp, (*EvalEvent)(unsafe.Pointer(p)).FzScript)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp)
	}
	_ = flags
	return 1
}

func postToParent(tls *libc.TLS, p uintptr, pScript uintptr) {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pEvent uintptr
	var zMsg uintptr

	zMsg = tcl.XTcl_GetStringFromObj(tls, pScript, bp)
	pEvent = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(EvalEvent{}))+uint32(*(*int32)(unsafe.Pointer(bp)))+uint32(1))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = pEvent + 1*16
	libc.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, uint32(*(*int32)(unsafe.Pointer(bp))+1))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp

	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, TCL_QUEUE_TAIL)
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)
}

func tclScriptThread(tls *libc.TLS, pSqlThread ClientData) {
	var interp uintptr
	var pRes uintptr
	var pList uintptr
	var rc int32
	var p uintptr = pSqlThread

	interp = tcl.XTcl_CreateInterp(tls)
	tcl.XTcl_CreateObjCommand(tls, interp, ts+42890, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{clock_seconds_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+42904, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{sqlthread_proc})), pSqlThread, uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+42914, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{blocking_step_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+42936, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(1), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+42964, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(0), uintptr(0))
	Sqlitetest1_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlite3_Init(tls, interp)

	rc = tcl.XTcl_Eval(tls, interp, (*SqlThread)(unsafe.Pointer(p)).FzScript)
	pRes = tcl.XTcl_GetObjResult(tls, interp)
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer(pRes)).FrefCount++

	if rc != TCL_OK {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+10051, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
		postToParent(tls, p, pList)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pList
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		pList = tcl.XTcl_NewObj(tls)
	}

	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+42995, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, (*SqlThread)(unsafe.Pointer(p)).FzVarname, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
	postToParent(tls, p, pList)

	tcl.XTcl_Free(tls, p)
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pList
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
		var _objPtr uintptr = pRes
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteInterp(tls, interp)
	for tcl.XTcl_DoOneEvent(tls, libc.CplInt32(int32(1)<<1)|int32(1)<<1) != 0 {
	}
	tcl.XTcl_ExitThread(tls, 0)

}

func sqlthread_spawn(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var pNew uintptr
	var rc int32

	var zVarname uintptr

	var zScript uintptr

	var nStack int32 = 0
	var flags int32 = 0000

	_ = clientData
	_ = objc

	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16)
	zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20)

	pNew = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(SqlThread{}))+uint32(*(*int32)(unsafe.Pointer(bp + 16)))+uint32(*(*int32)(unsafe.Pointer(bp + 20)))+uint32(2))
	(*SqlThread)(unsafe.Pointer(pNew)).FzVarname = pNew + 1*16
	(*SqlThread)(unsafe.Pointer(pNew)).FzScript = (*SqlThread)(unsafe.Pointer(pNew)).FzVarname + uintptr(*(*int32)(unsafe.Pointer(bp + 16))+1)
	libc.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzVarname, zVarname, uint32(*(*int32)(unsafe.Pointer(bp + 16))+1))
	libc.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzScript, zScript, uint32(*(*int32)(unsafe.Pointer(bp + 20))+1))
	(*SqlThread)(unsafe.Pointer(pNew)).Fparent = tcl.XTcl_GetCurrentThread(tls)
	(*SqlThread)(unsafe.Pointer(pNew)).Finterp = interp

	rc = tcl.XTcl_CreateThread(tls, bp+24, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{tclScriptThread})), pNew, nStack, flags)
	if rc != TCL_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+42999, 0))
		tcl.XTcl_Free(tls, pNew)
		return TCL_ERROR
	}

	return TCL_OK
}

func sqlthread_parent(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pEvent uintptr
	var zMsg uintptr

	var p uintptr = clientData

	_ = objc

	if p == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+43027, 0))
		return TCL_ERROR
	}

	zMsg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+16)
	pEvent = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(EvalEvent{}))+uint32(*(*int32)(unsafe.Pointer(bp + 16)))+uint32(1))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = pEvent + 1*16
	libc.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, uint32(*(*int32)(unsafe.Pointer(bp + 16))+1))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp
	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, TCL_QUEUE_TAIL)
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)

	return TCL_OK
}

func xBusy(tls *libc.TLS, pArg uintptr, nBusy int32) int32 {
	_ = pArg
	_ = nBusy
	sqlite3.Xsqlite3_sleep(tls, 50)
	return 1
}

func sqlthread_open(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(120)
	defer tls.Free(120)

	var zFilename uintptr

	_ = clientData
	_ = objc

	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	sqlite3.Xsqlite3_open(tls, zFilename, bp+16)
	Md5_Register(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_busy_handler(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{xBusy})), uintptr(0))

	if sqlite3TestMakePointerStr(tls, interp, bp+20, *(*uintptr)(unsafe.Pointer(bp + 16))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+20, 0))

	return TCL_OK
}

func sqlthread_id(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	var id Tcl_ThreadId = tcl.XTcl_GetCurrentThread(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(id)))
	_ = clientData
	_ = objc
	_ = objv
	return TCL_OK
}

func sqlthread_proc(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(84)
	defer tls.Free(84)

	*(*[5]struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	})(unsafe.Pointer(bp)) = [5]struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	}{
		{FzName: ts + 43044, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_parent})), FnArg: 1, FzUsage: ts + 10001},
		{FzName: ts + 43051, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_spawn})), FnArg: 2, FzUsage: ts + 43057},
		{FzName: ts + 41661, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_open})), FnArg: 1, FzUsage: ts + 43072},
		{FzName: ts + 43079, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_id})), FzUsage: ts + 584},
		{},
	}
	var pSub uintptr
	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2523)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp, int32(unsafe.Sizeof(struct {
			FzName  uintptr
			FxProc  uintptr
			FnArg   int32
			FzUsage uintptr
		}{})), ts+2014, 0, bp+80)
	if rc != TCL_OK {
		return rc
	}
	pSub = bp + uintptr(*(*int32)(unsafe.Pointer(bp + 80)))*16

	if objc < (*struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	})(unsafe.Pointer(pSub)).FnArg+2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*struct {
			FzName  uintptr
			FxProc  uintptr
			FnArg   int32
			FzUsage uintptr
		})(unsafe.Pointer(pSub)).FzUsage)
		return TCL_ERROR
	}

	return (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	})(unsafe.Pointer(pSub)).FxProc})).f(tls, clientData, interp, objc, objv)
}

func clock_seconds_proc(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	tcl.XTcl_GetTime(tls, bp)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*Tcl_Time)(unsafe.Pointer(bp)).Fsec))
	_ = clientData
	_ = objc
	_ = objv
	return TCL_OK
}

func clock_milliseconds_proc(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(8)
	defer tls.Free(8)

	tcl.XTcl_GetTime(tls, bp)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls,
		Tcl_WideInt((*Tcl_Time)(unsafe.Pointer(bp)).Fsec)*int64(1000)+Tcl_WideInt((*Tcl_Time)(unsafe.Pointer(bp)).Fusec/1000)))
	_ = clientData
	_ = objc
	_ = objv
	return TCL_OK
}

type UnlockNotification1 = struct {
	Ffired int32
	Fcond  pthread_cond_t
	Fmutex pthread_mutex_t
}

type UnlockNotification = UnlockNotification1

func unlock_notify_cb(tls *libc.TLS, apArg uintptr, nArg int32) {
	var i int32
	for i = 0; i < nArg; i++ {
		var p uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))
		libc.Xpthread_mutex_lock(tls, p+8)
		(*UnlockNotification)(unsafe.Pointer(p)).Ffired = 1
		libc.Xpthread_cond_signal(tls, p+4)
		libc.Xpthread_mutex_unlock(tls, p+8)
	}
}

func wait_for_unlock_notify(tls *libc.TLS, db uintptr) int32 {
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32

	(*UnlockNotification)(unsafe.Pointer(bp)).Ffired = 0
	libc.Xpthread_mutex_init(tls, bp+8, uintptr(0))
	libc.Xpthread_cond_init(tls, bp+4, uintptr(0))

	rc = sqlite3.Xsqlite3_unlock_notify(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{unlock_notify_cb})), bp)

	if rc == SQLITE_OK {
		libc.Xpthread_mutex_lock(tls, bp+8)
		if !((*UnlockNotification)(unsafe.Pointer(bp)).Ffired != 0) {
			libc.Xpthread_cond_wait(tls, bp+4, bp+8)
		}
		libc.Xpthread_mutex_unlock(tls, bp+8)
	}

	libc.Xpthread_cond_destroy(tls, bp+4)
	libc.Xpthread_mutex_destroy(tls, bp+8)

	return rc
}

func sqlite3_blocking_step(tls *libc.TLS, pStmt uintptr) int32 {
	var rc int32
	for SQLITE_LOCKED == libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt)) {
		rc = wait_for_unlock_notify(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt))
		if rc != SQLITE_OK {
			break
		}
		sqlite3.Xsqlite3_reset(tls, pStmt)
	}
	return rc
}

func sqlite3_blocking_prepare_v2(tls *libc.TLS, db uintptr, zSql uintptr, nSql int32, ppStmt uintptr, pz uintptr) int32 {
	var rc int32
	for SQLITE_LOCKED == libc.AssignInt32(&rc, sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, nSql, ppStmt, pz)) {
		rc = wait_for_unlock_notify(tls, db)
		if rc != SQLITE_OK {
			break
		}
	}
	return rc
}

func blocking_step_proc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	var pStmt uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21969)
		return TCL_ERROR
	}

	pStmt = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))))
	rc = sqlite3_blocking_step(tls, pStmt)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func blocking_prepare_v2_proc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(146)
	defer tls.Free(146)

	var zSql uintptr

	*(*uintptr)(unsafe.Pointer(bp + 92)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 88)) = uintptr(0)

	var rc int32
	var isBlocking int32 = libc.BoolInt32(!(clientData == uintptr(0)))

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19903,
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+22015, 0))
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+84) != 0 {
		return TCL_ERROR
	}

	if isBlocking != 0 {
		rc = sqlite3_blocking_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), zSql, *(*int32)(unsafe.Pointer(bp + 84)), bp+88, bp+92)
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80)), zSql, *(*int32)(unsafe.Pointer(bp + 84)), bp+88, bp+92)
	}

	if *(*uintptr)(unsafe.Pointer(bp + 92)) != 0 && objc >= 5 {
		if *(*int32)(unsafe.Pointer(bp + 84)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 84)) = *(*int32)(unsafe.Pointer(bp + 84)) - (int32(*(*uintptr)(unsafe.Pointer(bp + 92)))-int32(zSql))/1
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 92)), *(*int32)(unsafe.Pointer(bp + 84))), 0)
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96, ts+43082, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc)))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+96, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 88)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96, *(*uintptr)(unsafe.Pointer(bp + 88))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+96, 0))
	}
	return TCL_OK
}

func SqlitetestThread_Init(tls *libc.TLS, interp uintptr) int32 {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*[6]TclCmd)(unsafe.Pointer(bp)) = [6]TclCmd{
		{FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_proc})), FzName: ts + 42904},
		{FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{clock_seconds_proc})), FzName: ts + 43086},
		{FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{clock_milliseconds_proc})), FzName: ts + 43099},
		{FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_step_proc})), FzName: ts + 42914},
		{FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), FzName: ts + 42936, FiCtx: 1},
		{FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), FzName: ts + 42964},
	}
	var ii int32

	for ii = 0; uint32(ii) < uint32(unsafe.Sizeof([6]TclCmd{}))/uint32(unsafe.Sizeof(TclCmd{})); ii++ {
		var p uintptr = uintptr((*TclCmd)(unsafe.Pointer(bp + uintptr(ii)*12)).FiCtx)
		tcl.XTcl_CreateObjCommand(tls, interp, (*TclCmd)(unsafe.Pointer(bp+uintptr(ii)*12)).FzName, (*TclCmd)(unsafe.Pointer(bp+uintptr(ii)*12)).FxProc, p, uintptr(0))
	}
	return TCL_OK
}

type TclCmd = struct {
	FxProc uintptr
	FzName uintptr
	FiCtx  int32
}

func Sqlitetestvdbecov_Init(tls *libc.TLS, interp uintptr) int32 {
	return TCL_OK
}

type Testvfs1 = struct {
	FzName        uintptr
	FpParent      uintptr
	FpVfs         uintptr
	Finterp       uintptr
	FpScript      uintptr
	FpBuffer      uintptr
	FisNoshm      int32
	FisFullshm    int32
	Fmask         int32
	Fioerr_err    TestFaultInject
	Ffull_err     TestFaultInject
	Fcantopen_err TestFaultInject
	FiDevchar     int32
	FiSectorsize  int32
}

type Testvfs = Testvfs1
type TestvfsBuffer1 = struct {
	FzFile uintptr
	Fpgsz  int32
	FaPage [1024]uintptr
	FpFile uintptr
	FpNext uintptr
}

type TestvfsBuffer = TestvfsBuffer1
type TestvfsFile1 = struct {
	Fbase sqlite3_file
	FpFd  uintptr
}

type TestvfsFile = TestvfsFile1
type TestvfsFd1 = struct {
	FpVfs       uintptr
	FzFilename  uintptr
	FpReal      uintptr
	FpShmId     uintptr
	FpShm       uintptr
	Fexcllock   u32
	Fsharedlock u32
	FpNext      uintptr
}

type TestvfsFd = TestvfsFd1

type TestFaultInject1 = struct {
	FiCnt   int32
	FeFault int32
	FnFail  int32
}

type TestFaultInject = TestFaultInject1

var tvfs_io_methods = sqlite3_io_methods{
	FiVersion:               3,
	FxClose:                 0,
	FxRead:                  0,
	FxWrite:                 0,
	FxTruncate:              0,
	FxSync:                  0,
	FxFileSize:              0,
	FxLock:                  0,
	FxUnlock:                0,
	FxCheckReservedLock:     0,
	FxFileControl:           0,
	FxSectorSize:            0,
	FxDeviceCharacteristics: 0,
	FxShmMap:                0,
	FxShmLock:               0,
	FxShmBarrier:            0,
	FxShmUnmap:              0,
	FxFetch:                 0,
	FxUnfetch:               0,
}

func tvfsResultCode(tls *libc.TLS, p uintptr, pRc uintptr) int32 {
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*[9]errcode)(unsafe.Pointer(bp)) = [9]errcode{
		{FzCode: ts + 2127},
		{FeCode: SQLITE_ERROR, FzCode: ts + 2114},
		{FeCode: SQLITE_IOERR, FzCode: ts + 43118},
		{FeCode: SQLITE_LOCKED, FzCode: ts + 43131},
		{FeCode: SQLITE_BUSY, FzCode: ts + 43145},
		{FeCode: SQLITE_READONLY, FzCode: ts + 43157},
		{FeCode: SQLITE_READONLY | int32(5)<<8, FzCode: ts + 43173},
		{FeCode: SQLITE_NOTFOUND, FzCode: ts + 43198},
		{FeCode: -1, FzCode: ts + 43214},
	}
	var z uintptr
	var i int32

	z = tcl.XTcl_GetStringResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	for i = 0; i < int32(uint32(unsafe.Sizeof([9]errcode{}))/uint32(unsafe.Sizeof(errcode{}))); i++ {
		if 0 == libc.Xstrcmp(tls, z, (*errcode)(unsafe.Pointer(bp+uintptr(i)*8)).FzCode) {
			*(*int32)(unsafe.Pointer(pRc)) = (*errcode)(unsafe.Pointer(bp + uintptr(i)*8)).FeCode
			return 1
		}
	}

	return 0
}

type errcode = struct {
	FeCode int32
	FzCode uintptr
}

func tvfsInjectFault(tls *libc.TLS, p uintptr) int32 {
	var ret int32 = 0
	if (*TestFaultInject)(unsafe.Pointer(p)).FeFault != 0 {
		(*TestFaultInject)(unsafe.Pointer(p)).FiCnt--
		if (*TestFaultInject)(unsafe.Pointer(p)).FiCnt == 0 || (*TestFaultInject)(unsafe.Pointer(p)).FiCnt < 0 && (*TestFaultInject)(unsafe.Pointer(p)).FeFault == FAULT_INJECT_PERSISTENT {
			ret = 1
			(*TestFaultInject)(unsafe.Pointer(p)).FnFail++
		}
	}
	return ret
}

func tvfsInjectIoerr(tls *libc.TLS, p uintptr) int32 {
	return tvfsInjectFault(tls, p+36)
}

func tvfsInjectFullerr(tls *libc.TLS, p uintptr) int32 {
	return tvfsInjectFault(tls, p+48)
}

func tvfsInjectCantopenerr(tls *libc.TLS, p uintptr) int32 {
	return tvfsInjectFault(tls, p+60)
}

func tvfsExecTcl(tls *libc.TLS, p uintptr, zMethod uintptr, arg1 uintptr, arg2 uintptr, arg3 uintptr, arg4 uintptr) {
	var rc int32
	var pEval uintptr

	pEval = tcl.XTcl_DuplicateObj(tls, (*Testvfs)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zMethod, -1))
	if arg1 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg1)
	}
	if arg2 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg2)
	}
	if arg3 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg3)
	}
	if arg4 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg4)
	}

	rc = tcl.XTcl_EvalObjEx(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	}
}

func tvfsClose(tls *libc.TLS, pFile uintptr) int32 {
	var pTestfile uintptr = pFile
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_CLOSE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+40184,
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	}
	if (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods != 0 {
		tcl.XTcl_Free(tls, (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)
	}
	sqlite3.Xsqlite3OsClose(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
	tcl.XTcl_Free(tls, pFd)
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = uintptr(0)
	return SQLITE_OK
}

func tvfsRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_READ_MASK != 0 {
		tvfsExecTcl(tls, p, ts+40191,
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp)
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_READ_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3OsRead(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_WRITE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+40197,
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewWideIntObj(tls, iOfst), tcl.XTcl_NewIntObj(tls, iAmt))
		tvfsResultCode(tls, p, bp)
		if *(*int32)(unsafe.Pointer(bp)) < 0 {
			return SQLITE_OK
		}
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && tvfsInjectFullerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp)) = SQLITE_FULL
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_WRITE_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3OsWrite(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_TRUNCATE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+40204,
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp)
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3OsTruncate(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, size)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsSync(tls *libc.TLS, pFile uintptr, flags int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SYNC_MASK != 0 {
		var zFlags uintptr = uintptr(0)

		switch flags {
		case SQLITE_SYNC_NORMAL:
			zFlags = ts + 21271
			break
			fallthrough
		case SQLITE_SYNC_FULL:
			zFlags = ts + 23230
			break
			fallthrough
		case SQLITE_SYNC_NORMAL | SQLITE_SYNC_DATAONLY:
			zFlags = ts + 43226
			break
			fallthrough
		case SQLITE_SYNC_FULL | SQLITE_SYNC_DATAONLY:
			zFlags = ts + 43242
			break
			fallthrough
		default:
		}

		tvfsExecTcl(tls, p, ts+32466,
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, zFlags, -1), uintptr(0))
		tvfsResultCode(tls, p, bp)
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && tvfsInjectFullerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp)) = SQLITE_FULL
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3OsSync(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags)
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 {
	var p uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFileSize(tls, (*TestvfsFd)(unsafe.Pointer(p)).FpReal, pSize)
}

func tvfsLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_LOCK_MASK != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8, ts+1333, libc.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+40224, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8, -1), uintptr(0), uintptr(0))
	}
	if (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_LOCK_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		return SQLITE_IOERR | int32(15)<<8
	}
	return sqlite3.Xsqlite3OsLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

func tvfsUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 {
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_UNLOCK_MASK != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8, ts+1333, libc.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+40230, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8, -1), uintptr(0), uintptr(0))
	}
	if (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_UNLOCK_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		return SQLITE_IOERR | int32(8)<<8
	}
	return sqlite3.Xsqlite3OsUnlock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

func tvfsCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 {
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_CKLOCK_MASK != 0 {
		tvfsExecTcl(tls, p, ts+43256, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			uintptr(0), uintptr(0), uintptr(0))
	}
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, pResOut)
}

func tvfsFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 {
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if op == SQLITE_FCNTL_PRAGMA {
		var argv uintptr = pArg
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+10051) == 0 {
			var rc int32 = SQLITE_ERROR
			if *(*uintptr)(unsafe.Pointer(argv + 2*4)) != 0 {
				var z uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*4))
				var x int32 = libc.Xatoi(tls, z)
				if x != 0 {
					rc = x
					for int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x04 != 0 {
						z++
					}
					for int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x01 != 0 {
						z++
					}
				}
				if *(*int8)(unsafe.Pointer(z)) != 0 {
					*(*uintptr)(unsafe.Pointer(argv)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp, z))
				}
			}
			return rc
		}
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*4)), ts+5151) == 0 {
			*(*uintptr)(unsafe.Pointer(argv)) = sqlite3.Xsqlite3_mprintf(tls, ts, libc.VaList(bp+8, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
			return SQLITE_OK
		}
	}
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_FCNTL_MASK != 0 {
		*(*[3]Fcntl)(unsafe.Pointer(bp + 16)) = [3]Fcntl{
			{FiFnctl: SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, FzFnctl: ts + 43275},
			{FiFnctl: SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, FzFnctl: ts + 43294},
			{FiFnctl: SQLITE_FCNTL_ZIPVFS, FzFnctl: ts + 43314},
		}
		var i int32
		for i = 0; uint32(i) < uint32(unsafe.Sizeof([3]Fcntl{}))/uint32(unsafe.Sizeof(Fcntl{})); i++ {
			if op == (*Fcntl)(unsafe.Pointer(bp+16+uintptr(i)*8)).FiFnctl {
				break
			}
		}
		if uint32(i) < uint32(unsafe.Sizeof([3]Fcntl{}))/uint32(unsafe.Sizeof(Fcntl{})) {
			*(*int32)(unsafe.Pointer(bp + 40)) = 0
			tvfsExecTcl(tls, p, ts+40252,
				tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
				tcl.XTcl_NewStringObj(tls, (*Fcntl)(unsafe.Pointer(bp+16+uintptr(i)*8)).FzFnctl, -1),
				uintptr(0), uintptr(0))
			tvfsResultCode(tls, p, bp+40)
			if *(*int32)(unsafe.Pointer(bp + 40)) != 0 {
				return func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 40)) < 0 {
						return SQLITE_OK
					}
					return *(*int32)(unsafe.Pointer(bp + 40))
				}()
			}
		}
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, op, pArg)
}

type Fcntl = struct {
	FiFnctl int32
	FzFnctl uintptr
}

func tvfsSectorSize(tls *libc.TLS, pFile uintptr) int32 {
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiSectorsize >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiSectorsize
	}
	return sqlite3.Xsqlite3OsSectorSize(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

func tvfsDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 {
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiDevchar >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiDevchar
	}
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

func tvfsOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pTestfile uintptr = pFile
	var pFd uintptr
	var pId uintptr = uintptr(0)
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	pFd = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestvfsFd{}))+uint32((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent)).FszOsFile))
	libc.Xmemset(tls, pFd, 0, uint32(unsafe.Sizeof(TestvfsFd{}))+uint32((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent)).FszOsFile))
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename = zName
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs = pVfs
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpReal = pFd + 1*32
	libc.Xmemset(tls, pTestfile, 0, uint32(unsafe.Sizeof(TestvfsFile{})))
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = pFd

	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_OPEN_MASK != 0 {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		if flags&SQLITE_OPEN_MAIN_DB != 0 {
			var z uintptr = zName + uintptr(libc.Xstrlen(tls, zName)+size_t(1))
			for *(*int8)(unsafe.Pointer(z)) != 0 {
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += uintptr(libc.Xstrlen(tls, z) + size_t(1))
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += uintptr(libc.Xstrlen(tls, z) + size_t(1))
			}
		}
		tvfsExecTcl(tls, p, ts+32044, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), pArg, uintptr(0), uintptr(0))
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pArg
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp))
			}
		} else {
			pId = tcl.XTcl_GetObjResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_OPEN_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		return SQLITE_IOERR
	}
	if tvfsInjectCantopenerr(tls, p) != 0 {
		return SQLITE_CANTOPEN
	}
	if tvfsInjectFullerr(tls, p) != 0 {
		return SQLITE_FULL
	}

	if !(pId != 0) {
		pId = tcl.XTcl_NewStringObj(tls, ts+43321, -1)
	}
	(*Tcl_Obj)(unsafe.Pointer(pId)).FrefCount++
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = pId
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)

	*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3OsOpen(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zName, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods != 0 {
		var pMethods uintptr
		var nByte int32

		if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1 {
			nByte = int32(unsafe.Sizeof(sqlite3_io_methods{}))
		} else {
			nByte = int32(uintptr(0) + 52)
		}

		pMethods = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemcpy(tls, pMethods, uintptr(unsafe.Pointer(&tvfs_io_methods)), uint32(nByte))
		(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods)).FiVersion
		if (*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion > (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion
		}
		if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1 && (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FisNoshm != 0 {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmUnmap = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmLock = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmBarrier = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmMap = uintptr(0)
		}
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = pMethods
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_DELETE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+40289,
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewIntObj(tls, dirSync), uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp)
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp)) = sqlite3.Xsqlite3OsDelete(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, dirSync)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_ACCESS_MASK != 0 {
		var zArg uintptr = uintptr(0)
		if flags == SQLITE_ACCESS_EXISTS {
			zArg = ts + 43326
		}
		if flags == SQLITE_ACCESS_READWRITE {
			zArg = ts + 43347
		}
		if flags == SQLITE_ACCESS_READ {
			zArg = ts + 43371
		}
		tvfsExecTcl(tls, p, ts+40297,
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewStringObj(tls, zArg, -1), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp))
			}
		} else {
			var interp uintptr = (*Testvfs)(unsafe.Pointer(p)).Finterp
			if TCL_OK == tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), tcl.XTcl_GetObjResult(tls, interp), pResOut) {
				return SQLITE_OK
			}
		}
	}
	return sqlite3.Xsqlite3OsAccess(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, flags, pResOut)
}

func tvfsFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_FULLPATHNAME_MASK != 0 {
		tvfsExecTcl(tls, p, ts+40305, tcl.XTcl_NewStringObj(tls, zPath, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp))
			}
		}
	}
	return sqlite3.Xsqlite3OsFullPathname(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, nOut, zOut)
}

func tvfsRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 {
	return sqlite3.Xsqlite3OsRandomness(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nByte, zBufOut)
}

func tvfsSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 {
	return sqlite3.Xsqlite3OsSleep(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nMicro)
}

func tvfsCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 {
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent)).FxCurrentTime})).f(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, pTimeOut)
}

func tvfsShmOpen(tls *libc.TLS, pFile uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pBuffer uintptr
	var pFd uintptr

	pFd = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	p = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMOPEN_MASK != 0 {
		tvfsExecTcl(tls, p, ts+43390, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp))
			}
		}
	}

	if (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMOPEN_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		return SQLITE_IOERR
	}

	for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
		if 0 == libc.Xstrcmp(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile) {
			break
		}
	}
	if !(pBuffer != 0) {
		var szName int32 = int32(libc.Xstrlen(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
		var nByte int32 = int32(uint32(unsafe.Sizeof(TestvfsBuffer{})) + uint32(szName) + uint32(1))
		pBuffer = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemset(tls, pBuffer, 0, uint32(nByte))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile = pBuffer + 1*4112
		libc.Xmemcpy(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, uint32(szName+1))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext = (*Testvfs)(unsafe.Pointer(p)).FpBuffer
		(*Testvfs)(unsafe.Pointer(p)).FpBuffer = pBuffer
	}

	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile
	(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile = pFd
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = pBuffer
	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsAllocPage(tls *libc.TLS, p uintptr, iPage int32, pgsz int32) {
	if *(*uintptr)(unsafe.Pointer(p + 8 + uintptr(iPage)*4)) == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(p + 8 + uintptr(iPage)*4)) = tcl.XTcl_Alloc(tls, uint32(pgsz))
		libc.Xmemset(tls, *(*uintptr)(unsafe.Pointer(p + 8 + uintptr(iPage)*4)), 0, uint32(pgsz))
		(*TestvfsBuffer)(unsafe.Pointer(p)).Fpgsz = pgsz
	}
}

func tvfsShmMap(tls *libc.TLS, pFile uintptr, iPage int32, pgsz int32, isWrite int32, pp uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmMap})).f(tls, pReal, iPage, pgsz, isWrite, pp)
	}

	if uintptr(0) == (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm {
		*(*int32)(unsafe.Pointer(bp)) = tvfsShmOpen(tls, pFile)
		if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp))
		}
	}

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMMAP_MASK != 0 {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, iPage))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, pgsz))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, isWrite))
		tvfsExecTcl(tls, p, ts+40382,
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, pArg, uintptr(0))
		tvfsResultCode(tls, p, bp)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = pArg
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMMAP_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && isWrite != 0 && !(int32(*(*uintptr)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 8 + uintptr(iPage)*4))) != 0) {
		tvfsAllocPage(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm, iPage, pgsz)
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK || *(*int32)(unsafe.Pointer(bp)) == SQLITE_READONLY {
		*(*uintptr)(unsafe.Pointer(pp)) = *(*uintptr)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 8 + uintptr(iPage)*4))
	}

	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 {
	bp := tls.Alloc(100)
	defer tls.Free(100)

	*(*int32)(unsafe.Pointer(bp + 96)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var nLock int32

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmLock})).f(tls, pReal, ofst, n, flags)
	}

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMLOCK_MASK != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+16, ts+22765, libc.VaList(bp, ofst, n))
		nLock = int32(libc.Xstrlen(tls, bp+16))
		if flags&SQLITE_SHM_LOCK != 0 {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+43399)
		} else {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+43405)
		}
		nLock = nLock + int32(libc.Xstrlen(tls, bp+16+uintptr(nLock)))
		if flags&SQLITE_SHM_SHARED != 0 {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+43413)
		} else {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+43421)
		}
		tvfsExecTcl(tls, p, ts+40361,
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, bp+16, -1), uintptr(0))
		tvfsResultCode(tls, p, bp+96)
	}

	if *(*int32)(unsafe.Pointer(bp + 96)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMLOCK_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp + 96)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp + 96)) == SQLITE_OK {
		var isLock int32 = flags & SQLITE_SHM_LOCK
		var isExcl int32 = flags & SQLITE_SHM_EXCLUSIVE
		var mask u32 = u32((int32(1)<<n - 1) << ofst)
		if isLock != 0 {
			var p2 uintptr
			for p2 = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FpFile; p2 != 0; p2 = (*TestvfsFd)(unsafe.Pointer(p2)).FpNext {
				if p2 == pFd {
					continue
				}
				if (*TestvfsFd)(unsafe.Pointer(p2)).Fexcllock&mask != 0 || isExcl != 0 && (*TestvfsFd)(unsafe.Pointer(p2)).Fsharedlock&mask != 0 {
					*(*int32)(unsafe.Pointer(bp + 96)) = SQLITE_BUSY
					break
				}
			}
			if *(*int32)(unsafe.Pointer(bp + 96)) == SQLITE_OK {
				if isExcl != 0 {
					*(*u32)(unsafe.Pointer(pFd + 20)) |= mask
				}
				if !(isExcl != 0) {
					*(*u32)(unsafe.Pointer(pFd + 24)) |= mask
				}
			}
		} else {
			if isExcl != 0 {
				*(*u32)(unsafe.Pointer(pFd + 20)) &= ^mask
			}
			if !(isExcl != 0) {
				*(*u32)(unsafe.Pointer(pFd + 24)) &= ^mask
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 96))
}

func tvfsShmBarrier(tls *libc.TLS, pFile uintptr) {
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMBARRIER_MASK != 0 {
		var z uintptr
		if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm != 0 {
			z = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile
		} else {
			z = ts + 584
		}
		tvfsExecTcl(tls, p, ts+40370, tcl.XTcl_NewStringObj(tls, z, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmBarrier})).f(tls, pReal)
		return
	}
}

func tvfsShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var pBuffer uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm
	var ppFd uintptr

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmUnmap})).f(tls, pReal, deleteFlag)
	}

	if !(pBuffer != 0) {
		return SQLITE_OK
	}

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMCLOSE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+40351,
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp)
	}

	for ppFd = pBuffer + 4104; *(*uintptr)(unsafe.Pointer(ppFd)) != pFd; ppFd = *(*uintptr)(unsafe.Pointer(ppFd)) + 28 {
	}

	*(*uintptr)(unsafe.Pointer(ppFd)) = (*TestvfsFd)(unsafe.Pointer(pFd)).FpNext
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = uintptr(0)

	if (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile == uintptr(0) {
		var i int32
		var pp uintptr
		for pp = p + 20; *(*uintptr)(unsafe.Pointer(pp)) != pBuffer; pp = *(*uintptr)(unsafe.Pointer(pp)) + 4108 {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*TestvfsBuffer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNext
		for i = 0; *(*uintptr)(unsafe.Pointer(pBuffer + 8 + uintptr(i)*4)) != 0; i++ {
			tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(pBuffer + 8 + uintptr(i)*4)))
		}
		tcl.XTcl_Free(tls, pBuffer)
	}
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)

	return *(*int32)(unsafe.Pointer(bp))
}

func tvfsFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 {
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, iAmt, pp)
}

func tvfsUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, p uintptr) int32 {
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsUnfetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, p)
}

func testvfs_obj_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(348)
	defer tls.Free(348)

	var p uintptr = cd
	*(*[10]TestvfsSubcmd)(unsafe.Pointer(bp + 96)) = [10]TestvfsSubcmd{
		{FzName: ts + 43432},
		{FzName: ts + 15040, FeCmd: uint32(1)},
		{FzName: ts + 43436, FeCmd: uint32(2)},
		{FzName: ts + 43443, FeCmd: uint32(3)},
		{FzName: ts + 43449, FeCmd: uint32(7)},
		{FzName: ts + 43457, FeCmd: uint32(8)},
		{FzName: ts + 43469, FeCmd: uint32(4)},
		{FzName: ts + 43476, FeCmd: uint32(5)},
		{FzName: ts + 43484, FeCmd: uint32(6)},
		{},
	}

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*4)), bp+96, int32(unsafe.Sizeof(TestvfsSubcmd{})), ts+43495, 0, bp+176) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_ResetResult(tls, interp)

	switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 + uintptr(*(*int32)(unsafe.Pointer(bp + 176)))*8)).FeCmd {
	case uint32(0):
		{
			var pObj uintptr
			var rc int32
			var pBuffer uintptr
			var zName uintptr
			if objc != 3 && objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43506)
				return TCL_ERROR
			}
			zName = tcl.XTcl_Alloc(tls, uint32((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname))
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FxFullPathname})).f(tls,
				(*Testvfs)(unsafe.Pointer(p)).FpParent, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))),
				(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname, zName)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+43519,
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
				tcl.XTcl_Free(tls, zName)
				return TCL_ERROR
			}
			for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
				if 0 == libc.Xstrcmp(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, zName) {
					break
				}
			}
			tcl.XTcl_Free(tls, zName)
			if !(pBuffer != 0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+43545, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
				return TCL_ERROR
			}
			if objc == 4 {
				var a uintptr = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+180)
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				for *(*int32)(unsafe.Pointer(bp + 176)) = 0; *(*int32)(unsafe.Pointer(bp + 176))*pgsz < *(*int32)(unsafe.Pointer(bp + 180)); *(*int32)(unsafe.Pointer(bp + 176))++ {
					var nByte int32 = pgsz
					tvfsAllocPage(tls, pBuffer, *(*int32)(unsafe.Pointer(bp + 176)), pgsz)
					if *(*int32)(unsafe.Pointer(bp + 180))-*(*int32)(unsafe.Pointer(bp + 176))*pgsz < pgsz {
						nByte = *(*int32)(unsafe.Pointer(bp + 180))
					}
					libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(pBuffer + 8 + uintptr(*(*int32)(unsafe.Pointer(bp + 176)))*4)), a+uintptr(*(*int32)(unsafe.Pointer(bp + 176))*pgsz), uint32(nByte))
				}
			}

			pObj = tcl.XTcl_NewObj(tls)
			for *(*int32)(unsafe.Pointer(bp + 176)) = 0; *(*uintptr)(unsafe.Pointer(pBuffer + 8 + uintptr(*(*int32)(unsafe.Pointer(bp + 176)))*4)) != 0; *(*int32)(unsafe.Pointer(bp + 176))++ {
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				tcl.XTcl_AppendObjToObj(tls, pObj, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(pBuffer + 8 + uintptr(*(*int32)(unsafe.Pointer(bp + 176)))*4)), pgsz))
			}
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break

		}

	case uint32(2):
		{
			*(*uintptr)(unsafe.Pointer(bp + 188)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 184)) = 0
			var mask int32 = 0
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+37047)
				return TCL_ERROR
			}
			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+184, bp+188) != 0 {
				return TCL_ERROR
			}
			tcl.XTcl_ResetResult(tls, interp)
			for *(*int32)(unsafe.Pointer(bp + 176)) = 0; *(*int32)(unsafe.Pointer(bp + 176)) < *(*int32)(unsafe.Pointer(bp + 184)); *(*int32)(unsafe.Pointer(bp + 176))++ {
				var iMethod int32
				var zElem uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 188)) + uintptr(*(*int32)(unsafe.Pointer(bp + 176)))*4)))
				for iMethod = 0; iMethod < int32(uint32(unsafe.Sizeof(vfsmethod))/uint32(unsafe.Sizeof(VfsMethod{}))); iMethod++ {
					if libc.Xstrcmp(tls, zElem, vfsmethod[iMethod].FzName) == 0 {
						mask = mask | vfsmethod[iMethod].Fmask
						break
					}
				}
				if iMethod == int32(uint32(unsafe.Sizeof(vfsmethod))/uint32(unsafe.Sizeof(VfsMethod{}))) {
					tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+43560, zElem, 0))
					return TCL_ERROR
				}
			}
			(*Testvfs)(unsafe.Pointer(p)).Fmask = mask
			break

		}

	case uint32(4):
		{
			if objc == 3 {
				if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
					for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
						var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
						if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
							tcl.XTclFreeObj(tls, _objPtr)
						}
					}
					(*Testvfs)(unsafe.Pointer(p)).FpScript = uintptr(0)
				}
				tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+192)
				if *(*int32)(unsafe.Pointer(bp + 192)) > 0 {
					(*Testvfs)(unsafe.Pointer(p)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
					(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
				}
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18210)
				return TCL_ERROR
			}

			tcl.XTcl_ResetResult(tls, interp)
			if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
				tcl.XTcl_SetObjResult(tls, interp, (*Testvfs)(unsafe.Pointer(p)).FpScript)
			}

			break

		}

	case uint32(8):
		fallthrough
	case uint32(3):
		fallthrough
	case uint32(7):
		{
			var pTest uintptr = uintptr(0)
			var iRet int32

			switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 + uintptr(*(*int32)(unsafe.Pointer(bp + 176)))*8)).FeCmd {
			case uint32(3):
				pTest = p + 36
				break
			case uint32(7):
				pTest = p + 48
				break
			case uint32(8):
				pTest = p + 60
				break
			default:
			}
			iRet = (*TestFaultInject)(unsafe.Pointer(pTest)).FnFail
			(*TestFaultInject)(unsafe.Pointer(pTest)).FnFail = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = 0

			if objc == 4 {
				if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+196) ||
					TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+200) {
					return TCL_ERROR
				}
				(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 200)) != 0 {
						return FAULT_INJECT_PERSISTENT
					}
					return FAULT_INJECT_TRANSIENT
				}()
				(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = *(*int32)(unsafe.Pointer(bp + 196))
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43577)
				return TCL_ERROR
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iRet))
			break

		}

	case uint32(1):
		{
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
			break

		}

	case uint32(5):
		{
			*(*[16]DeviceFlag)(unsafe.Pointer(bp + 212)) = [16]DeviceFlag{
				{FzName: ts + 43591, FiValue: -1},
				{FzName: ts + 31198, FiValue: SQLITE_IOCAP_ATOMIC},
				{FzName: ts + 31205, FiValue: SQLITE_IOCAP_ATOMIC512},
				{FzName: ts + 31215, FiValue: SQLITE_IOCAP_ATOMIC1K},
				{FzName: ts + 31224, FiValue: SQLITE_IOCAP_ATOMIC2K},
				{FzName: ts + 31233, FiValue: SQLITE_IOCAP_ATOMIC4K},
				{FzName: ts + 31242, FiValue: SQLITE_IOCAP_ATOMIC8K},
				{FzName: ts + 31251, FiValue: SQLITE_IOCAP_ATOMIC16K},
				{FzName: ts + 31261, FiValue: SQLITE_IOCAP_ATOMIC32K},
				{FzName: ts + 31271, FiValue: SQLITE_IOCAP_ATOMIC64K},
				{FzName: ts + 31281, FiValue: SQLITE_IOCAP_SEQUENTIAL},
				{FzName: ts + 31292, FiValue: SQLITE_IOCAP_SAFE_APPEND},
				{FzName: ts + 43599, FiValue: SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN},
				{FzName: ts + 31304, FiValue: SQLITE_IOCAP_POWERSAFE_OVERWRITE},
				{FzName: ts + 43621, FiValue: SQLITE_IOCAP_IMMUTABLE},
				{},
			}
			var pRet uintptr
			var iFlag int32

			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43631)
				return TCL_ERROR
			}
			if objc == 3 {
				var j int32
				var iNew int32 = 0
				*(*uintptr)(unsafe.Pointer(bp + 208)) = uintptr(0)
				*(*int32)(unsafe.Pointer(bp + 204)) = 0

				if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+204, bp+208) != 0 {
					return TCL_ERROR
				}

				for j = 0; j < *(*int32)(unsafe.Pointer(bp + 204)); j++ {
					*(*int32)(unsafe.Pointer(bp + 340)) = 0
					if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 208)) + uintptr(j)*4)), bp+212,
						int32(unsafe.Sizeof(DeviceFlag{})), ts+22558, 0, bp+340) != 0 {
						return TCL_ERROR
					}
					if (*DeviceFlag)(unsafe.Pointer(bp+212+uintptr(*(*int32)(unsafe.Pointer(bp + 340)))*8)).FiValue < 0 && *(*int32)(unsafe.Pointer(bp + 204)) > 1 {
						tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+43643, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4))), 0))
						return TCL_ERROR
					}
					iNew = iNew | (*DeviceFlag)(unsafe.Pointer(bp+212+uintptr(*(*int32)(unsafe.Pointer(bp + 340)))*8)).FiValue
				}

				(*Testvfs)(unsafe.Pointer(p)).FiDevchar = iNew | 0x10000000
			}

			pRet = tcl.XTcl_NewObj(tls)
			for iFlag = 0; uint32(iFlag) < uint32(unsafe.Sizeof([16]DeviceFlag{}))/uint32(unsafe.Sizeof(DeviceFlag{})); iFlag++ {
				if (*Testvfs)(unsafe.Pointer(p)).FiDevchar&(*DeviceFlag)(unsafe.Pointer(bp+212+uintptr(iFlag)*8)).FiValue != 0 {
					tcl.XTcl_ListObjAppendElement(tls,
						interp, pRet, tcl.XTcl_NewStringObj(tls, (*DeviceFlag)(unsafe.Pointer(bp+212+uintptr(iFlag)*8)).FzName, -1))
				}
			}
			tcl.XTcl_SetObjResult(tls, interp, pRet)

			break

		}

	case uint32(6):
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43655)
				return TCL_ERROR
			}
			if objc == 3 {
				*(*int32)(unsafe.Pointer(bp + 344)) = 0
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*4)), bp+344) != 0 {
					return TCL_ERROR
				}
				(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = *(*int32)(unsafe.Pointer(bp + 344))
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*Testvfs)(unsafe.Pointer(p)).FiSectorsize))
			break

		}
	}

	return TCL_OK
}

type TestvfsSubcmd = struct {
	FzName uintptr
	FeCmd  uint32
}

type VfsMethod = struct {
	FzName uintptr
	Fmask  int32
}

var vfsmethod = [18]VfsMethod{
	{FzName: ts + 43390, Fmask: TESTVFS_SHMOPEN_MASK},
	{FzName: ts + 40361, Fmask: TESTVFS_SHMLOCK_MASK},
	{FzName: ts + 40370, Fmask: TESTVFS_SHMBARRIER_MASK},
	{FzName: ts + 40351, Fmask: TESTVFS_SHMCLOSE_MASK},
	{FzName: ts + 40382, Fmask: TESTVFS_SHMMAP_MASK},
	{FzName: ts + 32466, Fmask: TESTVFS_SYNC_MASK},
	{FzName: ts + 40289, Fmask: TESTVFS_DELETE_MASK},
	{FzName: ts + 40197, Fmask: TESTVFS_WRITE_MASK},
	{FzName: ts + 40191, Fmask: TESTVFS_READ_MASK},
	{FzName: ts + 40204, Fmask: TESTVFS_TRUNCATE_MASK},
	{FzName: ts + 32044, Fmask: TESTVFS_OPEN_MASK},
	{FzName: ts + 40184, Fmask: TESTVFS_CLOSE_MASK},
	{FzName: ts + 40297, Fmask: TESTVFS_ACCESS_MASK},
	{FzName: ts + 40305, Fmask: TESTVFS_FULLPATHNAME_MASK},
	{FzName: ts + 40230, Fmask: TESTVFS_UNLOCK_MASK},
	{FzName: ts + 40224, Fmask: TESTVFS_LOCK_MASK},
	{FzName: ts + 43256, Fmask: TESTVFS_CKLOCK_MASK},
	{FzName: ts + 40252, Fmask: TESTVFS_FCNTL_MASK},
}

func testvfs_obj_del(tls *libc.TLS, cd ClientData) {
	var p uintptr = cd
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	libc.Xmemset(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs, 0, uint32(unsafe.Sizeof(sqlite3_vfs{})))
	tcl.XTcl_Free(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(Testvfs{})))
	tcl.XTcl_Free(tls, p)
}

func testvfs_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var p uintptr
	var pVfs uintptr
	var zVfs uintptr
	var nByte int32

	var i int32

	var zSwitch uintptr
	*(*int32)(unsafe.Pointer(bp + 4)) = 0
	*(*int32)(unsafe.Pointer(bp + 24)) = 0
	*(*int32)(unsafe.Pointer(bp + 8)) = 0
	*(*int32)(unsafe.Pointer(bp + 12)) = 0
	*(*int32)(unsafe.Pointer(bp + 16)) = -1
	*(*int32)(unsafe.Pointer(bp + 20)) = 3

	if !(objc < 2 || 0 != objc%2) {
		goto __1
	}
	goto bad_args
__1:
	;
	i = 2
__2:
	if !(i < objc) {
		goto __4
	}
	zSwitch = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*4)), bp)

	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+43663, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp))))) {
		goto __5
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+4) != 0) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 4)) != 0) {
		goto __8
	}
	*(*int32)(unsafe.Pointer(bp + 24)) = 0
__8:
	;
	goto __6
__5:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+31574, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp))))) {
		goto __9
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+8) != 0) {
		goto __11
	}
	return TCL_ERROR
__11:
	;
	goto __10
__9:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+43670, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp))))) {
		goto __12
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+12) != 0) {
		goto __14
	}
	return TCL_ERROR
__14:
	;
	goto __13
__12:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+43680, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp))))) {
		goto __15
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+16) != 0) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	goto __16
__15:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+43692, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp))))) {
		goto __18
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+20) != 0) {
		goto __20
	}
	return TCL_ERROR
__20:
	;
	goto __19
__18:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+43702, zSwitch, uint32(*(*int32)(unsafe.Pointer(bp))))) {
		goto __21
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*4)), bp+24) != 0) {
		goto __23
	}
	return TCL_ERROR
__23:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 24)) != 0) {
		goto __24
	}
	*(*int32)(unsafe.Pointer(bp + 4)) = 0
__24:
	;
	goto __22
__21:
	goto bad_args
__22:
	;
__19:
	;
__16:
	;
__13:
	;
__10:
	;
__6:
	;
	goto __3
__3:
	i = i + 2
	goto __2
	goto __4
__4:
	;
	if !(uint32(*(*int32)(unsafe.Pointer(bp + 12))) < uint32(unsafe.Sizeof(TestvfsFile{}))) {
		goto __25
	}
	*(*int32)(unsafe.Pointer(bp + 12)) = int32(unsafe.Sizeof(TestvfsFile{}))
__25:
	;
	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4)))
	nByte = int32(uint32(unsafe.Sizeof(Testvfs{})) + uint32(int32(libc.Xstrlen(tls, zVfs))) + uint32(1))
	p = tcl.XTcl_Alloc(tls, uint32(nByte))
	libc.Xmemset(tls, p, 0, uint32(nByte))
	(*Testvfs)(unsafe.Pointer(p)).FiDevchar = -1
	(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = -1

	tcl.XTcl_CreateObjCommand(tls, interp, zVfs, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_obj_cmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{testvfs_obj_del})))
	(*Testvfs)(unsafe.Pointer(p)).FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	(*Testvfs)(unsafe.Pointer(p)).Finterp = interp

	(*Testvfs)(unsafe.Pointer(p)).FzName = p + 1*80
	libc.Xmemcpy(tls, (*Testvfs)(unsafe.Pointer(p)).FzName, zVfs, libc.Xstrlen(tls, zVfs)+size_t(1))

	pVfs = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(sqlite3_vfs{})))
	libc.Xmemcpy(tls, pVfs, uintptr(unsafe.Pointer(&tvfs_vfs)), uint32(unsafe.Sizeof(sqlite3_vfs{})))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData = p
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion = *(*int32)(unsafe.Pointer(bp + 20))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName = (*Testvfs)(unsafe.Pointer(p)).FzName
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = (*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname
	if !(*(*int32)(unsafe.Pointer(bp + 16)) >= 0 && *(*int32)(unsafe.Pointer(bp + 16)) < (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname) {
		goto __26
	}
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = *(*int32)(unsafe.Pointer(bp + 16))
__26:
	;
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile = *(*int32)(unsafe.Pointer(bp + 12))
	(*Testvfs)(unsafe.Pointer(p)).FpVfs = pVfs
	(*Testvfs)(unsafe.Pointer(p)).FisNoshm = *(*int32)(unsafe.Pointer(bp + 4))
	(*Testvfs)(unsafe.Pointer(p)).FisFullshm = *(*int32)(unsafe.Pointer(bp + 24))
	(*Testvfs)(unsafe.Pointer(p)).Fmask = TESTVFS_ALL_MASK

	sqlite3.Xsqlite3_vfs_register(tls, pVfs, *(*int32)(unsafe.Pointer(bp + 8)))

	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+43711)
	return TCL_ERROR
}

var tvfs_vfs = sqlite3_vfs{
	FiVersion:      3,
	FxOpen:         0,
	FxDelete:       0,
	FxAccess:       0,
	FxFullPathname: 0,
	FxRandomness:   0,
	FxSleep:        0,
	FxCurrentTime:  0,
}

func test_vfs_shmlock(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*[3]uintptr)(unsafe.Pointer(bp + 4)) = [3]uintptr{ts + 43815, ts + 18932, uintptr(0)}
	*(*[3]uintptr)(unsafe.Pointer(bp + 20)) = [3]uintptr{ts + 43822, ts + 43827, uintptr(0)}
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	var rc int32 = SQLITE_OK
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 16)) = 0
	*(*int32)(unsafe.Pointer(bp + 32)) = 0
	*(*int32)(unsafe.Pointer(bp + 36)) = 0
	*(*int32)(unsafe.Pointer(bp + 40)) = 0

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+43834)
		return TCL_ERROR
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 ||
		tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+4, int32(unsafe.Sizeof(uintptr(0))), ts+14647, 0, bp+16) != 0 ||
		tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+20, int32(unsafe.Sizeof(uintptr(0))), ts+14647, 0, bp+32) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*4)), bp+36) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 6*4)), bp+40) != 0 {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp)), zDbname, SQLITE_FCNTL_FILE_POINTER, bp+44)
	if *(*uintptr)(unsafe.Pointer(bp + 44)) == uintptr(0) {
		return TCL_ERROR
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 44)))).FpMethods)).FxShmLock})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 44)), *(*int32)(unsafe.Pointer(bp + 36)), *(*int32)(unsafe.Pointer(bp + 40)),
		func() int32 {
			if *(*int32)(unsafe.Pointer(bp + 16)) == 0 {
				return SQLITE_SHM_SHARED
			}
			return SQLITE_SHM_EXCLUSIVE
		}()|
			func() int32 {
				if *(*int32)(unsafe.Pointer(bp + 32)) == 0 {
					return SQLITE_SHM_LOCK
				}
				return SQLITE_SHM_UNLOCK
			}())
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

func test_vfs_set_readmark(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	var rc int32 = SQLITE_OK
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 20)) = 0
	*(*int32)(unsafe.Pointer(bp + 24)) = -1

	*(*uintptr)(unsafe.Pointer(bp + 32)) = uintptr(0)
	var aShm uintptr
	var iOff int32

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+43886)
		return TCL_ERROR
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp+16) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*4)), bp+20) != 0 ||
		objc == 5 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*4)), bp+24) != 0 {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), zDbname, SQLITE_FCNTL_FILE_POINTER, bp+28)
	if *(*uintptr)(unsafe.Pointer(bp + 28)) == uintptr(0) {
		return TCL_ERROR
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 28)))).FpMethods)).FxShmMap})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 28)), 0, 32*1024, 0, bp+32)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	if *(*uintptr)(unsafe.Pointer(bp + 32)) == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+43909, 0))
		return TCL_ERROR
	}
	aShm = *(*uintptr)(unsafe.Pointer(bp + 32))
	iOff = 12*2 + 1 + *(*int32)(unsafe.Pointer(bp + 20))

	if objc == 5 {
		*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)) = u32(*(*int32)(unsafe.Pointer(bp + 24)))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)))))

	return TCL_OK
}

func Sqlitetestvfs_Init(tls *libc.TLS, interp uintptr) int32 {
	tcl.XTcl_CreateObjCommand(tls, interp, ts+43933, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_cmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+43941, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_shmlock})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+43953, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_set_readmark})), uintptr(0), uintptr(0))
	return TCL_OK
}

type TestWindow1 = struct {
	FxStep    uintptr
	FxFinal   uintptr
	FxValue   uintptr
	FxInverse uintptr
	Finterp   uintptr
}

type TestWindow = TestWindow1

type TestWindowCtx1 = struct{ FpVal uintptr }

type TestWindowCtx = TestWindowCtx1

func doTestWindowStep(tls *libc.TLS, bInverse int32, ctx uintptr, nArg int32, apArg uintptr) {
	var i int32
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bInverse != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxInverse
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxStep
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+584, -1))
		}
		for i = 0; i < nArg; i++ {
			var pArg uintptr
			pArg = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*4))), -1)
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, pArg)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
		if rc != TCL_OK {
			zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp))
			(*Tcl_Obj)(unsafe.Pointer((*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal)).FrefCount++
		}
	}
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func doTestWindowFinalize(tls *libc.TLS, bValue int32, ctx uintptr) {
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bValue != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxValue
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxFinal
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+584, -1))
		}

		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
		zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
		if rc != TCL_OK {
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			sqlite3.Xsqlite3_result_text(tls, ctx, zResult, -1, libc.UintptrFromInt32(-1))
		}

		if bValue == 0 {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = uintptr(0)
		}
	}
	for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func testWindowStep(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) {
	doTestWindowStep(tls, 0, ctx, nArg, apArg)
}

func testWindowInverse(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) {
	doTestWindowStep(tls, 1, ctx, nArg, apArg)
}

func testWindowFinal(tls *libc.TLS, ctx uintptr) {
	doTestWindowFinalize(tls, 0, ctx)
}

func testWindowValue(tls *libc.TLS, ctx uintptr) {
	doTestWindowFinalize(tls, 1, ctx)
}

func testWindowDestroy(tls *libc.TLS, pCtx uintptr) {
	tcl.XTcl_Free(tls, pCtx)
}

func test_create_window(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pNew uintptr

	var zName uintptr
	var rc int32

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+43970)
		return TCL_ERROR
	}

	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*4)))
	pNew = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestWindow{})))
	libc.Xmemset(tls, pNew, 0, uint32(unsafe.Sizeof(TestWindow{})))
	(*TestWindow)(unsafe.Pointer(pNew)).FxStep = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxFinal = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 4*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxValue = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 5*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxInverse = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 6*4)))
	(*TestWindow)(unsafe.Pointer(pNew)).Finterp = interp

	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxStep)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxFinal)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxValue)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxInverse)).FrefCount++

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp)), zName, -1, SQLITE_UTF8, pNew,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowDestroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}

	return TCL_OK
}

func test_create_window_misuse(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
	return TCL_ERROR
__1:
	;
	if !(getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+44007, -1, SQLITE_UTF8, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	goto error
__3:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+44007, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	goto error
__4:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+44007, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	goto error
__5:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+44007, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), uintptr(0),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	goto error
__6:
	;
	return TCL_OK

error:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, ts+44011, -1))
	return TCL_ERROR
}

func sumintStep(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) {
	var pInt uintptr

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apArg))) != SQLITE_INTEGER {
		sqlite3.Xsqlite3_result_error(tls, ctx, ts+44029, -1)
		return
	}
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	if pInt != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pInt)) += sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg)))
	}
}

func sumintInverse(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) {
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	*(*sqlite3_int64)(unsafe.Pointer(pInt)) -= sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg)))
}

func sumintFinal(tls *libc.TLS, ctx uintptr) {
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

func sumintValue(tls *libc.TLS, ctx uintptr) {
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

func test_create_sumint(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+44046, 1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintInverse})),
		uintptr(0))

	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

func test_override_sum(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 {
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050)
		return TCL_ERROR
	}
	if getDbPointer1(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*4))), bp) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+44053, -1, SQLITE_UTF8, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintFinal})))

	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

func Sqlitetest_window_Init(tls *libc.TLS, interp uintptr) int32 {
	var i int32
	for i = 0; uint32(i) < uint32(unsafe.Sizeof(aObjCmd14))/uint32(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData int32
	}{})); i++ {
		var c ClientData = uintptr(aObjCmd14[i].FclientData)
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd14[i].FzName, aObjCmd14[i].FxProc, c, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd14 = [4]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData int32
}{
	{FzName: ts + 44057, FxProc: 0},
	{FzName: ts + 44088, FxProc: 0},
	{FzName: ts + 44123, FxProc: 0},
	{FzName: ts + 44142, FxProc: 0},
}

func init() {
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 4)) = cfClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 8)) = cfRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 12)) = cfWrite
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 16)) = cfTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 20)) = cfSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 24)) = cfFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 28)) = cfLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 32)) = cfUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 36)) = cfCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 40)) = cfFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 44)) = cfSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 48)) = cfDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 52)) = cfShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 56)) = cfShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 60)) = cfShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 64)) = cfShmUnmap
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 4)) = csvtabCreate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 8)) = csvtabConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 12)) = csvtabBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 16)) = csvtabDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 20)) = csvtabDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 24)) = csvtabOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 28)) = csvtabClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 32)) = csvtabFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 36)) = csvtabNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 40)) = csvtabEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 44)) = csvtabColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 48)) = csvtabRowid
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 4)) = csvtabCreate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 8)) = csvtabConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 12)) = csvtabBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 16)) = csvtabDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 20)) = csvtabDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 24)) = csvtabOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 28)) = csvtabClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 32)) = csvtabFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 36)) = csvtabNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 40)) = csvtabEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 44)) = csvtabColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 48)) = csvtabRowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 52)) = csvtabUpdate
	*(*func(*libc.TLS, ClientData, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 8)) = incrblobClose
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 12)) = incrblobInput
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 16)) = incrblobOutput
	*(*func(*libc.TLS, ClientData, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 20)) = incrblobSeek
	*(*func(*libc.TLS, ClientData, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 32)) = incrblobWatch
	*(*func(*libc.TLS, ClientData, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 36)) = incrblobHandle
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 4)) = f5tCreateTokenizer
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 16)) = f5tTokenizerReturn
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 28)) = f5tTokenize
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 40)) = f5tCreateFunction
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 52)) = f5tMayBeCorrupt
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 64)) = f5tTokenHash
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 76)) = f5tRegisterMatchinfo
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 88)) = f5tRegisterTok
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 4)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_enter}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 12)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_leave}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 20)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 28)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int64}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 36)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_long}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 44)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_str}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 52)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_snprintf_str}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 60)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_stronly}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 68)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_double}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 76)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_scaled}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 84)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_hexdouble}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 92)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_z}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 100)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_n}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 108)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_snprintf_int}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 116)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_last_rowid}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 124)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_printf}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 132)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_hex}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 140)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 148)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_nr}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 156)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_get_table_printf}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 164)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 172)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close_v2}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 180)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_function}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 188)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_aggregate}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 196)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_drop_modules}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 204)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_register_func}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 212)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_abort}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 220)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_bind}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 228)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_breakpoint}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 236)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_key}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 244)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_rekey}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 252)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_interrupt}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 260)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_is_interrupted}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 268)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_function}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 276)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_collation}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 284)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{get_autocommit}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 292)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_busy_timeout}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 300)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_printf}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 308)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_io_trace}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 316)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{clang_sanitize_address}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 4)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_open}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 12)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_close}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 20)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_commit}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 28)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_rollback}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 36)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_begin}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 44)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_commit}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 52)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_rollback}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 60)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stats}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 68)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_pagecount}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 76)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_get}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 84)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_lookup}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 92)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_unref}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 100)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_read}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 108)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_write}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 116)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_number}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 124)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_truncate}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 132)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{fake_big_file}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 140)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testBitvecBuiltinTest}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 148)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testPendingByte}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 156)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{faultInstallCmd}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 4)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_open}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 12)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 20)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_begin_transaction}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 28)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_pager_stats}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 36)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_cursor}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 44)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close_cursor}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 52)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_next}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 60)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_eof}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 68)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_payload_size}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 76)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_first}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 84)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_varint_test}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 92)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_from_db}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 100)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_ismemdb}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 108)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_set_cache_size}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 4)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_create}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 12)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_wait}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 20)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_halt}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 28)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argc}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 36)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argv}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 44)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_colname}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 52)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_result}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 60)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_error}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 68)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_compile}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 76)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_step}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 84)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_finalize}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 92)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_swap}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 100)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_get}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 108)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_put}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 116)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_stmt_get}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 4)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{binarize}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 12)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_value_overhead}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 20)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 28)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate_selftest}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 4)) = test_multiplex_initialize
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 12)) = test_multiplex_shutdown
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 20)) = test_multiplex_control
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 4)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_shutdown}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 12)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_initialize}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 20)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_config}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 28)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_static_mutex}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 36)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_static_mutex}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 44)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_db_mutex}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 52)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_db_mutex}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 60)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_alloc_mutex}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 68)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_install_mutex_counters}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 76)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_read_mutex_counters}))
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 84)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_clear_mutex_counters}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 4)) = test_quota_initialize
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 12)) = test_quota_shutdown
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 20)) = test_quota_set
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 28)) = test_quota_file
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 36)) = test_quota_dump
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 44)) = test_quota_fopen
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 52)) = test_quota_fread
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 60)) = test_quota_fwrite
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 68)) = test_quota_fclose
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 76)) = test_quota_fflush
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 84)) = test_quota_fseek
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 92)) = test_quota_rewind
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 100)) = test_quota_ftell
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 108)) = test_quota_ftruncate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 116)) = test_quota_file_size
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 124)) = test_quota_file_truesize
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 132)) = test_quota_file_mtime
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 140)) = test_quota_remove
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 148)) = test_quota_glob
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 156)) = test_quota_file_available
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 164)) = test_quota_ferror
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 4)) = sqlite3_amatch_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 12)) = sqlite3_appendvfs_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 20)) = sqlite3_basexx_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 28)) = sqlite3_carray_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 36)) = sqlite3_closure_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 44)) = sqlite3_csv_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 52)) = sqlite3_decimal_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 60)) = sqlite3_eval_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 68)) = sqlite3_explain_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 76)) = sqlite3_fileio_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 84)) = sqlite3_fuzzer_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 92)) = sqlite3_ieee_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 100)) = sqlite3_nextchar_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 108)) = sqlite3_percentile_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 116)) = sqlite3_prefixes_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 124)) = sqlite3_qpvtab_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 132)) = sqlite3_regexp_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 140)) = sqlite3_remember_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 148)) = sqlite3_series_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 156)) = sqlite3_spellfix_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 164)) = sqlite3_totype_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 172)) = sqlite3_unionvtab_init
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 180)) = sqlite3_wholenumber_init
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 8)) = decimalFunc
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 20)) = decimalCmpFunc
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 32)) = decimalAddFunc
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 44)) = decimalSubFunc
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 56)) = decimalMulFunc
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 12)) = ieee754func
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 28)) = ieee754func
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 44)) = ieee754func
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 60)) = ieee754func
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 76)) = ieee754func_to_blob
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 92)) = ieee754func_from_blob
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 12)) = randStr
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 28)) = test_destructor
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 44)) = test_destructor16
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 60)) = testHexToUtf16be
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 76)) = testHexToUtf16le
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 92)) = testHexToUtf8
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 108)) = test_destructor_count
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 124)) = test_auxdata
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 140)) = test_error
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 156)) = test_error
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 172)) = test_eval
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 188)) = test_isolation
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 204)) = counterFunc
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 220)) = real2hex
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 236)) = test_decode
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 252)) = test_extract
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 268)) = test_zeroblob
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 284)) = test_getsubtype
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 300)) = test_setsubtype
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 316)) = test_frombind
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 4)) = test_sqlite3rbu
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 12)) = test_sqlite3rbu_vacuum
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 20)) = test_sqlite3rbu_create_vfs
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 28)) = test_sqlite3rbu_destroy_vfs
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 36)) = test_sqlite3rbu_internal_test
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 4)) = test_sqlite3_db_config
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 16)) = test_sqlite3_txn_state
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 28)) = test_bad_behavior
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 32)) = uintptr(unsafe.Pointer(&iZero))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 40)) = test_register_dbstat_vtab
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 52)) = get_sqlite_pointer
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 64)) = test_intarray_addr
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 76)) = test_int64array_addr
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 88)) = test_doublearray_addr
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 100)) = test_textarray_addr
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 112)) = test_bind_int
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 124)) = test_bind_zeroblob
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 136)) = test_bind_zeroblob64
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 148)) = test_bind_int64
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 160)) = test_bind_double
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 172)) = test_bind_null
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 184)) = test_bind_text
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 196)) = test_bind_text16
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 208)) = test_bind_blob
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 220)) = test_bind_value_from_select
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 232)) = test_bind_value_from_preupdate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 244)) = test_carray_bind
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 256)) = test_bind_parameter_count
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 268)) = test_bind_parameter_name
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 280)) = test_bind_parameter_index
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 292)) = test_clear_bindings
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 304)) = test_sleep
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 316)) = test_errcode
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 328)) = test_ex_errcode
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 340)) = test_errmsg
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 352)) = test_error_offset
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 364)) = test_errmsg16
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 376)) = test_open
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 388)) = test_open16
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 400)) = test_open_v2
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 412)) = test_complete16
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 424)) = test_normalize
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 436)) = test_prepare
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 448)) = test_prepare16
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 460)) = test_prepare_v2
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 472)) = test_prepare_v3
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 484)) = test_prepare_tkt3134
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 496)) = test_prepare16_v2
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 508)) = test_finalize
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 520)) = test_stmt_status
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 532)) = test_reset
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 544)) = test_expired
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 556)) = test_transfer_bind
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 568)) = test_changes
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 580)) = test_step
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 592)) = test_sql
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 604)) = test_ex_sql
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 616)) = test_next_stmt
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 628)) = test_stmt_readonly
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 640)) = test_stmt_isexplain
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 652)) = test_stmt_busy
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 664)) = uses_stmt_journal
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 676)) = test_release_memory
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 688)) = test_db_release_memory
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 700)) = test_db_cacheflush
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 712)) = test_system_errno
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 724)) = test_db_filename
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 736)) = test_db_readonly
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 748)) = test_soft_heap_limit
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 760)) = test_soft_heap_limit
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 772)) = test_hard_heap_limit
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 784)) = test_thread_cleanup
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 796)) = test_pager_refcounts
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 808)) = test_load_extension
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 820)) = test_enable_load
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 832)) = test_extended_result_codes
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 844)) = test_limit
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 856)) = test_dbconfig_maindbname_icecube
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 868)) = save_prng_state
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 880)) = restore_prng_state
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 892)) = reset_prng_state
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 904)) = prng_seed
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 916)) = extra_schema_checks
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 928)) = database_never_corrupt
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 940)) = database_may_be_corrupt
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 952)) = optimization_control
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 964)) = runAsObjProc
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 976)) = test_column_count
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 988)) = test_data_count
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1000)) = test_column_type
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1012)) = test_column_blob
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1024)) = test_column_double
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1036)) = test_column_int64
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1048)) = test_stmt_utf8
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1052)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_text}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1060)) = test_stmt_utf8
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1064)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_name}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1072)) = test_stmt_int
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1076)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_int}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1084)) = test_stmt_int
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1088)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_bytes}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1096)) = test_stmt_utf8
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1100)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_decltype}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1108)) = test_stmt_utf8
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1112)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_database_name}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1120)) = test_stmt_utf8
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1124)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_table_name}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1132)) = test_stmt_utf8
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1136)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_origin_name}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1144)) = test_stmt_int
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1148)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_bytes16}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1156)) = test_stmt_utf16
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1160)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_text16}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1168)) = test_stmt_utf16
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1172)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_name16}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1180)) = add_alignment_test_collations
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1192)) = test_stmt_utf16
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1196)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_decltype16}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1204)) = test_stmt_utf16
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1208)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_database_name16}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1216)) = test_stmt_utf16
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1220)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_table_name16}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1228)) = test_stmt_utf16
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1232)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_origin_name16}))
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1240)) = test_create_collation_v2
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1252)) = test_global_recover
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1264)) = working_64bit_int
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1276)) = vfs_unlink_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1288)) = vfs_initfail_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1300)) = vfs_unregister_all
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1312)) = vfs_reregister_all
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1324)) = file_control_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1336)) = file_control_lasterrno_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1348)) = file_control_lockproxy_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1360)) = file_control_chunksize_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1372)) = file_control_sizehint_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1384)) = file_control_data_version
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1396)) = file_control_persist_wal
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1408)) = file_control_powersafe_overwrite
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1420)) = file_control_vfsname
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1432)) = file_control_reservebytes
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1444)) = file_control_tempfilename
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1456)) = file_control_external_reader
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1468)) = vfs_list
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1480)) = test_create_function_v2
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1492)) = test_collate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1504)) = test_collate_needed
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1516)) = test_function
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1528)) = test_utf16bin_collate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1540)) = test_errstr
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1552)) = tcl_variable_type
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1564)) = test_enable_shared
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1576)) = sqlite3BtreeSharedCacheReport
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1588)) = test_libversion_number
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1600)) = test_table_column_metadata
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1612)) = test_blob_reopen
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1624)) = test_pcache_stats
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1636)) = test_unlock_notify
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1648)) = test_wal_checkpoint
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1660)) = test_wal_checkpoint_v2
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1672)) = test_wal_autocheckpoint
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1684)) = test_sqlite3_log
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1696)) = test_print_eqp
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1708)) = test_test_control
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1720)) = test_getrusage
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1732)) = tclLoadStaticExtensionCmd
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1744)) = sorter_test_fakeheap
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1756)) = sorter_test_sort4_helper
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1768)) = vfsCurrentTimeInt64
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1780)) = test_delete_database
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1792)) = test_atomic_batch_write
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1804)) = test_mmap_warm
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1816)) = test_config_sorterref
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1828)) = test_autovacuum_pages
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1840)) = test_decode_hexdb
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1852)) = test_write_db
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1864)) = test_register_cksumvfs
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1876)) = test_unregister_cksumvfs
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 4)) = test_intarray_create
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 16)) = test_intarray_bind
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 4)) = test_malloc
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 16)) = test_realloc
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 28)) = test_free
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 40)) = test_memset
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 52)) = test_memget
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 64)) = test_memory_used
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 76)) = test_memory_highwater
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 88)) = test_memdebug_backtrace
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 100)) = test_memdebug_dump
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 112)) = test_memdebug_fail
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 124)) = test_memdebug_pending
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 136)) = test_memdebug_settitle
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 148)) = test_memdebug_malloc_count
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 160)) = test_memdebug_log
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 172)) = test_config_pagecache
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 184)) = test_alt_pcache
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 196)) = test_status
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 208)) = test_db_status
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 220)) = test_install_malloc_faultsim
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 232)) = test_config_heap
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 244)) = test_config_heap_size
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 256)) = test_config_memstatus
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 268)) = test_config_lookaside
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 280)) = test_config_error
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 292)) = test_config_uri
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 304)) = test_config_cis
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 316)) = test_config_pmasz
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 328)) = test_db_config_lookaside
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 340)) = test_dump_memsys3
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 352)) = test_dump_memsys3
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 364)) = test_install_memsys3
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 376)) = test_vfs_oom_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd12)) + 4)) = register_schema_module
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd13)) + 4)) = register_tclvar_module
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 4)) = test_create_window
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 16)) = test_create_window_misuse
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 28)) = test_create_sumint
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 40)) = test_override_sum
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 4)) = register_echo_module
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 16)) = declare_vtab
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 4)) = c_misuse_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 16)) = c_realloc_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 28)) = c_collation_test
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd4)) + 4)) = register_tcl_module
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 4)) = test_blob_open
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 12)) = test_blob_close
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 20)) = test_blob_bytes
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 28)) = test_blob_read
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 36)) = test_blob_write
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd6)) + 4)) = register_fs_module
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 4)) = autoinstall_test_funcs
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 12)) = abuse_create_function
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 20)) = install_fts3_rank_function
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 4)) = hexio_read
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 12)) = hexio_write
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 20)) = hexio_get_int
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 28)) = hexio_render_int16
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 36)) = hexio_render_int32
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 44)) = utf8_to_utf8
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 52)) = read_fts3varint
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 60)) = make_fts3record
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 4)) = init_wrapper_install
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 12)) = init_wrapper_query
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 20)) = init_wrapper_uninstall
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 28)) = init_wrapper_clear
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 4)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32) int32
	}{ts_open}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 24)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{ts_close}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 44)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{ts_access}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 64)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t) uintptr
	}{ts_getcwd}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 84)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{ts_stat}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 104)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr) int32
	}{ts_fstat}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 124)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, off_t) int32
	}{ts_ftruncate}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 144)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, int32, uintptr) int32
	}{ts_fcntl}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 164)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t) int32
	}{ts_read}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 184)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pread}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 204)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pread64}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 224)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t) int32
	}{ts_write}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 244)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pwrite}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 264)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pwrite64}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 284)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, mode_t) int32
	}{ts_fchmod}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 304)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, off_t, off_t) int32
	}{ts_fallocate}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 324)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr
	}{ts_mmap}))
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 344)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr
	}{ts_mremap}))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 4)) = amatchConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 8)) = amatchConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 12)) = amatchBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 16)) = amatchDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 20)) = amatchDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 24)) = amatchOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 28)) = amatchClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 32)) = amatchFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 36)) = amatchNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 40)) = amatchEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 44)) = amatchColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 48)) = amatchRowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 52)) = amatchUpdate
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 4)) = apndClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 8)) = apndRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 12)) = apndWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 16)) = apndTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 20)) = apndSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 24)) = apndFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 28)) = apndLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 32)) = apndUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 36)) = apndCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 40)) = apndFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 44)) = apndSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 48)) = apndDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 52)) = apndShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 56)) = apndShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 60)) = apndShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 64)) = apndShmUnmap
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 68)) = apndFetch
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 72)) = apndUnfetch
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 24)) = apndOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 28)) = apndDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 32)) = apndAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 36)) = apndFullPathname
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 40)) = apndDlOpen
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 44)) = apndDlError
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 48)) = apndDlSym
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 52)) = apndDlClose
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 56)) = apndRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 60)) = apndSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 64)) = apndCurrentTime
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 68)) = apndGetLastError
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 72)) = apndCurrentTimeInt64
	*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 76)) = apndSetSystemCall
	*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 80)) = apndGetSystemCall
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 84)) = apndNextSystemCall
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 8)) = carrayConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 12)) = carrayBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 16)) = carrayDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 24)) = carrayOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 28)) = carrayClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 32)) = carrayFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 36)) = carrayNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 40)) = carrayEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 44)) = carrayColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 48)) = carrayRowid
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 4)) = cksmClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 8)) = cksmRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 12)) = cksmWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 16)) = cksmTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 20)) = cksmSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 24)) = cksmFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 28)) = cksmLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 32)) = cksmUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 36)) = cksmCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 40)) = cksmFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 44)) = cksmSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 48)) = cksmDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 52)) = cksmShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 56)) = cksmShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 60)) = cksmShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 64)) = cksmShmUnmap
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 68)) = cksmFetch
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 72)) = cksmUnfetch
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 24)) = cksmOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 28)) = cksmDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 32)) = cksmAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 36)) = cksmFullPathname
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 40)) = cksmDlOpen
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 44)) = cksmDlError
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 48)) = cksmDlSym
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 52)) = cksmDlClose
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 56)) = cksmRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 60)) = cksmSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 64)) = cksmCurrentTime
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 68)) = cksmGetLastError
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 72)) = cksmCurrentTimeInt64
	*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 76)) = cksmSetSystemCall
	*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 80)) = cksmGetSystemCall
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 84)) = cksmNextSystemCall
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 4)) = closureConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 8)) = closureConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 12)) = closureBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 16)) = closureDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 20)) = closureDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 24)) = closureOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 28)) = closureClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 32)) = closureFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 36)) = closureNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 40)) = closureEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 44)) = closureColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 48)) = closureRowid
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 24)) = cfOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 28)) = cfDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 32)) = cfAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 36)) = cfFullPathname
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 40)) = cfDlOpen
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 44)) = cfDlError
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 48)) = cfDlSym
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 52)) = cfDlClose
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 56)) = cfRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 60)) = cfSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 64)) = cfCurrentTime
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 68)) = cfGetLastError
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 8)) = dbdataConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 12)) = dbdataBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 16)) = dbdataDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 24)) = dbdataOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 28)) = dbdataClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 32)) = dbdataFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 36)) = dbdataNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 40)) = dbdataEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 44)) = dbdataColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&dbdata_module)) + 48)) = dbdataRowid
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 4)) = devsymClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 8)) = devsymRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 12)) = devsymWrite
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 16)) = devsymTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 20)) = devsymSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 24)) = devsymFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 28)) = devsymLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 32)) = devsymUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 36)) = devsymCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 40)) = devsymFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 44)) = devsymSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 48)) = devsymDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 52)) = devsymShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 56)) = devsymShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 60)) = devsymShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 64)) = devsymShmUnmap
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 24)) = devsymOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 28)) = devsymDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 32)) = devsymAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 36)) = devsymFullPathname
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 56)) = devsymRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 60)) = devsymSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 64)) = devsymCurrentTime
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 4)) = echoCreate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 8)) = echoConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 12)) = echoBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 16)) = echoDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 20)) = echoDestroy
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 24)) = echoOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 28)) = echoClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 32)) = echoFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 36)) = echoNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 40)) = echoEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 44)) = echoColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 48)) = echoRowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 52)) = echoUpdate
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 56)) = echoBegin
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 60)) = echoSync
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 64)) = echoCommit
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 68)) = echoRollback
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 72)) = echoFindFunction
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 76)) = echoRename
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 4)) = echoCreate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 8)) = echoConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 12)) = echoBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 16)) = echoDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 20)) = echoDestroy
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 24)) = echoOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 28)) = echoClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 32)) = echoFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 36)) = echoNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 40)) = echoEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 44)) = echoColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 48)) = echoRowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 52)) = echoUpdate
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 56)) = echoBegin
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 60)) = echoSync
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 64)) = echoCommit
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 68)) = echoRollback
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 72)) = echoFindFunction
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 76)) = echoRename
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 80)) = echoSavepoint
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 84)) = echoRelease
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 88)) = echoRollbackTo
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 4)) = expertConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 8)) = expertConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 12)) = expertBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 16)) = expertDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 20)) = expertDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 24)) = expertOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 28)) = expertClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 32)) = expertFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 36)) = expertNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 40)) = expertEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 44)) = expertColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 48)) = expertRowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 52)) = expertUpdate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 8)) = explainConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 12)) = explainBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 16)) = explainDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 24)) = explainOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 28)) = explainClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 32)) = explainFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 36)) = explainNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 40)) = explainEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 44)) = explainColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 48)) = explainRowid
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 4)) = fsConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 8)) = fsConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 12)) = fsBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 16)) = fsDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 20)) = fsDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 24)) = fsOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 28)) = fsClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 32)) = fsFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 36)) = fsNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 40)) = fsEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 44)) = fsColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 48)) = fsRowid
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 4)) = fsClose1
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 8)) = fsRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 12)) = fsWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 16)) = fsTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 20)) = fsSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 24)) = fsFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 28)) = fsLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 32)) = fsUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 36)) = fsCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 40)) = fsFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 44)) = fsSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 48)) = fsDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 24)) = fsOpen1
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 28)) = fsDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 32)) = fsAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 36)) = fsFullPathname
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 40)) = fsDlOpen
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 44)) = fsDlError
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 48)) = fsDlSym
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 52)) = fsDlClose
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 56)) = fsRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 60)) = fsSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 64)) = fsCurrentTime
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 4)) = fsdirConnect1
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 8)) = fsdirConnect1
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 12)) = fsdirBestIndex1
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 16)) = fsdirDisconnect1
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 20)) = fsdirDisconnect1
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 24)) = fsdirOpen1
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 28)) = fsdirClose1
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 32)) = fsdirFilter1
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 36)) = fsdirNext1
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 40)) = fsdirEof1
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 44)) = fsdirColumn1
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 48)) = fsdirRowid1
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 8)) = fsdirConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 12)) = fsdirBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 16)) = fsdirDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 24)) = fsdirOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 28)) = fsdirClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 32)) = fsdirFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 36)) = fsdirNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 40)) = fsdirEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 44)) = fsdirColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 48)) = fsdirRowid
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 4)) = fstreeConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 8)) = fstreeConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 12)) = fstreeBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 16)) = fstreeDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 20)) = fstreeDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 24)) = fstreeOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 28)) = fstreeClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 32)) = fstreeFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 36)) = fstreeNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 40)) = fstreeEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 44)) = fstreeColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 48)) = fstreeRowid
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 4)) = fts5tokConnectMethod
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 8)) = fts5tokConnectMethod
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 12)) = fts5tokBestIndexMethod
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 16)) = fts5tokDisconnectMethod
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 20)) = fts5tokDisconnectMethod
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 24)) = fts5tokOpenMethod
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 28)) = fts5tokCloseMethod
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 32)) = fts5tokFilterMethod
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 36)) = fts5tokNextMethod
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 40)) = fts5tokEofMethod
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 44)) = fts5tokColumnMethod
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 48)) = fts5tokRowidMethod
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 4)) = fuzzerConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 8)) = fuzzerConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 12)) = fuzzerBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 16)) = fuzzerDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 20)) = fuzzerDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 24)) = fuzzerOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 28)) = fuzzerClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 32)) = fuzzerFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 36)) = fuzzerNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 40)) = fuzzerEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 44)) = fuzzerColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 48)) = fuzzerRowid
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 4)) = intarrayCreate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 8)) = intarrayCreate
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 12)) = intarrayBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 16)) = intarrayDestroy
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 20)) = intarrayDestroy
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 24)) = intarrayOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 28)) = intarrayClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 32)) = intarrayFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 36)) = intarrayNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 40)) = intarrayEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 44)) = intarrayColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 48)) = intarrayRowid
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 4)) = jtClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 8)) = jtRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 12)) = jtWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 16)) = jtTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 20)) = jtSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 24)) = jtFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 28)) = jtLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 32)) = jtUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 36)) = jtCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 40)) = jtFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 44)) = jtSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 48)) = jtDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 24)) = jtOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 28)) = jtDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 32)) = jtAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 36)) = jtFullPathname
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 40)) = jtDlOpen
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 44)) = jtDlError
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 48)) = jtDlSym
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 52)) = jtDlClose
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 56)) = jtRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 60)) = jtSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 64)) = jtCurrentTime
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 68)) = jtGetLastError
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 72)) = jtCurrentTimeInt64
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 8)) = prefixesConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 12)) = prefixesBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 16)) = prefixesDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 24)) = prefixesOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 28)) = prefixesClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 32)) = prefixesFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 36)) = prefixesNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 40)) = prefixesEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 44)) = prefixesColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 48)) = prefixesRowid
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&pzNeededCollation)) + 0)) = uintptr(unsafe.Pointer(&zNeededCollation))
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 8)) = qpvtabConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 12)) = qpvtabBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 16)) = qpvtabDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 24)) = qpvtabOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 28)) = qpvtabClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 32)) = qpvtabFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 36)) = qpvtabNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 40)) = qpvtabEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 44)) = qpvtabColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&qpvtabModule)) + 48)) = qpvtabRowid
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 4)) = recoverVfsClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 8)) = recoverVfsRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 12)) = recoverVfsWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 16)) = recoverVfsTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 20)) = recoverVfsSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 24)) = recoverVfsFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 28)) = recoverVfsLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 32)) = recoverVfsUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 36)) = recoverVfsCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 40)) = recoverVfsFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 44)) = recoverVfsSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 48)) = recoverVfsDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 52)) = recoverVfsShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 56)) = recoverVfsShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 60)) = recoverVfsShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 64)) = recoverVfsShmUnmap
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 68)) = recoverVfsFetch
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&recover_methods)) + 72)) = recoverVfsUnfetch
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 4)) = schemaCreate
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 8)) = schemaCreate
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 12)) = schemaBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 16)) = schemaDestroy
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 20)) = schemaDestroy
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 24)) = schemaOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 28)) = schemaClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 32)) = schemaFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 36)) = schemaNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 40)) = schemaEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 44)) = schemaColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 48)) = schemaRowid
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 8)) = seriesConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 12)) = seriesBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 16)) = seriesDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 24)) = seriesOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 28)) = seriesClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 32)) = seriesFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 36)) = seriesNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 40)) = seriesEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 44)) = seriesColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 48)) = seriesRowid
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 4)) = spellfix1Create
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 8)) = spellfix1Connect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 12)) = spellfix1BestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 16)) = spellfix1Disconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 20)) = spellfix1Destroy
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 24)) = spellfix1Open
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 28)) = spellfix1Close
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 32)) = spellfix1Filter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 36)) = spellfix1Next
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 40)) = spellfix1Eof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 44)) = spellfix1Column
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 48)) = spellfix1Rowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 52)) = spellfix1Update
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 76)) = spellfix1Rename
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 4)) = tclConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 8)) = tclConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 12)) = tclBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 16)) = tclDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 20)) = tclDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 24)) = tclOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 28)) = tclClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 32)) = tclFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 36)) = tclNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 40)) = tclEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 44)) = tclColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 48)) = tclRowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 72)) = tclFindFunction
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 4)) = tclvarConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 8)) = tclvarConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 12)) = tclvarBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 16)) = tclvarDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 20)) = tclvarDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 24)) = tclvarOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 28)) = tclvarClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 32)) = tclvarFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 36)) = tclvarNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 40)) = tclvarEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 44)) = tclvarColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 48)) = tclvarRowid
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 52)) = tclvarUpdate
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 4)) = uintptr(unsafe.Pointer(&testpcacheGlobal))
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 8)) = testpcacheInit
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 12)) = testpcacheShutdown
	*(*func(*libc.TLS, int32, int32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 16)) = testpcacheCreate
	*(*func(*libc.TLS, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 20)) = testpcacheCachesize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 24)) = testpcachePagecount
	*(*func(*libc.TLS, uintptr, uint32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 28)) = testpcacheFetch
	*(*func(*libc.TLS, uintptr, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 32)) = testpcacheUnpin
	*(*func(*libc.TLS, uintptr, uintptr, uint32, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 36)) = testpcacheRekey
	*(*func(*libc.TLS, uintptr, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 40)) = testpcacheTruncate
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 44)) = testpcacheDestroy
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 4)) = tmpClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 8)) = tmpRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 12)) = tmpWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 16)) = tmpTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 20)) = tmpSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 24)) = tmpFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 28)) = tmpLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 32)) = tmpUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 36)) = tmpCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 40)) = tmpFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 44)) = tmpSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 48)) = tmpDeviceCharacteristics
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 4)) = tvfsClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 8)) = tvfsRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 12)) = tvfsWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 16)) = tvfsTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 20)) = tvfsSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 24)) = tvfsFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 28)) = tvfsLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 32)) = tvfsUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 36)) = tvfsCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 40)) = tvfsFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 44)) = tvfsSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 48)) = tvfsDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 52)) = tvfsShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 56)) = tvfsShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 60)) = tvfsShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 64)) = tvfsShmUnmap
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 68)) = tvfsFetch
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 72)) = tvfsUnfetch
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 24)) = tvfsOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 28)) = tvfsDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 32)) = tvfsAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 36)) = tvfsFullPathname
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 56)) = tvfsRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 60)) = tvfsSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 64)) = tvfsCurrentTime
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 4)) = unionConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 8)) = unionConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 12)) = unionBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 16)) = unionDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 20)) = unionDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 24)) = unionOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 28)) = unionClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 32)) = unionFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 36)) = unionNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 40)) = unionEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 44)) = unionColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 48)) = unionRowid
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 4)) = vfslogClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 8)) = vfslogRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 12)) = vfslogWrite
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 16)) = vfslogTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 20)) = vfslogSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 24)) = vfslogFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 28)) = vfslogLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 32)) = vfslogUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 36)) = vfslogCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 40)) = vfslogFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 44)) = vfslogSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 48)) = vfslogDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 52)) = vfslogShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 56)) = vfslogShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 60)) = vfslogShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 64)) = vfslogShmUnmap
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 4)) = vlogConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 8)) = vlogConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 12)) = vlogBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 16)) = vlogDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 20)) = vlogDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 24)) = vlogOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 28)) = vlogClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 32)) = vlogFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 36)) = vlogNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 40)) = vlogEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 44)) = vlogColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 48)) = vlogRowid
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 24)) = vfslogOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 28)) = vfslogDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 32)) = vfslogAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 36)) = vfslogFullPathname
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 40)) = vfslogDlOpen
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 44)) = vfslogDlError
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 48)) = vfslogDlSym
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 52)) = vfslogDlClose
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 56)) = vfslogRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 60)) = vfslogSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 64)) = vfslogCurrentTime
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 68)) = vfslogGetLastError
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 72)) = vfslogCurrentTimeInt64
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 4)) = wholenumberConnect
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 8)) = wholenumberConnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 12)) = wholenumberBestIndex
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 16)) = wholenumberDisconnect
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 20)) = wholenumberDisconnect
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 24)) = wholenumberOpen
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 28)) = wholenumberClose
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 32)) = wholenumberFilter
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 36)) = wholenumberNext
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 40)) = wholenumberEof
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 44)) = wholenumberColumn
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 48)) = wholenumberRowid
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 4)) = devsymClose
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 8)) = devsymRead
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 12)) = writecrashWrite
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 16)) = devsymTruncate
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 20)) = devsymSync
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 24)) = devsymFileSize
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 28)) = devsymLock
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 32)) = devsymUnlock
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 36)) = devsymCheckReservedLock
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 40)) = devsymFileControl
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 44)) = writecrashSectorSize
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 48)) = writecrashDeviceCharacteristics
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 52)) = devsymShmMap
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 56)) = devsymShmLock
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 60)) = devsymShmBarrier
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 64)) = devsymShmUnmap
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 24)) = writecrashOpen
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 28)) = devsymDelete
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 32)) = devsymAccess
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 36)) = devsymFullPathname
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 56)) = devsymRandomness
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 60)) = devsymSleep
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 64)) = devsymCurrentTime
}

var ts1 = "%s\x00internal error!\x00SELECT * FROM main.%Q WHERE sample()\x00expert\x00PRAGMA table_xinfo=%Q\x00main\x00binary\x00, \x00%Q\x00 COLLATE %Q\x00 COLLATE %s\x00 DESC\x00PRAGMA index_list=%Q\x00PRAGMA index_xInfo=%Q\x00%s_idx_%08x\x00SELECT count(*) FROM sqlite_schema WHERE name=%Q AND type in ('index','table','view')\x00CREATE INDEX \"%w\" ON \"%w\"(%s)\x00CREATE INDEX %s ON %s(%s)\x00EXPLAIN QUERY PLAN %s\x00 USING INDEX \x00 USING COVERING INDEX \x00%s\n\x00%s;\n\x00SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema WHERE tbl_name = %Q AND type IN ('table', 'trigger') ORDER BY type;\x00ALTER TABLE temp.%Q RENAME TO %Q\x00INSERT INTO %Q VALUES(\x00%s?\x00\x00)\x00UPDATE %Q SET \x00%s%Q=?\x00DELETE FROM %Q\x00t592690916721053953805701627921227776\x00DROP TABLE t592690916721053953805701627921227776\x00SELECT type, name, sql, 1 FROM sqlite_schema WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_schema WHERE type = 'trigger'  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') ORDER BY 4, 1\x00CREATE TABLE x(\x00%s%Q COLLATE %s\x00CREATE VIRTUAL TABLE %Q USING expert(%Q)\x00SELECT max(i.seqno) FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = 'table'\x00%sx.%Q IS rem(%d, x.%Q) COLLATE %s\x00%s%d\x00SELECT %s FROM %Q x ORDER BY %s\x00SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\x00%d\x00 %d\x00DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\x00CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\x00SELECT s.rowid, s.name, l.name FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l WHERE s.type = 'table'\x00SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\x00INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\x00ANALYZE; PRAGMA writable_schema=1\x00rem\x00sample\x00ANALYZE sqlite_schema\x00:memory:\x00SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%' AND sql NOT LIKE 'CREATE VIRTUAL %%'\x00Cannot find a unique index name to propose.\x00%s;%s%s\n\x00 -- stat1: \x00no such handle: \x00sql\x00TABLE\x00analyze\x00count\x00report\x00STMT EREPORT\x00destroy\x00SUBCOMMAND ...\x00sub-command\x00indexes\x00plan\x00candidates\x00DB\x00sqlite3expert%d\x00out of memory\x00sqlite3_expert_new\x00SQLITE_DONE\x00SQLITE_ERROR\x00SQLITE_OK\x00SELECT fts5(?1)\x00error: \x00fts5_api_ptr\x00f5t_2_%lld\x00xColumnCount\x00xRowCount\x00xColumnTotalSize\x00COL\x00xTokenize\x00TEXT SCRIPT\x00xPhraseCount\x00xPhraseSize\x00PHRASE\x00xInstCount\x00xInst\x00IDX\x00xRowid\x00xColumnText\x00xColumnSize\x00xQueryPhrase\x00PHRASE SCRIPT\x00xSetAuxdata\x00VALUE\x00xGetAuxdata\x00CLEAR\x00xSetAuxdataInt\x00INTEGER\x00xGetAuxdataInt\x00xPhraseForeach\x00IPHRASE COLVAR OFFVAR SCRIPT\x00xPhraseColumnForeach\x00IPHRASE COLVAR SCRIPT\x00SUB-COMMAND\x00f5t_%lld\x00bytearray\x00boolean\x00double\x00wideInt\x00int\x00DB NAME SCRIPT\x00?-subst? DB NAME TEXT\x00-subst\x00unrecognized option: \x00no such tokenizer: \x00error in tokenizer.xCreate()\x00error in tokenizer.xTokenize()\x00document\x00aux\x00query\x00prefixquery\x00invalid\x00-colocated\x00sqlite3_fts5_token may only be used by tokenizer callback\x00?-colocated? TEXT START END\x00error in fts5_api.xCreateTokenizer()\x00NSLOT TOKEN\x00sqlite3_fts5_create_tokenizer\x00sqlite3_fts5_token\x00sqlite3_fts5_tokenize\x00sqlite3_fts5_create_function\x00sqlite3_fts5_may_be_corrupt\x00sqlite3_fts5_token_hash\x00sqlite3_fts5_register_matchinfo\x00sqlite3_fts5_register_fts5tokenize\x00unrecognized matchinfo flag: %c\x00pcx\x00matchinfo\x00CREATE TABLE x(input HIDDEN, token, start, end, position)\x00fts5tokenize\x00%s: cost must be between 1 and %d\x00%s: maximum string length is %d\x00%s: iLang must be between 0 and %d\x00?\x00SELECT * FROM %Q.%Q\x00%s: %s\x00%s: %s has %d columns, expected 4\x00vocabulary_table\x00vocabulary_word\x00vocabulary_language\x00edit_distances\x00unrecognized argument: [%s]\n\x00no edit_distances table specified\x00CREATE TABLE x(word,distance,language,command HIDDEN,nword HIDDEN)\x000123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz~\x00SELECT \"%w\" FROM \"%w\"\x00 WHERE \"%w\">=?1 AND \"%w\"=?2 ORDER BY 1\x00SELECT \"%w\" FROM \"%w\" WHERE \"%w\">=?1 ORDER BY 1\x00*\x00DELETE from %s is not allowed\x00UPDATE of %s is not allowed\x00INSERT INTO %s allowed for column [command] only\x00approximate_match\x00apndvfs\x00Start-Of-SQLite3-\x00apnd(%lld)/%z\x00SQLite format 3\x00ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x00blob expanded to base64 too big\x00blob from base64 may be too big\x00base64 accepts only blob or text\x00base64 OOM\x00base64\x00is_base85 accepts only text or NULL\x00blob expanded to base85 too big\x00\n\x00blob from base85 may be too big\x00base85 accepts only blob or text.\x00base85 OOM\x00is_base85\x00base85\x00int32\x00int64\x00char*\x00struct iovec\x00CREATE TABLE x(value,pointer hidden,count hidden,ctype hidden)\x00carray-bind\x00carray\x00unknown datatype: %Q\x00inttoptr\x00cksmvfs\x00ZV-\x00checksum fault offset %lld of \"%s\"\x00checksum_verification\x00enable%\x00yes\x00on\x00page_size\x00cksm/%z\x00verify_checksum\x00tablename\x00idcolumn\x00parentcolumn\x00CREATE TABLE x(id,depth,root HIDDEN,tablename HIDDEN,idcolumn HIDDEN,parentcolumn HIDDEN)\x00SELECT \"%w\".\"%w\" FROM \"%w\" WHERE \"%w\".\"%w\"=?1\x00transitive_closure\x00rb\x00cannot open '%s' for reading\x00line %d: unescaped %c character\x00line %d: unterminated %c-quoted field\n\x00more than one '%s' parameter\x00true\x00no\x00off\x00false\x00header\x00more than one 'header' parameter\x00testflags\x00columns\x00more than one 'columns' parameter\x00column= value must be positive\x00bad parameter: '%s'\x00must specify either filename= or data= but not both\x00%sc%d TEXT\x00,\x00%s\"%w\" TEXT\x00bad schema: '%s' - %s\x00filename\x00data\x00schema\x00csv\x00csv_wr\x00decimal_sum\x00decimal\x00decimal_cmp\x00decimal_add\x00decimal_sub\x00decimal_mul\x00 \x00eval\x00CREATE TABLE x(addr,opcode,p1,p2,p3,p4,p5,comment,sql HIDDEN)\x00EXPLAIN %s\x00explain\x00wb\x00wrong number of arguments to function writefile()\x00failed to create symlink: %s\x00failed to create directory: %s\x00failed to write file: %s\x00CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\x00cannot read directory: %s\x00%s/%s\x00cannot stat file: %s\x00table function fsdir requires an argument\x00table function fsdir requires a non-NULL argument\x00fsdir\x00readfile\x00writefile\x00lsmode\x00%s: ruleset must be between 0 and %d\x00%s: wrong number of CREATE VIRTUAL TABLE arguments\x00CREATE TABLE x(word,distance,ruleset)\x00fuzzer\x00ieee754(%lld,%d)\x00ieee754\x00ieee754_mantissa\x00ieee754_exponent\x00ieee754_to_blob\x00ieee754_from_blob\x00BEGIN; SELECT * FROM %s%q%ssqlite_schema\x00'\x00'.\x00PRAGMA %s%q%spage_size\x00sqlite3_mmap_warm_cache: Warmed up %d pages of %s\x00END\x00AND (%s)\x00collate \"%w\"\x00SELECT %s FROM %s WHERE %s>=(?1 || ?2) %s   AND %s<=(?1 || char(1114111)) %s   %s ORDER BY 1 %s ASC LIMIT 1\x00next_char\x00NULL\x00is\x00not\x00in(\x00in(select\x00in(with\x00?,?,?\x002nd argument to percentile() is not a number between 0.0 and 100.0\x002nd argument to percentile() is not the same for all input rows\x001st argument to percentile() is not numeric\x00Inf input to percentile()\x00percentile\x00CREATE TABLE prefixes(prefix TEXT, original_string TEXT HIDDEN)\x00prefixes\x00prefix_length\x00vn\x00ix\x00cn\x00op\x00ux\x00rhs\x00a\x00b\x00c\x00d\x00e\x00flags\x00CREATE TABLE x( vn TEXT, ix INT, cn TEXT, op INT, ux BOOLEAN, rhs TEXT, a, b, c, d, e, flags INT HIDDEN)\x00%lld\x00%!f\x00x'\x00%02x\x00nConstraint,%d,,,,\n\x00aConstraint,%d,%s,%d,%d,\x00nOrderBy,%d,,,,\n\x00aOrderBy,%d,%s,%d,,\n\x00rowid\x00sqlite3_vtab_distinct,%d,,,,\n\x00idxFlags,%d,,,,\n\x00colUsed,%d,,,,\n\x00idxNum,%d,,,,\n\x00orderByConsumed,%d,,,,\n\x00qpvtab\x00unknown \\ escape\x00afnrtv\\()*.+?[$^{|}]\x00\a\f\n\r\t\v\x00unmatched '('\x00'*' without operand\x00'+' without operand\x00'?' without operand\x00'{m,n}' without operand\x00unmatched '{'\x00n less than m in '{m,n}'\x00both m and n are zero in '{m,n}'\x00POSIX character classes not supported\x00unclosed '['\x00unrecognized character\x00regexp\x00regexpi\x00remember\x00CREATE TABLE x(value,start hidden,stop hidden,step hidden)\x00first argument to \"generate_series()\" missing or unusable\x00generate_series() requires SQLite 3.8.12 or later\x00generate_series\x00.ABCDHLRMY9 ?\x00non-ASCII input to editdist()\x00NULL input to editdist()\x00SELECT iLang, cFrom, cTo, iCost FROM \"%w\" WHERE iLang>=0 ORDER BY iLang\x00editdist3\x00DROP TABLE IF EXISTS \"%w\".\"%w_vocab\"\x00CREATE TABLE x(word,rank,distance,langid, score, matchlen, phonehash HIDDEN, top HIDDEN, scope HIDDEN, srchcnt HIDDEN, soundslike HIDDEN, command HIDDEN)\x00CREATE TABLE IF NOT EXISTS \"%w\".\"%w_vocab\"(\n  id INTEGER PRIMARY KEY,\n  rank INT,\n  langid INT,\n  word TEXT,\n  k1 TEXT,\n  k2 TEXT\n);\n\x00CREATE INDEX IF NOT EXISTS \"%w\".\"%w_vocab_index_langid_k2\" ON \"%w_vocab\"(langid,k2);\x00edit_cost_table=\x00bad argument to spellfix1(): \"%s\"\x00SELECT id, word, rank, coalesce(k1,word)  FROM \"%w\".\"%w_vocab\" WHERE langid=%d AND k2>=?1 AND k2<?2\x00SELECT word, rank, NULL, langid, id FROM \"%w\".\"%w_vocab\"%s\x00 WHERE rowid=?\x00ROLLBACK\x00IGNORE\x00ABORT\x00REPLACE\x00DELETE FROM \"%w\".\"%w_vocab\"  WHERE id=%lld\x00NOT NULL constraint failed: %s.word\x00reset\x00null\x00unknown value for %s.command: \"%w\"\x00INSERT INTO \"%w\".\"%w_vocab\"(rank,langid,word,k1,k2) VALUES(%d,%d,%Q,nullif(%Q,%Q),%Q)\x00INSERT OR %s INTO \"%w\".\"%w_vocab\"(id,rank,langid,word,k1,k2) VALUES(%lld,%d,%d,%Q,nullif(%Q,%Q),%Q)\x00UPDATE OR %s \"%w\".\"%w_vocab\" SET id=%lld, rank=%d, langid=%d, word=%Q, k1=nullif(%Q,%Q), k2=%Q WHERE id=%lld\x00ALTER TABLE \"%w\".\"%w_vocab\" RENAME TO \"%w_vocab\"\x00spellfix1_translit\x00spellfix1_editdist\x00spellfix1_phonehash\x00spellfix1_scriptcode\x00spellfix1\x00922337203685477580\x00tointeger\x00toreal\x00sql error: %s\x00_rowid_\x00integer\x00no such rowid table: %s%s%s\x00.\x00SELECT group_concat(quote(name) || '.' || quote(type)) FROM pragma_table_info(?, ?)\x00source table schema mismatch\x00swarmvtab: no such SQL parameter: %s\x00maxopen\x00swarmvtab: illegal maxopen value\x00missing\x00swarmvtab: duplicate \"missing\" option\x00SELECT \"%w\"(?%s)\x00,?\x00openclose\x00swarmvtab: duplicate \"openclose\" option\x00SELECT \"%w\"(?,?%s)\x00swarmvtab: unrecognized option: %s\x00SELECT \"%w\"(?)\x00swarmvtab: parse error: %s\x00swarmvtab\x00unionvtab\x00temp\x00%s tables must be created in TEMP schema\x00wrong number of arguments for %s\x00SELECT * FROM (%z) ORDER BY 3\x00rowid range mismatch error\x00no source tables configured\x00SELECT 'CREATE TABLE xyz('    || group_concat(quote(name) || ' ' || type, ', ')    || ')',max((cid+1) * (type='INTEGER' COLLATE nocase AND pk=1))-1 FROM pragma_table_info(%Q, ?)\x00SELECT rowid, * FROM %Q %s %lld\x00WHERE _rowid_ <=\x00-- \x00%z%sSELECT rowid, * FROM %s%q%s%Q\x00 UNION ALL \x00%z WHERE rowid=%lld\x00WHERE\x00%z WHERE rowid>=%lld\x00AND\x00%z %s rowid<=%lld\x00CREATE TABLE x(value)\x00wholenumber\x00rbu_delta\x00step\x00close\x00create_rbu_delta\x00savestate\x00dbMain_eval\x00SQL\x00bp_progress\x00db\x00RBU\x00state\x00progress\x00close_no_error\x00temp_size_limit\x00LIMIT\x00temp_size\x00dbRbu_eval\x00rename_handler\x00SCRIPT\x00METHOD\x00method\x00 - \x00oal\x00move\x00checkpoint\x00done\x00error\x00NAME TARGET-DB RBU-DB ?STATE-DB?\x00NAME TARGET-DB ?STATE-DB?\x00?-default? NAME PARENT\x00NAME\x00sqlite3rbu_db(0, 0)!=0\x00sqlite3rbu\x00sqlite3rbu_vacuum\x00sqlite3rbu_create_vfs\x00sqlite3rbu_destroy_vfs\x00sqlite3rbu_internal_test\x00CREATE TABLE x(  pgno INTEGER,  child INTEGER,  schema TEXT HIDDEN)\x00CREATE TABLE x(  pgno INTEGER,  cell INTEGER,  field INTEGER,  value ANY,  schema TEXT HIDDEN)\x00SELECT %.*s(0)\x00PRAGMA %Q.page_count\x00SELECT %.*s(?2)\x00SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\x00sqlite_dbdata\x00sqlite_dbptr\x00SELECT data FROM sqlite_dbpage(%Q) WHERE pgno=?\x00(%s%u)\x00\\n\x00\\012\x00\\r\x00\\015\x00replace(replace(\x00replace(\x00,'\x00', char(10))\x00', char(13))\x00WITH RECURSIVE pages(p) AS (  SELECT 1    UNION  SELECT child FROM sqlite_dbptr('getpage()'), pages WHERE pgno=p)INSERT INTO recovery.schema SELECT  max(CASE WHEN field=0 THEN value ELSE NULL END),  max(CASE WHEN field=1 THEN value ELSE NULL END),  max(CASE WHEN field=2 THEN value ELSE NULL END),  max(CASE WHEN field=3 THEN value ELSE NULL END),  max(CASE WHEN field=4 THEN value ELSE NULL END)FROM sqlite_dbdata('getpage()') WHERE pgno IN (  SELECT p FROM pages) GROUP BY pgno, cell\x00callback returned an error - %d\x00encoding\x00auto_vacuum\x00user_version\x00application_id\x00PRAGMA %Q.%s\x00PRAGMA %s = %Q\x00CREATE TABLE t1(a); DROP TABLE t1;\x00getpage\x00page_is_used\x00read_i32\x00escape_crnl\x00ATTACH %Q AS recovery;\x00PRAGMA writable_schema = 1;CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, parent INT);CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\x00PRAGMA table_xinfo(%Q)\x00PRAGMA index_xinfo(%Q)\x00WITH dbschema(rootpage, name, sql, tbl, isVirtual, isIndex) AS (  SELECT rootpage, name, sql,     type='table',     sql LIKE 'create virtual%',    (type='index' AND (sql LIKE '%unique%' OR ?1))  FROM recovery.schema)SELECT rootpage, tbl, isVirtual, name, sql FROM dbschema   WHERE tbl OR isIndex  ORDER BY tbl DESC, name=='sqlite_sequence' DESC\x00SELECT name FROM sqlite_schema WHERE type='table' ORDER BY rowid DESC LIMIT 1\x00INSERT INTO sqlite_schema VALUES('table', %Q, %Q, 0, %Q)\x00SELECT rootpage, sql FROM recovery.schema   WHERE type!='table' AND type!='index'\x00SELECT rootpage, sql FROM recovery.schema   WHERE type!='table' AND (type!='index' OR sql NOT LIKE '%unique%')\x00INSERT OR IGNORE INTO %Q(\x00%z_rowid_\x00%zquote(?%d)\x00%z?%d\x00||', '||\x00%z%s%Q\x00%z%sescape_crnl(quote(?%d))\x00%z%s?%d\x00SELECT %Q || ') VALUES (' || %s || ')'\x00%s) VALUES (%s)\x00SELECT 1 FROM sqlite_schema WHERE name=?\x00%s_%d\x00rootpgno INTEGER, pgno INTEGER, nfield INTEGER, id INTEGER, \x00%z%sc%d\x00CREATE TABLE %s(%s)\x00failed to create %s output table\x00%z%s?\x00INSERT INTO %s VALUES(%s)\x00%z%squote(?)\x00|| ', ' ||\x00SELECT 'INSERT INTO %s VALUES(' || %s || ')'\x00WITH RECURSIVE p(pgno) AS (  SELECT ?    UNION  SELECT parent FROM recovery.map AS m, p WHERE m.pgno=p.pgno) SELECT p.pgno FROM p, recovery.map m WHERE m.pgno=p.pgno     AND m.parent IS NULL\x00WITH RECURSIVE seq(ii) AS (  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii<%lld)SELECT ii FROM seq\x00SELECT cell, field, value FROM sqlite_dbdata('getpage()') d WHERE d.pgno=? UNION ALL SELECT -1, -1, -1\x00SELECT rootpage FROM recovery.schema   WHERE type='table' AND (sql NOT LIKE 'create virtual%')  ORDER BY (tbl_name='sqlite_sequence') ASC\x00WITH RECURSIVE pages(page) AS (  SELECT ?1    UNION  SELECT child FROM sqlite_dbptr('getpage()'), pages     WHERE pgno=page) SELECT page, cell, field, value FROM sqlite_dbdata('getpage()') d, pages p WHERE p.page=d.pgno UNION ALL SELECT 0, 0, 0, 0\x00sqlite_sequence\x00DELETE FROM sqlite_sequence\x00WITH trunk(pgno) AS (  SELECT read_i32(getpage(1), 8) AS x WHERE x>0    UNION  SELECT read_i32(getpage(trunk.pgno), 0) AS x FROM trunk WHERE x>0),trunkdata(pgno, data) AS (  SELECT pgno, getpage(pgno) FROM trunk),freelist(data, n, freepgno) AS (  SELECT data, min(16384, read_i32(data, 1)-1), pgno FROM trunkdata    UNION ALL  SELECT data, n-1, read_i32(data, 2+n) FROM freelist WHERE n>=0),roots(r) AS (  SELECT 1 UNION ALL  SELECT rootpage FROM recovery.schema WHERE rootpage>0),used(page) AS (  SELECT r FROM roots    UNION  SELECT child FROM sqlite_dbptr('getpage()'), used     WHERE pgno=page) SELECT page FROM used UNION ALL SELECT freepgno FROM freelist WHERE NOT ?\x00INSERT OR IGNORE INTO recovery.map(pgno, parent) VALUES(?, ?)\x00WITH RECURSIVE seq(ii) AS (  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii<%lld)SELECT pgno, child FROM sqlite_dbptr('getpage()')  UNION ALL SELECT NULL, ii FROM seq\x00SELECT max(field)+1 FROM sqlite_dbdata('getpage') WHERE pgno = ?\x00BEGIN\x00PRAGMA writable_schema = on\x00SELECT 1 FROM sqlite_schema\x00COMMIT\x00PRAGMA writable_schema = off\x00testdb\x00lostandfound\x00freelistcorrupt\x00rowids\x00slowindexes\x00option\x00config\x00ARG\x00run\x00errmsg\x00errcode\x00finish\x00DB DBNAME SCRIPT\x00DB DBNAME URI\x00sqlite_recover%d\x00sqlite3_recover_init\x00sqlite3_recover_init_sql\x00sqlite3_dbdata_init\x00%p\x00zero\x00user\x00user_is_zero\x00box\x00DB SCRIPT\x00partly\x00fully\x00aParam\x00aCoord\x00anQueue\x00iLevel\x00mxLevel\x00iRowid\x00rParentScore\x00eParentWithin\x00value\x00qbox\x00register_box_geom\x00register_box_query\x00DB SQL\x00error in sql_exec_changeset()\x00sqlite3session_streams\x00attach\x00changeset\x00delete\x00enable\x00BOOL\x00indirect\x00isempty\x00table_filter\x00patchset\x00diff\x00FROMDB TBL\x00memory_used\x00changeset_size\x00object_config_size\x00CMD DB-HANDLE DB-NAME\x00n\x00i\x00f\x00t\x00FOREIGN_KEY\x00INSERT\x00UPDATE\x00DELETE\x00DATA\x00NOTFOUND\x00CONFLICT\x00CONSTRAINT\x00OMIT\x00-nosavepoint\x00-invert\x00?-nosavepoint? ?-inverse? DB CHANGESET CONFLICT-SCRIPT ?FILTER-SCRIPT?\x00DB CHANGESET CONFLICT-SCRIPT ?FILTER-SCRIPT?\x00DB CHANGESET\x00CHANGESET\x00LEFT RIGHT\x00-next\x00?-next? ?-invert? VARNAME CHANGESET SCRIPT\x00configure\x00REBASE-BLOB\x00rebase\x00unexpected SQLITE_UPDATE (bPatch=%d pk=%d pOld=%d pNew=%d)\x00(%d) - \"%s\"\x00OP VALUE\x00strm_size\x00sqlite3session\x00sqlite3session_foreach\x00sqlite3changeset_invert\x00sqlite3changeset_concat\x00sqlite3changeset_apply\x00sqlite3changeset_apply_v2\x00sqlite3changeset_apply_replace_all\x00sql_exec_changeset\x00sqlite3rebaser_create\x00sqlite3session_config\x00test_changeset\x00incrblob\x00incrblob_%d\x00sqlite_unlock_notify_arg\x00sqlite_unlock_notify_argcount\x00SQLITE_COPY\x00SQLITE_CREATE_INDEX\x00SQLITE_CREATE_TABLE\x00SQLITE_CREATE_TEMP_INDEX\x00SQLITE_CREATE_TEMP_TABLE\x00SQLITE_CREATE_TEMP_TRIGGER\x00SQLITE_CREATE_TEMP_VIEW\x00SQLITE_CREATE_TRIGGER\x00SQLITE_CREATE_VIEW\x00SQLITE_DELETE\x00SQLITE_DROP_INDEX\x00SQLITE_DROP_TABLE\x00SQLITE_DROP_TEMP_INDEX\x00SQLITE_DROP_TEMP_TABLE\x00SQLITE_DROP_TEMP_TRIGGER\x00SQLITE_DROP_TEMP_VIEW\x00SQLITE_DROP_TRIGGER\x00SQLITE_DROP_VIEW\x00SQLITE_INSERT\x00SQLITE_PRAGMA\x00SQLITE_READ\x00SQLITE_SELECT\x00SQLITE_TRANSACTION\x00SQLITE_UPDATE\x00SQLITE_ATTACH\x00SQLITE_DETACH\x00SQLITE_ALTER_TABLE\x00SQLITE_REINDEX\x00SQLITE_ANALYZE\x00SQLITE_CREATE_VTABLE\x00SQLITE_DROP_VTABLE\x00SQLITE_FUNCTION\x00SQLITE_SAVEPOINT\x00SQLITE_RECURSIVE\x00????\x00SQLITE_DENY\x00SQLITE_IGNORE\x00RELEASE _tcl_transaction\x00ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction\x00?CALLBACK?\x00?DATABASE? FILENAME\x00cannot open target database: \x00backup failed: \x00CALLBACK\x00cache option ?arg?\x00flush\x00size\x00size n\x00cannot convert \"\x00\" to integer\x00bad option \"\x00\": must be flush or size\x00NAME SCRIPT\x00?OPTION? ?BOOLEAN?\x00unknown config option: \"\x00\"\x00CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\x00\t\x00Error: non-null separator required for copy\x00rollback\x00abort\x00fail\x00ignore\x00replace\x00Error: \"\x00\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\x00SELECT * FROM '%q'\x00Error: no such table: \x00Error: \x00Error: can't malloc()\x00INSERT OR %q INTO '%q' VALUES(?\x00Error: cannot open file: \x00Error: %s line %d: expected %d columns of data but found %d\x00, failed while processing line: \x00?DATABASE? VALUE\x00-maxsize\x00-readonly\x00unknown option: \x00unable to set MEMDB content\x00extension loading is turned off at compile-time\x00-withoutnulls\x00unknown option: \"\x00?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\x00NAME ?SWITCHES? SCRIPT\x00-argcount\x00option requires an argument: \x00number of arguments must be non-negative\x00-deterministic\x00-directonly\x00-innocuous\x00-returntype\x00real\x00text\x00blob\x00any\x00type\x00\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\x00?-readonly? ?DB? TABLE COLUMN ROWID\x00NULLVALUE\x00N CALLBACK\x00KEY\x00cannot open source database: \x00restore failed: \x00restore failed: source database busy\x00?DATABASE?\x00(step|sort|autoindex)\x00sort\x00autoindex\x00vmstep\x00bad argument: should be autoindex, step, sort or vmstep\x00MILLISECONDS\x00?CALLBACK? ?MASK?\x00trace type\x00SAVEPOINT _tcl_transaction\x00[TYPE] SCRIPT\x00transaction type\x00BEGIN EXCLUSIVE\x00BEGIN IMMEDIATE\x00?SCRIPT?\x00SUB-COMMAND ?ARGS?\x00hook ?SCRIPT?\x00INDEX\x00-use-legacy-prepare\x00-last-stmt-ptr\x00unknown argument: \x00authorizer\x00backup\x00bind_fallback\x00busy\x00cache\x00changes\x00collate\x00collation_needed\x00commit_hook\x00complete\x00copy\x00deserialize\x00enable_load_extension\x00errorcode\x00erroroffset\x00exists\x00function\x00interrupt\x00last_insert_rowid\x00nullvalue\x00onecolumn\x00preupdate\x00profile\x00rekey\x00restore\x00rollback_hook\x00serialize\x00status\x00timeout\x00total_changes\x00trace\x00trace_v2\x00transaction\x00unlock_notify\x00update_hook\x00version\x00wal_hook\x00defensive\x00dqs_ddl\x00dqs_dml\x00enable_fkey\x00enable_qpsg\x00enable_trigger\x00enable_view\x00fts3_tokenizer\x00legacy_alter_table\x00legacy_file_format\x00load_extension\x00no_ckpt_on_close\x00reset_database\x00trigger_eqp\x00trusted_schema\x00writable_schema\x00statement\x00row\x00deferred\x00exclusive\x00immediate\x00depth\x00hook\x00new\x00old\x00HANDLE ?FILENAME? ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN? ?-nofollow BOOLEAN? ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?\x00-version\x00-sourceid\x00-has-codec\x000\x00-key\x00-vfs\x00-create\x00-nofollow\x00-nomutex\x00-fullmutex\x00-uri\x00-translatefilename\x00sqlite3\x00sqlite\x003.41.2\x00if {[llength $argv]>=1} {\nset argv0 [lindex $argv 0]\nset argv [lrange $argv 1 end]\nsource $argv0\n} else {\nset line {}\nwhile {![eof stdin]} {\nif {$line!=\"\"} {\nputs -nonewline \"> \"\n} else {\nputs -nonewline \"% \"\n}\nflush stdout\nappend line [gets stdin]\nif {[info complete $line]} {\nif {[catch {uplevel #0 $line} result]} {\nputs stderr \"Error: $result\"\n} elseif {$result!=\"\"} {\nputs $result\n}\nset line {}\n} else {\nappend line \\n\n}\n}\n}\n\x00SQLITE_DEBUG_BREAK\x00attach debugger to process %d and press any key to continue.\n\x00utf-8\x00argc\x00argv0\x00argv\x00errorInfo\x00%s: %s\n\x00SQLITE-CONNECTION\x00command not found: \x00error code %s (%d) does not match sqlite3_errcode %s (%d)\x00OMIT_MISUSE\x00wrong # args: should be \"\x00 DB FORMAT STRING\x00 DB HEX\x00 DB\x00 DB SQL\x00%z%s%s\x00%s%n\x00abcdefghijklmnopqrstuvwxyz\x00 DB FORMAT STRING ?COUNT?\x00 DB\"\x00 FILENAME\"\x00%04x\x00tkt2213 is not fixed\x00text16\x00bytes\x00bytes16\x00noop\x00x_coalesce\x00hex8\x00hex16\x00tkt2213func\x00pointer_change\x00counter1\x00counter2\x00intreal\x00x_sqlite_exec\x00value of 40 handed to x_count\x00x_count totals to 42\x00x_count\x00legacy_count\x00 TEXT\"\x00 FORMAT INT INT INT\"\x00argument is not a valid 64-bit integer\x00 FORMAT INT INT ?STRING?\"\x00 INT FORMAT INT INT ?STRING?\"\x00N must be non-negative\x00 FORMAT INT INT DOUBLE\"\x00 FORMAT DOUBLE DOUBLE\"\x00 FORMAT STRING\"\x00%08x%08x\x002nd argument should be 16-characters of hex\x00?BOOLEAN?\x00DB BOOLEAN\x00DB dbname tblname colname\x00CHANNEL ROWID\x00DB-HANDLE NAME CMP-PROC DEL-PROC\x00sqlite3_create_collate_v2() failed to detect an invalid encoding\x00utf8\x00utf16\x00utf16le\x00utf16be\x00DB NAME NARG ENC SWITCHES...\x00-func\x00-step\x00-final\x00-destroy\x00switch\x00DB-HANDLE FILE ?PROC?\x00this build omits sqlite3_load_extension()\x00DB-HANDLE ONOFF\x00string\x00first argument should be one of: int int64 string double null value\x00 DB FUNCTION-NAME\x00 <STMT>\x00STMT PARAMETER RESETFLAG\x00SQLITE_STMTSTATUS_FULLSCAN_STEP\x00SQLITE_STMTSTATUS_SORT\x00SQLITE_STMTSTATUS_AUTOINDEX\x00SQLITE_STMTSTATUS_VM_STEP\x00SQLITE_STMTSTATUS_REPREPARE\x00SQLITE_STMTSTATUS_RUN\x00SQLITE_STMTSTATUS_MEMUSED\x00NBYTE\x00FILE\x00PATH\x00 DB STMT\x00 STMT\x00 FROM-STMT TO-STMT\x00 VM IDX VALUE (null|static|normal)\"\x00static\x00static-nbytes\x00normal\x00blob10\x00abc\x00xyz\x00pq\x004th argument should be \"null\" or \"static\" or \"normal\"\x00(%d) \x00test_collate\x00UTF-8\x00UTF-16LE\x00UTF-16BE\x00 <DB> <utf8> <utf16le> <utf16be>\x00utf16bin\x00utf16_unaligned\x00utf16_aligned\x00test_function\x00<error code>\x00STMT IDX N\x00 STMT N VALUE\x00NaN\x00SNaN\x00-NaN\x00-SNaN\x00+Inf\x00-Inf\x00Epsilon\x00-Epsilon\x00NaN0\x00-NaN0\x00 STMT N\x00 STMT N VALUE BYTES\x00 STMT N DATA BYTES\x00cannot use %d blob bytes, have %d\x00STMT N NEW|OLD IDX\x00expected new or old, got: \x00STMT N SELECT\x00error in SQL: \x00error runnning SQL: \x00-transient\x00-static\x00-int32\x00-int64\x00-double\x00-text\x00-blob\x00--\x00text data must be either -static or -transient\x00blob data must be either -static or -transient\x00cannot be both -static and -transient\x00[OPTIONS] STMT IDX VALUE ...\x00STMT\x00STMT N\x00STMT NAME\x00 DB sql bytes ?tailvar?\x00 DB sql bytes tailvar\x00 DB sql bytes flags tailvar\x00\x00SELECT 1\x00 filename options-list\x00FILENAME FLAGS VFS\x00SQLITE_OPEN_READONLY\x00SQLITE_OPEN_READWRITE\x00SQLITE_OPEN_CREATE\x00SQLITE_OPEN_DELETEONCLOSE\x00SQLITE_OPEN_EXCLUSIVE\x00SQLITE_OPEN_AUTOPROXY\x00SQLITE_OPEN_MAIN_DB\x00SQLITE_OPEN_TEMP_DB\x00SQLITE_OPEN_TRANSIENT_DB\x00SQLITE_OPEN_MAIN_JOURNAL\x00SQLITE_OPEN_TEMP_JOURNAL\x00SQLITE_OPEN_SUBJOURNAL\x00SQLITE_OPEN_SUPER_JOURNAL\x00SQLITE_OPEN_NOMUTEX\x00SQLITE_OPEN_FULLMUTEX\x00SQLITE_OPEN_SHAREDCACHE\x00SQLITE_OPEN_PRIVATECACHE\x00SQLITE_OPEN_WAL\x00SQLITE_OPEN_URI\x00SQLITE_OPEN_EXRESCODE\x00flag\x00<utf-16 sql>\x00 STMT column\x00FLOAT\x00TEXT\x00BLOB\x001\x00 DB function-name\x00VARIABLE\x00?N?\x00DB DBNAME\x001234567890000000\x00__one\x00__two\x00notadatabase\x00Unexpected non-zero errno: \x00DB [DBNAME]\x00%u\x00DB DBNAME SIZE\x00 DB PWD\x00 DB FLAG\x00%d %d\x00 DB ?AUXDB?\x00DB N\x00 DB ID VALUE\x00unknown limit type: \x00SQLITE_LIMIT_LENGTH\x00SQLITE_LIMIT_SQL_LENGTH\x00SQLITE_LIMIT_COLUMN\x00SQLITE_LIMIT_EXPR_DEPTH\x00SQLITE_LIMIT_COMPOUND_SELECT\x00SQLITE_LIMIT_VDBE_OP\x00SQLITE_LIMIT_FUNCTION_ARG\x00SQLITE_LIMIT_ATTACHED\x00SQLITE_LIMIT_LIKE_PATTERN_LENGTH\x00SQLITE_LIMIT_VARIABLE_NUMBER\x00SQLITE_LIMIT_TRIGGER_DEPTH\x00SQLITE_LIMIT_WORKER_THREADS\x00SQLITE_LIMIT_TOOSMALL\x00SQLITE_LIMIT_TOOBIG\x00SEED ?DB?\x00BOOLEAN\x00current\x00max\x00min\x00recyclable\x00DB ?NAME?\x00passive\x00full\x00restart\x00truncate\x00DB MODE ?NAME?\x00mode\x00DB VALUE\x00COMMAND ...\x00command has no objProc: \x00%d %d %d %s\n\x00SQLITE_TESTCTRL_LOCALTIME_FAULT\x00SQLITE_TESTCTRL_SORTER_MMAP\x00SQLITE_TESTCTRL_IMPOSTER\x00SQLITE_TESTCTRL_INTERNAL_FUNCTIONS\x00VERB ARGS...\x00VERB\x000|1|2\x00DB LIMIT\x00DB dbName onOff tnum\x00ru_utime=%d.%06d ru_stime=%d.%06d ru_minflt=%d ru_majflt=%d\x00DB OPT BOOLEAN\x00unknown optimization - should be one of:\x00all\x00none\x00query-flattener\x00groupby-order\x00factor-constants\x00distinct-opt\x00cover-idx-scan\x00order-by-idx-join\x00transitive\x00omit-noop-join\x00stat4\x00skip-scan\x00push-down\x00balanced-merge\x00propagate-const\x00DB NAME ...\x00no such extension: \x00initialization of \x00 failed: \x00amatch\x00appendvfs\x00basexx\x00closure\x00fileio\x00nextchar\x00series\x00spellfix\x00totype\x00DB SQL1 NSTEP SQL2\x00data error: (a!=b)\x00checksum mismatch\x00sql error: \x00TYPE\x00Deliberate panic\x00DB SETTING [VALUE]\x00SQLITE_*\x00DBCONFIG_*\x00ENABLE_*\x00unknown sqlite3_db_config setting\x00FKEY\x00TRIGGER\x00FTS3_TOKENIZER\x00LOAD_EXTENSION\x00NO_CKPT_ON_CLOSE\x00QPSG\x00TRIGGER_EQP\x00RESET_DB\x00DEFENSIVE\x00WRITABLE_SCHEMA\x00LEGACY_ALTER_TABLE\x00DQS_DML\x00DQS_DDL\x00LEGACY_FILE_FORMAT\x00DB ?SCHEMA?\x00icecube\x00DB ?DBNAME?\x00DB OFFSET DATA\x00HEXDB\x00| size %d pagesize %d\x00bad 'pagesize' field\x00bad 'size' field\x00| page %d offset %d\x00| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\x00DB ?SCRIPT?\x00sqlite3_autovacuum_pages() returns %d\x00sqlite_search_count\x00sqlite_found_count\x00sqlite_sort_count\x00sqlite3_max_blobsize\x00sqlite_like_count\x00sqlite_interrupt_count\x00sqlite_open_file_count\x00sqlite_current_time\x00sqlite3_xferopt_count\x00sqlite3_pager_readdb_count\x00sqlite3_pager_writedb_count\x00sqlite3_pager_writej_count\x00unaligned_string_counter\x00sqlite_last_needed_collation\x00sqlite_query_plan\x00sqlite_opentemp_count\x00sqlite_static_bind_value\x00sqlite_static_bind_nbyte\x00sqlite_temp_directory\x00sqlite_data_directory\x00bitmask_size\x00longdouble_size\x00sqlite_sync_count\x00sqlite_fullsync_count\x00db_enter\x00db_leave\x00sqlite3_mprintf_int\x00sqlite3_mprintf_int64\x00sqlite3_mprintf_long\x00sqlite3_mprintf_str\x00sqlite3_snprintf_str\x00sqlite3_mprintf_stronly\x00sqlite3_mprintf_double\x00sqlite3_mprintf_scaled\x00sqlite3_mprintf_hexdouble\x00sqlite3_mprintf_z_test\x00sqlite3_mprintf_n_test\x00sqlite3_snprintf_int\x00sqlite3_last_insert_rowid\x00sqlite3_exec_printf\x00sqlite3_exec_hex\x00sqlite3_exec\x00sqlite3_exec_nr\x00sqlite3_get_table_printf\x00sqlite3_close\x00sqlite3_close_v2\x00sqlite3_create_function\x00sqlite3_create_aggregate\x00sqlite3_drop_modules\x00sqlite_register_test_function\x00sqlite_abort\x00sqlite_bind\x00breakpoint\x00sqlite3_key\x00sqlite3_rekey\x00sqlite3_interrupt\x00sqlite3_is_interrupted\x00sqlite_delete_function\x00sqlite_delete_collation\x00sqlite3_get_autocommit\x00sqlite3_busy_timeout\x00printf\x00sqlite3IoTrace\x00clang_sanitize_address\x00sqlite3_db_config\x00sqlite3_txn_state\x00bad_behavior\x00register_dbstat_vtab\x00sqlite3_connection_pointer\x00intarray_addr\x00int64array_addr\x00doublearray_addr\x00textarray_addr\x00sqlite3_bind_int\x00sqlite3_bind_zeroblob\x00sqlite3_bind_zeroblob64\x00sqlite3_bind_int64\x00sqlite3_bind_double\x00sqlite3_bind_null\x00sqlite3_bind_text\x00sqlite3_bind_text16\x00sqlite3_bind_blob\x00sqlite3_bind_value_from_select\x00sqlite3_bind_value_from_preupdate\x00sqlite3_carray_bind\x00sqlite3_bind_parameter_count\x00sqlite3_bind_parameter_name\x00sqlite3_bind_parameter_index\x00sqlite3_clear_bindings\x00sqlite3_sleep\x00sqlite3_errcode\x00sqlite3_extended_errcode\x00sqlite3_errmsg\x00sqlite3_error_offset\x00sqlite3_errmsg16\x00sqlite3_open\x00sqlite3_open16\x00sqlite3_open_v2\x00sqlite3_complete16\x00sqlite3_normalize\x00sqlite3_prepare\x00sqlite3_prepare16\x00sqlite3_prepare_v2\x00sqlite3_prepare_v3\x00sqlite3_prepare_tkt3134\x00sqlite3_prepare16_v2\x00sqlite3_finalize\x00sqlite3_stmt_status\x00sqlite3_reset\x00sqlite3_expired\x00sqlite3_transfer_bindings\x00sqlite3_changes\x00sqlite3_step\x00sqlite3_sql\x00sqlite3_expanded_sql\x00sqlite3_next_stmt\x00sqlite3_stmt_readonly\x00sqlite3_stmt_isexplain\x00sqlite3_stmt_busy\x00uses_stmt_journal\x00sqlite3_release_memory\x00sqlite3_db_release_memory\x00sqlite3_db_cacheflush\x00sqlite3_system_errno\x00sqlite3_db_filename\x00sqlite3_db_readonly\x00sqlite3_soft_heap_limit\x00sqlite3_soft_heap_limit64\x00sqlite3_hard_heap_limit64\x00sqlite3_thread_cleanup\x00sqlite3_pager_refcounts\x00sqlite3_load_extension\x00sqlite3_enable_load_extension\x00sqlite3_extended_result_codes\x00sqlite3_limit\x00dbconfig_maindbname_icecube\x00save_prng_state\x00restore_prng_state\x00reset_prng_state\x00prng_seed\x00extra_schema_checks\x00database_never_corrupt\x00database_may_be_corrupt\x00optimization_control\x00tcl_objproc\x00sqlite3_column_count\x00sqlite3_data_count\x00sqlite3_column_type\x00sqlite3_column_blob\x00sqlite3_column_double\x00sqlite3_column_int64\x00sqlite3_column_text\x00sqlite3_column_name\x00sqlite3_column_int\x00sqlite3_column_bytes\x00sqlite3_column_decltype\x00sqlite3_column_database_name\x00sqlite3_column_table_name\x00sqlite3_column_origin_name\x00sqlite3_column_bytes16\x00sqlite3_column_text16\x00sqlite3_column_name16\x00add_alignment_test_collations\x00sqlite3_column_decltype16\x00sqlite3_column_database_name16\x00sqlite3_column_table_name16\x00sqlite3_column_origin_name16\x00sqlite3_create_collation_v2\x00sqlite3_global_recover\x00working_64bit_int\x00vfs_unlink_test\x00vfs_initfail_test\x00vfs_unregister_all\x00vfs_reregister_all\x00file_control_test\x00file_control_lasterrno_test\x00file_control_lockproxy_test\x00file_control_chunksize_test\x00file_control_sizehint_test\x00file_control_data_version\x00file_control_persist_wal\x00file_control_powersafe_overwrite\x00file_control_vfsname\x00file_control_reservebytes\x00file_control_tempfilename\x00file_control_external_reader\x00sqlite3_vfs_list\x00sqlite3_create_function_v2\x00add_test_collate\x00add_test_collate_needed\x00add_test_function\x00add_test_utf16bin_collate\x00sqlite3_test_errstr\x00tcl_variable_type\x00sqlite3_enable_shared_cache\x00sqlite3_shared_cache_report\x00sqlite3_libversion_number\x00sqlite3_table_column_metadata\x00sqlite3_blob_reopen\x00pcache_stats\x00sqlite3_unlock_notify\x00sqlite3_wal_checkpoint\x00sqlite3_wal_checkpoint_v2\x00sqlite3_wal_autocheckpoint\x00test_sqlite3_log\x00print_explain_query_plan\x00sqlite3_test_control\x00getrusage\x00load_static_extension\x00sorter_test_fakeheap\x00sorter_test_sort4_helper\x00vfs_current_time_int64\x00sqlite3_delete_database\x00atomic_batch_write\x00sqlite3_mmap_warm\x00sqlite3_config_sorterref\x00sqlite3_autovacuum_pages\x00decode_hexdb\x00test_write_db\x00sqlite3_register_cksumvfs\x00sqlite3_unregister_cksumvfs\x00*** OBSOLETE VARIABLE ***\x00 FILENAME N-PAGE\"\x00 ID\"\x00ref\x00page\x00err\x00hit\x00miss\x00ovfl\x00 ID PGNO\"\x00 PAGE\"\x00 PAGE DATA\"\x00 N-MEGABYTES FILE\"\x00open failed: \x00Hello, World!\x00write failed: \x00 PENDING-BYTE\"\x00fault simulator script failed: [%s]\x00 SCRIPT\"\x00 SIZE PROGRAM\"\x00sqlite_io_error_pending\x00sqlite_io_error_persist\x00sqlite_io_error_hit\x00sqlite_io_error_hardhit\x00sqlite_diskfull_pending\x00sqlite_diskfull\x00sqlite_pending_byte\x00pager_open\x00pager_close\x00pager_commit\x00pager_rollback\x00pager_stmt_begin\x00pager_stmt_commit\x00pager_stmt_rollback\x00pager_stats\x00pager_pagecount\x00page_get\x00page_lookup\x00page_unref\x00page_read\x00page_write\x00page_number\x00pager_truncate\x00fake_big_file\x00sqlite3BitvecBuiltinTest\x00sqlite3_test_control_pending_byte\x00sqlite3_test_control_fault_install\x00 FILENAME NCACHE FLAGS\"\x00read\x00write\x00 ID TABLENUM WRITEABLE\"\x00 START MULTIPLIER COUNT INCREMENT\"\x00putVarint returned %d - should be between 1 and 9\x00putVarint returned %d and getVarint returned %d\x00Wrote 0x%016llx and got back 0x%016llx\x00putVarint returned %d and GetVarint32 returned %d\x00Wrote 0x%016llx and got back 0x%016llx from GetVarint32\x00 DB-HANDLE ?N?\"\x00No such db-handle: \"\x00 BT NCACHE\"\x00?-intkey? CSR KEY VALUE\x00btree_insert\x00btree_open\x00btree_close\x00btree_begin_transaction\x00btree_pager_stats\x00btree_cursor\x00btree_close_cursor\x00btree_next\x00btree_eof\x00btree_payload_size\x00btree_first\x00btree_varint_test\x00btree_from_db\x00btree_ismemdb\x00btree_set_cache_size\x00thread ID must be an upper case letter\x00 ID FILENAME\x00thread \x00 is already running\x00failed to create the thread\x00 ID\x00no such thread\x00 ID N\x00column number out of range\x00no database is open\x00 ID SQL\x00no virtual machine available\x00 IDL\x00 ID1 ID2\x00 ID DB\x00thread_create\x00thread_wait\x00thread_halt\x00thread_argc\x00thread_argv\x00thread_colname\x00thread_result\x00thread_error\x00thread_compile\x00thread_step\x00thread_finalize\x00thread_swap\x00thread_db_get\x00thread_db_put\x00thread_stmt_get\x00 <repeat-count> <do-calls>\x00hello world\x00UTF8\x00UTF16LE\x00UTF16BE\x00UTF16\x00No such encoding: \x00 <string/blob> <from enc> <to enc>\x00binarize\x00test_value_overhead\x00test_translate\x00translate_selftest\x00out of memory in the crash simulator\n\x00atomic\x00atomic512\x00atomic1k\x00atomic2k\x00atomic4k\x00atomic8k\x00atomic16k\x00atomic32k\x00atomic64k\x00sequential\x00safe_append\x00powersafe_overwrite\x00batch-atomic\x00-sectorsize\x00-characteristics\x00Bad option: \"\x00\" - must be \"-characteristics\" or \"-sectorsize\"\x00Option requires an argument: \"\x00no such flag\x00ENABLE ?DEFAULT?\x00crash\x00?OPTIONS? DELAY CRASHFILE\x00Filename is too long: \"\x00NWRITE\x00?-default? PARENT-VFS\x00-default\x00\": must be -default\x00Error in jt_register\x00sqlite3_crash_enable\x00sqlite3_crashparams\x00sqlite3_crash_now\x00sqlite3_simulate_device\x00sqlite3_crash_on_write\x00unregister_devsim\x00register_jt_vfs\x00unregister_jt_vfs\x00echo_module_fail(%s,%s)\x00echo-vtab-error: %s\x00SELECT * FROM %Q\x00PRAGMA index_list(%s)\x00PRAGMA index_info(%s)\x00echo_module\x00SELECT sql FROM sqlite_schema WHERE type = 'table' AND name = ?\x00%s%s\x00xCreate\x00CREATE TABLE %Q(logmsg)\x00xConnect\x00xDisconnect\x00xDestroy\x00DROP TABLE %Q\x00xOpen\x00xNext\x00xColumn\x00xFilter\x00, *\x00%z, %s\x00%z, NULL\x00echo_module_ignore_usable\x00xBestIndex\x00echo_module_cost\x00SELECT count(*) FROM %Q\x00SELECT rowid%z FROM %Q\x00=\x00<\x00>\x00<=\x00>=\x00LIKE\x00like\x00glob\x00 %s %s LIKE (SELECT '%%'||?||'%%')\x00 %s %s %s ?\x00DESC\x00ASC\x00 ORDER BY %s %s\x00xUpdate\x00 SET\x00UPDATE %Q\x00 SET rowid=?1 \x00%s %Q=?%d\x00 WHERE rowid=?%d\x00DELETE FROM %Q WHERE rowid = ?1\x00INSERT INTO %Q (\x00%s%Q\x00%s?%d\x00) VALUES(\x00echo(%s)\x00xBegin\x00echo_module_begin_fail\x00xSync\x00echo_module_sync_fail\x00xCommit\x00xRollback\x00::echo_glob_overload\x00xRename\x00ALTER TABLE %s RENAME TO %s%s\x00function_that_does_not_exist_0982ma98\x00echo\x00echo_v2\x00register_echo_module\x00sqlite3_declare_vtab\x00N/A\x00sqlite3_create_collation\x00Error testing function: \x00sqlite3_malloc\x00sqlite3_realloc\x00c_misuse_test\x00c_realloc_test\x00c_collation_test\x00sqlite3_reset_auto_extension\x00npage\x00remaining\x00pagecount\x00CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME\x00sqlite3_backup_init() failed\x00sqlite3_backup\x00wrong number of arguments\x00unexpected: %s\x00eq\x00gt\x00le\x00lt\x00ge\x00match\x00ne\x00isnot\x00isnotnull\x00isnull\x00limit\x00offset\x00column\x00usable\x00desc\x00constraints\x00orderby\x00mask\x00distinct\x00in\x00rhs_value\x00INDEX BOOLEAN\x00INDEX ?DEFAULT?\x00bestindex%d\x00cost\x00idxnum\x00idxstr\x00rows\x00use\x00omit\x00unexpected: %d\x00xFindFunction\x00tcl\x00register_tcl_module\x00incrblob_\x00DB DATABASE TABLE COLUMN ROWID FLAGS VARNAME\x00HANDLE\x00CHANNEL OFFSET N\x00out of memory in testdata/sqlite-src-3410200/src/test_blob.c\x00HANDLE OFFSET DATA ?NDATA?\x00sqlite3_blob_open\x00sqlite3_blob_close\x00sqlite3_blob_bytes\x00sqlite3_blob_read\x00sqlite3_blob_write\x00sqlite_options\x00malloc_usable_size\x00rowid32\x00casesensitivelike\x00configslower\x001.0\x00curdir\x00win32malloc\x00debug\x00default_ckptfullfsync\x00direct_read\x00dirsync\x00lfs\x00pagecache_overflow_stats\x00mmap\x00worker_threads\x008\x00memdebug\x008_3_names\x00cursorhints\x00hiddencolumns\x00mathlib\x00mem3\x00mem5\x00offset_sql_func\x00snapshot\x00mutex\x00mutex_noop\x00altertable\x00api_armor\x00atomicwrite\x00geopoly\x00json1\x00has_codec\x00like_match_blobs\x00auth\x00autoinc\x00autoreset\x00autovacuum\x00default_autovacuum\x00between_opt\x00builtin_test\x00bloblit\x00cast\x00check\x00cte\x00columnmetadata\x00oversize_cell_check\x00compileoption_diags\x00compound\x00conflict\x00crashtest\x00datetime\x00decltype\x00deprecated\x00diskio\x00floatingpoint\x00foreignkey\x00fts1\x00fts2\x00fts3\x00fts5\x00fts3_unicode\x00fts4_deferred\x00gettable\x00icu\x00icu_collations\x00integrityck\x00legacyformat\x00like_opt\x00load_ext\x00localtime\x00lookaside\x00long_double\x00memorydb\x00memorymanage\x00mergesort\x00null_trim\x00or_opt\x00rbu\x00pager_pragmas\x00pragma\x00reindex\x00rtree\x00rtree_int_only\x00schema_pragmas\x00schema_version\x00session\x00stmtvtab\x00scanstatus\x00lock_proxy_pragmas\x00prefer_proxy_locking\x00shared_cache\x00subquery\x00tclvar\x00threadsafe\x00threadsafe1\x00threadsafe2\x00tempdb\x00trigger\x00truncate_opt\x00vacuum\x00view\x00vtab\x00wal\x00wsd\x00update_delete_limit\x00fast_secure_delete\x00secure_delete\x00userauth\x00multiplex_ext_overwrite\x00yytrackmaxstackdepth\x00sqllog\x00uri_00_error\x00normalize\x00windowfunc\x00SQLITE_MAX_LENGTH\x00SQLITE_MAX_COLUMN\x00SQLITE_MAX_SQL_LENGTH\x00SQLITE_MAX_EXPR_DEPTH\x00SQLITE_MAX_COMPOUND_SELECT\x00SQLITE_MAX_VDBE_OP\x00SQLITE_MAX_FUNCTION_ARG\x00SQLITE_MAX_VARIABLE_NUMBER\x00SQLITE_MAX_PAGE_SIZE\x00SQLITE_MAX_PAGE_COUNT\x00SQLITE_MAX_LIKE_PATTERN_LENGTH\x00SQLITE_MAX_TRIGGER_DEPTH\x00SQLITE_DEFAULT_CACHE_SIZE\x00SQLITE_DEFAULT_PAGE_SIZE\x00SQLITE_DEFAULT_FILE_FORMAT\x00SQLITE_DEFAULT_SYNCHRONOUS\x00SQLITE_DEFAULT_WAL_SYNCHRONOUS\x00SQLITE_MAX_ATTACHED\x00SQLITE_MAX_DEFAULT_PAGE_SIZE\x00SQLITE_MAX_WORKER_THREADS\x00TEMP_STORE\x00__GNUC__\x00%s-journal\x00%s-wal\x00%s-shm\x00%s%03d\x00%s-journal%03d\x00%s-wal%03d\x00devsym\x00writecrash\x00CREATE TABLE xyz(dir, name);\x00CREATE TABLE xyz(path, size, data);\x00WITH r(d) AS (  SELECT CASE WHEN dir=?2 THEN ?3 ELSE dir END || '/' || name     FROM fsdir WHERE dir=?1 AND name NOT LIKE '.%'  UNION ALL  SELECT dir || '/' || name FROM r, fsdir WHERE dir=d AND name NOT LIKE '.%') SELECT d FROM r;\x00/\x00CREATE TABLE x(path TEXT, data TEXT)\x00SELECT * FROM %Q.%Q WHERE rowid=?\x00fs\x00fstree\x00register_fs_module\x00abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-!,:*^+=_|?/<> \x00sqlite3_prepare_v2() error: %s\x000123456789abcdef\x00test_agg_errmsg16\x00randstr\x00test_destructor\x00test_destructor16\x00hex_to_utf16be\x00hex_to_utf16le\x00hex_to_utf8\x00test_destructor_count\x00test_auxdata\x00test_error\x00test_eval\x00test_isolation\x00test_counter\x00real2hex\x00test_decode\x00test_extract\x00test_zeroblob\x00test_getsubtype\x00test_setsubtype\x00test_frombind\x00tx\x00funcxx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00nullx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00sqlite3_create_function abused test failed\x00invalid matchinfo blob passed to function rank()\x00wrong number of arguments to function rank()\x00rank\x00autoinstall_test_functions\x00abuse_create_function\x00install_fts3_rank_function\x000123456789ABCDEF\x00FILENAME OFFSET AMT\x00r\x00cannot open input file \x00FILENAME OFFSET HEXDATA\x00r+b\x00r+\x00cannot open output file \x00HEXDATA\x00[utf8_to_utf8] unavailable - SQLITE_DEBUG not defined\x00BLOB VARNAME\x00LIST\x00hexio_read\x00hexio_write\x00hexio_get_int\x00hexio_render_int16\x00hexio_render_int32\x00utf8_to_utf8\x00read_fts3varint\x00make_fts3record\x00mem\x00pcache\x00Unknown argument: \"\x00init_wrapper_install\x00init_wrapper_query\x00init_wrapper_uninstall\x00init_wrapper_clear\x00CREATE TABLE x(value INTEGER PRIMARY KEY)\x00CREATE VIRTUAL TABLE temp.%Q USING %Q\x00INTARRAY\x00SQLITE_NOMEM\x00sqlite3_intarray_create\x00sqlite3_intarray_bind\x00jt\x00-journal\x00NBYTES\x00PRIOR NBYTES\x00bad pointer: \x00PRIOR\x00ADDRESS SIZE HEX\x00size must be positive\x00no data\x00ADDRESS SIZE\x00?RESET?\x00DEPT\x00FILENAME\x00COUNTER ?OPTIONS?\x00-repeat\x00-benigncnt\x00TITLE\x00SUB-COMMAND ...\x00start\x00stop\x00dump\x00clear\x00sync\x00SIZE N\x00INSTALLFLAG DISCARDCHANCE PRNGSEEED HIGHSTRESS\x00discard-chance should be between 0 and 100\x00SIZE COUNT\x00BUFID SIZE COUNT\x00illegal arguments - see documentation\x00NBYTE NMINALLOC\x00[DB]\x00sqlite3_db_config(db, 99999) does not return SQLITE_ERROR\x00sqlite3_config(99999) does not return SQLITE_ERROR\x00PARAMETER RESETFLAG\x00SQLITE_STATUS_MEMORY_USED\x00SQLITE_STATUS_MALLOC_SIZE\x00SQLITE_STATUS_PAGECACHE_USED\x00SQLITE_STATUS_PAGECACHE_OVERFLOW\x00SQLITE_STATUS_PAGECACHE_SIZE\x00SQLITE_STATUS_SCRATCH_USED\x00SQLITE_STATUS_SCRATCH_OVERFLOW\x00SQLITE_STATUS_SCRATCH_SIZE\x00SQLITE_STATUS_PARSER_STACK\x00SQLITE_STATUS_MALLOC_COUNT\x00DB PARAMETER RESETFLAG\x00SQLITE_\x00DBSTATUS_\x00LOOKASIDE_USED\x00CACHE_USED\x00SCHEMA_USED\x00STMT_USED\x00LOOKASIDE_HIT\x00LOOKASIDE_MISS_SIZE\x00LOOKASIDE_MISS_FULL\x00CACHE_HIT\x00CACHE_MISS\x00CACHE_WRITE\x00DEFERRED_FKS\x00CACHE_USED_SHARED\x00CACHE_SPILL\x00?INTEGER?\x00sqlite3_free\x00memset\x00memget\x00sqlite3_memory_used\x00sqlite3_memory_highwater\x00sqlite3_memdebug_backtrace\x00sqlite3_memdebug_dump\x00sqlite3_memdebug_fail\x00sqlite3_memdebug_pending\x00sqlite3_memdebug_settitle\x00sqlite3_memdebug_malloc_count\x00sqlite3_memdebug_log\x00sqlite3_config_pagecache\x00sqlite3_config_alt_pcache\x00sqlite3_status\x00sqlite3_db_status\x00install_malloc_faultsim\x00sqlite3_config_heap\x00sqlite3_config_heap_size\x00sqlite3_config_memstatus\x00sqlite3_config_lookaside\x00sqlite3_config_error\x00sqlite3_config_uri\x00sqlite3_config_cis\x00sqlite3_config_pmasz\x00sqlite3_db_config_lookaside\x00sqlite3_dump_memsys3\x00sqlite3_dump_memsys5\x00sqlite3_install_memsys3\x00sqlite3_memdebug_vfs_oom_test\x00%05u\x00 FILENAME [OFFSET AMT]\"\x00unable to open file \"\x00\" for reading\x00md5\x00md5-10x8\x00md5file\x00md5file-10x8\x00md5sum\x00%03d\x00multiplexor.xAccess failure on %s\x00multiplexor.xOpen failure on %s\x00multiplex_control\x00chunksize\x00multiplex_\x00multiplex_truncate\x00multiplex_enabled\x00multiplex_chunksize\x00multiplex_filecount\x00multiplex/%z\x00multiplex\x00NAME MAKEDEFAULT\x00-force\x00?-force?\x00chunk_size\x00max_chunks\x00HANDLE DBNAME SUB-COMMAND INT-VALUE\x00expected database handle, got \"\x00sqlite3_multiplex_initialize\x00sqlite3_multiplex_shutdown\x00sqlite3_multiplex_control\x00fast\x00recursive\x00static_main\x00static_mem\x00static_open\x00static_prng\x00static_lru\x00static_pmem\x00static_app1\x00static_app2\x00static_app3\x00static_vfs1\x00static_vfs2\x00static_vfs3\x00mutex counters are \x00already installed\x00not installed\x00singlethread\x00multithread\x00serialized\x00mutex name\x00disable_mutex_init\x00disable_mutex_try\x00sqlite3_shutdown\x00sqlite3_initialize\x00sqlite3_config\x00enter_static_mutex\x00leave_static_mutex\x00enter_db_mutex\x00leave_db_mutex\x00alloc_dealloc_mutex\x00install_mutex_counters\x00read_mutex_counters\x00clear_mutex_counters\x00\x00\x00\x00\x00\x00\x00\x00vfslog/%z\x00sqlite_ostrace1.....\x00xClose\x00xRead\x00xWrite\x00xTruncate\x00xFilesize\x00xLock\x00xUnlock\x00xCheckResLock\x00xFileControl\x00xSectorSize\x00xDeviceChar\x00xDelete\x00xAccess\x00xFullPathname\x00xRandomness\x00xSleep\x00xCurrentTime\x00xShmUnmap\x00xShmLock\x00xShmBarrier\x00xShmMap\x00annotation\x00CREATE TABLE xxx(event, file, click, rc, size, offset)\x00vfslog\x00VFS\x00failed\x00VFS PARENT LOGFILE\x00bad sqlite3 handle: \x00annotate\x00finalize\x00register\x00quota/%z\x00quota\x00::piLimit_\x00PATTERN LIMIT SCRIPT\x00FILENAME MODE\x00HANDLE SIZE NELEM\x00HANDLE SIZE NELEM CONTENT\x00HANDLE ?HARDSYNC?\x00HANDLE OFFSET WHENCE\x00SEEK_SET\x00SEEK_CUR\x00SEEK_END\x00WHENCE should be SEEK_SET, SEEK_CUR, or SEEK_END\x00HANDLE SIZE\x00PATTERN TEXT\x00sqlite3_quota_initialize\x00sqlite3_quota_shutdown\x00sqlite3_quota_set\x00sqlite3_quota_file\x00sqlite3_quota_dump\x00sqlite3_quota_fopen\x00sqlite3_quota_fread\x00sqlite3_quota_fwrite\x00sqlite3_quota_fclose\x00sqlite3_quota_fflush\x00sqlite3_quota_fseek\x00sqlite3_quota_rewind\x00sqlite3_quota_ftell\x00sqlite3_quota_ftruncate\x00sqlite3_quota_file_size\x00sqlite3_quota_file_truesize\x00sqlite3_quota_file_mtime\x00sqlite3_quota_remove\x00sqlite3_quota_glob\x00sqlite3_quota_file_available\x00sqlite3_quota_ferror\x00cube\x00circle\x00Qcircle\x00breadthfirstsearch\x00register_cube_geom\x00register_circle_geom\x00CREATE TABLE x(database,tablename,cid,name,type,not_null,dflt_value,pk)\x00SELECT name FROM sqlite_temp_schema WHERE type='table'\x00SELECT name FROM %Q.sqlite_schema WHERE type='table'\x00PRAGMA %Q.table_info(%Q)\x00PRAGMA database_list\x00register_schema_module\x00PRAGMA main.journal_mode\x00CMDNAME PATH ?VFS? ?BUSY-HANDLER-SCRIPT?\x00sqlite3demo_superlock\x00open\x00access\x00getcwd\x00stat\x00fstat\x00ftruncate\x00fcntl\x00pread\x00pread64\x00pwrite\x00pwrite64\x00fchmod\x00fallocate\x00mremap\x00SYSCALL-LIST\x00system-call\x00?COUNT PERSIST?\x00EACCES\x00EINTR\x00EIO\x00EOVERFLOW\x00ENOMEM\x00EAGAIN\x00ETIMEDOUT\x00EBUSY\x00EPERM\x00EDEADLK\x00ENOLCK\x00SYSCALL ERRNO\x00errno\x00PGSZ\x00getpagesize\x00pgsz out of range\x00fault\x00install\x00uninstall\x00list\x00defaultvfs\x00pagesize\x00VFS does not support xSetSystemCall\x00test_syscall\x00load_testfixture_extensions\x00SLAVE\x00CREATE TABLE x(  name TEXT,  arrayname TEXT,  value TEXT,  fullname TEXT PRIMARY KEY) WITHOUT ROWID\x00array names\x00tclvar_filter_cmd\x00%s(%s)\x00expr {[info exists ::tclvar_set_omit] && $::tclvar_set_omit}\x00the 'fullname' column must be TEXT\x00prohibited TCL variable change\x00proc like {pattern str} {\n  set p [string map {% * _ ?} $pattern]\n  string match $p $str\n}\nproc tclvar_filter_cmd {eq match glob regexp like} {\n  set res {}\n  set pattern $eq\n  if {$pattern=={}} { set pattern $match }\n  if {$pattern=={}} { set pattern * }\n  foreach v [uplevel #0 info vars $pattern] {\n    if {($glob=={} || [string match $glob [uplevel #0 set $v]])\n     && ($like=={} || [like $like [uplevel #0 set $v]])\n     && ($regexp=={} || [regexp $regexp [uplevel #0 set $v]])\n    } {\n      lappend res $v\n    }\n  }\n  set res\n}\n\x00register_tclvar_module\x00clock_seconds\x00sqlthread\x00sqlite3_blocking_step\x00sqlite3_blocking_prepare_v2\x00sqlite3_nonblocking_prepare_v2\x00set\x00Error in Tcl_CreateThread()\x00no parent thread\x00parent\x00spawn\x00VARNAME SCRIPT\x00DBNAME\x00id\x00%s \x00clock_second\x00clock_milliseconds\x00SQLITE_IOERR\x00SQLITE_LOCKED\x00SQLITE_BUSY\x00SQLITE_READONLY\x00SQLITE_READONLY_CANTINIT\x00SQLITE_NOTFOUND\x00SQLITE_OMIT\x00normal|dataonly\x00full|dataonly\x00xCheckReservedLock\x00BEGIN_ATOMIC_WRITE\x00COMMIT_ATOMIC_WRITE\x00ZIPVFS\x00anon\x00SQLITE_ACCESS_EXISTS\x00SQLITE_ACCESS_READWRITE\x00SQLITE_ACCESS_READ\x00xShmOpen\x00 lock\x00 unlock\x00 shared\x00 exclusive\x00shm\x00filter\x00ioerr\x00fullerr\x00cantopenerr\x00script\x00devchar\x00sectorsize\x00subcommand\x00FILE ?VALUE?\x00failed to get full path: \x00no such file: \x00unknown method: \x00?CNT PERSIST?\x00default\x00undeletable_when_open\x00immutable\x00?ATTR-LIST?\x00bad flags: \x00?VALUE?\x00-noshm\x00-szosfile\x00-mxpathname\x00-iversion\x00-fullshm\x00VFSNAME ?-noshm BOOL? ?-fullshm BOOL? ?-default BOOL? ?-mxpathname INT? ?-szosfile INT? ?-iversion INT?\x00shared\x00lock\x00unlock\x00DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N\x00DB DBNAME SLOT ?VALUE?\x00*-shm is not yet mapped\x00testvfs\x00vfs_shmlock\x00vfs_set_readmark\x00DB NAME XSTEP XFINAL XVALUE XINVERSE\x00fff\x00misuse test error\x00invalid argument\x00sumint\x00sum\x00sqlite3_create_window_function\x00test_create_window_function_misuse\x00test_create_sumint\x00test_override_sum\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
